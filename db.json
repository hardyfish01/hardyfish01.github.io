{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"themes/tree/source/404.html","path":"404.html","modified":0,"renderable":1},{"_id":"themes/tree/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/tree/source/个人公众号.jpg","path":"个人公众号.jpg","modified":0,"renderable":1},{"_id":"themes/tree/source/个人微信.jpeg","path":"个人微信.jpeg","modified":0,"renderable":1},{"_id":"themes/tree/source/头像.jpg","path":"头像.jpg","modified":0,"renderable":1},{"_id":"themes/tree/source/css/clipboard-use.css","path":"css/clipboard-use.css","modified":0,"renderable":1},{"_id":"themes/tree/source/css/jquery.fancybox.min.css","path":"css/jquery.fancybox.min.css","modified":0,"renderable":1},{"_id":"themes/tree/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/tree/source/js/clipboard.min.js","path":"js/clipboard.min.js","modified":0,"renderable":1},{"_id":"themes/tree/source/js/jquery.fancybox.min.js","path":"js/jquery.fancybox.min.js","modified":0,"renderable":1},{"_id":"themes/tree/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/jquery-3.4.1.min.js","path":"lib/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/jquery.pjax.js","path":"lib/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/font-awesome/font-awesome.min.css","path":"lib/font-awesome/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/highlight/darcula.css","path":"lib/highlight/darcula.css","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/highlight/highlight.pack.js","path":"lib/highlight/highlight.pack.js","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/valine/Valine-1.3.10-min.js","path":"lib/valine/Valine-1.3.10-min.js","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/valine/av-3.0.4-min.js","path":"lib/valine/av-3.0.4-min.js","modified":0,"renderable":1},{"_id":"themes/tree/source/lib/busuanzi/2.3/busuanzi.pure.mini.js","path":"lib/busuanzi/2.3/busuanzi.pure.mini.js","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"85483aca99cabb9092246c4e05f6591074440cac","modified":1647481930856},{"_id":"source/404/index.md","hash":"797bcd667ca4b7c1dcdc2a611274ff381b771ccf","modified":1630473738193},{"_id":"source/.DS_Store","hash":"c16b977d42edebc989752b2b5b1caaa918cc8254","modified":1647479515400},{"_id":"source/graph/index.md","hash":"42b9764ae59521ff9ee3aa2e0f5afd9dd0b1cb28","modified":1644281997803},{"_id":"source/neitui/index.md","hash":"c24a7129dafb7efe5757371f12caf5b92a497b81","modified":1639252416007},{"_id":"source/rescource/index.md","hash":"09150573c926223264735677077643438c4df847","modified":1630473738222},{"_id":"source/_posts/Apache Dubbo实战/基本架构.md","hash":"5141c9a6c9c18cf998e17509b67f98ec6f2daaaf","modified":1643886446029},{"_id":"source/about/index.md","hash":"725536a857797e6bc8f97323886727aa3502754c","modified":1639282766596},{"_id":"source/_posts/Apache Dubbo实战/核心模块.md","hash":"e2ff518b44d0c2a2bbd42602f9f75862100f663e","modified":1643886465671},{"_id":"source/_posts/Apache KAFKA实战/位移主题.md","hash":"3f14a24a361b3cdf272a075e6c0b31a9b980bd66","modified":1641647171792},{"_id":"source/_posts/.DS_Store","hash":"292fd866a851a1774c4e4491cb6f8b91b763a434","modified":1647480451173},{"_id":"source/_posts/Apache KAFKA实战/位移提交.md","hash":"a367261b13826895cd81c83196f5f86250f8cab2","modified":1641640959132},{"_id":"source/_posts/Apache KAFKA实战/如何保证高可用.md","hash":"99da497476afdf2d80471a7a870e218c5b6c5c19","modified":1643707450818},{"_id":"source/_posts/Apache KAFKA实战/常用参数.md","hash":"c639176f9ffe5fe8529593d228f389137c69ea44","modified":1641642567869},{"_id":"source/_posts/Apache KAFKA实战/幂等性和事务.md","hash":"02db4675702e2cf5b15101db8a4116b835a8e00c","modified":1641618135256},{"_id":"source/_posts/Apache KAFKA实战/拦截器.md","hash":"bcc65243bea2fae814b40d8840d9ecabab5d2d46","modified":1641633451154},{"_id":"source/movie/index.md","hash":"c09dda4130f1931e2ef8defb6b4e855700b7981b","modified":1647393360494},{"_id":"source/_posts/Apache KAFKA实战/日志存储.md","hash":"f47977868c6aa293c15fb4a50606059267f04847","modified":1641647004235},{"_id":"source/_posts/Apache KAFKA实战/消息丢失.md","hash":"ca7076d116c13130fc6c7c683dc8a91e5a16fdd3","modified":1641643901838},{"_id":"source/_posts/Apache KAFKA实战/消息积压.md","hash":"90947d7fe097e3a046954f7caff644d728985459","modified":1645882708507},{"_id":"source/_posts/Apache KAFKA实战/消息顺序.md","hash":"5d97729294c5b613452d50f6793fea2fec874a95","modified":1641647176557},{"_id":"source/_posts/Apache KAFKA实战/副本机制.md","hash":"9a10f1f8ab06cde7d0e73d1161bd6637e78759ae","modified":1641657670225},{"_id":"source/_posts/Apache KAFKA实战/基本概念.md","hash":"d11f6133e476324e62508ed1e55473980ee3007c","modified":1641647184828},{"_id":"source/_posts/Apache KAFKA实战/控制器.md","hash":"baea74a99adf5e1a8d17636705ba7a3f0ed981f3","modified":1641635528286},{"_id":"source/_posts/Apache KAFKA实战/消费者组.md","hash":"7a2c4f9d482e0ca12788ce6b7b9d35baf9f519f0","modified":1641642200627},{"_id":"source/_posts/Apache KAFKA实战/重复消费.md","hash":"08f20dcc7be2bbfda3347169e2ba48e1eb80eb6a","modified":1641644984389},{"_id":"source/_posts/Apache KAFKA实战/生产者分区.md","hash":"81fd68aaa2f886a14b0f88aa2442f5da962208e8","modified":1641539893201},{"_id":"source/_posts/Docker开发指南/云计算平台.md","hash":"2ddaef33b22ac3fb726676777c37a848a6c27a2c","modified":1645333842267},{"_id":"source/_posts/Apache Dubbo实战/序列化.md","hash":"0eff11db44419e3afbeacf709a473304a90ae335","modified":1643886456486},{"_id":"source/_posts/Apache KAFKA实战/生产者压缩算法.md","hash":"8e12b52975fd10a7c29dd34c7656dc618c077f82","modified":1641603973008},{"_id":"source/_posts/Docker开发指南/镜像和容器.md","hash":"0659bc2bea050b547a75dd0cbf4295964eab77d4","modified":1643367236378},{"_id":"source/_posts/Apache KAFKA实战/认识KAFKA.md","hash":"21a3f7650e2499becfb2058437e53f43cfa479b3","modified":1644651536209},{"_id":"source/_posts/Apache KAFKA实战/重平衡.md","hash":"2bba46e66133758499942d00087abd4ae2936954","modified":1641647180699},{"_id":"source/_posts/Docker开发指南/基本概念.md","hash":"64cee5a71fd4b2616a8422a9c7d5b0b44c13636d","modified":1643368379177},{"_id":"source/_posts/Effective Java/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1640519669476},{"_id":"source/_posts/Elasticsearch实战/倒排索引.md","hash":"522e355391a066cbcd20ef91f67786913a070940","modified":1643431694931},{"_id":"source/_posts/Elasticsearch实战/分词.md","hash":"ab477382eca7f90d57e487a842b1b515a8644e4e","modified":1643431825489},{"_id":"source/_posts/Elasticsearch实战/分页.md","hash":"63f40b41d7fab989920ec8a1595ac9aa7249d182","modified":1643010314943},{"_id":"source/_posts/Elasticsearch实战/数据处理.md","hash":"24c6d043cbeb1e05619c0573418b5fbb23ee0968","modified":1643438284531},{"_id":"source/_posts/Elasticsearch实战/数据持久化.md","hash":"4e47dbc9cca8ab1bb2724df64ae2b6b94d462408","modified":1643438064150},{"_id":"source/_posts/Effective Java/创建和销毁对象.md","hash":"b1fc4d38eabd5c6d6191a2f8c401dda4e3976892","modified":1640511206136},{"_id":"source/_posts/Effective Java/类和接口.md","hash":"89011231249714b3c6ae1f1cc068a0ac76f40a99","modified":1644251865603},{"_id":"source/_posts/Java并发编程实战/CAS.md","hash":"27b3c6c7f809c69e53a0c5a45a2c86712d5a385d","modified":1644051759055},{"_id":"source/_posts/Java并发编程实战/Disruptor框架.md","hash":"e1a2ca115e8f959e990c176b67c806e23c0621c3","modified":1643704311415},{"_id":"source/_posts/Java并发编程实战/ThreadLocal.md","hash":"5202f6b21c76d67c3de83d18dead9aa48d46f2f1","modified":1642232141961},{"_id":"source/_posts/Effective Java/通用方法.md","hash":"ea5742adffc76afd2d74fe6ced5fd4f88431986c","modified":1644138394074},{"_id":"source/_posts/Elasticsearch实战/集群.md","hash":"9e15b92439ea07ee93e60160b93e301e2c5d4f51","modified":1643437732581},{"_id":"source/_posts/Java并发编程实战/内存模型.md","hash":"6ea04d1c2e0353ab7ad12b8d08ca7ff6e66a5200","modified":1647165458605},{"_id":"source/_posts/Java并发编程实战/共享对象.md","hash":"bbc5ed71857ea6346a9392a419f4aa17252eb4a1","modified":1640582151296},{"_id":"source/_posts/Java并发编程实战/线程池.md","hash":"8a506389c1263ffd34d3e2a437175cc9fa398c6b","modified":1644117172218},{"_id":"source/_posts/Java并发编程实战/阻塞队列.md","hash":"0272ab7e5009441a25dd0d06b6418c9a68596be6","modified":1644054179243},{"_id":"source/_posts/Java并发编程实战/锁机制.md","hash":"58cedc1540a7dda970eb7a9fc062f6b89a79e3b5","modified":1643704766535},{"_id":"source/_posts/Java并发编程实战/线程.md","hash":"e5edfb06a34cd249f0f196f445631d034f0979cf","modified":1644053601226},{"_id":"source/_posts/Java编程思想/HashSet.md","hash":"d69d0642c86258e16dadd2a1841a3c423b4545d0","modified":1644116024193},{"_id":"source/_posts/Java编程思想/Lambda.md","hash":"e7de7621f5242e3a6ba7ad780d8851c1a4b7dec8","modified":1643706575795},{"_id":"source/_posts/Java编程思想/ArrayList.md","hash":"b5c8298bb0e57374aed38bdcf3376e08a8040205","modified":1644080620501},{"_id":"source/_posts/Java编程思想/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644080889094},{"_id":"source/_posts/Java编程思想/Long类.md","hash":"ef1dab604e4b7a15457d7b956a6e52d4ac89f74e","modified":1643774449101},{"_id":"source/_posts/Java编程思想/String类.md","hash":"90c597399ade7665029d23b619c239d505cf09cb","modified":1644034376099},{"_id":"source/_posts/Java编程思想/Switch.md","hash":"51b3c7f672a73166561e477906aa625b7a35ab99","modified":1643704214479},{"_id":"source/_posts/Java编程思想/TreeMap.md","hash":"eedf399f44565c1bbc3b8d1160f5b1ce2f613e37","modified":1644115506215},{"_id":"source/_posts/Java编程思想/TreeSet.md","hash":"e70fe4172fcf32faa80f5f5f8e81cf64a7807d84","modified":1644116309264},{"_id":"source/_posts/Docker开发指南/基本架构.md","hash":"e397c846615047ab61c78ae772b44d0ff3d43290","modified":1643367416815},{"_id":"source/_posts/Java编程思想/抽象类和接口.md","hash":"40510e4256d92d20a6e24e84213a25e2973f76ca","modified":1643774700672},{"_id":"source/_posts/Java编程思想/HashMap.md","hash":"0e673fabe2c39f5284e4a6dc9f705769c4a1296d","modified":1644115419570},{"_id":"source/_posts/Java编程思想/编译和反编译.md","hash":"fcf72560902ee3ad314cebc4d263de96a35dde58","modified":1643703475879},{"_id":"source/_posts/MyBatis技术内幕/基本架构.md","hash":"247c0c83c8b3196f5fed4a07913d1727de689155","modified":1647149777806},{"_id":"source/_posts/Java编程思想/LinkedHashMap.md","hash":"944408eb2626f69aed8e8a62c918e8b369382e07","modified":1644115585446},{"_id":"source/_posts/MyBatis技术内幕/缓存机制.md","hash":"4df671298e8a67b3edc72b4c699de0350c43c3a0","modified":1647153528505},{"_id":"source/_posts/MySQL必知必会/ER模型.md","hash":"019081861cb0d988a8f34dd05c311c517551b019","modified":1647221622752},{"_id":"source/_posts/MySQL必知必会/字段类型.md","hash":"e4bf4c478f2dcb3f292a82194877903cd0eb2b56","modified":1646667674160},{"_id":"source/_posts/MySQL必知必会/数据备份.md","hash":"b1330d4e682a5409ed256f3e339824dd21742018","modified":1647142338889},{"_id":"source/_posts/Java编程思想/泛型.md","hash":"8d926d28a6f41f8521c73196e4dbada86ca0297c","modified":1643774651762},{"_id":"source/_posts/Java编程思想/LinkedList.md","hash":"8b7cb4255874a603a8eb2727caab491833753e50","modified":1644081433710},{"_id":"source/_posts/Netty权威指南/.DS_Store","hash":"72469e4d5866f59820d19f6c90ff11d69a5a9219","modified":1646319746939},{"_id":"source/_posts/MySQL必知必会/日志查看.md","hash":"af1ddd2c9b7a0e9410a75b7219375a7141ba6770","modified":1647055209970},{"_id":"source/_posts/Netty权威指南/FastThreadLocal.md","hash":"2e3fbcf3db15b00a328b31c507774d114cc60d43","modified":1643787582560},{"_id":"source/_posts/Netty权威指南/Future回调机制.md","hash":"8b018a3c690cab6fd6ef852716addac0596e8381","modified":1643787402194},{"_id":"source/_posts/Netty权威指南/Reactor线程模型.md","hash":"e4096757466a96f2bf69a38b0f49934554762910","modified":1643787670334},{"_id":"source/_posts/Netty权威指南/Recycler对象池.md","hash":"c76b8dc53b562ad009925388e313911fa45a11c2","modified":1643787882716},{"_id":"source/_posts/Netty权威指南/入门案例.md","hash":"36f7a0dbc738d3341b578c95ad9538552507f088","modified":1643785686597},{"_id":"source/_posts/Netty权威指南/基础知识.md","hash":"199d58b9ecf6aaf2a9b6bde361568022950bd9d0","modified":1643787793596},{"_id":"source/_posts/Netty权威指南/ByteBuf.md","hash":"9dc5e55a2eecae7eea430f2859193cb4d28565a0","modified":1643785951789},{"_id":"source/_posts/MyBatis技术内幕/核心原理.md","hash":"4f94f7c9f45a7e1a8fc6b16a2b1030ee583397e5","modified":1647150972261},{"_id":"source/_posts/Netty权威指南/空闲检测.md","hash":"4456bb026dc166afb347910b7a6a294f86189090","modified":1643786115995},{"_id":"source/_posts/Netty权威指南/基本架构.md","hash":"2e081b5dbb539be6d811a9479713b28ba343f74e","modified":1646380368262},{"_id":"source/_posts/Netty权威指南/核心流程.md","hash":"3edbf951e422ee4e4adb627158bdde2537d44a40","modified":1643787977195},{"_id":"source/_posts/Netty权威指南/编解码.md","hash":"0bfb4a73a7eea90f3e7365990fdf2c1109ea4b40","modified":1643785887202},{"_id":"source/_posts/Netty权威指南/核心组件.md","hash":"7dfcdcc128fef74df72107bb2c282c3b6aa48078","modified":1643786443628},{"_id":"source/_posts/LeetCode/100相同的树.md","hash":"b4a147f10e35488d6846fcf9b66330e6a679f113","modified":1643386502187},{"_id":"source/_posts/LeetCode/1014最佳观光组合.md","hash":"e605ab552e5f169f3c0260c9af95bea154daf1b6","modified":1643386508088},{"_id":"source/_posts/LeetCode/101对称二叉树.md","hash":"c9514416bc8e9abf7d093aa27c62d24b62fac713","modified":1643386513627},{"_id":"source/_posts/LeetCode/102二叉树的层序遍历.md","hash":"db19d226bc89eaa46053e8b76611f78f32b4a502","modified":1643386517883},{"_id":"source/_posts/LeetCode/104二叉树的最大深度.md","hash":"cf278b177c3d3b22f4c3c7c4124a4c93bbce193b","modified":1643386522383},{"_id":"source/_posts/LeetCode/112路径总和.md","hash":"08a495c94bfa8474031e0ee01f5cad2fd875ab61","modified":1643386530199},{"_id":"source/_posts/LeetCode/1137第N个泰波那契数.md","hash":"40c7e64d7a2606df1820f7a345bdbdd4769118d8","modified":1643386535634},{"_id":"source/_posts/LeetCode/113路径总和II.md","hash":"7ff720dbab257a321b0b4fa140a448c1b6a9ad7d","modified":1643386540845},{"_id":"source/_posts/LeetCode/110平衡二叉树.md","hash":"9ca1c3710ddf2ecce9e006ae71c841acbb8f96fc","modified":1643386526327},{"_id":"source/_posts/LeetCode/11盛最多水的容器.md","hash":"cb10811a5bc82d2567bae1fd0ffe6f87a743880a","modified":1640653789381},{"_id":"source/_posts/LeetCode/121买卖股票的最佳时机.md","hash":"3ab7459b90a73b2aa41bc4240889575ed75078d7","modified":1643386551863},{"_id":"source/_posts/LeetCode/122买卖股票的最佳时机II.md","hash":"09a55b60b1fd27d84190dd7674c138d33d328bea","modified":1643386556104},{"_id":"source/_posts/Netty权威指南/零拷贝.md","hash":"88739af3214ad3a48b589c43d1a28db33df6105c","modified":1643786045792},{"_id":"source/_posts/LeetCode/125验证回文串.md","hash":"11f8d114fc459c4af3fda959e80e73bb883aa438","modified":1643386560153},{"_id":"source/_posts/LeetCode/129求根节点到叶节点数字之和.md","hash":"83f16d5cbda2aba8bfe46ff6d294846d739924bd","modified":1643386565006},{"_id":"source/_posts/LeetCode/1143最长公共子序列.md","hash":"70304241f375a9c0afdb56a432dbc55b301045bb","modified":1643386545099},{"_id":"source/_posts/LeetCode/13罗马数字转整数.md","hash":"db09c944ae611b267d55bb6fc752e9b928301355","modified":1640760269218},{"_id":"source/_posts/LeetCode/136只出现一次的数字.md","hash":"c4428ad5e9a6ad23e443c0d2bc1759dae2ae7fb5","modified":1643386570059},{"_id":"source/_posts/LeetCode/142环形链表II.md","hash":"dc51a224dffba3d64e961de98f9287daeef53ad4","modified":1643386582035},{"_id":"source/_posts/LeetCode/141环形链表.md","hash":"9c7682e35269591718744f860a5a91848b893a46","modified":1643386578642},{"_id":"source/_posts/LeetCode/144二叉树的前序遍历.md","hash":"e2d6c64518bc4b4062ce8e679e775beddcc583e6","modified":1643386594940},{"_id":"source/_posts/LeetCode/143重排链表.md","hash":"15dafbd03aef5c880b98a39557f301fa355baa5b","modified":1643386590982},{"_id":"source/_posts/LeetCode/146LRU缓存机制.md","hash":"42c34ab9d4febf6b7e778b6e7948edd15cae4653","modified":1643386603414},{"_id":"source/_posts/LeetCode/148排序链表.md","hash":"5b7db9b116b77e69815e485043612fe28002189d","modified":1643386611705},{"_id":"source/_posts/LeetCode/14最长公共前缀.md","hash":"f685ad044971c1249c2b67742d74406543debd66","modified":1640760650531},{"_id":"source/_posts/LeetCode/152乘积最大子数组.md","hash":"157fdd7fd6216478fced3c4668fb153f2f310121","modified":1643386618138},{"_id":"source/_posts/LeetCode/155最小栈.md","hash":"7fa61c6c64aede2de3b0f57c998cb7849c29b0ff","modified":1643386623832},{"_id":"source/_posts/LeetCode/15三数之和.md","hash":"a84d73d3e81b869de845e82a24920f6a96313380","modified":1640838802230},{"_id":"source/_posts/LeetCode/145二叉树的后序遍历.md","hash":"d2160413e94665a50f5d22e56eb585513625e1ad","modified":1643386599374},{"_id":"source/_posts/LeetCode/160相交链表.md","hash":"c173862119433ea7652ff379c4188dc561dd88dd","modified":1643386630453},{"_id":"source/_posts/LeetCode/16.06最小差.md","hash":"39ef268cb3738d6bc1b76aa5109642128856c53e","modified":1643770007855},{"_id":"source/_posts/LeetCode/162寻找峰值.md","hash":"c87763ae6dc8d316540201a56eff35abc1a9fb5a","modified":1643386634881},{"_id":"source/_posts/LeetCode/16最接近的三数之和.md","hash":"ba1c91aa4f541fef8b39b35c951650611d3ca4a9","modified":1640838881753},{"_id":"source/_posts/LeetCode/18四数之和.md","hash":"ef0a1997ca4cca82d04521fff2cd5df9c4682bb3","modified":1641023614936},{"_id":"source/_posts/LeetCode/17.14最小K个数.md","hash":"25e77ba9bc5c98f554745e33d3517b8ebafa968c","modified":1643769945862},{"_id":"source/_posts/LeetCode/198打家劫舍.md","hash":"2636fb7273088778a938fab9bd3283cae2429d25","modified":1643386646298},{"_id":"source/_posts/LeetCode/199二叉树的右视图.md","hash":"c0cbd7d8e96321ba8d5b79ac8a2383ca49d4496d","modified":1643386650200},{"_id":"source/_posts/LeetCode/19删除链表的倒数第N个节点.md","hash":"9994e4c6c583286063140c45c1ea6553150a6053","modified":1641024489065},{"_id":"source/_posts/LeetCode/1两数之和.md","hash":"c6cb41df34db2576909c1e958665d2b3b08f73f2","modified":1639414220480},{"_id":"source/_posts/LeetCode/206反转链表.md","hash":"197bf407459d7d4f6db4018ba2eee23c4fc5d94e","modified":1643386658826},{"_id":"source/_posts/LeetCode/20有效的括号.md","hash":"59525b470928f8a14c52ed1263c48717a6879af0","modified":1641194643234},{"_id":"source/_posts/LeetCode/213打家劫舍II.md","hash":"cbb62c656ea4b491a9b45dca74784fe619c06c77","modified":1643386697636},{"_id":"source/_posts/LeetCode/215数组中的第K个最大元素.md","hash":"962c6da5320f91e152ca8228c90b92d500558680","modified":1643386702420},{"_id":"source/_posts/LeetCode/217存在重复元素.md","hash":"6dc888f08b750b6eb336b264c9a96381c0ba854e","modified":1643386709601},{"_id":"source/_posts/LeetCode/169多数元素.md","hash":"809cb61afd1d0fe2442c1a9b2a153efdce780fa3","modified":1643386639303},{"_id":"source/_posts/LeetCode/21合并两个有序链表.md","hash":"f20707f45f4ab71ff43df3e52d8a7b97ed8ecbbc","modified":1641194685915},{"_id":"source/_posts/LeetCode/226翻转二叉树.md","hash":"942ae41a95b54fcfcb83993712d2db0e2576fc2d","modified":1643386715971},{"_id":"source/_posts/LeetCode/229求众数II.md","hash":"52b281d1fdbe5f73d5b6a4d6e16e9d4e1215c128","modified":1643386719516},{"_id":"source/_posts/LeetCode/234回文链表.md","hash":"a90e2a74827b394a7e9e02dfff5cab207ffa4829","modified":1643386741180},{"_id":"source/_posts/LeetCode/230二叉搜索树中第K小的元素.md","hash":"393015d6f8a00f7ada7a31ae64fb996ce36012f4","modified":1643386732923},{"_id":"source/_posts/LeetCode/240搜索二维矩阵II.md","hash":"23238514e438755f6e28f983484129024dac8895","modified":1643386816345},{"_id":"source/_posts/Java编程思想/关键词.md","hash":"a6d7372d9bb322ed72477016327bbeab590da97b","modified":1643774539894},{"_id":"source/_posts/LeetCode/24两两交换链表中的节点.md","hash":"e8720bdbbd7809fd16d640019a5114e664c6151a","modified":1641194898480},{"_id":"source/_posts/LeetCode/257二叉树的所有路径.md","hash":"e8cae419c67d10fa6c945af5e2e05c02ddd08755","modified":1643386821412},{"_id":"source/_posts/LeetCode/26删除排序数组中的重复项.md","hash":"f2e3c6fc5f66288d7edf615ae38cef50387717d6","modified":1641194969128},{"_id":"source/_posts/LeetCode/237删除链表中的节点.md","hash":"c548333f77f89bec81cd80ec7932c1832926dffb","modified":1643386791592},{"_id":"source/_posts/LeetCode/31下一个排列.md","hash":"786817487aa9fe49bd805d47cd87c5a6eca30a21","modified":1641907369903},{"_id":"source/_posts/LeetCode/300最长上升子序列.md","hash":"2b88f5a75bf75de06722a0240e28f436d8391b67","modified":1643386829866},{"_id":"source/_posts/LeetCode/2两数相加.md","hash":"5451de99b307d1ca2f45f69932bfba7e50ed2c26","modified":1639414865323},{"_id":"source/_posts/LeetCode/322零钱兑换.md","hash":"5e7536c730443ab4202a3327407a7c6880c264b6","modified":1643386836261},{"_id":"source/_posts/LeetCode/328奇偶链表.md","hash":"a3ce181a14294ff8cb9bcf7a76af11bb32c0306c","modified":1643386843547},{"_id":"source/_posts/LeetCode/27移除元素.md","hash":"de8e76788804b7c976ac673ff699679d79e86ba8","modified":1641949503449},{"_id":"source/_posts/LeetCode/3无重复字符的最长子串.md","hash":"b7479484465cef56102ccd56e0060c8cbab56641","modified":1639414955464},{"_id":"source/_posts/LeetCode/344反转字符串.md","hash":"eb8d492a54d2ccc43574cd72bdf1c4f08665473f","modified":1643386848764},{"_id":"source/_posts/LeetCode/45跳跃游戏II.md","hash":"19d243163dc8e78eab466cd9cfda68e3204692da","modified":1641948870750},{"_id":"source/_posts/LeetCode/46全排列.md","hash":"18fa76283aa53434b2c459bbf83282f235b0b774","modified":1643386858631},{"_id":"source/_posts/LeetCode/415字符串相加.md","hash":"1f8a0bc213c015b3f9b70c44b8ce7a3ada0a3c72","modified":1643386854031},{"_id":"source/_posts/LeetCode/470用Rand7()实现Rand10().md","hash":"daa8b8a71fee5e81b153c4b956decee26b3d2a7b","modified":1643386865122},{"_id":"source/_posts/LeetCode/509斐波那契数.md","hash":"e711137c6b62e0dabc6e52a01457b1977aeaab7d","modified":1643386870233},{"_id":"source/_posts/LeetCode/33搜索旋转排序数组.md","hash":"9d8e1f0b60b44c80d44348dfa196a3169e215917","modified":1641948828274},{"_id":"source/_posts/LeetCode/53最大子序和.md","hash":"7b9566a498e2948f34174122c8991c832d6de7f4","modified":1643386879063},{"_id":"source/_posts/LeetCode/543二叉树的直径.md","hash":"435ae323a4815634c74845357da5699a5e327f8b","modified":1643386882502},{"_id":"source/_posts/LeetCode/50第一个只出现一次的字符.md","hash":"3ad547b36be602e3a8783465f23d4f9ca9c5f627","modified":1643386875149},{"_id":"source/_posts/LeetCode/55跳跃游戏.md","hash":"b74ad912999ae5e35f94cddd3b0d34c22df236fa","modified":1643386890059},{"_id":"source/_posts/LeetCode/54螺旋矩阵.md","hash":"87059b4fbf45e8ee2f2f29ce9d8f1cdcc7f4f52a","modified":1643386886042},{"_id":"source/_posts/LeetCode/617合并二叉树.md","hash":"b4de7ef07f123df54c456cb75f05d627dda88739","modified":1643386895380},{"_id":"source/_posts/LeetCode/637二叉树的层平均值.md","hash":"e2ad5a3c82483aacda62ca7243d8aaafa154838f","modified":1643386899484},{"_id":"source/_posts/LeetCode/5最长回文子串.md","hash":"b222fd789c25a8f42d65ca3036ccfef7c206a546","modified":1640581790487},{"_id":"source/_posts/LeetCode/64最小路径和.md","hash":"3870b02500fcf4f335c670c8c49f33c9f12caeff","modified":1643386905438},{"_id":"source/_posts/LeetCode/69X的平方根.md","hash":"95e8acfb3cf80bd3c2a6e29279c21df2758fd19d","modified":1643386913734},{"_id":"source/_posts/LeetCode/674最长连续递增序列.md","hash":"7505d4f313b97c21559d3288aced86b7a43f031a","modified":1643386909917},{"_id":"source/_posts/LeetCode/704二分查找.md","hash":"9599fd558157151c849b249aac05a18a430f06a2","modified":1643386919114},{"_id":"source/_posts/LeetCode/70爬楼梯.md","hash":"c2ef7a2b6e40b7c802d552750995a354673c928c","modified":1643386923946},{"_id":"source/_posts/LeetCode/746使用最小花费爬楼梯.md","hash":"e98e992e2ad61c78ae5d0d8fc6960b02169613b8","modified":1643386929759},{"_id":"source/_posts/LeetCode/75颜色分类.md","hash":"70f346e547a513dc5572be53a89b8b248310b560","modified":1643386935292},{"_id":"source/_posts/LeetCode/78子集.md","hash":"70ab334829177053ddd12e32ca9f81e5ba6c1e40","modified":1643386940585},{"_id":"source/_posts/LeetCode/7整数反转.md","hash":"8f0124413b1e76191d66b53e7b746660622afb18","modified":1640581941461},{"_id":"source/_posts/LeetCode/88合并两个有序数组.md","hash":"c3b3f98f204af3c68e58de725e322add283a42a1","modified":1643386950089},{"_id":"source/_posts/LeetCode/90子集II.md","hash":"c2a009de1c083e4c64850880738d7da0a8b5eb97","modified":1643386954197},{"_id":"source/_posts/LeetCode/83删除排序链表中的重复元素.md","hash":"14045891968b6f350ca7299ee7932408613c6b2a","modified":1643386945952},{"_id":"source/_posts/LeetCode/92反转链表II.md","hash":"0adeecfceb0137891a7a44f0bf720ff62764ae8e","modified":1643386958004},{"_id":"source/_posts/LeetCode/94二叉树的中序遍历.md","hash":"77e80c549cb277115b8066fa37d1db2394e5ad0e","modified":1643386962266},{"_id":"source/_posts/LeetCode/98验证二叉搜索树.md","hash":"767ce73a58a7473694bd4ab0ef0fb10f8c7aec94","modified":1643386966200},{"_id":"source/_posts/LeetCode/9回文数.md","hash":"09b168bca57ee4fb008470c223e7005ce280f747","modified":1640653793478},{"_id":"source/_posts/Redis开发与运维/Pipeline.md","hash":"b2b6b23ad259a256940a04da261cc674250f2038","modified":1643706453931},{"_id":"source/_posts/Redis开发与运维/分布式锁.md","hash":"954ab2e84aed707c30d584beeec58a67b9a24773","modified":1643706367497},{"_id":"source/_posts/Redis开发与运维/客户端.md","hash":"5a3a03c5df43616e0726ba8e45e1c8ac612d59f2","modified":1639913395761},{"_id":"source/_posts/Redis开发与运维/延时队列.md","hash":"fc22f14af99b7688999403a51911d91b8d445463","modified":1643706271155},{"_id":"source/_posts/Redis开发与运维/慢查询.md","hash":"24939d60b8543e8fba3f541ecc8e7449b6ac618f","modified":1643707989570},{"_id":"source/_posts/Redis开发与运维/哨兵机制.md","hash":"4621678b22d5c4aa177808371b35e7812e3b805a","modified":1639967518587},{"_id":"source/_posts/Redis开发与运维/初识Redis.md","hash":"323bce5babe4fbf756f71cf0e1276d63dbc06626","modified":1640009512031},{"_id":"source/_posts/Redis开发与运维/缓存一致性.md","hash":"eb99edf3ca9b34706486b3691a7fca47da1ce564","modified":1643707766172},{"_id":"source/_posts/Redis开发与运维/缓存穿透雪崩击穿.md","hash":"13ad11e6c42aeb18a9a4f1d5a96423761f400268","modified":1643707873210},{"_id":"source/_posts/Redis开发与运维/内存机制.md","hash":"fe507a062d521c656a39b8d905add3681817dd15","modified":1639966022433},{"_id":"source/_posts/Redis开发与运维/持久化.md","hash":"ac8fa0ef60120b873cfc3ac9e4076c0639a22a2c","modified":1640017395353},{"_id":"source/_posts/Redis开发与运维/缓存设计.md","hash":"1d3a711b315994f02710dd251d4eb2f8c441672a","modified":1640011436911},{"_id":"source/_posts/Redis设计与实现/RDB持久化.md","hash":"56566f841100ce9b7f8fa5311264afcc076ae5f9","modified":1646271040071},{"_id":"source/_posts/Redis开发与运维/数据结构.md","hash":"a0fbe796512518516bd21439b639063c4c9b9e65","modified":1640011753661},{"_id":"source/_posts/Redis设计与实现/事件.md","hash":"68ff57ad4131de9435ff88b11307a4b6093d6e5d","modified":1646567105828},{"_id":"source/_posts/Redis设计与实现/事务.md","hash":"cab9391e330f3b7a78cd628b2af97a5ce8ad7aab","modified":1646927015698},{"_id":"source/_posts/Redis设计与实现/压缩列表.md","hash":"fbb38169a50e8f0ba4d499222a97d8051062a4fa","modified":1646024836003},{"_id":"source/_posts/Redis设计与实现/AOF持久化.md","hash":"93bcacd49c23a30c21591d1e7e2cce52e2ae7b8c","modified":1646361134903},{"_id":"source/_posts/Redis设计与实现/Sentinel机制.md","hash":"89d6f15e2e18140d1b26f5bf09ba294e64e39e9f","modified":1646706180425},{"_id":"source/_posts/Redis开发与运维/集群.md","hash":"dc69974a029f490e85e1401a24b095e1b3cc226e","modified":1640009255178},{"_id":"source/_posts/Redis设计与实现/复制.md","hash":"f9f5f13c764f76d212133e676ab27e69e7fa8afc","modified":1646627639180},{"_id":"source/_posts/Redis设计与实现/整数集合.md","hash":"033c577bae1142e8c17d4f3abfd146570e1c8b8e","modified":1646303395895},{"_id":"source/_posts/Redis设计与实现/字典.md","hash":"a6c9a06c64e096ebaaf5d4c75f03532d85b7e20d","modified":1646283378210},{"_id":"source/_posts/Redis设计与实现/简单动态字符串.md","hash":"2d2c7fdc2fa7da797f4b5aa80faf04d2de9801d8","modified":1645495594639},{"_id":"source/_posts/Redis设计与实现/跳跃表.md","hash":"388615be440279d3b25a6356984c828623e0b7cb","modified":1645862380751},{"_id":"source/_posts/Redis设计与实现/链表.md","hash":"f1054aff3da718853058e675a87253f6bd04fbf5","modified":1645580496589},{"_id":"source/_posts/Redis设计与实现/对象.md","hash":"da44327b1dbeafc637bbd660378945ff298ebcad","modified":1646111069228},{"_id":"source/_posts/Shell脚本编程大全/变量.md","hash":"250cbfb211de78edcabcb71670fa0e50fe737f91","modified":1645321709661},{"_id":"source/_posts/Shell脚本编程大全/基础知识.md","hash":"0b355490a9a3120cb8ed50579ec51753938f8c39","modified":1645260850733},{"_id":"source/_posts/Spring技术内幕/事务.md","hash":"8307766d4c50f4693da31a2a8723b5608f842e4f","modified":1643389576121},{"_id":"source/_posts/Redis设计与实现/数据库.md","hash":"24b6ace5d89139b1dc5ab956d4489ee79a38ea6c","modified":1646231734792},{"_id":"source/_posts/Redis设计与实现/集群.md","hash":"044587599618bcf0f7780118f67010c4606458bd","modified":1646790962155},{"_id":"source/_posts/Spring技术内幕/源码环境.md","hash":"dec4a115cb371e6fa6ded736745178e317c25205","modified":1643388594759},{"_id":"source/_posts/Spring技术内幕/扩展点.md","hash":"e7281049b5878c2bbe841e0425a683e9de849159","modified":1643703977303},{"_id":"source/_posts/Spring技术内幕/设计模式.md","hash":"c5f0cc841c3526cf1e480baf3b4e57cc9ed0845b","modified":1643703890370},{"_id":"source/_posts/SpringCloud微服务实战/Feign.md","hash":"f6597be5fd28830a64772bb8e05e3bccc4fddaf0","modified":1643456496467},{"_id":"source/_posts/SpringCloud微服务实战/Hystrix.md","hash":"eae15ea22c82894a179f85babae25b79ae786b0e","modified":1643455432236},{"_id":"source/_posts/Service Mesh实战/ServiceMesh.md","hash":"c2629429f3a20a5035aa09d10789fdd8342015c6","modified":1645458200530},{"_id":"source/_posts/SpringCloud微服务实战/Spring Cloud Circuit Breaker.md","hash":"e85dcca618724315cc0df408a7ed48fec0d07290","modified":1646392319911},{"_id":"source/_posts/SpringCloud微服务实战/Spring Cloud Gateway.md","hash":"e61daf5041ed5c9d685d5c91d0a8aa9834626d70","modified":1643538463659},{"_id":"source/_posts/Spring技术内幕/循环依赖.md","hash":"709309f658ad9b042669d5c3e99ece600a4e1c89","modified":1643389213006},{"_id":"source/_posts/SpringCloud微服务实战/Ribbon.md","hash":"6f08ab61978a2cb0c217f94baa645b2808ae5600","modified":1643454998494},{"_id":"source/_posts/Redis开发与运维/事务.md","hash":"8d070478371806c0b6cceeb55a43b278d4e7397c","modified":1639707048602},{"_id":"source/_posts/SpringCloud微服务实战/Zuul.md","hash":"18fa9fd4e230f35bac9bb7bc6950ed5a1db2bf1c","modified":1643538106238},{"_id":"source/_posts/SpringCloud微服务实战/常见问题.md","hash":"6453d34647f3c1484d16bab28a89dfb07a3ced68","modified":1643541219652},{"_id":"source/_posts/ZooKeeper分布式技术/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644157849689},{"_id":"source/_posts/ZooKeeper分布式技术/Leader选举.md","hash":"10096751321d483b4a11ed79644aabff9a9a8fa5","modified":1644156862451},{"_id":"source/_posts/ZooKeeper分布式技术/ACL权限.md","hash":"aaa9a40c21f57503f2ba9b78780964f61bb087e7","modified":1644230339826},{"_id":"source/_posts/ZooKeeper分布式技术/分布式ID.md","hash":"bad6e1a45de3a151ffd78dcdb4c52f259331a90f","modified":1644149766653},{"_id":"source/_posts/ZooKeeper分布式技术/分布式锁.md","hash":"fb2b0c7c3dce8c9fb30b124c0feefece45d36412","modified":1644149508286},{"_id":"source/_posts/ZooKeeper分布式技术/ZAB协议.md","hash":"e4d4af2272a4d543cabee476457f556dac0a69fb","modified":1644157464186},{"_id":"source/_posts/ZooKeeper分布式技术/Watch机制.md","hash":"ff1838a7e5ab567271fc59a8c8ba404fa9241551","modified":1644151395776},{"_id":"source/_posts/ZooKeeper分布式技术/会话机制.md","hash":"e8e510e31e9c47722dc1b76a5fb56c5eb9f1d0d2","modified":1644231362880},{"_id":"source/_posts/ZooKeeper分布式技术/序列化.md","hash":"c13b16f19de40610f70915477b991023d0e12401","modified":1644145486674},{"_id":"source/_posts/ZooKeeper分布式技术/日志清理.md","hash":"8a876fbdc4f0d7e730123828205dcb5d587289e0","modified":1644154160179},{"_id":"source/_posts/ZooKeeper分布式技术/负载均衡.md","hash":"6228a4350de14045b23b7e2f88e13cbeaa819701","modified":1644152255777},{"_id":"source/_posts/ZooKeeper分布式技术/数据同步.md","hash":"45b2eaf5ee3ae8be28622e5b1beb8d7e377775d6","modified":1644232463307},{"_id":"source/_posts/ZooKeeper分布式技术/数据文件.md","hash":"3ce8cb6fae9909b3bfbcc070956e07044d38f0ef","modified":1644155768074},{"_id":"source/_posts/ZooKeeper分布式技术/数据模型.md","hash":"252e3ca89bdab7572f401421ca3ddb18d9d62d2a","modified":1644161789905},{"_id":"source/_posts/Tomcat架构解析/Servlet.md","hash":"171eed9e773da5ce0d924621b8702ef8e1c2fe33","modified":1643814878542},{"_id":"source/_posts/Tomcat架构解析/双亲委托机制.md","hash":"f90fd35c0b867bb4a83e1cf5d854c558f7303f2d","modified":1644032134347},{"_id":"source/_posts/Tomcat架构解析/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1643954047381},{"_id":"source/_posts/Tomcat架构解析/核心组件.md","hash":"94e7db0906eecae1cb79ccf6e05604b686d47de0","modified":1643950487147},{"_id":"source/_posts/Tomcat架构解析/多层容器.md","hash":"213fa320ffb53d1d6f888a4d293175aa31892783","modified":1643861819200},{"_id":"source/_posts/Tomcat架构解析/Executor组件.md","hash":"6b2124d13893bde9aeb59f0fbdb4173929294cea","modified":1643952355556},{"_id":"source/_posts/ZooKeeper分布式技术/集群.md","hash":"f6ef581c3c7831252bfea0588ee07fcbe29b719f","modified":1644232342993},{"_id":"source/_posts/Tomcat架构解析/热部署和热加载.md","hash":"7f671097f0d79eb028ab7c140dd53805acc35e4b","modified":1643954179054},{"_id":"source/_posts/Tomcat架构解析/类加载器.md","hash":"74ac5a001a95b034643819658c2a7b570e9a02ee","modified":1644033198764},{"_id":"source/_posts/Tomcat架构解析/生命周期管理.md","hash":"4f727b5c632cab6da1c32d6b2a070e1fb808a4b0","modified":1643862264587},{"_id":"source/_posts/Tomcat架构解析/连接器.md","hash":"f808c1038e7babfc315664dd4653b720f15fb5d4","modified":1643861160726},{"_id":"source/_posts/代码整洁之道/组合和继承.md","hash":"a98fde19ee6e944a5c25976d410d9ead5b8eb8e6","modified":1643606807967},{"_id":"source/_posts/代码整洁之道/集合去重问题.md","hash":"9874baac058e9a2df706817ff29beba15fdb0275","modified":1643704959861},{"_id":"source/_posts/代码整洁之道/多层嵌套优化.md","hash":"e5fc5588952535e9db7e7df387f89d2e8268aa0f","modified":1643703655870},{"_id":"source/_posts/公众号文章/Disruptor框架.md","hash":"6a4afc75e51db138b247a5171f941e84023b015f","modified":1646498613778},{"_id":"source/_posts/公众号文章/Explain.md","hash":"04211a36e9605f361cc271d83f21f5997e6cd373","modified":1647051363759},{"_id":"source/_posts/公众号文章/ArrayList和LinkedList.md","hash":"518627ec0f9a2d64cf19e717d3f8ca71b5589b9e","modified":1644425769922},{"_id":"source/_posts/公众号文章/MySQL优化.md","hash":"3f622f4cd7f799b0ddbe7831de42948736ec4712","modified":1645666990331},{"_id":"source/_posts/公众号文章/动态代理.md","hash":"a77eec6a502f600901136847a7dee6d168451563","modified":1644323902116},{"_id":"source/_posts/公众号文章/慢查询.md","hash":"8675cb1f791bec5ba579b17299aec24cf3ce5344","modified":1644805946548},{"_id":"source/_posts/公众号文章/Spring设计模式.md","hash":"3fa8aea645acab6972e510741036db012fc27ea2","modified":1645243503868},{"_id":"source/_posts/公众号文章/ZooKeeper.md","hash":"c7eef3709a42d5a4f2d49713a0b592e48c3f6046","modified":1644166163538},{"_id":"source/_posts/公众号文章/散列表.md","hash":"78544a350bacfb63ffa54ff108f357d7adbe67bc","modified":1647190223615},{"_id":"source/_posts/公众号文章/线程安全.md","hash":"6b67ab9160a26e03d1570a64f590a0ea0f40d90f","modified":1643949809575},{"_id":"source/_posts/分布式服务架构/CAP和BASE.md","hash":"907b94f8479fe06a4f3af5b476c23f63734c39c9","modified":1643779256884},{"_id":"source/_posts/分布式服务架构/一致性Hash.md","hash":"9a36e6838dc6186c3d13de42724b29a2bd91f3b4","modified":1644226177282},{"_id":"source/_posts/公众号文章/网络IO模型.md","hash":"261ffbdeb50af69723f1030a7e24e524c539f62d","modified":1645374883929},{"_id":"source/_posts/分布式服务架构/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1645457772473},{"_id":"source/_posts/公众号文章/缓存一致性.md","hash":"badacdc3ed0417e675f18308720856950229bdd9","modified":1646152563592},{"_id":"source/_posts/分布式服务架构/分库分表.md","hash":"72e9def0d41cf7d6bc7003f9e387ca8f4130e586","modified":1643779302731},{"_id":"source/_posts/分布式服务架构/服务架构.md","hash":"c06f29682055236eddbf3ab2f5c4a23684a89507","modified":1643785157549},{"_id":"source/_posts/分布式服务架构/分布式事务.md","hash":"83e2740caf9611d827584fa4716c49465135f799","modified":1643785119244},{"_id":"source/_posts/分布式服务架构/分布式算法.md","hash":"1ff3f2a133f4d33affb911ae76cd5046717e9aaf","modified":1643784868912},{"_id":"source/_posts/图解TCP IP/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644072373480},{"_id":"source/_posts/图解TCP IP/HTTP.md","hash":"8d90eca9d4420e0d930deb22c223c22a3afcef74","modified":1644288675739},{"_id":"source/_posts/图解TCP IP/TCP IP基础知识.md","hash":"d66ac02207f58d980c1db46d74eb8a97f15838ac","modified":1644459626913},{"_id":"source/_posts/剑指OFFER/10II青蛙跳台阶问题.md","hash":"da3e919ccf4bfdd3aee10758b4219ef9f3bbe760","modified":1643389899425},{"_id":"source/_posts/剑指OFFER/15二进制中1的个数.md","hash":"9ca2e0b062da40aa9a98c5d5822ec3396badd577","modified":1643389904767},{"_id":"source/_posts/剑指OFFER/18删除链表的节点.md","hash":"43039489e38f265fab2de321035500ce56d8ffaf","modified":1643389909150},{"_id":"source/_posts/图解TCP IP/网络安全.md","hash":"b7ca305c1a2d7b0c51b488f8fd5317b8ca7dd4d2","modified":1644459648387},{"_id":"source/_posts/剑指OFFER/21调整数组顺序使奇数位于偶数前面.md","hash":"2392703d9943cc7e1db69d047ddebee740ada46a","modified":1643389913725},{"_id":"source/_posts/剑指OFFER/22链表中倒数第K个节点.md","hash":"30e4c45966f0c870e253afd39cb5de22e6c6c34d","modified":1643389917981},{"_id":"source/_posts/剑指OFFER/25合并两个排序的链表.md","hash":"9e07aa47f7e5f4a9bed2b8fad78d7824e8a89f41","modified":1643389925459},{"_id":"source/_posts/图解TCP IP/TCP和UDP.md","hash":"c48132b590c5d576035e6d142a0f4c4a506158fa","modified":1644288703913},{"_id":"source/_posts/剑指OFFER/24反转链表.md","hash":"0b8102a1095e3b7f0858b2f548357b421ab49b54","modified":1643389921841},{"_id":"source/_posts/剑指OFFER/27二叉树的镜像.md","hash":"ba366d75653c0bbc44bf5dff2836032fe7317f4b","modified":1643389935454},{"_id":"source/_posts/剑指OFFER/26树的子结构.md","hash":"1001c20a4f1e840e71ad973433499e165e7a91fa","modified":1643389929190},{"_id":"source/_posts/剑指OFFER/32III从上到下打印二叉树III.md","hash":"1a311892c75a82d692b6c1f8bbaeda1376195f84","modified":1643389945916},{"_id":"source/_posts/剑指OFFER/31栈的压入、弹出序列.md","hash":"b290d2090d2404b8b5ff1e4be1eadd8a80b7b549","modified":1643389939299},{"_id":"source/_posts/剑指OFFER/33二叉搜索树的后序遍历序列.md","hash":"9f3f21a7c44ab2c7367e2d1ab8c137555c472b54","modified":1643389962363},{"_id":"source/_posts/剑指OFFER/39数组中出现次数超过一半的数字.md","hash":"bf3eb0bf308735311eab7c0c18e04b77c660a67b","modified":1643389966448},{"_id":"source/_posts/剑指OFFER/32II从上到下打印二叉树II.md","hash":"86119db1b29b4817f2f3e0a3262896d825391ac2","modified":1643389949260},{"_id":"source/_posts/剑指OFFER/41数据流中的中位数.md","hash":"ada910e86a0eaa3ec779e852434f5b0c0522ea67","modified":1643389975938},{"_id":"source/_posts/剑指OFFER/42连续子数组的最大和.md","hash":"4e2e13e3b0e8c55339d2d6e4b0097a7623fe0bfa","modified":1643389979772},{"_id":"source/_posts/剑指OFFER/4二维数组中的查找.md","hash":"491dfab948666e6176f2b56402eec6a67e89e855","modified":1643389983692},{"_id":"source/_posts/剑指OFFER/54二叉搜索树的K大节点.md","hash":"d2edaecc69d97e34f1a7293f89a806b256fa81b7","modified":1643389993967},{"_id":"source/_posts/剑指OFFER/52两个链表的第一个公共节点.md","hash":"b984c7db19db317aafdf8733d955a1eeb2c34718","modified":1643389989565},{"_id":"source/_posts/剑指OFFER/55I二叉树的深度.md","hash":"4204353b351ce62108119209241b993842e87138","modified":1643390000177},{"_id":"source/_posts/剑指OFFER/3数组中重复的数字.md","hash":"744ec5926411e5055b8aad9a9c9d4e2ce3752b71","modified":1643389971682},{"_id":"source/_posts/剑指OFFER/65不用加减乘除做加法.md","hash":"2e71fc7603aeec7ea886bbfe50da876ae91ad2f7","modified":1643390009461},{"_id":"source/_posts/剑指OFFER/68II二叉树的最近公共祖先.md","hash":"97320eb27a8297d6d2c0fba4c0c149201142bf99","modified":1643390013379},{"_id":"source/_posts/剑指OFFER/63股票的最大利润.md","hash":"48e487c9f97a2f95e0daf0be8d77924885e7a89d","modified":1643390004346},{"_id":"source/_posts/剑指OFFER/68I二叉搜索树的最近公共祖先.md","hash":"6d3d528e359c970613f78c82aa35079284a3a27b","modified":1643390017322},{"_id":"source/_posts/剑指OFFER/6从尾到头打印链表.md","hash":"a23a100ce178bbadf5a824957b98eda5801ec390","modified":1643390021159},{"_id":"source/_posts/大话设计模式/UML.md","hash":"6bd62134e672ae304113914974f15127cb4bb140","modified":1642855065528},{"_id":"source/_posts/大话设计模式/代理模式.md","hash":"db2e437558e3f06aa0200a20d55999b0f3a6f1f5","modified":1642869346532},{"_id":"source/_posts/大话设计模式/六大设计原则.md","hash":"cfffba9cda2766b8de4ba1d177634e50c0182209","modified":1642855391932},{"_id":"source/_posts/大话设计模式/工厂方法模式.md","hash":"3c267c5143010bdc4baf38b06c640a4f4a7f9c60","modified":1642856455635},{"_id":"source/_posts/图解TCP IP/网络基础知识.md","hash":"5d590eeaa842d36fa435bdd62679c8e3a9614951","modified":1644303247392},{"_id":"source/_posts/大话设计模式/抽象工厂模式.md","hash":"b8315f1156ca66ff854453daca00f0b5e1091236","modified":1642862021084},{"_id":"source/_posts/大话设计模式/桥接模式.md","hash":"38a4348b9d3d989d14d1b55b539ee1e391d419ad","modified":1642862484642},{"_id":"source/_posts/SpringCloud微服务实战/Eureka.md","hash":"6410a7bb8bebabcc321635d3b57a4036e5aa2eb5","modified":1643453260158},{"_id":"source/_posts/大话设计模式/单例模式.md","hash":"461caabb399dfef830e736470dac0da3145a8167","modified":1647395278360},{"_id":"source/_posts/大话设计模式/简单工厂模式.md","hash":"c6e11c2a4dd0653ec1dd4135644cfe2c01953574","modified":1642856230202},{"_id":"source/_posts/大话设计模式/建造者模式.md","hash":"2569ca9fc29e6df740efd63bbcf8f1086f7e45ba","modified":1642862246343},{"_id":"source/_posts/剑指OFFER/9用两个栈实现队列.md","hash":"5030bbf52d820b826390acd340f0d406ccc42dfb","modified":1643390025367},{"_id":"source/_posts/大话设计模式/模板方法模式.md","hash":"2d14c193ab9618d88ccfc7a62a789e91e1d485c6","modified":1642866992702},{"_id":"source/_posts/大话设计模式/策略模式.md","hash":"1b83c56e7542cbcc1c2d32f4966413d57d787f64","modified":1642867131868},{"_id":"source/_posts/实现领域驱动设计/DDD入门.md","hash":"36d52bf9e7e2c4ddc257364bf3c1ce904697c771","modified":1641113879529},{"_id":"source/_posts/实现领域驱动设计/中台.md","hash":"185d9e8838e880ed574b0b3f12d21f5e2d67ed10","modified":1645945478292},{"_id":"source/_posts/实现领域驱动设计/仓库和工厂.md","hash":"39c2dd8291e62f2671ab967c2ccefe3135c95eea","modified":1645946345423},{"_id":"source/_posts/大话设计模式/装饰者模式.md","hash":"d60ffaea4c41a1ae46de90968611cf6b93922962","modified":1642863349651},{"_id":"source/_posts/大话设计模式/组合模式.md","hash":"2714b77fc27d2bf544657e3b4fd5f61157cea83e","modified":1645878914840},{"_id":"source/_posts/大话设计模式/适配器模式.md","hash":"6d924cf26fbfd546aae4983b67589959285764a8","modified":1645877626587},{"_id":"source/_posts/实现领域驱动设计/代码模型.md","hash":"7fea2735daa43b0d6509f01a3bad7a621ec15098","modified":1645947068597},{"_id":"source/_posts/实现领域驱动设计/实体和值对象.md","hash":"5ea7e7014deecd0bd3aa08bfe15542a6adca9449","modified":1641131989666},{"_id":"source/_posts/实现领域驱动设计/微服务架构.md","hash":"763b891c2b9691e92f0a6a02bbfbc5f0de69d8c6","modified":1641189073490},{"_id":"source/_posts/实现领域驱动设计/经典架构.md","hash":"ff607ed4627769ed8ed782c335fb7394b12b3ee7","modified":1641192637482},{"_id":"source/_posts/实现领域驱动设计/经典分层.md","hash":"bed5be03b47c0dc9df68cdd818a7036f1458f3b9","modified":1645946544819},{"_id":"source/_posts/实现领域驱动设计/领域服务.md","hash":"a3deb8a0e07e343af8230041f0480ef7bef7d5cf","modified":1641191831646},{"_id":"source/_posts/实现领域驱动设计/聚合和聚合根.md","hash":"33d7e4314cbf81744c99b9ab4d37f298440bfe5d","modified":1641140473229},{"_id":"source/_posts/实现领域驱动设计/领域、子域和限界上下文.md","hash":"3012372e6115eda901678fc323494e451864ca51","modified":1644728170748},{"_id":"source/_posts/实现领域驱动设计/领域模型.md","hash":"662e9d516bcd1f842656bac95ef605b51b0a38e9","modified":1641180426074},{"_id":"source/_posts/实现领域驱动设计/领域事件.md","hash":"72bde7906000ada043f414ee6e3bf3c32d52831e","modified":1641183225536},{"_id":"source/_posts/操作系统导论/线程.md","hash":"91f4a418be04469d0484c47e55e8dc8e53427ac5","modified":1643723594716},{"_id":"source/_posts/操作系统导论/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1643885842277},{"_id":"source/_posts/操作系统导论/设备管理.md","hash":"dd0470867893f49a715b03f54753eff0e734e0df","modified":1643722650403},{"_id":"source/_posts/操作系统导论/常见面试题.md","hash":"a44ed0ef3f566154e676430ec075420004299cdc","modified":1643726070176},{"_id":"source/_posts/操作系统导论/内存管理.md","hash":"3830f895bbf5e929281a75e68f58aa177959ac1f","modified":1643725995494},{"_id":"source/_posts/操作系统导论/计算机结构.md","hash":"af0bc383c7120613e2aea303acbd421537302026","modified":1643885959198},{"_id":"source/_posts/数据结构与算法分析/B树和B+树.md","hash":"fa3eaa8f1d7b8db08380b7e8e9e04ddfee6e3575","modified":1643885169061},{"_id":"source/_posts/操作系统导论/进程.md","hash":"5de1cb760737d42751e7d54167162058e798bd86","modified":1643725749182},{"_id":"source/_posts/架构师修炼之道/异地多活.md","hash":"9ca011e0321c64b28e672e722059c3850139031d","modified":1645969414809},{"_id":"source/_posts/架构师修炼之道/秒杀系统.md","hash":"926ebdd266fa8527dceac2d6478d384c3b36234a","modified":1644726559433},{"_id":"source/_posts/数据结构与算法分析/LRU算法.md","hash":"226f7e5329b28f4f03f9b4b24cbcced9d32add65","modified":1643885435443},{"_id":"source/_posts/数据结构与算法分析/红黑树.md","hash":"8c5d69b57aed620e5c947f17888756b5a7818039","modified":1643883944842},{"_id":"source/_posts/数据结构与算法分析/跳跃表.md","hash":"2b116fdeef147efbb3cfea96b653d536b6c40a6b","modified":1643884778809},{"_id":"source/_posts/数据结构与算法分析/二分查找算法.md","hash":"e0929ffa5f18be0b7c784a91e7e44beacb361fa3","modified":1645976946776},{"_id":"source/_posts/数据结构与算法分析/布隆过滤器.md","hash":"9433579dd928d18fd3eefaa4e3c6929f4aab5dba","modified":1643883542661},{"_id":"source/_posts/深入浅出ServerLess/基本定义.md","hash":"fe2627eb075580c43902f55785746a489b861102","modified":1645331651740},{"_id":"source/_posts/深入理解JVM虚拟机/GC日志.md","hash":"a5112326539a9e8f2be12ca6bfcd44bda3067ae1","modified":1643704511849},{"_id":"source/_posts/数据结构与算法分析/排序算法.md","hash":"bb05fd86c630b742bfc05f5595dfe4ccfcf320df","modified":1643884364735},{"_id":"source/_posts/深入浅出ServerLess/基本介绍.md","hash":"d8797150fff7bcf994f830058bb41c832dbd3d99","modified":1645325713048},{"_id":"source/_posts/深入理解JVM虚拟机/内存区域.md","hash":"b670a0d9c87c94cc7537314a849b76b5318fe096","modified":1640013161169},{"_id":"source/_posts/深入理解JVM虚拟机/内存回收.md","hash":"9f19fa01020b34abff7b5199b89f3a95a7160ef1","modified":1640501240079},{"_id":"source/_posts/深入理解JVM虚拟机/内存溢出.md","hash":"dfe13a54a26308480221450ae64e0b4a39108d50","modified":1643707350363},{"_id":"source/_posts/深入理解JVM虚拟机/垃圾收集器.md","hash":"becd24763074a138662d99772011184e1bad00d3","modified":1640015309544},{"_id":"source/_posts/深入理解JVM虚拟机/即时编译器.md","hash":"0e3e1956f8a37fec1da6e7f20095fda691d045b2","modified":1640535143114},{"_id":"source/_posts/深入理解JVM虚拟机/类加载机制.md","hash":"757155b0d6c9cf81a18a86b45a684e90710e1276","modified":1640017623397},{"_id":"source/_posts/深入理解Nginx/反向代理.md","hash":"08d2f7b1b839d78fe5efd6a81209a34a5a571018","modified":1644670729522},{"_id":"source/_posts/深入理解Nginx/基础知识.md","hash":"e245bdb0a5e74c0f434ada358d8f3a6510f11bc3","modified":1644670878003},{"_id":"source/_posts/深入理解Nginx/负载均衡.md","hash":"cedb98d361d889fb6f27682cfac7f2235c088636","modified":1644670130889},{"_id":"source/_posts/金字塔原理/为什么要用金字塔结构.md","hash":"8b413db55d69c8229fa819ba50e8f31ab0fcf509","modified":1643702878753},{"_id":"source/_posts/金字塔原理/如何构建金字塔.md","hash":"97ef2d9298d32c9012b1a3dbe3cfd7db2ce1c542","modified":1643702884472},{"_id":"source/_posts/深入理解JVM虚拟机/垃圾收集算法.md","hash":"2b0860337c524539e77fd4e96e35a2a3cd26324b","modified":1640501606109},{"_id":"source/_posts/大话设计模式/责任链模式.md","hash":"0bc76d4ee46c3f450dddf9c0d0f097bf1fa52d07","modified":1642867420887},{"_id":"source/_posts/深入理解JVM虚拟机/类文件结构.md","hash":"b437bc47fa9b9e1d2626e7dc5bb93021573c3f17","modified":1640503474319},{"_id":"source/_posts/深入理解RPC框架原理/优雅启动.md","hash":"18a2bbefeecaac1da5e423ad7a2efad27aeffb65","modified":1644133840288},{"_id":"source/_posts/深入理解RPC框架原理/兼容协议.md","hash":"65b5e26e59fe7cc07207dfda8bfd1c1038368d79","modified":1644130323610},{"_id":"source/_posts/深入理解RPC框架原理/协议.md","hash":"02c0fca7ad17fb87860d574f59ca1f7587f8dfa4","modified":1644132309236},{"_id":"source/_posts/深入理解RPC框架原理/基本介绍.md","hash":"d281b6d929a9ce44c3abef269f00c993dc5787f7","modified":1644130357711},{"_id":"source/_posts/深入理解RPC框架原理/安全体系.md","hash":"6bcbc73a8f6fa32f682e6da86bc236540568583d","modified":1644127571096},{"_id":"source/_posts/深入理解RPC框架原理/定位问题.md","hash":"0b2f902cfc55d9fc12883e9e6c0de7f43255e59c","modified":1644127783390},{"_id":"source/_posts/深入理解RPC框架原理/序列化.md","hash":"c8cbd6d138ae5dfe8139fadf33a2db113e5db9c1","modified":1644132427664},{"_id":"source/_posts/深入理解RPC框架原理/异常重试.md","hash":"032e07eb97cd69e6987ebe60cd2336e809897ad9","modified":1644132953249},{"_id":"source/_posts/深入理解RPC框架原理/异步RPC.md","hash":"1c3d35e3bc4f0d1a669543d270c2656e94b63cd9","modified":1644132839651},{"_id":"source/_posts/深入理解JVM虚拟机/虚拟机对象.md","hash":"eaa3dea890e5ab5b89031b5c1a408844d186f389","modified":1640431780144},{"_id":"source/_posts/深入理解RPC框架原理/架构设计.md","hash":"52aa6e31a01fc7df345cce3e22dc5565093f8ff2","modified":1644130048896},{"_id":"source/_posts/深入理解RPC框架原理/泛化调用.md","hash":"f09a9985865791bbb3f0ebbb0cb97334c5e3206f","modified":1644128455762},{"_id":"source/_posts/深入理解RPC框架原理/流量回放.md","hash":"80a5b82ef97f5a2fa5ac94f26e944dd13f6964d6","modified":1644130483320},{"_id":"source/_posts/深入理解RPC框架原理/熔断限流.md","hash":"ff896d5ef1a43ba6dfe2d434de7e3125d4b17cb9","modified":1644131896565},{"_id":"source/_posts/深入理解RPC框架原理/秒级扩缩容.md","hash":"fc7bfe95f2c92ff9beb99447ce72b11089b180e3","modified":1644131686374},{"_id":"source/_posts/深入理解RPC框架原理/负载均衡.md","hash":"536288d8ec38165a100cc2341c33377cb20918bd","modified":1644129340378},{"_id":"source/_posts/深入理解RPC框架原理/隔离流量.md","hash":"983acc4268757a19a1af6cafba70eec45627ce18","modified":1644129512515},{"_id":"source/_posts/金字塔原理/金字塔内部结构.md","hash":"860fa8f237e0230049510986b2cfb7663c8437ad","modified":1643702888925},{"_id":"source/_posts/高性能MySQL/Explain.md","hash":"6e932bd1b72a898c3623f1381080fbcea99f9828","modified":1642126025327},{"_id":"source/_posts/深入理解RPC框架原理/优雅关闭.md","hash":"e8d3d9414a4885ef59450b0c091d8fab979b949a","modified":1644133410453},{"_id":"source/_posts/高性能MySQL/MVCC.md","hash":"1ebf544f3a3f7449110b54629658898f9c004851","modified":1642089801018},{"_id":"source/_posts/高性能MySQL/MySQL基础.md","hash":"6afce821a07de5712949b68ca01c68da4cf8ab33","modified":1642299348975},{"_id":"source/_posts/高性能MySQL/MySQL调优.md","hash":"9eb726b4d82e18f98830b9cf9844bd077cc787e1","modified":1642300452860},{"_id":"source/_posts/高性能MySQL/Order By.md","hash":"c0f7a8d6ed480556a0a96783c6002fb5377b9439","modified":1642224924352},{"_id":"source/_posts/高性能MySQL/SQL更新.md","hash":"b09d188770bf13d3bc9286d972ee7c7743b79109","modified":1642298885757},{"_id":"source/_posts/高性能MySQL/主从复制.md","hash":"c4a14bd8dd3db269d2280664a7da7ee513441139","modified":1641949288124},{"_id":"source/_posts/阿里Java开发手册/.DS_Store","hash":"a36b8882b78cbd6818f6d401c7ae1e25551d79a2","modified":1647322212891},{"_id":"source/_posts/高性能MySQL/关联查询.md","hash":"9fada2bdf04ab049161a64bd0511d95bd1cf1436","modified":1642228678951},{"_id":"source/_posts/高性能MySQL/分区表.md","hash":"32ca95dcb71c7e6ee296be419796149801775a9e","modified":1642214718478},{"_id":"source/_posts/高性能MySQL/存储引擎.md","hash":"d18fa9ac3bababec89b48511788951f6c4d302b7","modified":1642037318709},{"_id":"source/_posts/高性能MySQL/常用SQL.md","hash":"923dd9fd7aa7787728ee21b09d03256b430a6d91","modified":1642231022028},{"_id":"source/_posts/高性能MySQL/MySQL架构.md","hash":"f46cbb345cb48494d9f74734bd7affa172045455","modified":1642085526988},{"_id":"source/_posts/高性能MySQL/事务.md","hash":"e99c93d7255c1002498e80429f88f1d438abe79f","modified":1642325584226},{"_id":"source/_posts/高性能MySQL/范式.md","hash":"b90792a4a40789e342b329aa0b2053b9019bbb59","modified":1642036896566},{"_id":"source/_posts/高性能MySQL/Buffer Pool.md","hash":"f7c55b017eb3bcd3552e403a2f71874d9a8cafba","modified":1646706904833},{"_id":"source/_posts/高性能MySQL/日志文件.md","hash":"21d5c05a63a77f74d07aab60697d5b791a44d653","modified":1641914163588},{"_id":"source/_posts/鸟哥的Linux私房菜/IO多路复用.md","hash":"ef6c7a1d2cc9e11c1e102d56afbbca1d6711c33e","modified":1644652090171},{"_id":"source/_posts/鸟哥的Linux私房菜/IO模型.md","hash":"c13933fbb75733a1090ea14cb947115de691e3c0","modified":1644652765140},{"_id":"source/_posts/高性能MySQL/索引.md","hash":"408a4d8d8585d48e3871aa901bb36d56efa84f98","modified":1642322377471},{"_id":"source/_posts/高性能MySQL/锁机制.md","hash":"d8577ccefec7b2cf6c99b12b8754f3c15ddeeeb4","modified":1642327261897},{"_id":"source/_posts/鸟哥的Linux私房菜/常见问题.md","hash":"ded64f23b03c0fc237f85775acca567f0243acbc","modified":1644640369531},{"_id":"source/_posts/鸟哥的Linux私房菜/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644645153833},{"_id":"source/_posts/鸟哥的Linux私房菜/服务管理.md","hash":"c1a6dcb2b7af361cd7a220fd2b631a5f41cc1609","modified":1644648809685},{"_id":"source/_posts/鸟哥的Linux私房菜/权限管理.md","hash":"351315466b2422b500d7a569a1195d40bac8b456","modified":1644645612874},{"_id":"source/_posts/鸟哥的Linux私房菜/用户管理.md","hash":"82ebcdf8c80aad0aabdacf01a6022deff53a40e5","modified":1644647182456},{"_id":"source/_posts/鸟哥的Linux私房菜/系统管理.md","hash":"b1d18093323b2c51355e24b90612afdd6846e2df","modified":1644649574333},{"_id":"source/_posts/鸟哥的Linux私房菜/VIM编辑器.md","hash":"f4b5dd5938a9ce9b8c47684e235c71cf45215920","modified":1644647398262},{"_id":"source/_posts/Netty权威指南/源码解读/编解码.md","hash":"f91b041a66d6e14d4cef80b9004317c031f06ad7","modified":1646391662793},{"_id":"source/_posts/鸟哥的Linux私房菜/基础知识.md","hash":"eda417b7a01aa81a17b4afc494bdb33ac462b6da","modified":1644652838452},{"_id":"source/_posts/Netty权威指南/源码解读/服务端启动.md","hash":"cc68c07cb963ba41301ef136614e40cd23736ceb","modified":1646319846508},{"_id":"source/_posts/阿里Java开发手册/编程规约/常量定义.md","hash":"fd1a4145a5d6103a92254dc1e6ba94cabc93fdd7","modified":1647322227778},{"_id":"source/_posts/阿里Java开发手册/编程规约/OOP规约.md","hash":"13a70d886c3dfc7c05d417ef8270053bed4213e9","modified":1647323791829},{"_id":"source/_posts/鸟哥的Linux私房菜/零拷贝问题.md","hash":"904f1723fb200d696e56d977342ac46d4f2e59e4","modified":1644651299240},{"_id":"source/_posts/阿里Java开发手册/编程规约/命名风格.md","hash":"e9ba653d34b6127296ae0779d1db0bda7d60d473","modified":1647309815731},{"_id":"source/_posts/阿里Java开发手册/编程规约/并发处理.md","hash":"e5eb1bb9eb375fce2d0028a3903d393109a4e166","modified":1647394884962},{"_id":"source/_posts/阿里Java开发手册/编程规约/集合处理.md","hash":"c575d6ecb3dc44ec76ae5f0c731403cd02b11854","modified":1647326009199},{"_id":"source/_posts/深入理解RPC框架原理/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1644132084775},{"_id":"source/_posts/Java并发编程实战/并发工具类.md","hash":"00a1122007d68fa01d0c47d10fab6919ca942cf3","modified":1647180776288},{"_id":"themes/tree/README.md","hash":"bb4595e8fe8c2ecf71b0449db8a77519307bf75b","modified":1630473738223},{"_id":"themes/tree/_config.yml","hash":"ec5bcd83da26f2ec8921db196145b1392745d9f2","modified":1647192840827},{"_id":"themes/tree/layout/layout.ejs","hash":"b1cbe3e0c52a8fa644a5adb97b31b5ecfdec2162","modified":1630473738223},{"_id":"themes/tree/source/404.html","hash":"9788847c4015f690d31185336add4d62c68dc68d","modified":1630473738224},{"_id":"themes/tree/layout/index.ejs","hash":"101bd5d563884579882c8caaeafbc3139134bab4","modified":1630473738223},{"_id":"themes/tree/source/个人公众号.jpg","hash":"a7528a513682ae9f10b826104274da759deb4ec8","modified":1630473738228},{"_id":"themes/tree/source/个人微信.jpeg","hash":"ba47cfa4fc9bc5579f10cbbb984baf7bff5726d6","modified":1630473738228},{"_id":"themes/tree/layout/_partial/footer.ejs","hash":"31f5c6ada41a9c03ad997d876213b7335e4b826a","modified":1643953288862},{"_id":"themes/tree/source/头像.jpg","hash":"2596dd7ebfc5c2a5bf4538525e7bdc1eebf6afb8","modified":1630473738229},{"_id":"themes/tree/layout/post.ejs","hash":"0def30128cc9c4fba697e7f7b5d2d71abcc5d1a8","modified":1647480858984},{"_id":"themes/tree/layout/_partial/head.ejs","hash":"27d8dc45662b313402ba9840eed85cfcc6b934f1","modified":1630473738223},{"_id":"themes/tree/layout/_partial/header.ejs","hash":"16d957b4e06190d205b89ad17b2f0bcb982a15df","modified":1646629646030},{"_id":"themes/tree/source/favicon.ico","hash":"268be0a863caae7c5a732fb8a911a81434f31117","modified":1630473738224},{"_id":"themes/tree/layout/_partial/totop.ejs","hash":"a94c4b350b76d21bb530095981049a2647cc6273","modified":1630473738223},{"_id":"themes/tree/source/css/clipboard-use.css","hash":"9536f622240449099e4a35072cc42b28538c0eec","modified":1630473738224},{"_id":"themes/tree/layout/_partial/sidebar.ejs","hash":"76296d9b3d5829e02ad02075447fda495ee9c825","modified":1630473738223},{"_id":"themes/tree/source/js/clipboard.min.js","hash":"6371ec0a8e242395c7d4d008d2b98e472c9dcc52","modified":1630473738224},{"_id":"themes/tree/source/js/main.js","hash":"b9ba5bd773383322d002ba92e9d205fd0b2fb599","modified":1630473738225},{"_id":"themes/tree/source/css/main.css","hash":"8f5499563af3f3f4f4c1826cb3e269486c01efe4","modified":1641658845876},{"_id":"themes/tree/source/lib/highlight/darcula.css","hash":"7740224d07375ddc321147dffabbfa83e39f0d8b","modified":1630473738226},{"_id":"themes/tree/source/css/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1630473738224},{"_id":"themes/tree/source/lib/font-awesome/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1630473738225},{"_id":"themes/tree/source/lib/jquery.pjax.js","hash":"13485a1e2dc9c8df28267549de1b8af8f39061d9","modified":1630473738227},{"_id":"themes/tree/source/lib/busuanzi/2.3/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1630473738225},{"_id":"themes/tree/source/lib/highlight/highlight.pack.js","hash":"84a7e42dfa8c44a422a8328277d660d9428fcea6","modified":1630473738226},{"_id":"themes/tree/source/js/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1630473738225},{"_id":"themes/tree/source/lib/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1630473738226},{"_id":"themes/tree/source/lib/valine/Valine-1.3.10-min.js","hash":"e3a340d0c39eee2ae651284fda9d351e752fcbd0","modified":1630473738227},{"_id":"themes/tree/source/lib/valine/av-3.0.4-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1630473738228},{"_id":"public/about/index.html","hash":"319639414fff47e40461892737b65c963f243d0d","modified":1647482410346},{"_id":"public/graph/index.html","hash":"9591c984abd173876c0ce18000f6f4ad69eb021f","modified":1647482410346},{"_id":"public/404/index.html","hash":"cdf2136748580be79dd8c60bcd987d8cdaaae92c","modified":1647482410346},{"_id":"public/movie/index.html","hash":"f7d70557d63667286d09963c3c26df793cb95c33","modified":1647482410346},{"_id":"public/neitui/index.html","hash":"b5483f76c2c576b5c30110c4c2fe4eae058045c3","modified":1647482410346},{"_id":"public/rescource/index.html","hash":"9aa70d092df8f3c3780ad17ad998e12bafc4445e","modified":1647482410346},{"_id":"public/2022/03/16/阿里Java开发手册/编程规约/并发处理/index.html","hash":"3378ab20097d64a1d0b831df5599682b27f72801","modified":1647482410346},{"_id":"public/2022/03/15/阿里Java开发手册/编程规约/集合处理/index.html","hash":"8f2e1f20682845f30f1639339c1eec1d2fa45281","modified":1647482410346},{"_id":"public/2022/03/15/阿里Java开发手册/编程规约/OOP规约/index.html","hash":"1c4d77680f9bd07d70f45de1ab20a6ccdafda879","modified":1647482410346},{"_id":"public/2022/03/15/阿里Java开发手册/编程规约/常量定义/index.html","hash":"408961005729d0847b2380a8beda181f41babb31","modified":1647482410346},{"_id":"public/2022/03/15/阿里Java开发手册/编程规约/命名风格/index.html","hash":"e1fe6e8134eed82ad5f154194e6fac1dfbd3d065","modified":1647482410346},{"_id":"public/2022/03/14/MySQL必知必会/ER模型/index.html","hash":"30125fd3bd0531d2def62d788048d2d700673994","modified":1647482410346},{"_id":"public/2022/03/13/公众号文章/散列表/index.html","hash":"85c2ae069e17ddc5eb1c50a7dad94d955a5110ff","modified":1647482410346},{"_id":"public/2022/03/13/MyBatis技术内幕/核心原理/index.html","hash":"aff2f2cec6a48c651a48d8691f8099d58483ec47","modified":1647447989172},{"_id":"public/2022/03/13/MySQL必知必会/数据备份/index.html","hash":"8a2950259132cbaa52a22502e4041257f759d0f6","modified":1647482410346},{"_id":"public/2022/03/12/MySQL必知必会/日志查看/index.html","hash":"f0bf831812ec32a5882db861bc68ef46446794fb","modified":1647482410346},{"_id":"public/2022/03/12/公众号文章/Explain/index.html","hash":"2cc90c02b3cc1b08756ba368c75eed985d7dbb3f","modified":1647482410346},{"_id":"public/2022/03/10/Redis设计与实现/事务/index.html","hash":"678f75b88bd9119145fd45ecc923a8c85c944a29","modified":1647447989172},{"_id":"public/2022/03/09/Redis设计与实现/集群/index.html","hash":"b07b62315befb67d19e54db9587ba9e9ed3a04c6","modified":1647447989172},{"_id":"public/2022/03/08/Redis设计与实现/Sentinel机制/index.html","hash":"f515c8e586c7b1dfc38427472f64670697d2bb3c","modified":1647447989172},{"_id":"public/2022/03/07/MySQL必知必会/字段类型/index.html","hash":"7d7ccec3d9acb5714993a4a951943577af78572b","modified":1647482410346},{"_id":"public/2022/03/07/Redis设计与实现/复制/index.html","hash":"a2c2147ecb50d2387090dd093b81c92b327dcea0","modified":1647447989172},{"_id":"public/2022/03/06/Redis设计与实现/事件/index.html","hash":"83ad4c97e8305fa6c63d38124c02545cd6a1596b","modified":1647447989172},{"_id":"public/2022/03/06/公众号文章/Disruptor框架/index.html","hash":"7a28f26c7850561c121a737922a55e3deb15906a","modified":1647482410346},{"_id":"public/2022/03/04/Netty权威指南/源码解读/编解码/index.html","hash":"4e1bc6a9a16f3ba85556492f0452ec4d25f64496","modified":1647447989172},{"_id":"public/2022/03/04/Redis设计与实现/AOF持久化/index.html","hash":"9f25b7233a130e832dc251d4151a5bb0794618ea","modified":1647447989172},{"_id":"public/2022/03/03/Netty权威指南/源码解读/服务端启动/index.html","hash":"cfad7ee9dde48e4eca128eaac4f2b0d815adbb0f","modified":1647447989172},{"_id":"public/2022/03/03/Redis设计与实现/RDB持久化/index.html","hash":"8c07ea7f8be301bf34be6150d6e27c25a3afe7a2","modified":1647447989172},{"_id":"public/2022/03/02/Redis设计与实现/数据库/index.html","hash":"b0d4b27184d1892d60d4c66a82dd23c2e8f62192","modified":1647447989172},{"_id":"public/2022/03/01/公众号文章/缓存一致性/index.html","hash":"01bf258d4597bf3a4a2f49dc069b0cfe7435d947","modified":1647482410346},{"_id":"public/2022/03/01/Redis设计与实现/对象/index.html","hash":"90b05cbede7601812289f07bd0ea4c5f7eb4ff7e","modified":1647447989172},{"_id":"public/2022/02/28/Redis设计与实现/压缩列表/index.html","hash":"2e3f9940c29511a3039418e76705e7b0baf701f4","modified":1647447989172},{"_id":"public/2022/02/27/数据结构与算法分析/二分查找算法/index.html","hash":"44d0c7f00958c9a53594e7bd7eaa41c7915442bd","modified":1647447989172},{"_id":"public/2022/02/27/架构师修炼之道/异地多活/index.html","hash":"60f07ebb254359f7c3007cf22c68ba55b60c4db3","modified":1647447989172},{"_id":"public/2022/02/27/Redis设计与实现/整数集合/index.html","hash":"e4181eda5493a5063721e259b654cb4740976af8","modified":1647447989172},{"_id":"public/2022/02/27/实现领域驱动设计/中台/index.html","hash":"b33bf257e5d7eeff21d3d71db47b23c426648548","modified":1647447989172},{"_id":"public/2022/02/26/大话设计模式/组合模式/index.html","hash":"0d6b5322bf306181a8870042c2af339736f29979","modified":1647447989172},{"_id":"public/2022/02/26/大话设计模式/适配器模式/index.html","hash":"32d3104b52a3e8be6a9c0689b9e5f81c26d0298e","modified":1647447989172},{"_id":"public/2022/02/26/Redis设计与实现/跳跃表/index.html","hash":"7f9855115c7f390a4c2141a5a6db8a32f148b02c","modified":1647447989172},{"_id":"public/2022/02/24/Redis设计与实现/字典/index.html","hash":"cda7e2425a8b5d3844a2510bed1f5eae8596686c","modified":1647447989172},{"_id":"public/2022/02/24/公众号文章/MySQL优化/index.html","hash":"b4c83b4139f23355e1652f97d606efcb67f10807","modified":1647482410346},{"_id":"public/2022/02/23/Redis设计与实现/链表/index.html","hash":"1a5dfd656f95b6a05fe31fce3f92c4d2ce6bbef0","modified":1647447989172},{"_id":"public/2022/02/22/Redis设计与实现/简单动态字符串/index.html","hash":"7b8b6c7d3984d1ecf91f7dc4f6c197601c7fcd2d","modified":1647447989172},{"_id":"public/2022/02/20/公众号文章/网络IO模型/index.html","hash":"a07e9e9ced17f723d71b397b1374890cebd7811f","modified":1647482410346},{"_id":"public/2022/02/20/深入浅出ServerLess/基本定义/index.html","hash":"f692803451d1d56be87cc45d65e33d1f6ebdf18a","modified":1647447989172},{"_id":"public/2022/02/20/Shell脚本编程大全/变量/index.html","hash":"1718779d66e503be504c5525e575a188d2d8e7c8","modified":1647482410346},{"_id":"public/2022/02/19/Shell脚本编程大全/基础知识/index.html","hash":"ed3226782284e0ff0880ff007493132e5cdae056","modified":1647482410346},{"_id":"public/2022/02/19/公众号文章/Spring设计模式/index.html","hash":"599425d0e968ccf2ed37266d8f454370651ef316","modified":1647482410346},{"_id":"public/2022/02/14/公众号文章/慢查询/index.html","hash":"5e742464b49ae718840d278ad7fd5676f9f54d9a","modified":1647482410346},{"_id":"public/2022/02/13/架构师修炼之道/秒杀系统/index.html","hash":"72c5ccaba041e1a7113da1fcadf07ff706c488bd","modified":1647447989172},{"_id":"public/2022/02/12/鸟哥的Linux私房菜/系统管理/index.html","hash":"fbe6a7a4143fcc2a3d75b3eda93e3275d9454290","modified":1647447989172},{"_id":"public/2022/02/12/鸟哥的Linux私房菜/服务管理/index.html","hash":"92c42bf1371c8ebdc268e5722cc3ddcda199312b","modified":1647447989172},{"_id":"public/2022/02/12/鸟哥的Linux私房菜/用户管理/index.html","hash":"72ebbbc98e695831038bfc5d228313b8326cc1bb","modified":1647447989172},{"_id":"public/2022/02/12/鸟哥的Linux私房菜/权限管理/index.html","hash":"f568346b03a019950ace647277f5c25266c5c1b4","modified":1647447989172},{"_id":"public/2022/02/12/鸟哥的Linux私房菜/基础知识/index.html","hash":"8e5d358a95b483cf7f05deeedd79039a899fe07f","modified":1647447989172},{"_id":"public/2022/02/12/鸟哥的Linux私房菜/常见问题/index.html","hash":"f6a63dd580d4996e6f3b3de97420b9346c1f3c0e","modified":1647447989172},{"_id":"public/2022/02/10/图解TCP IP/网络安全/index.html","hash":"9bf78169151fb6eb11455937a0ce30d84d33a78e","modified":1647482410346},{"_id":"public/2022/02/10/公众号文章/ArrayList和LinkedList/index.html","hash":"da7d97908290ae1e1399aae61a2a6c231017ac2d","modified":1647482410346},{"_id":"public/2022/02/09/图解TCP IP/TCP IP基础知识/index.html","hash":"5466cff2739ddcb0009fc9f454bcec43a9f00c5f","modified":1647482410346},{"_id":"public/2022/02/08/公众号文章/动态代理/index.html","hash":"01c599ead4e2fcd6003cd8ba42e14d1d6a7b26fe","modified":1647482410346},{"_id":"public/2022/02/08/图解TCP IP/网络基础知识/index.html","hash":"4259555a4b5b41662caeb8d534d3e1cf98aa192f","modified":1647482410346},{"_id":"public/2022/02/08/Effective Java/类和接口/index.html","hash":"8b45559d6f3a19e911f9ad7d64500ad87b07c63c","modified":1647482410346},{"_id":"public/2022/02/06/公众号文章/ZooKeeper/index.html","hash":"7590e1eca09b95a540ac634125ae1336ce3c54e9","modified":1647482410346},{"_id":"public/2022/02/06/Effective Java/通用方法/index.html","hash":"0fd03cc42fc478e8e8b66e019b86e7a40a65051c","modified":1647482410346},{"_id":"public/2022/02/05/Java并发编程实战/CAS/index.html","hash":"309bf3e0ce0d913882ec2fccaf2bcdcb0a134d00","modified":1647447989172},{"_id":"public/2022/02/05/Java并发编程实战/线程池/index.html","hash":"baef76e763f3be3fca1aa6a66ede7644885a1db9","modified":1647447989172},{"_id":"public/2022/02/05/Tomcat架构解析/类加载器/index.html","hash":"419c88af12125045b4d5965eb7c9625644b2679c","modified":1647482410346},{"_id":"public/2022/02/05/Tomcat架构解析/双亲委托机制/index.html","hash":"a8d5a238ea5c6283ed77e2b7efb87cd90aa8bb53","modified":1647482410346},{"_id":"public/2022/02/04/Tomcat架构解析/热部署和热加载/index.html","hash":"ccf0a8bd74c78b7ad3cd6a3fb867010b868d6b0b","modified":1647482410346},{"_id":"public/2022/02/04/Tomcat架构解析/Executor组件/index.html","hash":"e09a3e87bbcbcd26e975a6a8597a8d9d69415aa2","modified":1647482410346},{"_id":"public/2022/02/04/Tomcat架构解析/核心组件/index.html","hash":"4fa27f6183b7f07019d04d3d84ca7200f8ca0d6a","modified":1647482410346},{"_id":"public/2022/02/04/公众号文章/线程安全/index.html","hash":"afe9f3fa61a8f962091d2cec77d5c0f61035d118","modified":1647482410346},{"_id":"public/2022/02/03/Tomcat架构解析/生命周期管理/index.html","hash":"2f7b88c09009f277cca27dfa05524beeaf5f933f","modified":1647482410346},{"_id":"public/2022/02/03/Tomcat架构解析/多层容器/index.html","hash":"b06d19a00acaf49a1b72cc38236792a3a1645d73","modified":1647482410346},{"_id":"public/2022/02/03/Tomcat架构解析/连接器/index.html","hash":"63d5362206ef7b07595345b08fc460e71135e627","modified":1647482410346},{"_id":"public/2022/02/02/Tomcat架构解析/Servlet/index.html","hash":"22c44a4426fb12c0efac3ad550c6d4dd680db8fb","modified":1647482410346},{"_id":"public/2022/02/02/Java编程思想/TreeSet/index.html","hash":"9726c86086ae6b9a643a5648cc563fc67b2e1698","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/HashSet/index.html","hash":"9fe6369c54102f6f12d0b5672cb2eca421f4ab27","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/LinkedList/index.html","hash":"fb67c6c6649b85e22fe468ee1bdced409874aa02","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/LinkedHashMap/index.html","hash":"841f69ac16bd5b6256b8c7daf5f37fddfb061722","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/TreeMap/index.html","hash":"f0ade3e41759e2ff064112c2eeb505c6e8a050e7","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/HashMap/index.html","hash":"dfdf4dc9516792cc71d52da08f0fa363db097854","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/集群/index.html","hash":"174839606c0f3098ed24233c40930ae5818e5253","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/Leader选举/index.html","hash":"467279457ddb8c372d3f942e3321d1bdeb938f5d","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/数据同步/index.html","hash":"8ac90e2bfd27aae7d629dfac9c642159d4ea5492","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/ZAB协议/index.html","hash":"db9f593ac0d9782e10df3210a2e33ecf10265806","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/日志清理/index.html","hash":"7d19a46bd69c6c304fdbb21fe7f855acdad8addb","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/负载均衡/index.html","hash":"bdae7b3049bb1c5fe3daeb7ae5786abf10a1c44e","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/数据文件/index.html","hash":"289aba8078df0c6c5b015afd67bb4ebd718150b0","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/序列化/index.html","hash":"95e13324171e36fc7d8b1d1e34d94b04e8b1fb6f","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/分布式ID/index.html","hash":"623a0f0e4cd985508ee035ce6a2078a0c06c3bfe","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/分布式锁/index.html","hash":"1b0f28bb583c9f22ebde55f1647d621c7fe6ae18","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/ACL权限/index.html","hash":"e62fb0c06411e4fe69480efde547ee36d1e9281f","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/Watch机制/index.html","hash":"5b1afb1810d0d09eeb6bb79211b78c03214d8af6","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/会话机制/index.html","hash":"89decbc0fc01cdd9f851c9b92bb5788d047a9822","modified":1647447989172},{"_id":"public/2022/02/02/ZooKeeper分布式技术/数据模型/index.html","hash":"0b085de959949c4523336458408d9cacc158c1aa","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/基本架构/index.html","hash":"16d5609fa98f1c54b629de10bb9e18aa927701a6","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/核心流程/index.html","hash":"702c6045eaf041c3bf6f5b6348c3d982b04e45c8","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/Recycler对象池/index.html","hash":"bed88414eb5190e4d6cc3a7280e9b0e3fd00fa66","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/Reactor线程模型/index.html","hash":"7dcc53135247d48ccc25508e7a790fb0a4b713f8","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/FastThreadLocal/index.html","hash":"983f3f5a5593e1645546833f4a9b26c2e2adde77","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/Future回调机制/index.html","hash":"a5b9feddf7186b0eb16688bf71e34f175ac0e045","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/核心组件/index.html","hash":"d9505c30ec912bcfa8c83b4e154fcf5d7362784f","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/空闲检测/index.html","hash":"2f12f2a3220a241d64b068f9f470bc1ff3855d48","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/零拷贝/index.html","hash":"23344ec372c2ecd6507c1ad1dcfa93da810c001e","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/ByteBuf/index.html","hash":"52fd54fa6a2b391a56e600c46950219c2b0ea9dc","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/编解码/index.html","hash":"748605c410b5b330b215a346bb8d9c720e58d092","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/入门案例/index.html","hash":"582277d6c76be0cd49956c5ce87d47e3fda7abb6","modified":1647447989172},{"_id":"public/2022/02/02/Netty权威指南/基础知识/index.html","hash":"34eb7109ef3c6acf3f27f67b2d4dd45e3f1b7eb6","modified":1647447989172},{"_id":"public/2022/02/02/分布式服务架构/服务架构/index.html","hash":"82d09fd6a1584c324bec6fae8f4949831c5a95d7","modified":1647447989172},{"_id":"public/2022/02/02/分布式服务架构/分布式事务/index.html","hash":"5ecfb37ab680713b0ac179836d05fd6f601fba78","modified":1647447989172},{"_id":"public/2022/02/02/分布式服务架构/分布式算法/index.html","hash":"bee9c1bc64898fa46babb04cd6ef75409191b8ea","modified":1647447989172},{"_id":"public/2022/02/02/分布式服务架构/一致性Hash/index.html","hash":"55a15356bb899730830e22e4688dee3a39212f35","modified":1647447989172},{"_id":"public/2022/02/02/分布式服务架构/分库分表/index.html","hash":"4eb9c1870c34ca88bf166894557083171dc31be4","modified":1647447989172},{"_id":"public/2022/02/02/分布式服务架构/CAP和BASE/index.html","hash":"23f0e2de1319477b135ae85247b6905a459dc7fe","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/基本介绍/index.html","hash":"2a91b069ad9a99df74237cfa8676f043b137d6c0","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/协议/index.html","hash":"fe02277f857624197fa510de8b530dde9fc013fa","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/序列化/index.html","hash":"99c77f6b7295af91a9a2df7085074680a626ad19","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/架构设计/index.html","hash":"ad3004f50f13562852c9884f9c02d77575fe5542","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/负载均衡/index.html","hash":"f26397765de20388c3b9413ab167e8ee28d2d9da","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/异常重试/index.html","hash":"d19d827e1d28022dd726836f856a18f90da19206","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/优雅关闭/index.html","hash":"1c4a26f052fcf2862002864b97b73dfc38da7ef3","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/优雅启动/index.html","hash":"93466822837a66f8a8482b78c5f57e550d87f5bf","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/熔断限流/index.html","hash":"9d4f960a91e3f5f5f085bb5330a47d820561d703","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/隔离流量/index.html","hash":"d27029f41bfa4150e48ae9b03628e66dfd1aeaac","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/异步RPC/index.html","hash":"8340c4aed6458f18b06a8c592c6febe20f9fc428","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/安全体系/index.html","hash":"cd62d439b6660f030eacabf280ee71e6b84bc900","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/定位问题/index.html","hash":"04fbc1ef2a00f44aa9f0572fe9a2f0aa4606a527","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/秒级扩缩容/index.html","hash":"8563f6b8dc682d79c66e90af18357f9d9d065459","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/兼容协议/index.html","hash":"c3015a0c281ee0dba789d51d96cb77163dcd91cc","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/流量回放/index.html","hash":"5dfc7cff54efbee16287f4dd0b3f39d704c19417","modified":1647447989172},{"_id":"public/2022/02/02/深入理解RPC框架原理/泛化调用/index.html","hash":"f27dc377c64c21ddaa50444458bb0ccf0b64ae68","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/抽象类和接口/index.html","hash":"77c5d6c7b49f3e5e0e00cc0565440a77dee3f8c0","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/关键词/index.html","hash":"35364b883298d002c247fbde53b82799069f56f6","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/Long类/index.html","hash":"bfb7492bff3b54e26ea6da9cd68fa93c22cac1ca","modified":1647447989172},{"_id":"public/2022/02/02/Java编程思想/String类/index.html","hash":"99a21986e238fb66068321a90233c8f220aab2a3","modified":1647447989172},{"_id":"public/2022/02/02/深入理解Nginx/反向代理/index.html","hash":"86a8f3ec771df1011e11bb1a12f70a4ad4659344","modified":1647482410346},{"_id":"public/2022/02/02/深入理解Nginx/基础知识/index.html","hash":"bdc52b3b06b7ce75403bbff4ddffd2ac0343e29c","modified":1647482410346},{"_id":"public/2022/02/02/深入理解Nginx/负载均衡/index.html","hash":"1548ea653d80cf84c83922a5e75f88af8dd06c3e","modified":1647482410346},{"_id":"public/2022/02/02/鸟哥的Linux私房菜/VIM编辑器/index.html","hash":"86782cb4f64ded7324d78750c4c30e08b2a5a364","modified":1647447989172},{"_id":"public/2022/02/02/鸟哥的Linux私房菜/IO模型/index.html","hash":"08992325be5fdcbd94c1d22cfe7766d098a8e82d","modified":1647447989172},{"_id":"public/2022/02/02/鸟哥的Linux私房菜/IO多路复用/index.html","hash":"611fba449c108d8b8ec3053e83b6f10ece7c0277","modified":1647447989172},{"_id":"public/2022/02/02/鸟哥的Linux私房菜/零拷贝问题/index.html","hash":"37314add9fb9fa05a4c0b105f7cd914cc42c16dd","modified":1647447989172},{"_id":"public/2022/02/02/图解TCP IP/TCP和UDP/index.html","hash":"ce66646ac86e53a0626df0e763c2e743e721667c","modified":1647482410346},{"_id":"public/2022/02/01/图解TCP IP/HTTP/index.html","hash":"1c6bb2733267d29e8493326fe79fe98b8137cc4a","modified":1647482410346},{"_id":"public/2022/02/01/数据结构与算法分析/布隆过滤器/index.html","hash":"037a3b43fd008fd71337fd0f7498523f6f48dab9","modified":1647447989172},{"_id":"public/2022/02/01/数据结构与算法分析/红黑树/index.html","hash":"2d231ce7412facec9fae2c6340c1d2a814cc57ef","modified":1647447989172},{"_id":"public/2022/02/01/数据结构与算法分析/跳跃表/index.html","hash":"4854b7791288f5cdbdbcda2edfd8f9aed37510d4","modified":1647447989172},{"_id":"public/2022/02/01/数据结构与算法分析/B树和B+树/index.html","hash":"db4d8aa23b4498f2e17c0e6ade61b7dfc3e649f4","modified":1647447989172},{"_id":"public/2022/02/01/操作系统导论/常见面试题/index.html","hash":"2225232658731936dcc421f8e9cca1762f059e3b","modified":1647482410346},{"_id":"public/2022/02/01/操作系统导论/内存管理/index.html","hash":"b24338f2715d8a70e15e672b7dc623689b32e4f4","modified":1647482410346},{"_id":"public/2022/02/01/操作系统导论/进程/index.html","hash":"7699f16a214c14233497ee5b983003a7dcf42a74","modified":1647482410346},{"_id":"public/2022/02/01/操作系统导论/计算机结构/index.html","hash":"7b83301b96ecf442c655ec7987be5cf88b917494","modified":1647482410346},{"_id":"public/2022/02/01/操作系统导论/线程/index.html","hash":"d95cd881967f590b721074809e40b9389078ca02","modified":1647482410346},{"_id":"public/2022/02/01/操作系统导论/设备管理/index.html","hash":"305fe91385139cd40835afdd5c7e850bb61e42e7","modified":1647482410346},{"_id":"public/2022/02/01/Java编程思想/ArrayList/index.html","hash":"112c920e13f4d4385f460e41e0ab6af9c580770e","modified":1647447989172},{"_id":"public/2022/02/01/Redis开发与运维/缓存穿透雪崩击穿/index.html","hash":"1b9e4aa06724857b2ad353108ebfb81dd2288965","modified":1647447989172},{"_id":"public/2022/02/01/Redis开发与运维/缓存一致性/index.html","hash":"50e18e635636f75c461d68a51ec8332e1e13aca6","modified":1647447989172},{"_id":"public/2022/02/01/Apache KAFKA实战/如何保证高可用/index.html","hash":"15e0a3d6f1fb6d45a0399876651003d2b4ca7555","modified":1647447989172},{"_id":"public/2022/02/01/Java编程思想/Lambda/index.html","hash":"0f4f55791f1f2d28fc0e94ab791d7d7e7b3b3fee","modified":1647447989172},{"_id":"public/2022/02/01/Redis开发与运维/分布式锁/index.html","hash":"76b88a9051fc2d1ff0c97720d280fa39fc6a3b41","modified":1647447989172},{"_id":"public/2022/02/01/Redis开发与运维/延时队列/index.html","hash":"0eff66864351e6e738ab73faab8df2dd9b51c46f","modified":1647447989172},{"_id":"public/2022/02/01/代码整洁之道/集合去重问题/index.html","hash":"edf768c061875ef013250c7e848b906744fdac9d","modified":1647447989172},{"_id":"public/2022/02/01/深入理解JVM虚拟机/GC日志/index.html","hash":"bb0a3b98485b4a93143f97469d5e659a90640a5d","modified":1647482410346},{"_id":"public/2022/02/01/Java并发编程实战/Disruptor框架/index.html","hash":"faa3aba2daccaf84b2bfeb4cbd6ff08880ffe764","modified":1647447989172},{"_id":"public/2022/02/01/Java编程思想/Switch/index.html","hash":"9d24a31dbd41e255813d42ea51a041a083abf36c","modified":1647447989172},{"_id":"public/2022/02/01/Spring技术内幕/扩展点/index.html","hash":"f8f6efa99e3fe69c7c8956076ba8dde34737f2e4","modified":1647447989172},{"_id":"public/2022/02/01/Spring技术内幕/设计模式/index.html","hash":"b3f23b60c55b3c8f25e293fe13d06625f564b7ea","modified":1647447989172},{"_id":"public/2022/02/01/代码整洁之道/多层嵌套优化/index.html","hash":"f6b33723fcd8b99e72b9aa40fe0ab4857149db46","modified":1647447989172},{"_id":"public/2022/02/01/Java编程思想/编译和反编译/index.html","hash":"252b2ca4914b54be9ecfce40b0e5775b46273e02","modified":1647447989172},{"_id":"public/2022/02/01/Apache Dubbo实战/基本架构/index.html","hash":"d6ae2cef88af5e5f080123438526bf4c6e1cfe5f","modified":1647447989172},{"_id":"public/2022/02/01/Apache Dubbo实战/序列化/index.html","hash":"fbc79a14c61a9555a6f7e9ff1ea85a0ae1cbbf04","modified":1647447989172},{"_id":"public/2022/02/01/Apache Dubbo实战/核心模块/index.html","hash":"21903eab515a859e96c9fb5916ea0ee40c216937","modified":1647447989172},{"_id":"public/2022/01/31/代码整洁之道/组合和继承/index.html","hash":"0da36a0a8d84ae743c337f99cccea5d76557eb2d","modified":1647447989172},{"_id":"public/2022/01/30/SpringCloud微服务实战/常见问题/index.html","hash":"6d994e16414a7b11aac60dc3813650dd37db000f","modified":1647447989172},{"_id":"public/2022/01/30/SpringCloud微服务实战/Spring Cloud Circuit Breaker/index.html","hash":"7601bc94b38d5700fc2556598f7e06cfe4cecc83","modified":1647447989172},{"_id":"public/2022/01/30/SpringCloud微服务实战/Spring Cloud Gateway/index.html","hash":"c1c5bf5205f24be6f00ce548dcaf15af73ad0bdc","modified":1647447989172},{"_id":"public/2022/01/30/SpringCloud微服务实战/Zuul/index.html","hash":"8381824b53b187f423d9ee1d47623e36efddfc2c","modified":1647447989172},{"_id":"public/2022/01/29/SpringCloud微服务实战/Feign/index.html","hash":"b5d5704fa738fe2dc58c5aa8ea17999d3a4395ee","modified":1647447989172},{"_id":"public/2022/01/29/SpringCloud微服务实战/Hystrix/index.html","hash":"ef7dae97c432fdc6d2c5c7ff99677ac458256512","modified":1647447989172},{"_id":"public/2022/01/29/SpringCloud微服务实战/Ribbon/index.html","hash":"4c843623a1373918ec955e647b63a09aced0abfe","modified":1647447989172},{"_id":"public/2022/01/29/SpringCloud微服务实战/Eureka/index.html","hash":"53f96b5934672417ef5fce32541ba70c3292d8af","modified":1647447989172},{"_id":"public/2022/01/29/Elasticsearch实战/数据处理/index.html","hash":"f4789882e5f3b158ccc22e98b68adbcead72b599","modified":1647447989172},{"_id":"public/2022/01/29/Elasticsearch实战/数据持久化/index.html","hash":"c2e925b78cc0ffbe8900e061b0ae0648eeb6e6df","modified":1647447989172},{"_id":"public/2022/01/29/Elasticsearch实战/集群/index.html","hash":"a0c46e954d65fe93062fe25cb32d012880d7e2e8","modified":1647447989172},{"_id":"public/2022/01/29/Elasticsearch实战/分词/index.html","hash":"ce58eaf55d60beb8ffc1c2d793025517e437e8b5","modified":1647447989172},{"_id":"public/2022/01/29/Elasticsearch实战/倒排索引/index.html","hash":"9041a18e459b0d2ed39e7659710971571311bb4f","modified":1647447989172},{"_id":"public/2022/01/29/Spring技术内幕/事务/index.html","hash":"6341dfd0fc6ea4ceabfe9c7aebc8c29033397384","modified":1647447989172},{"_id":"public/2022/01/29/Spring技术内幕/循环依赖/index.html","hash":"28ca3403b71ec14d6659e57396cd8403729eb2e9","modified":1647447989172},{"_id":"public/2022/01/29/Spring技术内幕/源码环境/index.html","hash":"4c7429b0cbc09e08d3604959701b0c143485a493","modified":1647447989172},{"_id":"public/2022/01/29/MyBatis技术内幕/基本架构/index.html","hash":"d19fd24d65d8e42f6ca17b0f0a7ae512912c69af","modified":1647447989172},{"_id":"public/2022/01/29/MyBatis技术内幕/缓存机制/index.html","hash":"0c11a60be3f3ce04b29e317a75482b6136d6e139","modified":1647447989172},{"_id":"public/2022/01/29/Docker开发指南/云计算平台/index.html","hash":"0716dab1af72631e7e3d3fc33da8c55211bcc2be","modified":1647447989172},{"_id":"public/2022/01/28/Docker开发指南/镜像和容器/index.html","hash":"d78d41fa1572dcbfb67be7dec85dc66253d67d90","modified":1647447989172},{"_id":"public/2022/01/28/Docker开发指南/基本架构/index.html","hash":"8dc6c2143319110d9c8f0419f128ffa05c90c180","modified":1647447989172},{"_id":"public/2022/01/28/Docker开发指南/基本概念/index.html","hash":"44ec780c2b5572634d33b5c1ac4d5c065e5e703e","modified":1647447989172},{"_id":"public/2022/01/24/Elasticsearch实战/分页/index.html","hash":"9cf28ae99aae165e55e702fde6a6c30feb001255","modified":1647447989172},{"_id":"public/2022/01/23/Java编程思想/泛型/index.html","hash":"978bc8e0c26ef80a1fe7543eac2883a5f87f4992","modified":1647447989172},{"_id":"public/2022/01/23/大话设计模式/代理模式/index.html","hash":"f667b6c110624db61e67966ccab47f345d31cba5","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/责任链模式/index.html","hash":"33b52fcc5c417c11a3d93f93e3dde88d8e4462c5","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/策略模式/index.html","hash":"725ca4ddcc29f91758166947b07d4c24f20e3a34","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/模板方法模式/index.html","hash":"05f060cb201ac419e0815edc388bf664227ef827","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/装饰者模式/index.html","hash":"d402cb6b89b250b6828c01c922520d000cbbd1bc","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/桥接模式/index.html","hash":"22b741814f9669035236ac86390a3977271c7fab","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/建造者模式/index.html","hash":"10bba863d297266b1137276596399a931df707e4","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/抽象工厂模式/index.html","hash":"4bc9a11d3f89ae442b53599d80f49669bd8e408b","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/工厂方法模式/index.html","hash":"dcd144c8f4859fc6ba8b4906aa5574417385953c","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/简单工厂模式/index.html","hash":"b5c9cd98e892b1235066f3349268195e9d63815a","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/单例模式/index.html","hash":"6ca5ebfd69ced102ca63dbd0d8d91ce4781ea5f2","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/六大设计原则/index.html","hash":"0a3c22bfc0366086480ad64eec8219e91fab5b33","modified":1647447989172},{"_id":"public/2022/01/22/大话设计模式/UML/index.html","hash":"d9e67f6aeb60ffe7ce7a09e5cd35b8fc673e7f20","modified":1647447989172},{"_id":"public/2022/01/16/高性能MySQL/锁机制/index.html","hash":"6a7a24aadc5ba2e4ee9cfc6e3268497858aee217","modified":1647447989172},{"_id":"public/2022/01/16/高性能MySQL/事务/index.html","hash":"3536bf77440c401015edb57d94e13aeb95e4c8e4","modified":1647447989172},{"_id":"public/2022/01/16/高性能MySQL/索引/index.html","hash":"3e97955408c984a458e6a01f86a37366cf77c3a5","modified":1647447989172},{"_id":"public/2022/01/16/高性能MySQL/MySQL调优/index.html","hash":"4197df4e347b3531c64dd5a84f1be31b76b2eb3b","modified":1647447989172},{"_id":"public/2022/01/16/高性能MySQL/Buffer Pool/index.html","hash":"64ab863ee4431d566149c0b5babdced9c9ce4ae9","modified":1647447989172},{"_id":"public/2022/01/16/高性能MySQL/MySQL基础/index.html","hash":"45979ec7e5caf132e926ffc8d03b8d2e9d11f172","modified":1647447989172},{"_id":"public/2022/01/16/高性能MySQL/SQL更新/index.html","hash":"816907a8596a61b248fc50c27a5576881adcaa17","modified":1647447989172},{"_id":"public/2022/01/15/高性能MySQL/常用SQL/index.html","hash":"eb02e386a95bcc22a63350276937e954b140cc62","modified":1647447989172},{"_id":"public/2022/01/15/Java并发编程实战/ThreadLocal/index.html","hash":"1bb9f54a2d4ad33f2a09c9fcb8d528df4e697336","modified":1647447989172},{"_id":"public/2022/01/15/高性能MySQL/关联查询/index.html","hash":"7c22111b422ce339399e33f652cfb9255892301b","modified":1647447989172},{"_id":"public/2022/01/15/高性能MySQL/Order By/index.html","hash":"29af453e48b9190ecb0648e96f5b6c938326aede","modified":1647447989172},{"_id":"public/2022/01/14/高性能MySQL/分区表/index.html","hash":"eedf40fa7a924696113c503ac03038f50167669c","modified":1647447989172},{"_id":"public/2022/01/14/高性能MySQL/Explain/index.html","hash":"6c21f77a74d1d84852d686d309e52c0db7d42e0f","modified":1647447989172},{"_id":"public/2022/01/13/高性能MySQL/MVCC/index.html","hash":"7531662a11e3be5284f943ccd901264224f25198","modified":1647447989172},{"_id":"public/2022/01/13/高性能MySQL/MySQL架构/index.html","hash":"c34ffee03457c541a159cb536e12ad466d2b17f7","modified":1647447989172},{"_id":"public/2022/01/13/高性能MySQL/存储引擎/index.html","hash":"4c58934c88f9e9084f64857a66a92709964146f5","modified":1647447989172},{"_id":"public/2022/01/13/高性能MySQL/范式/index.html","hash":"e2b0af025e0580ed144be9bbdf1401e94891df4e","modified":1647447989172},{"_id":"public/2022/01/12/高性能MySQL/主从复制/index.html","hash":"58cc8ce789336f1011969a1494a635b0aadbe5fd","modified":1647447989172},{"_id":"public/2022/01/11/高性能MySQL/日志文件/index.html","hash":"69a81ca9977f1dd862720088df5e534d3a7e6555","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/日志存储/index.html","hash":"d617e7c7e2785c6baa1838fa41262f12ddd856a7","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/重复消费/index.html","hash":"5b6c57078b7fc0f281dc23d48fc4b5b80f1b4b92","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/消息顺序/index.html","hash":"ef66005e7285778b5d04b9d2c79ec61334eedd98","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/消息积压/index.html","hash":"88c076c3e1900d0c3275ad49a35a68da485f2c40","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/消息丢失/index.html","hash":"ba066b16a73fd4a59956cca7567d16436c76c9e0","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/常用参数/index.html","hash":"5ec01a6cdb771920dac5ef07d97bf787d16b5712","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/位移主题/index.html","hash":"64cb1aca23c5e93842c9df8a81d6e08116822798","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/位移提交/index.html","hash":"25ae6714c3b559db1599c974f5fddddd1986528a","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/控制器/index.html","hash":"6504f455c7be01b1bf4595ed6348c5cdac307677","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/副本机制/index.html","hash":"e8ffaefb1e4ebd97cb003d52a18fed59a048bbb6","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/拦截器/index.html","hash":"e967f9f62d6f324736b628a2f25115bd71a9a569","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/幂等性和事务/index.html","hash":"40e60742108e4907b2718b0e36f6c1ea29a25f8a","modified":1647447989172},{"_id":"public/2022/01/08/Apache KAFKA实战/生产者压缩算法/index.html","hash":"c41c0444fff06e7063e087b639c20d0c0b29ec79","modified":1647447989172},{"_id":"public/2022/01/07/Apache KAFKA实战/消费者组/index.html","hash":"bb0402587b37a73900a49d9cd7462a953d0b262f","modified":1647447989172},{"_id":"public/2022/01/07/Apache KAFKA实战/重平衡/index.html","hash":"c4010b4a626d1e438e31e76dcd5049319a758243","modified":1647447989172},{"_id":"public/2022/01/07/Apache KAFKA实战/生产者分区/index.html","hash":"361875bac368c73212b8ee04727db001956e279d","modified":1647447989172},{"_id":"public/2022/01/07/Apache KAFKA实战/基本概念/index.html","hash":"0846a7439fe7bce96beaa0e610e2da61e8929009","modified":1647447989172},{"_id":"public/2022/01/07/Apache KAFKA实战/认识KAFKA/index.html","hash":"f84f9305f2f0deb242d3666f8579ef677f04c2f4","modified":1647447989172},{"_id":"public/2022/01/03/实现领域驱动设计/微服务架构/index.html","hash":"ca68e18299621604c5021116b09fa33db08849f2","modified":1647447989172},{"_id":"public/2022/01/03/实现领域驱动设计/代码模型/index.html","hash":"25c2ff723743b3e2a558f9f4e331a33d6d76c0de","modified":1647447989172},{"_id":"public/2022/01/03/实现领域驱动设计/领域模型/index.html","hash":"3bf2e41600c1811674a56984b5e82faf525bcc54","modified":1647447989172},{"_id":"public/2022/01/03/实现领域驱动设计/仓库和工厂/index.html","hash":"b1f9dbbe0faa64179ac458d8d3358eef50dbb411","modified":1647447989172},{"_id":"public/2022/01/03/实现领域驱动设计/聚合和聚合根/index.html","hash":"af14b9b9fe811c6843dc2e886a3c32eef3fb1b1e","modified":1647447989172},{"_id":"public/2022/01/02/实现领域驱动设计/领域事件/index.html","hash":"f12f68564a580220149763d03ad2985176939eb6","modified":1647447989172},{"_id":"public/2022/01/02/实现领域驱动设计/领域服务/index.html","hash":"c05ec96e2f06e4c0759b9a81d2d01abd32a55530","modified":1647447989172},{"_id":"public/2022/01/02/实现领域驱动设计/实体和值对象/index.html","hash":"a8dd6ebec1a8bb40fc901c07244c0c6601ec34da","modified":1647447989172},{"_id":"public/2022/01/02/实现领域驱动设计/经典架构/index.html","hash":"b4a684d15e68b29ea41c04a3ea38cd54c560c943","modified":1647447989172},{"_id":"public/2022/01/02/实现领域驱动设计/经典分层/index.html","hash":"99d8f8f2bd526049fdd7cca2661933bd6b60421d","modified":1647447989172},{"_id":"public/2022/01/02/实现领域驱动设计/DDD入门/index.html","hash":"20546f105ca21fbedf56e295919025c6e5272410","modified":1647447989172},{"_id":"public/2022/01/02/实现领域驱动设计/领域、子域和限界上下文/index.html","hash":"34a7991b4370e8bcf0ae9e8e15187481ffe121fe","modified":1647447989172},{"_id":"public/2022/01/01/金字塔原理/如何构建金字塔/index.html","hash":"93063e0b977b1981307d389d5150d800323a95b4","modified":1647482410346},{"_id":"public/2022/01/01/Java并发编程实战/阻塞队列/index.html","hash":"6558da5fcf483dcc0369ad8078798a8cab445d92","modified":1647447989172},{"_id":"public/2021/12/30/金字塔原理/金字塔内部结构/index.html","hash":"486bd072db4d08589b52318e5d5f5af3010a4df3","modified":1647482410346},{"_id":"public/2021/12/30/Java并发编程实战/锁机制/index.html","hash":"b52d5f86887d1e0b92b9949710c30dd1c39d78a6","modified":1647447989172},{"_id":"public/2021/12/29/金字塔原理/为什么要用金字塔结构/index.html","hash":"574764173e8b544e6a554176e10e1f22428bf045","modified":1647482410346},{"_id":"public/2021/12/29/Java并发编程实战/并发工具类/index.html","hash":"6c6f73deb16a66708995d6656affdfdda831f775","modified":1647447989172},{"_id":"public/2021/12/28/Java并发编程实战/内存模型/index.html","hash":"9f49a1027998d422ea339733d47bee5049c38e43","modified":1647447989172},{"_id":"public/2021/12/27/Java并发编程实战/共享对象/index.html","hash":"f805c38200a298c133d6f5281f5e32aa17709a6f","modified":1647447989172},{"_id":"public/2021/12/26/Java并发编程实战/线程/index.html","hash":"6a283719d74a3c1c4e92a74fdb09fc97b675980a","modified":1647447989172},{"_id":"public/2021/12/26/Effective Java/创建和销毁对象/index.html","hash":"38a0a7b399491f853c37c173bd90cac5225a3750","modified":1647482410346},{"_id":"public/2021/12/26/深入理解JVM虚拟机/类文件结构/index.html","hash":"de3d5b7de4fcea000e1562ad89d886552e1ba1c7","modified":1647482410346},{"_id":"public/2021/12/25/深入理解JVM虚拟机/即时编译器/index.html","hash":"7f902f1226c0cf691277c5c84f6b1831310e83d8","modified":1647482410346},{"_id":"public/2021/12/25/深入理解JVM虚拟机/垃圾收集算法/index.html","hash":"1e17e44d0053a92612544d1304e42f2f3c23f9ba","modified":1647482410346},{"_id":"public/2021/12/25/深入理解JVM虚拟机/虚拟机对象/index.html","hash":"8679c9cba8639982a2364f314c10eaafa4432823","modified":1647482410346},{"_id":"public/2021/12/21/深入理解JVM虚拟机/内存回收/index.html","hash":"55f0363ad423fd8b05c811386a349fdcc40db4c2","modified":1647482410346},{"_id":"public/2021/12/21/深入理解JVM虚拟机/内存溢出/index.html","hash":"bfb6719f05fd1ed51505c6efa7c890cf24ad5cb0","modified":1647482410346},{"_id":"public/2021/12/21/深入理解JVM虚拟机/类加载机制/index.html","hash":"529b5d59a5b001e0fc865fa25aa0a3dab2350c8e","modified":1647482410346},{"_id":"public/2021/12/20/深入理解JVM虚拟机/垃圾收集器/index.html","hash":"10f018c500e6b43c115adcf1584d6c7b7264f157","modified":1647482410346},{"_id":"public/2021/12/20/深入理解JVM虚拟机/内存区域/index.html","hash":"035acd57b64f299245bfe3d8c35228413d9ce330","modified":1647482410346},{"_id":"public/2021/12/20/Redis开发与运维/缓存设计/index.html","hash":"728ca687d73833aa4f61eab37a2e0ccefb3e6aa4","modified":1647447989172},{"_id":"public/2021/12/20/Redis开发与运维/哨兵机制/index.html","hash":"e18d2a44522fd0555566f8fcd54dc721e829a025","modified":1647447989172},{"_id":"public/2021/12/20/Redis开发与运维/内存机制/index.html","hash":"5b0b0230e6a597d94fab116fc37a44e50967b14e","modified":1647447989172},{"_id":"public/2021/12/19/Redis开发与运维/集群/index.html","hash":"9fc6419ed5bd5e0a6e037f4ea058e0ebcff3f63d","modified":1647447989172},{"_id":"public/2021/12/19/Redis开发与运维/持久化/index.html","hash":"2ed4352b7cfb136fd59bd73dfd65867d7d47ff2b","modified":1647447989172},{"_id":"public/2021/12/19/Redis开发与运维/客户端/index.html","hash":"23942161c7da98b4e83a11ca11684e0b060e9358","modified":1647447989172},{"_id":"public/2021/12/17/Redis开发与运维/事务/index.html","hash":"5b8b15c93d620e99a698bac0643c0d9e88b89037","modified":1647447989172},{"_id":"public/2021/12/17/Redis开发与运维/Pipeline/index.html","hash":"058444b0887d246256fdfc11fc4aeddd7d84c40e","modified":1647447989172},{"_id":"public/2021/12/17/Redis开发与运维/慢查询/index.html","hash":"f94aee873da1b61b2dd9d53602a33f50793642e7","modified":1647447989172},{"_id":"public/2021/12/12/Redis开发与运维/数据结构/index.html","hash":"0572836bbde5b20cc3eced3aedf5ef23d55542e4","modified":1647447989172},{"_id":"public/2021/12/12/Redis开发与运维/初识Redis/index.html","hash":"064cdfe3025f6f0a5edb5e1e20a930bf2d34a87e","modified":1647447989172},{"_id":"public/2021/12/07/LeetCode/237删除链表中的节点/index.html","hash":"a69b6a3a765d0ba1a9f3f5dcd77297f366653858","modified":1647482410346},{"_id":"public/2021/12/06/LeetCode/230二叉搜索树中第K小的元素/index.html","hash":"6859e023e9e29b0ff0d3e30f0e30bc26d249acd5","modified":1647482410346},{"_id":"public/2021/12/05/LeetCode/217存在重复元素/index.html","hash":"e5651798d4d6a1dbd4569b0b57f2888ecd687c17","modified":1647482410346},{"_id":"public/2021/12/01/LeetCode/33搜索旋转排序数组/index.html","hash":"629bf45268087c16319767e96ac1cd7eb775abad","modified":1647482410346},{"_id":"public/2021/11/30/LeetCode/16最接近的三数之和/index.html","hash":"01db012a1e97a4c33738c12e10a520bb2d28495f","modified":1647482410346},{"_id":"public/2021/11/28/LeetCode/9回文数/index.html","hash":"c530c865aafb0c50e65dab946b08cf91b220d8f1","modified":1647482410346},{"_id":"public/2021/11/27/LeetCode/1014最佳观光组合/index.html","hash":"ddf35322eb24e29c4852aefa4875ddeaad34197a","modified":1647482410346},{"_id":"public/2021/11/26/LeetCode/152乘积最大子数组/index.html","hash":"4cc33560d37971114a8b3c9cd8e77cfc1502d430","modified":1647482410346},{"_id":"public/2021/11/25/LeetCode/45跳跃游戏II/index.html","hash":"3fe28de1472ac0d621317c005af63d05c4b2dad3","modified":1647482410346},{"_id":"public/2021/11/24/LeetCode/55跳跃游戏/index.html","hash":"b19a06b842823868ba097c8a006d402d1da85dd9","modified":1647482410346},{"_id":"public/2021/11/23/LeetCode/213打家劫舍II/index.html","hash":"15126cba59d4a4324ca67520274f0ea2bc9ccbca","modified":1647482410346},{"_id":"public/2021/11/22/LeetCode/746使用最小花费爬楼梯/index.html","hash":"51f5edd5e65ba679458ad5bfaef5b13a17ea8c9a","modified":1647482410346},{"_id":"public/2021/11/22/LeetCode/70爬楼梯/index.html","hash":"08c3fca7bec378931b7e3e835b98ef8000270015","modified":1647482410346},{"_id":"public/2021/11/21/LeetCode/1137第N个泰波那契数/index.html","hash":"6ed004bb2fb66a9889a9f6fb985765b07f6f26ab","modified":1647482410346},{"_id":"public/2021/11/02/深入浅出ServerLess/基本介绍/index.html","hash":"4dc8462dcb36abb101287011dac39d583078f7dd","modified":1647447989172},{"_id":"public/2021/10/31/数据结构与算法分析/LRU算法/index.html","hash":"bfb6b8bd229aec00f209f84b366e91d7daa36aae","modified":1647447989172},{"_id":"public/2021/10/25/Service Mesh实战/ServiceMesh/index.html","hash":"dca580a550d7e1bdb2912d67c9cd2ad4afa291f3","modified":1647447989172},{"_id":"public/2021/09/09/LeetCode/162寻找峰值/index.html","hash":"eacc094b32ef3145db003cef145b166263e4e762","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/16.06最小差/index.html","hash":"8d75819176da3bf30f72c9ce4e9c4020e435d812","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/17.14最小K个数/index.html","hash":"3d34db2298fbdaff1bce771cb4422832cb985145","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/6从尾到头打印链表/index.html","hash":"5bf8d71c94cb70a0e0118446553bd4946dbf3e2e","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/9用两个栈实现队列/index.html","hash":"2fb6f3e3109fdec27c0624324f05ff2423e6e44f","modified":1647482410346},{"_id":"public/2021/09/01/数据结构与算法分析/排序算法/index.html","hash":"28525a698abf302c6993bc9d75613cc6b4e1cde7","modified":1647447989172},{"_id":"public/2021/09/01/剑指OFFER/52两个链表的第一个公共节点/index.html","hash":"16edb1506735809aa98499c2a014d2729b7980d0","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/54二叉搜索树的K大节点/index.html","hash":"cabf2a2270a492f072852e9bfc33425f3dac918b","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/55I二叉树的深度/index.html","hash":"abd41e274627611be90d7aeed2341a959d2b449a","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/63股票的最大利润/index.html","hash":"ecc175db9cc83950009b39639f9388d4ebbe5e7d","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/65不用加减乘除做加法/index.html","hash":"c2f1a7860a11f179e0c7bf7d36a3981b2a26c481","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/68II二叉树的最近公共祖先/index.html","hash":"775353172cc44ac9069c3ce758e8f6764a715df1","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/68I二叉搜索树的最近公共祖先/index.html","hash":"32cbdba892a4b39b2f71c4ab45fd0c7d63a9c52b","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/32III从上到下打印二叉树III/index.html","hash":"b66963ec3e135151c7370d9ba7da26288574d4a3","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/32II从上到下打印二叉树II/index.html","hash":"9338df68795936af9a21691370f0d0146589e49a","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/33二叉搜索树的后序遍历序列/index.html","hash":"6ae9a6054b282b3f630f1ba76d429016e54f892c","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/39数组中出现次数超过一半的数字/index.html","hash":"d02e1449d55dfe6f3ed2155e3b664ca88bdf8547","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/3数组中重复的数字/index.html","hash":"d36b50885297a1eb99614944f390ef3770d008cf","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/41数据流中的中位数/index.html","hash":"83be6986927f1e9041f1740ed4a029b08f156776","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/42连续子数组的最大和/index.html","hash":"e6d00b8c3c512c0d30acf6ad6e9b15484e305251","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/4二维数组中的查找/index.html","hash":"819b0d86e760548aa6c6d70cb69886ec0eb87455","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/24反转链表/index.html","hash":"4df63c0c73618bf5c698c1756e20a0acbf680895","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/22链表中倒数第K个节点/index.html","hash":"480938dcd6aec382bd017e1e427a539cecded14b","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/25合并两个排序的链表/index.html","hash":"d5c0f1599a6de742342c02abe4487ed30d7d4a7b","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/26树的子结构/index.html","hash":"ac761be3c42372933a170926841c46c6965f0f77","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/27二叉树的镜像/index.html","hash":"0741996c8d500058c1839323c37d49c3372701cf","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/31栈的压入、弹出序列/index.html","hash":"fed0b527665edeb82875f6232e553207bc7f0c46","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/90子集II/index.html","hash":"4474d8db2b5f0afe7fbbc1a4910f0535dea5e3b3","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/92反转链表II/index.html","hash":"ad9f8c0b002a7a8aabdbed70ad9926b5e97a23b6","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/94二叉树的中序遍历/index.html","hash":"8544b336ff12ed26f9619b52a839c1e58a484376","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/98验证二叉搜索树/index.html","hash":"33bd6834439e9463e844d0d6420704b49efbbc44","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/10II青蛙跳台阶问题/index.html","hash":"5ff21c29d1a2e16a20c9b25f240f4c94dd138ec6","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/15二进制中1的个数/index.html","hash":"3560d6f361364fe0745a3321dc59a50e18909ad0","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/18删除链表的节点/index.html","hash":"f6149ba81fd83e2c661bfe1e282a20882f705893","modified":1647482410346},{"_id":"public/2021/09/01/剑指OFFER/21调整数组顺序使奇数位于偶数前面/index.html","hash":"1d97daae3f1cd9f8ecebaf404ca122dc19eaafbc","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/64最小路径和/index.html","hash":"85c2447be0bcff241522833d50ce7dad21139cbe","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/674最长连续递增序列/index.html","hash":"7944f9c24618b56783c735463a307417ece7ef22","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/69X的平方根/index.html","hash":"d7eb3273faf039b834cbf1663b5bddea22c22da8","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/704二分查找/index.html","hash":"cf1ff181a92bf300deb5c0cd8eb8abc4939d2942","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/75颜色分类/index.html","hash":"dfa6f9bf850a186f5de7c76e96fef0e9cb8ddd17","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/78子集/index.html","hash":"9de565abe6f1e6dab47c797e431acb1996124ba7","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/7整数反转/index.html","hash":"b88d45a8f9c733279ee6b8acb661ce49b65bb719","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/83删除排序链表中的重复元素/index.html","hash":"bc3c6c0c93d4d5727af72cfbd812c0bc8163a7c5","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/88合并两个有序数组/index.html","hash":"2c0f8644b71336f4a30357de3f1d0e2e45097835","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/470用Rand7()实现Rand10()/index.html","hash":"4c48c0d5d8c042533f6c3568bc5df2e18186f424","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/509斐波那契数/index.html","hash":"2be54ecd6fa350eedffe7310a36791cd255df205","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/50第一个只出现一次的字符/index.html","hash":"1273134de34aacaf9e6f927b0de15620f7a63fc7","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/53最大子序和/index.html","hash":"d89b8f9f05f38f51976c92272eb1c485582dafd5","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/543二叉树的直径/index.html","hash":"e2632acb0fefc8fe5f61d486296f7433036b018a","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/54螺旋矩阵/index.html","hash":"57d902abb0b156381704346b421815e65476a029","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/5最长回文子串/index.html","hash":"983650151d22ad4af818c8d91fe53406b2b2e06f","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/617合并二叉树/index.html","hash":"844d313bf872ea88b133b7c38b136af3d9f954f1","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/637二叉树的层平均值/index.html","hash":"911f2733c181b0938bec6723f349f2027ebc795d","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/27移除元素/index.html","hash":"767056aae40b6b54b09674356a67c7864f4a68cc","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/2两数相加/index.html","hash":"71010bdabec61f7aebe8a43bcad75541f5314d74","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/300最长上升子序列/index.html","hash":"b8bd78aa1aea46118b74bca8cad65504011d3691","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/31下一个排列/index.html","hash":"d7f3ef923f6d5827446da940cd2b69e6174f1879","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/322零钱兑换/index.html","hash":"cf83af29f05ac02e64c00f67fc22c25d3fc88f73","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/328奇偶链表/index.html","hash":"d536c036eb6ce6f634616fefddd0d5724441ea77","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/344反转字符串/index.html","hash":"b3a58d987116a4d2e982222604712ef8090b6617","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/3无重复字符的最长子串/index.html","hash":"afc0d6b8e54c3f46fda82373082848aa418d7920","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/415字符串相加/index.html","hash":"6a21f64a63a20812bcbf78947fbb7a2ae00eaf4a","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/46全排列/index.html","hash":"3934d118c6e46784a6455bffe3dc69209b926b4c","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/215数组中的第K个最大元素/index.html","hash":"aa06f95c0b717da2bc9c764f10705e876123e6f5","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/21合并两个有序链表/index.html","hash":"1cc56cbd609ec5d516d57cad47d2a2f9ddf5f5db","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/226翻转二叉树/index.html","hash":"33cc8a275d96169411ddce4d6f8926f414ba2fa5","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/229求众数II/index.html","hash":"c69457988f24b104ad6c6bad3a4bd9aa7e2d3e4a","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/234回文链表/index.html","hash":"ad2113a10ae8a13ee030e4258f8cd6845cccabe5","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/240搜索二维矩阵II/index.html","hash":"151757ceac4fe0a64d6e523c5de14bc83de79f2c","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/24两两交换链表中的节点/index.html","hash":"347a212218b6ab326864b8ab53ad8f6acd95e3b0","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/257二叉树的所有路径/index.html","hash":"61c613f4d96249239644f9f6bdeba4b3e522181c","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/26删除排序数组中的重复项/index.html","hash":"bff9afb25004c70df69244ac481096ed9b290f23","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/18四数之和/index.html","hash":"9d4ce43cee8634f5b4db8610fd80e040e3774276","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/198打家劫舍/index.html","hash":"f1817deb04c8c25c009e225d4b5de246c5327ae1","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/199二叉树的右视图/index.html","hash":"ef2d6871611ee6ef4b06de3164973777824440e3","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/19删除链表的倒数第N个节点/index.html","hash":"83053d91f65d930b8f1793e4dcc967fb7ca0ef7a","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/1两数之和/index.html","hash":"cb1db76d3a014cd0f68215a6e302383a22082027","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/206反转链表/index.html","hash":"f35fe9a3761f1df96cb07bce8faaad380aca3a8a","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/20有效的括号/index.html","hash":"bee225e19ff77496afd2da5cbc1d7b9d223318a7","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/14最长公共前缀/index.html","hash":"8824fa913abcb1c6c5b37bae9590b789c1f07997","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/155最小栈/index.html","hash":"23a4a3a786498206720fdd78fc2920123fd78a87","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/15三数之和/index.html","hash":"12185fd2eb14998bb344f2ace3f9a47792de1a21","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/160相交链表/index.html","hash":"4c4b90652b6fbb1f1f27f0761d794f603f238572","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/169多数元素/index.html","hash":"2e4453aeaffe1633c1401005d9a45e74ebdd60c4","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/141环形链表/index.html","hash":"6b5fc34efdcb6b7c9d1e2292580c019ebdb028ff","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/142环形链表II/index.html","hash":"5a6485180535708069296c7d594913cf0ce25e03","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/143重排链表/index.html","hash":"10e4db946727f0c8c3735b99a40822581e8eda70","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/144二叉树的前序遍历/index.html","hash":"76712e64f7de0a4ff8e8a4e7727b6ef4ca1041c7","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/145二叉树的后序遍历/index.html","hash":"3bb5071de8dcf161384b058410d99d9382b4ab1c","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/146LRU缓存机制/index.html","hash":"340143667888287dc320659360e61e22bb93dc8d","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/148排序链表/index.html","hash":"b0debc60b7a1d05dc1ebab4c87ccb86a130d5b83","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/122买卖股票的最佳时机II/index.html","hash":"eef6aaef5209ccb7a106505d3994c99c6385dc06","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/125验证回文串/index.html","hash":"8f1bc521e89e529443e1c3b5dc79db4123f53959","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/129求根节点到叶节点数字之和/index.html","hash":"5d7be3d1640c167b5bdc96ce027284b2088fddc6","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/136只出现一次的数字/index.html","hash":"1cc71f54e9ddb5a5bcde32ab73e57ecf2ebdddb1","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/13罗马数字转整数/index.html","hash":"0ee9b8e953592e657f0a3497c34456b7e0626bf7","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/110平衡二叉树/index.html","hash":"8f0ad359ed8cc8566d95d167da3027eb6380d202","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/112路径总和/index.html","hash":"75e4974b69d73badc22ac38b7982d59d2492c22b","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/113路径总和II/index.html","hash":"f755cccd1b541a43f82c7d7b202367883e0d2e03","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/1143最长公共子序列/index.html","hash":"523e09cdf0a5fcf8eb4afcfb8677607690f330ea","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/11盛最多水的容器/index.html","hash":"34e79f5b9bd14ed1f97b89ce9c08ac08d2de7b10","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/121买卖股票的最佳时机/index.html","hash":"4547a3075338c67fbaa51f142ab9ef236fac1ad8","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/100相同的树/index.html","hash":"f726b9c6246a1a03a0121b7ddafa18a35f9fadb8","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/101对称二叉树/index.html","hash":"fbc70a80fa6ac771d29059efd50b86c7cf6353b7","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/102二叉树的层序遍历/index.html","hash":"9a7dfd2252a499511ed25f181219be372af1842b","modified":1647482410346},{"_id":"public/2021/09/01/LeetCode/104二叉树的最大深度/index.html","hash":"5fb3c63b32160cc6c7489e4238a127cef633b550","modified":1647482410346},{"_id":"public/archives/index.html","hash":"c54e0b33415a30f34ee619b8b282b59c100e08b1","modified":1647480488957},{"_id":"public/archives/page/2/index.html","hash":"5b1db8cbc127be2e84ae8e86894e83d74588f039","modified":1647480488957},{"_id":"public/archives/page/3/index.html","hash":"eae673823f043ba8ee31005571314d7185d59d8f","modified":1647480488957},{"_id":"public/archives/page/4/index.html","hash":"b570f8df552c798f08e55ebcaaa93373f6abd8de","modified":1647480488957},{"_id":"public/archives/page/5/index.html","hash":"6f3fed057c1ce8f5567c2d398ea2758f1d715646","modified":1647480488957},{"_id":"public/archives/page/6/index.html","hash":"5d8f5a111b25594518ceba0b3b6fd5180364c293","modified":1647480488957},{"_id":"public/archives/page/7/index.html","hash":"e615a129bacd82a64b4029a2230a6cdf42f7419e","modified":1647480488957},{"_id":"public/archives/page/8/index.html","hash":"67e7d42429ffbe154031c549b5c4fba4e2605d4a","modified":1647480488957},{"_id":"public/archives/page/9/index.html","hash":"ee72083bb7dab50cec7b2078f5f4554a4c7a5bd7","modified":1647480488957},{"_id":"public/archives/page/10/index.html","hash":"d40dc09bec05aa0ee269b80c40b4d9dcb4f3e05b","modified":1647480488957},{"_id":"public/archives/page/11/index.html","hash":"96550f7438e91531b28691a85bcbfea0913f036a","modified":1647480488957},{"_id":"public/archives/page/12/index.html","hash":"bd88c0c92ae04e9e6664dfe5049c9b2dae56fb7a","modified":1647480488957},{"_id":"public/archives/page/13/index.html","hash":"724720c9840b88a3fb33dba81043686dacf98e75","modified":1647480488957},{"_id":"public/archives/page/14/index.html","hash":"6a8c0096c087dcc0faf447870c5a9ca1833faf0a","modified":1647480488957},{"_id":"public/archives/page/15/index.html","hash":"1f32067b9f56af8206d7e0ecf1a009f3d138d41e","modified":1647480488957},{"_id":"public/archives/page/16/index.html","hash":"7d0c10d868f4274e150b4f73f40ff20d3c6e9157","modified":1647480488957},{"_id":"public/archives/page/17/index.html","hash":"162eae6845e7fcae0d36a387f5a30f0c1740657d","modified":1647480488957},{"_id":"public/archives/page/18/index.html","hash":"59bc55f9c30564505d75bf483e1171796ec3c5a6","modified":1647480488957},{"_id":"public/archives/page/19/index.html","hash":"5e084e339a4d0a2d88f561d9e1b260a02f4dc296","modified":1647480488957},{"_id":"public/archives/page/20/index.html","hash":"ca67bf04c9bd0a893bab4b26cfd87f96e469eb80","modified":1647447989172},{"_id":"public/archives/page/21/index.html","hash":"b4205143ac1906876455addae05db6ef940e535b","modified":1647447989172},{"_id":"public/archives/page/22/index.html","hash":"4e1f63d60114169b4fc650ae23aa17a8cdd0fa4b","modified":1647447989172},{"_id":"public/archives/page/23/index.html","hash":"3c2a79f7a2f4bf936c338b72d432913a4e6bfec8","modified":1647447989172},{"_id":"public/archives/page/24/index.html","hash":"1d4293961513c8258f82de956661b5d589301610","modified":1647447989172},{"_id":"public/archives/page/25/index.html","hash":"62c7609e0ce6210f8cf01fa02b92ace11cf537af","modified":1647447989172},{"_id":"public/archives/page/26/index.html","hash":"7b40adc93ca3fe599557072147a7d6adfa3295d8","modified":1647447989172},{"_id":"public/archives/page/27/index.html","hash":"18cf8e10e0efe19166b69580d7b54f365192418b","modified":1647447989172},{"_id":"public/archives/page/28/index.html","hash":"7f338a66401221780e388b2fde9af6aeb6ebc0fe","modified":1647447989172},{"_id":"public/archives/page/29/index.html","hash":"3b159ed0f635ae48345c4b1e3cd3ac00cb409e87","modified":1647447989172},{"_id":"public/archives/page/30/index.html","hash":"02d93b5269843549d94b945e9a7d53ba67319047","modified":1647447989172},{"_id":"public/archives/page/31/index.html","hash":"362f6cd7c7f23086c9656dbb805f117dc16da6cc","modified":1647447989172},{"_id":"public/archives/page/32/index.html","hash":"11907c6359a22d0d649b50d92af438bdfe765a10","modified":1647447989172},{"_id":"public/archives/page/33/index.html","hash":"ad773082468b84e8c5af4638f6016593d6ca6d84","modified":1647447989172},{"_id":"public/archives/page/34/index.html","hash":"14d10fbf6ada810339b9339caf4a07c602122d2e","modified":1647447989172},{"_id":"public/archives/page/35/index.html","hash":"33d20ff17d7df3f175b5a8e91ac67850c3e694d4","modified":1647447989172},{"_id":"public/archives/page/36/index.html","hash":"37d9e395a43268fa41b1606b1ca5c2c27b60742b","modified":1647447989172},{"_id":"public/archives/page/37/index.html","hash":"2f858ae1aca89f2a8e4f10e7918af4762458f69e","modified":1647447989172},{"_id":"public/archives/page/38/index.html","hash":"715f4cadb78ef6b9cbfc21ff2ec36591a360cdae","modified":1647447989172},{"_id":"public/archives/page/39/index.html","hash":"a6ed88582ed1f76792ccdf3d8fc4f207393d44ec","modified":1647447989172},{"_id":"public/archives/page/40/index.html","hash":"b43a42c883f6ce95061e0ea705c31f5cf6ddc988","modified":1647447989172},{"_id":"public/archives/page/41/index.html","hash":"4638179dbd165f3874977d24966fc36a9005cc54","modified":1647447989172},{"_id":"public/archives/2021/index.html","hash":"30536ec6faffb6336ea4091d872e4107f4dfb07e","modified":1647480488957},{"_id":"public/archives/2021/page/2/index.html","hash":"c806eb608880db6e336096cfcbcef2e8eb3007fd","modified":1647480488957},{"_id":"public/archives/2021/page/3/index.html","hash":"59c1b762f61ee0991601a6cfc812096f5e316335","modified":1647480488957},{"_id":"public/archives/2021/page/4/index.html","hash":"1b5c878dbd4b0fbc90927abf55b652f409da1d19","modified":1647480488957},{"_id":"public/archives/2021/page/5/index.html","hash":"b60f556ac672138b61baf8f2799a18ea698b3422","modified":1647480488957},{"_id":"public/archives/2021/page/6/index.html","hash":"1096b6ad9ebbb784a6294663e3277fa9e6cca829","modified":1647480488957},{"_id":"public/archives/2021/page/7/index.html","hash":"c8bc4a489fd464fc458283a603b4ad59c13c63b3","modified":1647480488957},{"_id":"public/archives/2021/page/8/index.html","hash":"698b1f5fb07783b010ec89b5afb0c7545ece4dd3","modified":1647480488957},{"_id":"public/archives/2021/page/9/index.html","hash":"e6449dace7eca7ee9d63d922db9e5d1cbe2cd1ce","modified":1647480488957},{"_id":"public/archives/2021/page/10/index.html","hash":"4164a069610ce86bd4aa7a65ef01a22ebdc3df85","modified":1647480488957},{"_id":"public/archives/2021/page/11/index.html","hash":"16f32b4fa7db5f7bf8a85a0af874dc253e2acdb4","modified":1647480488957},{"_id":"public/archives/2021/page/12/index.html","hash":"ba99442504b089f838222e6ab2246ada1e717b04","modified":1647480488957},{"_id":"public/archives/2021/page/13/index.html","hash":"e146a50ca866ecc8420074ba3d34e635d5b68d08","modified":1647480488957},{"_id":"public/archives/2021/page/14/index.html","hash":"3dea58f76f26ee0e3e50acb74e77903a2b095720","modified":1647480488957},{"_id":"public/archives/2021/page/15/index.html","hash":"e5472b8336e88aa3000ca5b546ffb55c8d0e8f62","modified":1647447989172},{"_id":"public/archives/2021/page/16/index.html","hash":"db22a258a228a2b4baeabb8e396dfcb79dc08f08","modified":1647447989172},{"_id":"public/archives/2021/09/index.html","hash":"dc35386b8941ca369d19f825b18ebda7e2f02672","modified":1647480488957},{"_id":"public/archives/2021/09/page/2/index.html","hash":"f134ba825717f7c7e11efe88f4d490b17668c8fd","modified":1647480488957},{"_id":"public/archives/2021/09/page/3/index.html","hash":"c73af80fc05c09658fdea3193f9fc4332d4a85e2","modified":1647480488957},{"_id":"public/archives/2021/09/page/4/index.html","hash":"030122f289afb1d0d96750b531464bc2197ae72a","modified":1647480488957},{"_id":"public/archives/2021/09/page/5/index.html","hash":"6d2136a43dadf71eff43893647f0e6e6e6a5feb8","modified":1647480488957},{"_id":"public/archives/2021/09/page/6/index.html","hash":"43dffe7eb45392904ebe451352a5eb2b739edbf0","modified":1647480488957},{"_id":"public/archives/2021/09/page/7/index.html","hash":"5979ae8c89f0f978b9676d4e17de11897f636347","modified":1647480488957},{"_id":"public/archives/2021/09/page/8/index.html","hash":"c3cac796fa252302a1db66f0349514950f836f97","modified":1647480488957},{"_id":"public/archives/2021/09/page/9/index.html","hash":"9e34e61c9071e7e915d12021c722b41406b2e445","modified":1647480488957},{"_id":"public/archives/2021/09/page/10/index.html","hash":"c1d002eaf064de964bbca9de6ac45f8ff0a7e4a5","modified":1647480488957},{"_id":"public/archives/2021/09/page/11/index.html","hash":"9cc50bd8778b8df6b38a3f7c99d387262d0c1799","modified":1647480488957},{"_id":"public/archives/2021/10/index.html","hash":"f915c3f845ea269222fff0ad834c3f95dc16e170","modified":1647447989172},{"_id":"public/archives/2021/11/index.html","hash":"bf50284417dfedfcec0c33fd5370d52084053422","modified":1647480488957},{"_id":"public/archives/2021/11/page/2/index.html","hash":"c52f505f3464eed42c0c4d6e4f7dd67dd7a82cc4","modified":1647447989172},{"_id":"public/archives/2021/12/index.html","hash":"1c6e8dc16e297221e9f8c5987914d571682bcf7a","modified":1647480488957},{"_id":"public/archives/2021/12/page/2/index.html","hash":"9efb5f470cb32ac638db5c9f198085c0a13a883c","modified":1647480488957},{"_id":"public/archives/2021/12/page/3/index.html","hash":"bdf8fbb9a1a6edaae9d3b5f7529b2099151d1f6c","modified":1647447989172},{"_id":"public/archives/2021/12/page/4/index.html","hash":"80df35279f10fb5e98c0a3325bea7c499a975999","modified":1647447989172},{"_id":"public/archives/2022/index.html","hash":"fccae3f7d4d8e48e0036710d7a7576daadee071d","modified":1647480488957},{"_id":"public/archives/2022/page/2/index.html","hash":"532b6159bc93d4e941352e9518a179792456217f","modified":1647480488957},{"_id":"public/archives/2022/page/3/index.html","hash":"ceaca2fd9e4ea5275d56f5f722b8d2f8b9f2a1dd","modified":1647480488957},{"_id":"public/archives/2022/page/4/index.html","hash":"493d0f40b0ea54b5cc82aa516c1481978b362756","modified":1647480488957},{"_id":"public/archives/2022/page/5/index.html","hash":"5f4749afbe0387b551c5cfdfbd740707525b4906","modified":1647480488957},{"_id":"public/archives/2022/page/6/index.html","hash":"e8e6430e603c8e71bd7353e69d2801bef633cdda","modified":1647480488957},{"_id":"public/archives/2022/page/7/index.html","hash":"13167c0af6894e623c1d2045c8e8752a3cbfad08","modified":1647447989172},{"_id":"public/archives/2022/page/8/index.html","hash":"1a83e9f318c0eb7a89e8fc63edf1e50f6e9295cb","modified":1647447989172},{"_id":"public/archives/2022/page/9/index.html","hash":"a36a95ea24bf0e3924bc8e49d5d24eba34f7e507","modified":1647447989172},{"_id":"public/archives/2022/page/10/index.html","hash":"3cf646c8e26c9482316b476ec06812e5efead702","modified":1647447989172},{"_id":"public/archives/2022/page/11/index.html","hash":"163d956cf4162d03091f31f6c0e1aa85766a0976","modified":1647447989172},{"_id":"public/archives/2022/page/12/index.html","hash":"c56a98615bc835d514817249abfe5967e1c90553","modified":1647447989172},{"_id":"public/archives/2022/page/13/index.html","hash":"55d859ef9b7f8bf1616a17d62b55fe1baeff234c","modified":1647447989172},{"_id":"public/archives/2022/page/14/index.html","hash":"9f4acc67945065ee5b652fe92200856cc96dd1ee","modified":1647447989172},{"_id":"public/archives/2022/page/15/index.html","hash":"4181c032258e47d2af50b50a885808bc56a336b1","modified":1647447989172},{"_id":"public/archives/2022/page/16/index.html","hash":"23dc35baf1c6366be5d1e25f086a4d4699c930a1","modified":1647447989172},{"_id":"public/archives/2022/page/17/index.html","hash":"fd827cbe82080ff5017a3a8561fed6f941d620a5","modified":1647447989172},{"_id":"public/archives/2022/page/18/index.html","hash":"9b105d877ce2206dc987a1c89de8f501cd58cbc9","modified":1647447989172},{"_id":"public/archives/2022/page/19/index.html","hash":"39543ec17333a9c9eb05db5795c897de0cbdf4c1","modified":1647447989172},{"_id":"public/archives/2022/page/20/index.html","hash":"121f0cd9abf2746a0ea8e87a90a6d616be9c0725","modified":1647447989172},{"_id":"public/archives/2022/page/21/index.html","hash":"a78d2155982c7721615eaf6db2ba90ebbfbd1e7f","modified":1647447989172},{"_id":"public/archives/2022/page/22/index.html","hash":"e80b31df94cada0c275c3b0c5deeb3a8c41e7709","modified":1647447989172},{"_id":"public/archives/2022/page/23/index.html","hash":"99cb8f4989d3b71ec6ff68c1ca6a2e7b7bed2e14","modified":1647447989172},{"_id":"public/archives/2022/page/24/index.html","hash":"a5021bb000aad8dabdd05b96a24ed37e0280e78c","modified":1647447989172},{"_id":"public/archives/2022/page/25/index.html","hash":"32f2a13e40b8f9d021a177e23779e19cfc42ac64","modified":1647447989172},{"_id":"public/archives/2022/page/26/index.html","hash":"2566cc524e15b5ebfa1babb657c67fab0cfa63a9","modified":1647447989172},{"_id":"public/archives/2022/01/index.html","hash":"9b8e1e15f3ae0cb3783bd322236ec34623692e11","modified":1647480488957},{"_id":"public/archives/2022/01/page/2/index.html","hash":"742a1ae56eea4a03fa6ccebaff81b1953dbf2ecd","modified":1647447989172},{"_id":"public/archives/2022/01/page/3/index.html","hash":"adb0d19c9b48f7d8a7c76c04c91230abb1fd29fd","modified":1647447989172},{"_id":"public/archives/2022/01/page/4/index.html","hash":"5bd6161ccddf99532f1730f8924ac40fe2d13eb5","modified":1647447989172},{"_id":"public/archives/2022/01/page/5/index.html","hash":"768032da341edf85e2461d26daa3fff0891821a1","modified":1647447989172},{"_id":"public/archives/2022/01/page/6/index.html","hash":"2c1f145a901188364fab8281613eecdb446c2faa","modified":1647447989172},{"_id":"public/archives/2022/01/page/7/index.html","hash":"63c4cad2c5d27d44dad8b1a181449cddc0304474","modified":1647447989172},{"_id":"public/archives/2022/01/page/8/index.html","hash":"1e69d9e9a509185f2819fd9fa00e233f3cf62860","modified":1647447989172},{"_id":"public/archives/2022/01/page/9/index.html","hash":"b78541180707615ac95aee960cce8cc74d29210d","modified":1647447989172},{"_id":"public/archives/2022/02/index.html","hash":"aba9d519860e12a2b4cb6a5689f20ab3e3272fe7","modified":1647480488957},{"_id":"public/archives/2022/02/page/2/index.html","hash":"656a26dab33ff5682da26f510d4e92a01ff9965a","modified":1647480488957},{"_id":"public/archives/2022/02/page/3/index.html","hash":"c704f7fdf86e7dd99cd121f933b309d6c705bd3e","modified":1647480488957},{"_id":"public/archives/2022/02/page/4/index.html","hash":"16affddcb666edfa9e787abb376a37d3ca1c9589","modified":1647480488957},{"_id":"public/archives/2022/02/page/5/index.html","hash":"3b3e9b12dc796f3fe91b48943c2d42d75888b01a","modified":1647447989172},{"_id":"public/archives/2022/02/page/6/index.html","hash":"790e415d0b5ed841160ae8606cc9d125ed17c7e3","modified":1647447989172},{"_id":"public/archives/2022/02/page/7/index.html","hash":"12c776cb3c566e40625024c6ed6c93e11adec31e","modified":1647447989172},{"_id":"public/archives/2022/02/page/8/index.html","hash":"cf0f6e5cbe83c90e735aec0e5e02ec4e2d791a19","modified":1647447989172},{"_id":"public/archives/2022/02/page/9/index.html","hash":"2be48481ef26943d670e958606f828fe42186478","modified":1647447989172},{"_id":"public/archives/2022/02/page/10/index.html","hash":"d9b348879fb7df388734ad8df7992fbed4914582","modified":1647447989172},{"_id":"public/archives/2022/02/page/11/index.html","hash":"c5b1a2f24a06158fd13d45f79721d6f8cb075ac8","modified":1647447989172},{"_id":"public/archives/2022/02/page/12/index.html","hash":"4b800f9d4bc6f10eae39c424c2e10815ee4c773e","modified":1647447989172},{"_id":"public/archives/2022/02/page/13/index.html","hash":"24abef4e8d2d754db7221d40b5be91df09e4c7f2","modified":1647447989172},{"_id":"public/archives/2022/02/page/14/index.html","hash":"d3326c688a19c827975e5f4563d89578567d0280","modified":1647447989172},{"_id":"public/archives/2022/02/page/15/index.html","hash":"1f69e75f785a0b4f65c1b7487fd23b77ba374198","modified":1647447989172},{"_id":"public/archives/2022/03/index.html","hash":"ded300526b60fccdcc0128660d78d427c09bdbec","modified":1647480488957},{"_id":"public/archives/2022/03/page/2/index.html","hash":"3ec7c0ed8c60029096b4ae1fdef521433a11c0fc","modified":1647480488957},{"_id":"public/archives/2022/03/page/3/index.html","hash":"565f20ff2b1465e17265a35c694f5f546105632b","modified":1647447989172},{"_id":"public/categories/Apache-Dubbo实战/index.html","hash":"463969ab541e2e9f9d12d0b1b277ef3306b9dc32","modified":1647447989172},{"_id":"public/categories/Apache-KAFKA实战/index.html","hash":"8cfc6aea2e3d1b78150223c084d7cfbe4b662d0c","modified":1647447989172},{"_id":"public/categories/Apache-KAFKA实战/page/2/index.html","hash":"0b1257de0797f9a9fa64df1a6645b45b2b0db443","modified":1647447989172},{"_id":"public/categories/Docker开发指南/index.html","hash":"e65b1e43d07a4316a630c022ad88997790708f50","modified":1647447989172},{"_id":"public/categories/Effective-Java/index.html","hash":"8c1ab561f13e1aa71af34831d9924f04f70b9147","modified":1647480488957},{"_id":"public/categories/ElasticSearch实战/index.html","hash":"8d762cc5e47a2d3b205a99036fcc870dd0b60ac7","modified":1647447989172},{"_id":"public/categories/Java并发编程实战/index.html","hash":"6dd3515736224a5079b3a1d30deb65a70abd055b","modified":1647447989172},{"_id":"public/categories/Java编程思想/index.html","hash":"5cc6c799ffdd79199a71a6a511d8d3f2cfb0162a","modified":1647447989172},{"_id":"public/categories/Java编程思想/page/2/index.html","hash":"b59f3e3298258908780e1c42fb99e0b5c00a867d","modified":1647447989172},{"_id":"public/categories/MyBatis技术内幕/index.html","hash":"1783e08c9df030a248b69a612152d33164c16152","modified":1647447989172},{"_id":"public/categories/MySQL必知必会/index.html","hash":"f910d36eea33eefbe6f0cb32ef470aadaf670bea","modified":1647480488957},{"_id":"public/categories/Netty权威指南/index.html","hash":"de1f8e5775495bb49529e2bd4530406a7ecfbf57","modified":1647447989172},{"_id":"public/categories/Netty权威指南/page/2/index.html","hash":"f639b05d35164a5e05ed11cef71aa7f044d01f09","modified":1647447989172},{"_id":"public/categories/LeetCode/index.html","hash":"449f7aceafce303fb78bf3a226c9234beb32a10c","modified":1647480488957},{"_id":"public/categories/LeetCode/page/2/index.html","hash":"351e0b36a88337803cc5b70a6abccb40e8593461","modified":1647480488957},{"_id":"public/categories/LeetCode/page/3/index.html","hash":"127ee9f9e43999c1591d2b552302f775d04552df","modified":1647480488957},{"_id":"public/categories/LeetCode/page/4/index.html","hash":"a0caae775094d513a8f41f1a36969ef401f9280e","modified":1647480488957},{"_id":"public/categories/LeetCode/page/5/index.html","hash":"3bc8e3c1d61fc70c74ce5bf522dc3e3f4ae2ad91","modified":1647480488957},{"_id":"public/categories/LeetCode/page/6/index.html","hash":"ba028de9acc0a1cd6b60ef46081c960141d45197","modified":1647480488957},{"_id":"public/categories/LeetCode/page/7/index.html","hash":"a8e85262ebc9440df93c36691ae6db9af35cbdb2","modified":1647480488957},{"_id":"public/categories/LeetCode/page/8/index.html","hash":"229cb97c50cd8001359350da3617e8d73e46e8b6","modified":1647480488957},{"_id":"public/categories/LeetCode/page/9/index.html","hash":"848d73e9a762bf539942ddfe3f2d38c0382d50df","modified":1647480488957},{"_id":"public/categories/LeetCode/page/10/index.html","hash":"e9b528881cfe61d707e7371c78cf56c7394238dc","modified":1647480488957},{"_id":"public/categories/Redis开发与运维/index.html","hash":"a7afe4cc66ff6af0d3cfa447eac7bf7f399c0605","modified":1647447989172},{"_id":"public/categories/Redis开发与运维/page/2/index.html","hash":"3a622cd8cd436349044621fd46e4add312d30b6d","modified":1647447989172},{"_id":"public/categories/Redis设计与实现/index.html","hash":"115ef989db873efe04ae4cf5cf083ba86208559a","modified":1647447989172},{"_id":"public/categories/Redis设计与实现/page/2/index.html","hash":"310a1f8f98932f2f62eb381982d2a771f3c32ded","modified":1647447989172},{"_id":"public/categories/Service-Mesh实战/index.html","hash":"832605ee719629cdaa9a495f02cd282001d96e55","modified":1647447989172},{"_id":"public/categories/Shell脚本编程大全/index.html","hash":"6462b6a84affe5876700183bba5cfc0084aa882b","modified":1647480488957},{"_id":"public/categories/Spring技术内幕/index.html","hash":"4f9bdd590080debe706db06279e28b690519d2ed","modified":1647447989172},{"_id":"public/categories/SpringCloud微服务实战/index.html","hash":"3954a451112c3da60ab889ccd53d19511fe19f8e","modified":1647447989172},{"_id":"public/categories/ZooKeeper分布式技术/index.html","hash":"d2949ad6f9ddf9bbf8297d4cd45c349378214421","modified":1647447989172},{"_id":"public/categories/ZooKeeper分布式技术/page/2/index.html","hash":"65f218b35b79af5bc0400c99fca9ea3067399938","modified":1647447989172},{"_id":"public/categories/Tomcat架构解析/index.html","hash":"6037ee05053c3592060899154691e6a69ca14c55","modified":1647480488957},{"_id":"public/categories/代码整洁之道/index.html","hash":"f4487f5faa239d8d2216ef1810b922581d226287","modified":1647447989172},{"_id":"public/categories/公众号文章/index.html","hash":"a7ee5717adc1641c20b70e068c47a9334cac77ba","modified":1647480488957},{"_id":"public/categories/公众号文章/page/2/index.html","hash":"fbea8768b5f0aace3e6819c14b0dc37de28d9953","modified":1647480488957},{"_id":"public/categories/分布式服务架构/index.html","hash":"083f2a6a666f3cc269a58d3f8ea63f8030bfe8ad","modified":1647447989172},{"_id":"public/categories/图解TCP-IP/index.html","hash":"202921a70afeae63269e6bb88e1a8196a94edf2b","modified":1647480488957},{"_id":"public/categories/剑指OFFER/index.html","hash":"21bf606997c2e61a8c3feb0fff98f6085bbbd46b","modified":1647480488957},{"_id":"public/categories/剑指OFFER/page/2/index.html","hash":"d1b9e0fbff68a6cfbcaf91ea0730f5d12eb15782","modified":1647480488957},{"_id":"public/categories/剑指OFFER/page/3/index.html","hash":"a27aa35c93130906c75ba1cc78858209b45ba4fd","modified":1647480488957},{"_id":"public/categories/大话设计模式/index.html","hash":"d46b7a84ccdaf3366618343c9b57090d2e054139","modified":1647447989172},{"_id":"public/categories/大话设计模式/page/2/index.html","hash":"4fc261aa31d54c1a6c177828beaa07f0e1633ae2","modified":1647447989172},{"_id":"public/categories/实现领域驱动设计/index.html","hash":"bfeb824ed8fbfb432b218443b7ca09ab47ff2660","modified":1647447989172},{"_id":"public/categories/实现领域驱动设计/page/2/index.html","hash":"e3e2ae074f9599bcd6f5fd3720c36a98b36e6f30","modified":1647447989172},{"_id":"public/categories/操作系统导论/index.html","hash":"413fc7e8bbbc2dbc6ce15977c8426819f6d760a3","modified":1647480488957},{"_id":"public/categories/架构师修炼之道/index.html","hash":"c48d9b2132fbb5d9fffe287d9a4db58461ec24fd","modified":1647447989172},{"_id":"public/categories/数据结构和算法分析/index.html","hash":"0028877e767e317d6a28fc5cd859f1caa675960c","modified":1647447989172},{"_id":"public/categories/深入浅出ServerLess/index.html","hash":"aca5f09819a80914be5169b9a9a653aab643a99e","modified":1647447989172},{"_id":"public/categories/深入理解JVM虚拟机/index.html","hash":"5c7d0f4c88611e6fee90dcd83cf73a6045f52948","modified":1647480488957},{"_id":"public/categories/深入理解Nginx/index.html","hash":"0752f87942efa9cdf03217aa91e54978dd63aedf","modified":1647480488957},{"_id":"public/categories/金字塔原理/index.html","hash":"74d8c665a05167a93b007c11a40f862906e8a701","modified":1647480488957},{"_id":"public/categories/深入理解RPC框架原理/index.html","hash":"8a1e3f81130a56aa8a25d94318273caf2874ad8e","modified":1647447989172},{"_id":"public/categories/深入理解RPC框架原理/page/2/index.html","hash":"354384a5c866cf3745d072f21519b412e0fef2af","modified":1647447989172},{"_id":"public/categories/高性能MySQL/index.html","hash":"18311bc0e821d8d69f4c7062b48d0abd2c99efd4","modified":1647447989172},{"_id":"public/categories/高性能MySQL/page/2/index.html","hash":"fff23ba053dbb113e2716b2af2ae514f4e5e7c40","modified":1647447989172},{"_id":"public/categories/鸟哥的Linux私房菜/index.html","hash":"05b8da52edab81a7b5064be55c2f6c22dc9d9aa9","modified":1647447989172},{"_id":"public/categories/Netty权威指南/源码解读/index.html","hash":"1dc462bef538d130e0c96e5bc2613b4da33879fa","modified":1647447989172},{"_id":"public/categories/阿里Java开发手册/index.html","hash":"b67e71eb1a172229c0a9aa6c4951e843d6b8154f","modified":1647480488957},{"_id":"public/categories/阿里Java开发手册/编程规约/index.html","hash":"b67e71eb1a172229c0a9aa6c4951e843d6b8154f","modified":1647480488957},{"_id":"public/index.html","hash":"d7d5794299c3c1266362d8836e75694f9c869fdd","modified":1647480488957},{"_id":"public/page/2/index.html","hash":"e74f3ad0d405b1eb4b863ae47a236bef8b20649f","modified":1647480488957},{"_id":"public/page/3/index.html","hash":"3b509ba646ac142c661c9fbffafe2d9b47324860","modified":1647480488957},{"_id":"public/page/4/index.html","hash":"3fde2e5a00c2ef7703fabb57e38d29d925266070","modified":1647480488957},{"_id":"public/page/5/index.html","hash":"81365b69de2fffc23e18b6be92cde776dba608fc","modified":1647480488957},{"_id":"public/page/6/index.html","hash":"edf15432714d7d85049ddef66840828fbbed88ac","modified":1647480488957},{"_id":"public/page/7/index.html","hash":"ba643103659ac7756f45c2b63708fd5beb7c479d","modified":1647480488957},{"_id":"public/page/8/index.html","hash":"b5f3bc6d491e7aea0095113728a610f8c6732a58","modified":1647480488957},{"_id":"public/page/9/index.html","hash":"7939c76c0a3427b33683d7c87819fab187d763ce","modified":1647480488957},{"_id":"public/page/10/index.html","hash":"c1491b6e9298902134205129de55097cd193000e","modified":1647480488957},{"_id":"public/page/11/index.html","hash":"76d1ec29a3379e8ea6fad71e581fcf156da0727b","modified":1647447989172},{"_id":"public/page/12/index.html","hash":"7353d5ded9097f8baae7cfd4ce2ae96f9d16763d","modified":1647447989172},{"_id":"public/page/13/index.html","hash":"b82981c790fe6707a28777f5247341cdbb5566b8","modified":1647447989172},{"_id":"public/page/14/index.html","hash":"676ca036875dd6f10ed8dfc8ffdbf5b795802ef9","modified":1647447989172},{"_id":"public/page/15/index.html","hash":"3225c61e4eef1ee8e2e705a31d9c4358c7f86e80","modified":1647447989172},{"_id":"public/page/16/index.html","hash":"1524516769d5c26205188c7808e8446b2dfac945","modified":1647447989172},{"_id":"public/page/17/index.html","hash":"781c5f064603ab8705ceea0fc239fd4c11ccbf1d","modified":1647447989172},{"_id":"public/page/18/index.html","hash":"0e0425c069e4b372c29a86e0ba51bf237e18ffe4","modified":1647447989172},{"_id":"public/page/19/index.html","hash":"7cd1e53276e63b11995f62752649106e2eb1778b","modified":1647447989172},{"_id":"public/page/20/index.html","hash":"4c0bc459cbc4bfce03bdf74534cb4dd9956ce4e5","modified":1647447989172},{"_id":"public/page/21/index.html","hash":"ab050245e145cde23b4b19ac436064c451f6ba14","modified":1647447989172},{"_id":"public/CNAME","hash":"85483aca99cabb9092246c4e05f6591074440cac","modified":1647482410346},{"_id":"public/favicon.ico","hash":"268be0a863caae7c5a732fb8a911a81434f31117","modified":1647447989172},{"_id":"public/个人公众号.jpg","hash":"a7528a513682ae9f10b826104274da759deb4ec8","modified":1647447989172},{"_id":"public/个人微信.jpeg","hash":"ba47cfa4fc9bc5579f10cbbb984baf7bff5726d6","modified":1647447989172},{"_id":"public/头像.jpg","hash":"2596dd7ebfc5c2a5bf4538525e7bdc1eebf6afb8","modified":1647447989172},{"_id":"public/404.html","hash":"9788847c4015f690d31185336add4d62c68dc68d","modified":1647447989172},{"_id":"public/css/main.css","hash":"8f5499563af3f3f4f4c1826cb3e269486c01efe4","modified":1647447989172},{"_id":"public/css/jquery.fancybox.min.css","hash":"1be9b79be02a1cfc5d96c4a5e0feb8f472babd95","modified":1647447989172},{"_id":"public/js/clipboard.min.js","hash":"6371ec0a8e242395c7d4d008d2b98e472c9dcc52","modified":1647447989172},{"_id":"public/css/clipboard-use.css","hash":"9536f622240449099e4a35072cc42b28538c0eec","modified":1647447989172},{"_id":"public/js/main.js","hash":"b9ba5bd773383322d002ba92e9d205fd0b2fb599","modified":1647447989172},{"_id":"public/lib/highlight/darcula.css","hash":"7740224d07375ddc321147dffabbfa83e39f0d8b","modified":1647447989172},{"_id":"public/lib/busuanzi/2.3/busuanzi.pure.mini.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1647447989172},{"_id":"public/lib/jquery.pjax.js","hash":"13485a1e2dc9c8df28267549de1b8af8f39061d9","modified":1647447989172},{"_id":"public/js/jquery.fancybox.min.js","hash":"6181412e73966696d08e1e5b1243a572d0f22ba6","modified":1647447989172},{"_id":"public/lib/font-awesome/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1647447989172},{"_id":"public/lib/valine/Valine-1.3.10-min.js","hash":"e3a340d0c39eee2ae651284fda9d351e752fcbd0","modified":1647447989172},{"_id":"public/lib/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1647447989172},{"_id":"public/lib/valine/av-3.0.4-min.js","hash":"2577e72b52b736d99649f9e95be8976d58563333","modified":1647447989172},{"_id":"public/lib/highlight/highlight.pack.js","hash":"84a7e42dfa8c44a422a8328277d660d9428fcea6","modified":1647447989172},{"_id":"source/_posts/MySQL/MySQL面试题.md","hash":"13fcd684ac5260038debf667d8450fec34bf09f9","modified":1647480384198},{"_id":"public/2022/03/17/MySQL/MySQL面试题/index.html","hash":"3d6154b6cbdb1602ca56acdd8ec2839e165de7c8","modified":1647482410346}],"Category":[{"name":"Apache Dubbo实战","_id":"cl0trzwdu0004fhji5dgb3zk7"},{"name":"Apache KAFKA实战","_id":"cl0trzwe4000jfhji1mnacm07"},{"name":"Docker开发指南","_id":"cl0trzweg001ifhji7x2m6rg5"},{"name":"Effective Java","_id":"cl0trzwel001yfhji883818sg"},{"name":"ElasticSearch实战","_id":"cl0trzwep002dfhjidohsfrb6"},{"name":"Java并发编程实战","_id":"cl0trzwex0031fhjieudn6e8v"},{"name":"Java编程思想","_id":"cl0trzwf90045fhji75eu4jsk"},{"name":"MyBatis技术内幕","_id":"cl0trzwfw005ufhjifbec809z"},{"name":"MySQL必知必会","_id":"cl0trzwg00066fhjifi3ehx6i"},{"name":"Netty权威指南","_id":"cl0trzwg6006mfhji0e6z5pak"},{"name":"LeetCode","_id":"cl0trzwgp0082fhji6cr48g3e"},{"name":"Redis开发与运维","_id":"cl0trzwj500fqfhjihuo014kj"},{"name":"Redis设计与实现","_id":"cl0trzwjn00hefhji1fx7e05e"},{"name":"Service Mesh实战","_id":"cl0trzwk900j2fhji1jw41e7g"},{"name":"Shell脚本编程大全","_id":"cl0trzwka00j7fhjieuv6d8gl"},{"name":"Spring技术内幕","_id":"cl0trzwkd00jffhji0hq34yx9"},{"name":"SpringCloud微服务实战","_id":"cl0trzwki00jzfhjiepz540pz"},{"name":"ZooKeeper分布式技术","_id":"cl0trzwkq00krfhji04cv2ibp"},{"name":"Tomcat架构解析","_id":"cl0trzwl700mbfhji9v7mavwp"},{"name":"代码整洁之道","_id":"cl0trzwli00ncfhji1qcu123m"},{"name":"公众号文章","_id":"cl0trzwll00nofhjidx1e0jcw"},{"name":"分布式服务架构","_id":"cl0trzwlq00ocfhjic0js2t1e"},{"name":"图解TCP IP","_id":"cl0trzwls00oofhjig6qzb9il"},{"name":"剑指OFFER","_id":"cl0trzwlu00oyfhji7ieeh3on"},{"name":"大话设计模式","_id":"cl0trzwm400qgfhji20uu5byw"},{"name":"实现领域驱动设计","_id":"cl0trzwma00rafhjigzcag15q"},{"name":"操作系统导论","_id":"cl0trzwmf00s0fhjiesmhbb70"},{"name":"架构师修炼之道","_id":"cl0trzwmi00scfhjifvmzgsv3"},{"name":"数据结构和算法分析","_id":"cl0trzwmj00sgfhji5o1551v5"},{"name":"深入浅出ServerLess","_id":"cl0trzwml00sufhji6crng2av"},{"name":"深入理解JVM虚拟机","_id":"cl0trzwmm00syfhji7mre5s5h"},{"name":"深入理解Nginx","_id":"cl0trzwmq00tifhjih1d304h2"},{"name":"金字塔原理","_id":"cl0trzwmr00tofhjidarkbosr"},{"name":"深入理解RPC框架原理","_id":"cl0trzwms00tufhji7n7s8t9s"},{"name":"高性能MySQL","_id":"cl0trzwmz00usfhji8kf334ek"},{"name":"鸟哥的Linux私房菜","_id":"cl0trzwn600vsfhji8uqv548j"},{"name":"源码解读","parent":"cl0trzwg6006mfhji0e6z5pak","_id":"cl0trzwna00wcfhji66o9guot"},{"name":"阿里Java开发手册","_id":"cl0trzwnb00wgfhjidfzn7k1l"},{"name":"编程规约","parent":"cl0trzwnb00wgfhjidfzn7k1l","_id":"cl0trzwng00wpfhji4jim1a9x"}],"Data":[],"Page":[{"title":"关于我","date":"2020-12-03T03:29:32.000Z","_content":"\n本人目前在**美团**工作，小开发一枚，不是大佬，但会持续学习\n\n**公众号：月伴飞鱼**\n\n* 更多干货内容，包括分布式，并发编程，源码等\n* 公众号回复666获取海量电子书籍\n* 公众号有内推链接，需要的话也可以帮大家看看简历\n* 加入面试交流群，和一群大佬一起交流学习\n\n分享一篇本人之前面试总结的面经(应该会对大家有帮助)：\n\n* [社招一年半面经分享(含阿里美团头条京东滴滴)](https://www.nowcoder.com/discuss/594676?source_id=profile_create_nctrack&channel=-1)\n\n**公众号**\n\n<img src=\"https://img-blog.csdnimg.cn/20210613214230408.jpeg\" style=\"zoom:50%;\" />\n\n**个人微信**\n\n<img src=\"https://img-blog.csdnimg.cn/20210613214134582.jpeg\" style=\"zoom:25%;\" />","source":"about/index.md","raw":"---\ntitle: 关于我\ndate: 2020-12-03 11:29:32\n---\n\n本人目前在**美团**工作，小开发一枚，不是大佬，但会持续学习\n\n**公众号：月伴飞鱼**\n\n* 更多干货内容，包括分布式，并发编程，源码等\n* 公众号回复666获取海量电子书籍\n* 公众号有内推链接，需要的话也可以帮大家看看简历\n* 加入面试交流群，和一群大佬一起交流学习\n\n分享一篇本人之前面试总结的面经(应该会对大家有帮助)：\n\n* [社招一年半面经分享(含阿里美团头条京东滴滴)](https://www.nowcoder.com/discuss/594676?source_id=profile_create_nctrack&channel=-1)\n\n**公众号**\n\n<img src=\"https://img-blog.csdnimg.cn/20210613214230408.jpeg\" style=\"zoom:50%;\" />\n\n**个人微信**\n\n<img src=\"https://img-blog.csdnimg.cn/20210613214134582.jpeg\" style=\"zoom:25%;\" />","updated":"2021-12-12T04:19:26.596Z","path":"about/index.html","comments":1,"layout":"page","_id":"cl0trzwdo0000fhjialj1984n","content":"<p>本人目前在<strong>美团</strong>工作，小开发一枚，不是大佬，但会持续学习</p>\n<p><strong>公众号：月伴飞鱼</strong></p>\n<ul>\n<li>更多干货内容，包括分布式，并发编程，源码等</li>\n<li>公众号回复666获取海量电子书籍</li>\n<li>公众号有内推链接，需要的话也可以帮大家看看简历</li>\n<li>加入面试交流群，和一群大佬一起交流学习</li>\n</ul>\n<p>分享一篇本人之前面试总结的面经(应该会对大家有帮助)：</p>\n<ul>\n<li><a href=\"https://www.nowcoder.com/discuss/594676?source_id=profile_create_nctrack&channel=-1\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></li>\n</ul>\n<p><strong>公众号</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/20210613214230408.jpeg\" style=\"zoom:50%;\" />\n\n<p><strong>个人微信</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/20210613214134582.jpeg\" style=\"zoom:25%;\" />","site":{"data":{}},"excerpt":"","more":"<p>本人目前在<strong>美团</strong>工作，小开发一枚，不是大佬，但会持续学习</p>\n<p><strong>公众号：月伴飞鱼</strong></p>\n<ul>\n<li>更多干货内容，包括分布式，并发编程，源码等</li>\n<li>公众号回复666获取海量电子书籍</li>\n<li>公众号有内推链接，需要的话也可以帮大家看看简历</li>\n<li>加入面试交流群，和一群大佬一起交流学习</li>\n</ul>\n<p>分享一篇本人之前面试总结的面经(应该会对大家有帮助)：</p>\n<ul>\n<li><a href=\"https://www.nowcoder.com/discuss/594676?source_id=profile_create_nctrack&channel=-1\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></li>\n</ul>\n<p><strong>公众号</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/20210613214230408.jpeg\" style=\"zoom:50%;\" />\n\n<p><strong>个人微信</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/20210613214134582.jpeg\" style=\"zoom:25%;\" />"},{"title":"知识图谱","date":"2020-12-03T03:29:32.000Z","_content":"\n# ZooKeeper分布式技术\n\n![](https://img-blog.csdnimg.cn/d198ba306aac46e7b8f095c20d0dbe30.png)\n\n\n# Apache KAFKA实战\n\n![](https://img-blog.csdnimg.cn/3b8c74eba9f94346a81c745b65717bda.png)\n\n# Effective Java\n\n![](https://img-blog.csdnimg.cn/2d5e816b8fdc4b439089d2071a37694c.png)\n\n","source":"graph/index.md","raw":"---\ntitle: 知识图谱\ndate: 2020-12-03 11:29:32\n---\n\n# ZooKeeper分布式技术\n\n![](https://img-blog.csdnimg.cn/d198ba306aac46e7b8f095c20d0dbe30.png)\n\n\n# Apache KAFKA实战\n\n![](https://img-blog.csdnimg.cn/3b8c74eba9f94346a81c745b65717bda.png)\n\n# Effective Java\n\n![](https://img-blog.csdnimg.cn/2d5e816b8fdc4b439089d2071a37694c.png)\n\n","updated":"2022-02-08T00:59:57.803Z","path":"graph/index.html","comments":1,"layout":"page","_id":"cl0trzwdt0002fhji5c1td89d","content":"<h1 id=\"ZooKeeper分布式技术\"><a href=\"#ZooKeeper分布式技术\" class=\"headerlink\" title=\"ZooKeeper分布式技术\"></a>ZooKeeper分布式技术</h1><p><img src=\"https://img-blog.csdnimg.cn/d198ba306aac46e7b8f095c20d0dbe30.png\"></p>\n<h1 id=\"Apache-KAFKA实战\"><a href=\"#Apache-KAFKA实战\" class=\"headerlink\" title=\"Apache KAFKA实战\"></a>Apache KAFKA实战</h1><p><img src=\"https://img-blog.csdnimg.cn/3b8c74eba9f94346a81c745b65717bda.png\"></p>\n<h1 id=\"Effective-Java\"><a href=\"#Effective-Java\" class=\"headerlink\" title=\"Effective Java\"></a>Effective Java</h1><p><img src=\"https://img-blog.csdnimg.cn/2d5e816b8fdc4b439089d2071a37694c.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"ZooKeeper分布式技术\"><a href=\"#ZooKeeper分布式技术\" class=\"headerlink\" title=\"ZooKeeper分布式技术\"></a>ZooKeeper分布式技术</h1><p><img src=\"https://img-blog.csdnimg.cn/d198ba306aac46e7b8f095c20d0dbe30.png\"></p>\n<h1 id=\"Apache-KAFKA实战\"><a href=\"#Apache-KAFKA实战\" class=\"headerlink\" title=\"Apache KAFKA实战\"></a>Apache KAFKA实战</h1><p><img src=\"https://img-blog.csdnimg.cn/3b8c74eba9f94346a81c745b65717bda.png\"></p>\n<h1 id=\"Effective-Java\"><a href=\"#Effective-Java\" class=\"headerlink\" title=\"Effective Java\"></a>Effective Java</h1><p><img src=\"https://img-blog.csdnimg.cn/2d5e816b8fdc4b439089d2071a37694c.png\"></p>\n"},{"title":"404","date":"2020-12-03T03:29:32.000Z","_content":"\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>404</title>\n\t</head>\n\t<body>\n\t\t<script type=\"text/javascript\" \t\t\t  src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n\t</body>\n</html>\n\n","source":"404/index.md","raw":"---\ntitle: 404\ndate: 2020-12-03 11:29:32\n---\n\n<!DOCTYPE html>\n<html lang=\"en\">\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<title>404</title>\n\t</head>\n\t<body>\n\t\t<script type=\"text/javascript\" \t\t\t  src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n\t</body>\n</html>\n\n","updated":"2021-09-01T05:22:18.193Z","path":"404/index.html","comments":1,"layout":"page","_id":"cl0trzwdv0005fhjibs5bbbzw","content":"<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>404</title>\n    </head>\n    <body>\n        <script type=\"text/javascript\"               src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n\n","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE html>\n<html lang=\"en\">\n    <head>\n        <meta charset=\"UTF-8\">\n        <title>404</title>\n    </head>\n    <body>\n        <script type=\"text/javascript\"               src=\"//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js\" charset=\"utf-8\"></script>\n    </body>\n</html>\n\n"},{"title":"电影推荐","date":"2020-12-03T03:29:32.000Z","_content":"\n推荐100部我认为的好电影，拯救你的片荒，持续更新！\n\n# 动画电影\n\n**千与千寻**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291561/\n\n我喜欢的台词：\n\n* 曾经发生过的事情不可能忘记，只不过是想不起而已。\n\n**寻梦环游记**\n\n* 豆瓣地址：https://movie.douban.com/subject/20495023/\n\n我喜欢的台词：\n\n* 死亡不是生命的终点，遗忘才是。\n* 我受够了征求同意，我不要循规蹈矩，我要跟随自己的心。\n* 坚持梦想，努力把他变成现实。\n\n**怪兽大学**\n\n* 豆瓣地址：https://movie.douban.com/subject/3789848/\n\n我喜欢的台词：\n\n* 你一点也不可怕，但是你无所畏惧。\n\n**怪兽电力公司**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291579/\n\n我喜欢的台词：\n\n* 不要给它起名字，起了名字就有感情了。\n\n观后感：\n\n* 有很多很搞笑或感人的细节，很值得一看的卡通片。\n\n**飞屋环游记**\n\n* 豆瓣地址：https://movie.douban.com/subject/2129039/\n\n我喜欢的台词：\n\n* 为什么我总是记得那些无聊的小事情。可是就是这些小事情，才是我最怀念的。\n\n**疯狂动物城**\n\n* 豆瓣地址：https://movie.douban.com/subject/25662329/\n\n我喜欢的台词：\n\n* 天性如何并不重要，重要的是你开始改变。\n\n**机器人总动员**\n\n* 豆瓣地址：https://movie.douban.com/subject/2131459/\n\n我喜欢的台词：\n\n* 我不要只是生存，我要活得有意义。\n\n**神偷奶爸**\n\n* 豆瓣地址：https://movie.douban.com/subject/3287562/\n\n观后感：\n\n* 一部充满童真的电影。\n\n**超能陆战队**\n\n* 豆瓣地址：https://movie.douban.com/subject/11026735/\n\n观后感：\n\n* 世界上唯一比给予生命更美好的，就是让生命充满爱。\n\n**名侦探柯南：贝克街的亡灵**\n\n* 豆瓣地址：https://movie.douban.com/subject/2286642/\n\n观后感：\n\n* 我个人认为是柯南剧场版中最经典的一部！\n\n# 动作电影\n\n**功夫**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291543/\n\n我喜欢的台词：\n\n* 其实我只是想打死两位，又或者被两位打死。\n* 一曲肝肠断，天涯何处匿知音。\n* 一个傻子一个哑巴，死一边去吧。\n* 还有谁！\n* 天下武功，无坚不破，唯快不破。\n* 记忆是痛苦的根源，你能不记得算是一种福气了。\n\n**精武英雄**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292895/\n\n观后感：\n\n* 史上最佳纯武打片。\n* 两部个人心目中最好的功夫电影之一，另一部是周星驰的《功夫》。\n\n**武状元苏乞儿**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297863/\n\n观后感：\n\n* 抄家的那段戏，为了表现被抄家心情落寞的镜头，周星驰躺在了大烟床上唱起了歌，没哭没闹没上吊却将落寞表现的淋漓尽致，这演技令人佩服，我个人认为周星驰不仅仅是一个喜剧大师，也是一个真正的好演员。\n* 这部电影的背景音乐，一响起来也让人热血沸腾！\n\n**少林足球**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297747/\n\n我喜欢的台词：\n\n* 做人如果没梦想，那跟咸鱼有什么分别？\n* 你是用两只脚踢球的对不对？\n* 话不能这么讲，我心中的一团火是不会熄地。\n* 靓女又怎么样，我是读书人。\n* 少林功夫加唱歌跳舞你说有没有搞头？\n* 从他们整齐的制服，友善的眼神，我完全可以感受到那份诚意，和体育精神。\n* 你快点回火星吧，地球是很危险的！\n* 除了唱歌，我想不到其它的方法来表达内心地兴奋和对你的仰慕。\n\n**功夫熊猫**\n\n* 豆瓣地址：https://movie.douban.com/subject/1783457/\n\n我喜欢的台词：\n\n* 俗语说，昨天已经过去，明天一切未知，但今天是上帝赐给我们的礼物。\n\n# 喜剧电影\n\n**喜剧之王**\n\n* 豆瓣地址：https://movie.douban.com/subject/1302425/\n\n我喜欢的台词：\n\n* 喂，前面漆黑一片，什么都看不到。不会，天亮之后，就会很美。\n* 我养你啊！\n* 努力，奋斗！\n\n**让子弹飞**\n\n* 豆瓣地址：https://movie.douban.com/subject/3742360/\n\n我喜欢的台词：\n\n* 让子弹飞一会儿！\n* 他要是体面，你就让他体面，他要是不体面，你就帮他体面。\n* 如果你活着，早晚都会死，如果你死了，你就永远活着。\n* 你和钱对我都不重要，没有你对我很重要。\n* 黄四郎：师爷高！县长硬！师爷、张麻子：黄老爷又高又硬！\n\n**九品芝麻官**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297518/\n\n观后感：\n\n* 经典段子密集，建议全文背诵！\n\n**唐伯虎点秋香**\n\n* 豆瓣地址：https://movie.douban.com/subject/1306249/\n\n观后感：\n\n* 看一次笑崩一次，特别推荐不开心的时候看看！\n\n**疯狂的石头**\n\n* 豆瓣地址：https://movie.douban.com/subject/1862151/\n\n观后感：\n\n* 黑色幽默的经典之作，环环相扣的叙事手法，加上荒诞而又严谨的故事情节。\n\n**鬼子来了**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291858/\n\n观后感：\n\n* 姜文，中国最有想法的导演！\n\n# 爱情电影\n\n**大话西游之大圣娶亲**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292213/\n\n我喜欢的台词：\n\n* 曾经有一分真诚的爱情放在我面前，我没有珍惜..........\n* 爱一个人需要理由吗？需要吗？不需要吗？需要吗？\n* 原来那个女孩子在我心里留下了一滴眼泪，我完全可以感受到当时她是多么的伤心。\n* 那个人好像一条狗啊。\n\n**泰坦尼克号**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292722/\n\n我喜欢的台词：\n\n* You Jump，I Jump！\n* 当你一无所有，你没有什么可以失去。\n\n**那些年，我们一起追的女孩**\n\n* 豆瓣地址：https://movie.douban.com/subject/4920528/\n\n观后感：\n\n* 沒有遗憾的青春是不完整的。\n\n# 励志电影\n\n**三傻大闹宝莱坞**\n\n* 豆瓣地址：https://movie.douban.com/subject/3793023/\n\n我喜欢的台词：\n\n* All Is Well（一切皆好）！\n* 追求卓越，成功就会出其不意的找上门。\n* 总是担心明天，又怎能把握好今天。\n\n**阿甘正传**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292720/\n\n我喜欢的台词：\n\n* 生活就像一盒巧克力，你永远不知道下一块是什么味道。\n* 奇迹每天都在发生。\n* 你只有忘记以往的事情，才能够继续前进。\n\n**当幸福来敲门**\n\n* 豆瓣地址：https://movie.douban.com/subject/1849031/\n\n我喜欢的台词：\n\n* 机会总是留给有准备的人，但那往往是努力的人剩下来的。\n* 当你最认为困难的时候，其实就是你最接近成功的时候。\n* 别让别人告诉你你成不了才，即使是我也不行。\n* 那些一事无成的人总是告诉你，你也成不了大器。\n\n**摔跤吧！爸爸**\n\n* 豆瓣地址：https://movie.douban.com/subject/26387939/\n\n我喜欢的台词：\n\n* 永远不要忘记，你是如何走到这一步。\n\n**百万美元宝贝**\n\n* 豆瓣地址：https://movie.douban.com/subject/1309016/\n\n观后感：\n\n* 电影说的是两三个小时的悲剧，其中有太多的泪点，看到的是小人物身上为梦想的奋斗，为梦想的死亡。\n\n# 科幻电影\n\n**回到未来**\n\n* 豆瓣地址：https://movie.douban.com/subject/1300555/\n\n我喜欢的台词：\n\n* 路？我们要去的地方不需要路。\n* 每一个人的未来全靠自己去奋斗，这才能创造出一个美好的未来。\n\n**钢铁侠**\n\n* 豆瓣地址：https://movie.douban.com/subject/1432146/\n\n观后感：\n\n* 开创漫威宇宙的电影，这部电影拯救了漫威！\n\n**黑客帝国**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291843/\n\n观后感：\n\n* 很经典的科幻类型电影，既被片中震撼的打斗特效镜头所折服，又被其中蕴含的哲学思想所吸引。\n\n**阿凡达**\n\n* 豆瓣地址：https://movie.douban.com/subject/1652587/\n\n观后感：\n\n* 电影隐喻了希望人类既拥有现代的科技头脑，又拥有古人的信仰灵魂。\n\n**头号玩家**\n\n* 豆瓣地址：https://movie.douban.com/subject/4920389/\n\n我喜欢的台词：\n\n* 一个人有朋友就不算失败。\n* 是甘于现实，还是征战未来？\n* 不管你喜不喜欢，该往前的不会后退。\n* 只有生活，才是唯一真实的东西。\n\n**复仇者联盟4：终局之战**\n\n* 豆瓣地址：https://movie.douban.com/subject/26100958/\n\n观后感：\n\n* 作为系列的最终篇，确实已经努力做到最好了，有笑点、有泪点、也有燃点。\n\n# 剧情电影\n\n**我不是药神**\n\n* 豆瓣地址：https://movie.douban.com/subject/26752088/\n\n我喜欢的台词：\n\n* 我卖药这么多年，发现这世上只有一种病，穷病，这种病你没法治，你也治不过来。\n* 命就是钱！\n\n**熔炉**\n\n* 豆瓣地址：https://movie.douban.com/subject/5912992/\n\n观后感：\n\n* 这部电影可以说是有史以来最让我震撼的一部巨作，尤其是一想到此片还是以真实事件改编的，就更加让我感到痛心疾首。\n\n**素媛**\n\n* 豆瓣地址：https://movie.douban.com/subject/21937452/\n\n观后感：\n\n* 和《熔炉》不同，这部电影有温暖的部分，自然而然地带动观者情绪。\n\n**82年生的金智英**\n\n* 豆瓣地址：https://movie.douban.com/subject/30327842/\n\n观后感：\n\n* 成年后的女性生活看似由无数无关紧要的事所组成，实则每件小事都可能成为压垮骆驼的最后一根稻草。\n\n**无名之辈**\n\n* 豆瓣地址：https://movie.douban.com/subject/27110296/\n\n观后感：\n\n* 从对方最不堪的痛苦开始，才能触碰到彼此灵魂最深的爱。\n* 一个人对生活绝望，不是因为病痛和折磨，而是觉得没了尊严和爱。\n\n**驴得水**\n\n* 豆瓣地址：https://movie.douban.com/subject/25921812\n\n观后感：\n\n* 开心麻花出品的最好的电影。\n\n**贫民窟的百万富翁**\n\n* 豆瓣地址：https://movie.douban.com/subject/2209573/\n\n观后感：\n\n* 非常现实主义的剧情，最后有一个浪漫主义的结局。\n\n**低俗小说**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291832/\n\n观后感：\n\n* 结构上的巧妙和深意，特别精彩。\n\n# 悬疑电影\n\n**盗梦空间**\n\n* 豆瓣地址：https://movie.douban.com/subject/3541415/\n\n观后感：\n\n* 愿我们每一个人都能够分清现实与梦境，愿我们扎根现实，走好自己的每一步，度过属于自己的一生。\n\n**搏击俱乐部**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292000/\n\n观后感：\n\n* 最好的人格分裂电影！\n\n**禁闭岛**\n\n* 豆瓣地址：https://movie.douban.com/subject/2334904/\n\n观后感：\n\n* 一部让我回味了很久的电影，充满逻辑，又布满悬念。\n\n**神探**\n\n* 豆瓣地址：https://movie.douban.com/subject/2027938/\n\n观后感：\n\n* 我个人认为最好的国产悬疑电影，最后的换枪情节，奠定了此片神作的地位！\n\n# 恐怖电影\n\n**回魂夜**\n\n* 豆瓣地址：https://movie.douban.com/subject/1299765/\n\n观后感：\n\n* 恐怖+喜剧的结合，想象力与无厘头的极致，周星驰最被低估的一部电影！\n\n**倩女幽魂**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297447/\n\n观后感：\n\n* 此后人们心目中所有善良的女鬼都叫小倩！\n\n# 战争电影\n\n**美丽人生**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292063/\n\n我喜欢的台词：\n\n* 没有谁的人生是完美的，但生命的每一刻都是美丽的。\n\n**拯救大兵瑞恩**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292849/\n\n观后感：\n\n* 我个人认为最好看最真实的战争片，这部电影每个细节都很值得注意。\n\n**勇敢的心**\n\n* 豆瓣地址：https://movie.douban.com/subject/1294639\n\n观后感：\n\n* 这部影片从史实角度看完全不及格，但从史诗角度看绝对堪称经典。\n\n# 传记电影\n\n**美丽心灵**\n\n* 豆瓣地址：https://movie.douban.com/subject/1306029/\n\n我喜欢的台词：\n\n* 没有什么事情是肯定的，这也是唯一我能肯定的事情。\n* 我需要相信奇迹是可能的。\n\n**模仿游戏**\n\n* 豆瓣地址：https://movie.douban.com/subject/10463953/\n\n观后感：\n\n* 阿兰·图灵的陨落，对于一个民族、国家，乃至世界都是一种损失，更可悲的是这种损失完全可以避免，却因为人们的偏见让这位英雄含恨而终。\n\n# 犯罪电影\n\n**无间道**\n\n* 豆瓣地址：https://movie.douban.com/subject/1307914/\n\n观后感：\n\n* 影片着力于人物内心的刻画，给人很强的代入感，最后又给观众一个意料之外，情理之中的结局。\n\n**杀人回忆**\n\n* 豆瓣地址：https://movie.douban.com/subject/1300299/\n\n观后感：\n\n* 现实中不了了之的案子实在太多，可电影中几乎很少看到。\n\n**猫鼠游戏**\n\n* 豆瓣地址：https://movie.douban.com/subject/1305487/\n\n观后感：\n\n* 每个人内心都存有一份善良，希望法律森严的外表下留有一份人道主义。\n\n**无人区**\n\n* 豆瓣地址：https://movie.douban.com/\n\n观后感：\n\n* 我个人认为最好的犯罪公路电影，没有之一。\n\n**这个杀手不太冷**\n\n* 豆瓣地址：https://movie.douban.com/subject/1295644/\n\n我喜欢的台词：\n\n* 人生总是如此艰难，还是只有童年如此？总是如此！\n* 事情总是这样的 ，只有当你真正感受到对死亡的恐惧，你才会学到要珍惜生命 。\n\n**烈日灼心**\n\n* 豆瓣地址：https://movie.douban.com/subject/24719063/\n\n观后感：\n\n* 这部电影故事不算吸引人，不过演员演技都很不错，很多细节把握很好。\n\n**英雄本色**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297574/\n\n我喜欢的台词：\n\n* 我等了三年，就是要等一个机会，我要争一口气，不是想证明我了不起；我是要告诉人家，我失去的东西一定要拿回来！\n\n# 灾难电影\n\n**釜山行**\n\n* 豆瓣地址：https://movie.douban.com/subject/25986180/\n\n观后感：\n\n* 一部结合亲情、爱情、友情的电影，给丧尸类电影赋予更好地生命。","source":"movie/index.md","raw":"---\ntitle: 电影推荐\ndate: 2020-12-03 11:29:32\n---\n\n推荐100部我认为的好电影，拯救你的片荒，持续更新！\n\n# 动画电影\n\n**千与千寻**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291561/\n\n我喜欢的台词：\n\n* 曾经发生过的事情不可能忘记，只不过是想不起而已。\n\n**寻梦环游记**\n\n* 豆瓣地址：https://movie.douban.com/subject/20495023/\n\n我喜欢的台词：\n\n* 死亡不是生命的终点，遗忘才是。\n* 我受够了征求同意，我不要循规蹈矩，我要跟随自己的心。\n* 坚持梦想，努力把他变成现实。\n\n**怪兽大学**\n\n* 豆瓣地址：https://movie.douban.com/subject/3789848/\n\n我喜欢的台词：\n\n* 你一点也不可怕，但是你无所畏惧。\n\n**怪兽电力公司**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291579/\n\n我喜欢的台词：\n\n* 不要给它起名字，起了名字就有感情了。\n\n观后感：\n\n* 有很多很搞笑或感人的细节，很值得一看的卡通片。\n\n**飞屋环游记**\n\n* 豆瓣地址：https://movie.douban.com/subject/2129039/\n\n我喜欢的台词：\n\n* 为什么我总是记得那些无聊的小事情。可是就是这些小事情，才是我最怀念的。\n\n**疯狂动物城**\n\n* 豆瓣地址：https://movie.douban.com/subject/25662329/\n\n我喜欢的台词：\n\n* 天性如何并不重要，重要的是你开始改变。\n\n**机器人总动员**\n\n* 豆瓣地址：https://movie.douban.com/subject/2131459/\n\n我喜欢的台词：\n\n* 我不要只是生存，我要活得有意义。\n\n**神偷奶爸**\n\n* 豆瓣地址：https://movie.douban.com/subject/3287562/\n\n观后感：\n\n* 一部充满童真的电影。\n\n**超能陆战队**\n\n* 豆瓣地址：https://movie.douban.com/subject/11026735/\n\n观后感：\n\n* 世界上唯一比给予生命更美好的，就是让生命充满爱。\n\n**名侦探柯南：贝克街的亡灵**\n\n* 豆瓣地址：https://movie.douban.com/subject/2286642/\n\n观后感：\n\n* 我个人认为是柯南剧场版中最经典的一部！\n\n# 动作电影\n\n**功夫**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291543/\n\n我喜欢的台词：\n\n* 其实我只是想打死两位，又或者被两位打死。\n* 一曲肝肠断，天涯何处匿知音。\n* 一个傻子一个哑巴，死一边去吧。\n* 还有谁！\n* 天下武功，无坚不破，唯快不破。\n* 记忆是痛苦的根源，你能不记得算是一种福气了。\n\n**精武英雄**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292895/\n\n观后感：\n\n* 史上最佳纯武打片。\n* 两部个人心目中最好的功夫电影之一，另一部是周星驰的《功夫》。\n\n**武状元苏乞儿**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297863/\n\n观后感：\n\n* 抄家的那段戏，为了表现被抄家心情落寞的镜头，周星驰躺在了大烟床上唱起了歌，没哭没闹没上吊却将落寞表现的淋漓尽致，这演技令人佩服，我个人认为周星驰不仅仅是一个喜剧大师，也是一个真正的好演员。\n* 这部电影的背景音乐，一响起来也让人热血沸腾！\n\n**少林足球**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297747/\n\n我喜欢的台词：\n\n* 做人如果没梦想，那跟咸鱼有什么分别？\n* 你是用两只脚踢球的对不对？\n* 话不能这么讲，我心中的一团火是不会熄地。\n* 靓女又怎么样，我是读书人。\n* 少林功夫加唱歌跳舞你说有没有搞头？\n* 从他们整齐的制服，友善的眼神，我完全可以感受到那份诚意，和体育精神。\n* 你快点回火星吧，地球是很危险的！\n* 除了唱歌，我想不到其它的方法来表达内心地兴奋和对你的仰慕。\n\n**功夫熊猫**\n\n* 豆瓣地址：https://movie.douban.com/subject/1783457/\n\n我喜欢的台词：\n\n* 俗语说，昨天已经过去，明天一切未知，但今天是上帝赐给我们的礼物。\n\n# 喜剧电影\n\n**喜剧之王**\n\n* 豆瓣地址：https://movie.douban.com/subject/1302425/\n\n我喜欢的台词：\n\n* 喂，前面漆黑一片，什么都看不到。不会，天亮之后，就会很美。\n* 我养你啊！\n* 努力，奋斗！\n\n**让子弹飞**\n\n* 豆瓣地址：https://movie.douban.com/subject/3742360/\n\n我喜欢的台词：\n\n* 让子弹飞一会儿！\n* 他要是体面，你就让他体面，他要是不体面，你就帮他体面。\n* 如果你活着，早晚都会死，如果你死了，你就永远活着。\n* 你和钱对我都不重要，没有你对我很重要。\n* 黄四郎：师爷高！县长硬！师爷、张麻子：黄老爷又高又硬！\n\n**九品芝麻官**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297518/\n\n观后感：\n\n* 经典段子密集，建议全文背诵！\n\n**唐伯虎点秋香**\n\n* 豆瓣地址：https://movie.douban.com/subject/1306249/\n\n观后感：\n\n* 看一次笑崩一次，特别推荐不开心的时候看看！\n\n**疯狂的石头**\n\n* 豆瓣地址：https://movie.douban.com/subject/1862151/\n\n观后感：\n\n* 黑色幽默的经典之作，环环相扣的叙事手法，加上荒诞而又严谨的故事情节。\n\n**鬼子来了**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291858/\n\n观后感：\n\n* 姜文，中国最有想法的导演！\n\n# 爱情电影\n\n**大话西游之大圣娶亲**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292213/\n\n我喜欢的台词：\n\n* 曾经有一分真诚的爱情放在我面前，我没有珍惜..........\n* 爱一个人需要理由吗？需要吗？不需要吗？需要吗？\n* 原来那个女孩子在我心里留下了一滴眼泪，我完全可以感受到当时她是多么的伤心。\n* 那个人好像一条狗啊。\n\n**泰坦尼克号**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292722/\n\n我喜欢的台词：\n\n* You Jump，I Jump！\n* 当你一无所有，你没有什么可以失去。\n\n**那些年，我们一起追的女孩**\n\n* 豆瓣地址：https://movie.douban.com/subject/4920528/\n\n观后感：\n\n* 沒有遗憾的青春是不完整的。\n\n# 励志电影\n\n**三傻大闹宝莱坞**\n\n* 豆瓣地址：https://movie.douban.com/subject/3793023/\n\n我喜欢的台词：\n\n* All Is Well（一切皆好）！\n* 追求卓越，成功就会出其不意的找上门。\n* 总是担心明天，又怎能把握好今天。\n\n**阿甘正传**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292720/\n\n我喜欢的台词：\n\n* 生活就像一盒巧克力，你永远不知道下一块是什么味道。\n* 奇迹每天都在发生。\n* 你只有忘记以往的事情，才能够继续前进。\n\n**当幸福来敲门**\n\n* 豆瓣地址：https://movie.douban.com/subject/1849031/\n\n我喜欢的台词：\n\n* 机会总是留给有准备的人，但那往往是努力的人剩下来的。\n* 当你最认为困难的时候，其实就是你最接近成功的时候。\n* 别让别人告诉你你成不了才，即使是我也不行。\n* 那些一事无成的人总是告诉你，你也成不了大器。\n\n**摔跤吧！爸爸**\n\n* 豆瓣地址：https://movie.douban.com/subject/26387939/\n\n我喜欢的台词：\n\n* 永远不要忘记，你是如何走到这一步。\n\n**百万美元宝贝**\n\n* 豆瓣地址：https://movie.douban.com/subject/1309016/\n\n观后感：\n\n* 电影说的是两三个小时的悲剧，其中有太多的泪点，看到的是小人物身上为梦想的奋斗，为梦想的死亡。\n\n# 科幻电影\n\n**回到未来**\n\n* 豆瓣地址：https://movie.douban.com/subject/1300555/\n\n我喜欢的台词：\n\n* 路？我们要去的地方不需要路。\n* 每一个人的未来全靠自己去奋斗，这才能创造出一个美好的未来。\n\n**钢铁侠**\n\n* 豆瓣地址：https://movie.douban.com/subject/1432146/\n\n观后感：\n\n* 开创漫威宇宙的电影，这部电影拯救了漫威！\n\n**黑客帝国**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291843/\n\n观后感：\n\n* 很经典的科幻类型电影，既被片中震撼的打斗特效镜头所折服，又被其中蕴含的哲学思想所吸引。\n\n**阿凡达**\n\n* 豆瓣地址：https://movie.douban.com/subject/1652587/\n\n观后感：\n\n* 电影隐喻了希望人类既拥有现代的科技头脑，又拥有古人的信仰灵魂。\n\n**头号玩家**\n\n* 豆瓣地址：https://movie.douban.com/subject/4920389/\n\n我喜欢的台词：\n\n* 一个人有朋友就不算失败。\n* 是甘于现实，还是征战未来？\n* 不管你喜不喜欢，该往前的不会后退。\n* 只有生活，才是唯一真实的东西。\n\n**复仇者联盟4：终局之战**\n\n* 豆瓣地址：https://movie.douban.com/subject/26100958/\n\n观后感：\n\n* 作为系列的最终篇，确实已经努力做到最好了，有笑点、有泪点、也有燃点。\n\n# 剧情电影\n\n**我不是药神**\n\n* 豆瓣地址：https://movie.douban.com/subject/26752088/\n\n我喜欢的台词：\n\n* 我卖药这么多年，发现这世上只有一种病，穷病，这种病你没法治，你也治不过来。\n* 命就是钱！\n\n**熔炉**\n\n* 豆瓣地址：https://movie.douban.com/subject/5912992/\n\n观后感：\n\n* 这部电影可以说是有史以来最让我震撼的一部巨作，尤其是一想到此片还是以真实事件改编的，就更加让我感到痛心疾首。\n\n**素媛**\n\n* 豆瓣地址：https://movie.douban.com/subject/21937452/\n\n观后感：\n\n* 和《熔炉》不同，这部电影有温暖的部分，自然而然地带动观者情绪。\n\n**82年生的金智英**\n\n* 豆瓣地址：https://movie.douban.com/subject/30327842/\n\n观后感：\n\n* 成年后的女性生活看似由无数无关紧要的事所组成，实则每件小事都可能成为压垮骆驼的最后一根稻草。\n\n**无名之辈**\n\n* 豆瓣地址：https://movie.douban.com/subject/27110296/\n\n观后感：\n\n* 从对方最不堪的痛苦开始，才能触碰到彼此灵魂最深的爱。\n* 一个人对生活绝望，不是因为病痛和折磨，而是觉得没了尊严和爱。\n\n**驴得水**\n\n* 豆瓣地址：https://movie.douban.com/subject/25921812\n\n观后感：\n\n* 开心麻花出品的最好的电影。\n\n**贫民窟的百万富翁**\n\n* 豆瓣地址：https://movie.douban.com/subject/2209573/\n\n观后感：\n\n* 非常现实主义的剧情，最后有一个浪漫主义的结局。\n\n**低俗小说**\n\n* 豆瓣地址：https://movie.douban.com/subject/1291832/\n\n观后感：\n\n* 结构上的巧妙和深意，特别精彩。\n\n# 悬疑电影\n\n**盗梦空间**\n\n* 豆瓣地址：https://movie.douban.com/subject/3541415/\n\n观后感：\n\n* 愿我们每一个人都能够分清现实与梦境，愿我们扎根现实，走好自己的每一步，度过属于自己的一生。\n\n**搏击俱乐部**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292000/\n\n观后感：\n\n* 最好的人格分裂电影！\n\n**禁闭岛**\n\n* 豆瓣地址：https://movie.douban.com/subject/2334904/\n\n观后感：\n\n* 一部让我回味了很久的电影，充满逻辑，又布满悬念。\n\n**神探**\n\n* 豆瓣地址：https://movie.douban.com/subject/2027938/\n\n观后感：\n\n* 我个人认为最好的国产悬疑电影，最后的换枪情节，奠定了此片神作的地位！\n\n# 恐怖电影\n\n**回魂夜**\n\n* 豆瓣地址：https://movie.douban.com/subject/1299765/\n\n观后感：\n\n* 恐怖+喜剧的结合，想象力与无厘头的极致，周星驰最被低估的一部电影！\n\n**倩女幽魂**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297447/\n\n观后感：\n\n* 此后人们心目中所有善良的女鬼都叫小倩！\n\n# 战争电影\n\n**美丽人生**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292063/\n\n我喜欢的台词：\n\n* 没有谁的人生是完美的，但生命的每一刻都是美丽的。\n\n**拯救大兵瑞恩**\n\n* 豆瓣地址：https://movie.douban.com/subject/1292849/\n\n观后感：\n\n* 我个人认为最好看最真实的战争片，这部电影每个细节都很值得注意。\n\n**勇敢的心**\n\n* 豆瓣地址：https://movie.douban.com/subject/1294639\n\n观后感：\n\n* 这部影片从史实角度看完全不及格，但从史诗角度看绝对堪称经典。\n\n# 传记电影\n\n**美丽心灵**\n\n* 豆瓣地址：https://movie.douban.com/subject/1306029/\n\n我喜欢的台词：\n\n* 没有什么事情是肯定的，这也是唯一我能肯定的事情。\n* 我需要相信奇迹是可能的。\n\n**模仿游戏**\n\n* 豆瓣地址：https://movie.douban.com/subject/10463953/\n\n观后感：\n\n* 阿兰·图灵的陨落，对于一个民族、国家，乃至世界都是一种损失，更可悲的是这种损失完全可以避免，却因为人们的偏见让这位英雄含恨而终。\n\n# 犯罪电影\n\n**无间道**\n\n* 豆瓣地址：https://movie.douban.com/subject/1307914/\n\n观后感：\n\n* 影片着力于人物内心的刻画，给人很强的代入感，最后又给观众一个意料之外，情理之中的结局。\n\n**杀人回忆**\n\n* 豆瓣地址：https://movie.douban.com/subject/1300299/\n\n观后感：\n\n* 现实中不了了之的案子实在太多，可电影中几乎很少看到。\n\n**猫鼠游戏**\n\n* 豆瓣地址：https://movie.douban.com/subject/1305487/\n\n观后感：\n\n* 每个人内心都存有一份善良，希望法律森严的外表下留有一份人道主义。\n\n**无人区**\n\n* 豆瓣地址：https://movie.douban.com/\n\n观后感：\n\n* 我个人认为最好的犯罪公路电影，没有之一。\n\n**这个杀手不太冷**\n\n* 豆瓣地址：https://movie.douban.com/subject/1295644/\n\n我喜欢的台词：\n\n* 人生总是如此艰难，还是只有童年如此？总是如此！\n* 事情总是这样的 ，只有当你真正感受到对死亡的恐惧，你才会学到要珍惜生命 。\n\n**烈日灼心**\n\n* 豆瓣地址：https://movie.douban.com/subject/24719063/\n\n观后感：\n\n* 这部电影故事不算吸引人，不过演员演技都很不错，很多细节把握很好。\n\n**英雄本色**\n\n* 豆瓣地址：https://movie.douban.com/subject/1297574/\n\n我喜欢的台词：\n\n* 我等了三年，就是要等一个机会，我要争一口气，不是想证明我了不起；我是要告诉人家，我失去的东西一定要拿回来！\n\n# 灾难电影\n\n**釜山行**\n\n* 豆瓣地址：https://movie.douban.com/subject/25986180/\n\n观后感：\n\n* 一部结合亲情、爱情、友情的电影，给丧尸类电影赋予更好地生命。","updated":"2022-03-16T01:16:00.494Z","path":"movie/index.html","comments":1,"layout":"page","_id":"cl0trzwdx0007fhji22903zv2","content":"<p>推荐100部我认为的好电影，拯救你的片荒，持续更新！</p>\n<h1 id=\"动画电影\"><a href=\"#动画电影\" class=\"headerlink\" title=\"动画电影\"></a>动画电影</h1><p><strong>千与千寻</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291561/\">https://movie.douban.com/subject/1291561/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>曾经发生过的事情不可能忘记，只不过是想不起而已。</li>\n</ul>\n<p><strong>寻梦环游记</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/20495023/\">https://movie.douban.com/subject/20495023/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>死亡不是生命的终点，遗忘才是。</li>\n<li>我受够了征求同意，我不要循规蹈矩，我要跟随自己的心。</li>\n<li>坚持梦想，努力把他变成现实。</li>\n</ul>\n<p><strong>怪兽大学</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3789848/\">https://movie.douban.com/subject/3789848/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>你一点也不可怕，但是你无所畏惧。</li>\n</ul>\n<p><strong>怪兽电力公司</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291579/\">https://movie.douban.com/subject/1291579/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>不要给它起名字，起了名字就有感情了。</li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>有很多很搞笑或感人的细节，很值得一看的卡通片。</li>\n</ul>\n<p><strong>飞屋环游记</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2129039/\">https://movie.douban.com/subject/2129039/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>为什么我总是记得那些无聊的小事情。可是就是这些小事情，才是我最怀念的。</li>\n</ul>\n<p><strong>疯狂动物城</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/25662329/\">https://movie.douban.com/subject/25662329/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>天性如何并不重要，重要的是你开始改变。</li>\n</ul>\n<p><strong>机器人总动员</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2131459/\">https://movie.douban.com/subject/2131459/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>我不要只是生存，我要活得有意义。</li>\n</ul>\n<p><strong>神偷奶爸</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3287562/\">https://movie.douban.com/subject/3287562/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>一部充满童真的电影。</li>\n</ul>\n<p><strong>超能陆战队</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/11026735/\">https://movie.douban.com/subject/11026735/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>世界上唯一比给予生命更美好的，就是让生命充满爱。</li>\n</ul>\n<p><strong>名侦探柯南：贝克街的亡灵</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2286642/\">https://movie.douban.com/subject/2286642/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为是柯南剧场版中最经典的一部！</li>\n</ul>\n<h1 id=\"动作电影\"><a href=\"#动作电影\" class=\"headerlink\" title=\"动作电影\"></a>动作电影</h1><p><strong>功夫</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291543/\">https://movie.douban.com/subject/1291543/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>其实我只是想打死两位，又或者被两位打死。</li>\n<li>一曲肝肠断，天涯何处匿知音。</li>\n<li>一个傻子一个哑巴，死一边去吧。</li>\n<li>还有谁！</li>\n<li>天下武功，无坚不破，唯快不破。</li>\n<li>记忆是痛苦的根源，你能不记得算是一种福气了。</li>\n</ul>\n<p><strong>精武英雄</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292895/\">https://movie.douban.com/subject/1292895/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>史上最佳纯武打片。</li>\n<li>两部个人心目中最好的功夫电影之一，另一部是周星驰的《功夫》。</li>\n</ul>\n<p><strong>武状元苏乞儿</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297863/\">https://movie.douban.com/subject/1297863/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>抄家的那段戏，为了表现被抄家心情落寞的镜头，周星驰躺在了大烟床上唱起了歌，没哭没闹没上吊却将落寞表现的淋漓尽致，这演技令人佩服，我个人认为周星驰不仅仅是一个喜剧大师，也是一个真正的好演员。</li>\n<li>这部电影的背景音乐，一响起来也让人热血沸腾！</li>\n</ul>\n<p><strong>少林足球</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297747/\">https://movie.douban.com/subject/1297747/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>做人如果没梦想，那跟咸鱼有什么分别？</li>\n<li>你是用两只脚踢球的对不对？</li>\n<li>话不能这么讲，我心中的一团火是不会熄地。</li>\n<li>靓女又怎么样，我是读书人。</li>\n<li>少林功夫加唱歌跳舞你说有没有搞头？</li>\n<li>从他们整齐的制服，友善的眼神，我完全可以感受到那份诚意，和体育精神。</li>\n<li>你快点回火星吧，地球是很危险的！</li>\n<li>除了唱歌，我想不到其它的方法来表达内心地兴奋和对你的仰慕。</li>\n</ul>\n<p><strong>功夫熊猫</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1783457/\">https://movie.douban.com/subject/1783457/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>俗语说，昨天已经过去，明天一切未知，但今天是上帝赐给我们的礼物。</li>\n</ul>\n<h1 id=\"喜剧电影\"><a href=\"#喜剧电影\" class=\"headerlink\" title=\"喜剧电影\"></a>喜剧电影</h1><p><strong>喜剧之王</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1302425/\">https://movie.douban.com/subject/1302425/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>喂，前面漆黑一片，什么都看不到。不会，天亮之后，就会很美。</li>\n<li>我养你啊！</li>\n<li>努力，奋斗！</li>\n</ul>\n<p><strong>让子弹飞</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3742360/\">https://movie.douban.com/subject/3742360/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>让子弹飞一会儿！</li>\n<li>他要是体面，你就让他体面，他要是不体面，你就帮他体面。</li>\n<li>如果你活着，早晚都会死，如果你死了，你就永远活着。</li>\n<li>你和钱对我都不重要，没有你对我很重要。</li>\n<li>黄四郎：师爷高！县长硬！师爷、张麻子：黄老爷又高又硬！</li>\n</ul>\n<p><strong>九品芝麻官</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297518/\">https://movie.douban.com/subject/1297518/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>经典段子密集，建议全文背诵！</li>\n</ul>\n<p><strong>唐伯虎点秋香</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1306249/\">https://movie.douban.com/subject/1306249/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>看一次笑崩一次，特别推荐不开心的时候看看！</li>\n</ul>\n<p><strong>疯狂的石头</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1862151/\">https://movie.douban.com/subject/1862151/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>黑色幽默的经典之作，环环相扣的叙事手法，加上荒诞而又严谨的故事情节。</li>\n</ul>\n<p><strong>鬼子来了</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291858/\">https://movie.douban.com/subject/1291858/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>姜文，中国最有想法的导演！</li>\n</ul>\n<h1 id=\"爱情电影\"><a href=\"#爱情电影\" class=\"headerlink\" title=\"爱情电影\"></a>爱情电影</h1><p><strong>大话西游之大圣娶亲</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292213/\">https://movie.douban.com/subject/1292213/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>曾经有一分真诚的爱情放在我面前，我没有珍惜……….</li>\n<li>爱一个人需要理由吗？需要吗？不需要吗？需要吗？</li>\n<li>原来那个女孩子在我心里留下了一滴眼泪，我完全可以感受到当时她是多么的伤心。</li>\n<li>那个人好像一条狗啊。</li>\n</ul>\n<p><strong>泰坦尼克号</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292722/\">https://movie.douban.com/subject/1292722/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>You Jump，I Jump！</li>\n<li>当你一无所有，你没有什么可以失去。</li>\n</ul>\n<p><strong>那些年，我们一起追的女孩</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/4920528/\">https://movie.douban.com/subject/4920528/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>沒有遗憾的青春是不完整的。</li>\n</ul>\n<h1 id=\"励志电影\"><a href=\"#励志电影\" class=\"headerlink\" title=\"励志电影\"></a>励志电影</h1><p><strong>三傻大闹宝莱坞</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3793023/\">https://movie.douban.com/subject/3793023/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>All Is Well（一切皆好）！</li>\n<li>追求卓越，成功就会出其不意的找上门。</li>\n<li>总是担心明天，又怎能把握好今天。</li>\n</ul>\n<p><strong>阿甘正传</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292720/\">https://movie.douban.com/subject/1292720/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>生活就像一盒巧克力，你永远不知道下一块是什么味道。</li>\n<li>奇迹每天都在发生。</li>\n<li>你只有忘记以往的事情，才能够继续前进。</li>\n</ul>\n<p><strong>当幸福来敲门</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1849031/\">https://movie.douban.com/subject/1849031/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>机会总是留给有准备的人，但那往往是努力的人剩下来的。</li>\n<li>当你最认为困难的时候，其实就是你最接近成功的时候。</li>\n<li>别让别人告诉你你成不了才，即使是我也不行。</li>\n<li>那些一事无成的人总是告诉你，你也成不了大器。</li>\n</ul>\n<p><strong>摔跤吧！爸爸</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/26387939/\">https://movie.douban.com/subject/26387939/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>永远不要忘记，你是如何走到这一步。</li>\n</ul>\n<p><strong>百万美元宝贝</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1309016/\">https://movie.douban.com/subject/1309016/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>电影说的是两三个小时的悲剧，其中有太多的泪点，看到的是小人物身上为梦想的奋斗，为梦想的死亡。</li>\n</ul>\n<h1 id=\"科幻电影\"><a href=\"#科幻电影\" class=\"headerlink\" title=\"科幻电影\"></a>科幻电影</h1><p><strong>回到未来</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1300555/\">https://movie.douban.com/subject/1300555/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>路？我们要去的地方不需要路。</li>\n<li>每一个人的未来全靠自己去奋斗，这才能创造出一个美好的未来。</li>\n</ul>\n<p><strong>钢铁侠</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1432146/\">https://movie.douban.com/subject/1432146/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>开创漫威宇宙的电影，这部电影拯救了漫威！</li>\n</ul>\n<p><strong>黑客帝国</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291843/\">https://movie.douban.com/subject/1291843/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>很经典的科幻类型电影，既被片中震撼的打斗特效镜头所折服，又被其中蕴含的哲学思想所吸引。</li>\n</ul>\n<p><strong>阿凡达</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1652587/\">https://movie.douban.com/subject/1652587/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>电影隐喻了希望人类既拥有现代的科技头脑，又拥有古人的信仰灵魂。</li>\n</ul>\n<p><strong>头号玩家</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/4920389/\">https://movie.douban.com/subject/4920389/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>一个人有朋友就不算失败。</li>\n<li>是甘于现实，还是征战未来？</li>\n<li>不管你喜不喜欢，该往前的不会后退。</li>\n<li>只有生活，才是唯一真实的东西。</li>\n</ul>\n<p><strong>复仇者联盟4：终局之战</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/26100958/\">https://movie.douban.com/subject/26100958/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>作为系列的最终篇，确实已经努力做到最好了，有笑点、有泪点、也有燃点。</li>\n</ul>\n<h1 id=\"剧情电影\"><a href=\"#剧情电影\" class=\"headerlink\" title=\"剧情电影\"></a>剧情电影</h1><p><strong>我不是药神</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/26752088/\">https://movie.douban.com/subject/26752088/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>我卖药这么多年，发现这世上只有一种病，穷病，这种病你没法治，你也治不过来。</li>\n<li>命就是钱！</li>\n</ul>\n<p><strong>熔炉</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/5912992/\">https://movie.douban.com/subject/5912992/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>这部电影可以说是有史以来最让我震撼的一部巨作，尤其是一想到此片还是以真实事件改编的，就更加让我感到痛心疾首。</li>\n</ul>\n<p><strong>素媛</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/21937452/\">https://movie.douban.com/subject/21937452/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>和《熔炉》不同，这部电影有温暖的部分，自然而然地带动观者情绪。</li>\n</ul>\n<p><strong>82年生的金智英</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/30327842/\">https://movie.douban.com/subject/30327842/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>成年后的女性生活看似由无数无关紧要的事所组成，实则每件小事都可能成为压垮骆驼的最后一根稻草。</li>\n</ul>\n<p><strong>无名之辈</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/27110296/\">https://movie.douban.com/subject/27110296/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>从对方最不堪的痛苦开始，才能触碰到彼此灵魂最深的爱。</li>\n<li>一个人对生活绝望，不是因为病痛和折磨，而是觉得没了尊严和爱。</li>\n</ul>\n<p><strong>驴得水</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/25921812\">https://movie.douban.com/subject/25921812</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>开心麻花出品的最好的电影。</li>\n</ul>\n<p><strong>贫民窟的百万富翁</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2209573/\">https://movie.douban.com/subject/2209573/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>非常现实主义的剧情，最后有一个浪漫主义的结局。</li>\n</ul>\n<p><strong>低俗小说</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291832/\">https://movie.douban.com/subject/1291832/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>结构上的巧妙和深意，特别精彩。</li>\n</ul>\n<h1 id=\"悬疑电影\"><a href=\"#悬疑电影\" class=\"headerlink\" title=\"悬疑电影\"></a>悬疑电影</h1><p><strong>盗梦空间</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3541415/\">https://movie.douban.com/subject/3541415/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>愿我们每一个人都能够分清现实与梦境，愿我们扎根现实，走好自己的每一步，度过属于自己的一生。</li>\n</ul>\n<p><strong>搏击俱乐部</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292000/\">https://movie.douban.com/subject/1292000/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>最好的人格分裂电影！</li>\n</ul>\n<p><strong>禁闭岛</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2334904/\">https://movie.douban.com/subject/2334904/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>一部让我回味了很久的电影，充满逻辑，又布满悬念。</li>\n</ul>\n<p><strong>神探</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2027938/\">https://movie.douban.com/subject/2027938/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为最好的国产悬疑电影，最后的换枪情节，奠定了此片神作的地位！</li>\n</ul>\n<h1 id=\"恐怖电影\"><a href=\"#恐怖电影\" class=\"headerlink\" title=\"恐怖电影\"></a>恐怖电影</h1><p><strong>回魂夜</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1299765/\">https://movie.douban.com/subject/1299765/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>恐怖+喜剧的结合，想象力与无厘头的极致，周星驰最被低估的一部电影！</li>\n</ul>\n<p><strong>倩女幽魂</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297447/\">https://movie.douban.com/subject/1297447/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>此后人们心目中所有善良的女鬼都叫小倩！</li>\n</ul>\n<h1 id=\"战争电影\"><a href=\"#战争电影\" class=\"headerlink\" title=\"战争电影\"></a>战争电影</h1><p><strong>美丽人生</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292063/\">https://movie.douban.com/subject/1292063/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>没有谁的人生是完美的，但生命的每一刻都是美丽的。</li>\n</ul>\n<p><strong>拯救大兵瑞恩</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292849/\">https://movie.douban.com/subject/1292849/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为最好看最真实的战争片，这部电影每个细节都很值得注意。</li>\n</ul>\n<p><strong>勇敢的心</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1294639\">https://movie.douban.com/subject/1294639</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>这部影片从史实角度看完全不及格，但从史诗角度看绝对堪称经典。</li>\n</ul>\n<h1 id=\"传记电影\"><a href=\"#传记电影\" class=\"headerlink\" title=\"传记电影\"></a>传记电影</h1><p><strong>美丽心灵</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1306029/\">https://movie.douban.com/subject/1306029/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>没有什么事情是肯定的，这也是唯一我能肯定的事情。</li>\n<li>我需要相信奇迹是可能的。</li>\n</ul>\n<p><strong>模仿游戏</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/10463953/\">https://movie.douban.com/subject/10463953/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>阿兰·图灵的陨落，对于一个民族、国家，乃至世界都是一种损失，更可悲的是这种损失完全可以避免，却因为人们的偏见让这位英雄含恨而终。</li>\n</ul>\n<h1 id=\"犯罪电影\"><a href=\"#犯罪电影\" class=\"headerlink\" title=\"犯罪电影\"></a>犯罪电影</h1><p><strong>无间道</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1307914/\">https://movie.douban.com/subject/1307914/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>影片着力于人物内心的刻画，给人很强的代入感，最后又给观众一个意料之外，情理之中的结局。</li>\n</ul>\n<p><strong>杀人回忆</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1300299/\">https://movie.douban.com/subject/1300299/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>现实中不了了之的案子实在太多，可电影中几乎很少看到。</li>\n</ul>\n<p><strong>猫鼠游戏</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1305487/\">https://movie.douban.com/subject/1305487/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>每个人内心都存有一份善良，希望法律森严的外表下留有一份人道主义。</li>\n</ul>\n<p><strong>无人区</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/\">https://movie.douban.com/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为最好的犯罪公路电影，没有之一。</li>\n</ul>\n<p><strong>这个杀手不太冷</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1295644/\">https://movie.douban.com/subject/1295644/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>人生总是如此艰难，还是只有童年如此？总是如此！</li>\n<li>事情总是这样的 ，只有当你真正感受到对死亡的恐惧，你才会学到要珍惜生命 。</li>\n</ul>\n<p><strong>烈日灼心</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/24719063/\">https://movie.douban.com/subject/24719063/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>这部电影故事不算吸引人，不过演员演技都很不错，很多细节把握很好。</li>\n</ul>\n<p><strong>英雄本色</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297574/\">https://movie.douban.com/subject/1297574/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>我等了三年，就是要等一个机会，我要争一口气，不是想证明我了不起；我是要告诉人家，我失去的东西一定要拿回来！</li>\n</ul>\n<h1 id=\"灾难电影\"><a href=\"#灾难电影\" class=\"headerlink\" title=\"灾难电影\"></a>灾难电影</h1><p><strong>釜山行</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/25986180/\">https://movie.douban.com/subject/25986180/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>一部结合亲情、爱情、友情的电影，给丧尸类电影赋予更好地生命。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>推荐100部我认为的好电影，拯救你的片荒，持续更新！</p>\n<h1 id=\"动画电影\"><a href=\"#动画电影\" class=\"headerlink\" title=\"动画电影\"></a>动画电影</h1><p><strong>千与千寻</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291561/\">https://movie.douban.com/subject/1291561/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>曾经发生过的事情不可能忘记，只不过是想不起而已。</li>\n</ul>\n<p><strong>寻梦环游记</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/20495023/\">https://movie.douban.com/subject/20495023/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>死亡不是生命的终点，遗忘才是。</li>\n<li>我受够了征求同意，我不要循规蹈矩，我要跟随自己的心。</li>\n<li>坚持梦想，努力把他变成现实。</li>\n</ul>\n<p><strong>怪兽大学</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3789848/\">https://movie.douban.com/subject/3789848/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>你一点也不可怕，但是你无所畏惧。</li>\n</ul>\n<p><strong>怪兽电力公司</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291579/\">https://movie.douban.com/subject/1291579/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>不要给它起名字，起了名字就有感情了。</li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>有很多很搞笑或感人的细节，很值得一看的卡通片。</li>\n</ul>\n<p><strong>飞屋环游记</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2129039/\">https://movie.douban.com/subject/2129039/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>为什么我总是记得那些无聊的小事情。可是就是这些小事情，才是我最怀念的。</li>\n</ul>\n<p><strong>疯狂动物城</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/25662329/\">https://movie.douban.com/subject/25662329/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>天性如何并不重要，重要的是你开始改变。</li>\n</ul>\n<p><strong>机器人总动员</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2131459/\">https://movie.douban.com/subject/2131459/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>我不要只是生存，我要活得有意义。</li>\n</ul>\n<p><strong>神偷奶爸</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3287562/\">https://movie.douban.com/subject/3287562/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>一部充满童真的电影。</li>\n</ul>\n<p><strong>超能陆战队</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/11026735/\">https://movie.douban.com/subject/11026735/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>世界上唯一比给予生命更美好的，就是让生命充满爱。</li>\n</ul>\n<p><strong>名侦探柯南：贝克街的亡灵</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2286642/\">https://movie.douban.com/subject/2286642/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为是柯南剧场版中最经典的一部！</li>\n</ul>\n<h1 id=\"动作电影\"><a href=\"#动作电影\" class=\"headerlink\" title=\"动作电影\"></a>动作电影</h1><p><strong>功夫</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291543/\">https://movie.douban.com/subject/1291543/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>其实我只是想打死两位，又或者被两位打死。</li>\n<li>一曲肝肠断，天涯何处匿知音。</li>\n<li>一个傻子一个哑巴，死一边去吧。</li>\n<li>还有谁！</li>\n<li>天下武功，无坚不破，唯快不破。</li>\n<li>记忆是痛苦的根源，你能不记得算是一种福气了。</li>\n</ul>\n<p><strong>精武英雄</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292895/\">https://movie.douban.com/subject/1292895/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>史上最佳纯武打片。</li>\n<li>两部个人心目中最好的功夫电影之一，另一部是周星驰的《功夫》。</li>\n</ul>\n<p><strong>武状元苏乞儿</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297863/\">https://movie.douban.com/subject/1297863/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>抄家的那段戏，为了表现被抄家心情落寞的镜头，周星驰躺在了大烟床上唱起了歌，没哭没闹没上吊却将落寞表现的淋漓尽致，这演技令人佩服，我个人认为周星驰不仅仅是一个喜剧大师，也是一个真正的好演员。</li>\n<li>这部电影的背景音乐，一响起来也让人热血沸腾！</li>\n</ul>\n<p><strong>少林足球</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297747/\">https://movie.douban.com/subject/1297747/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>做人如果没梦想，那跟咸鱼有什么分别？</li>\n<li>你是用两只脚踢球的对不对？</li>\n<li>话不能这么讲，我心中的一团火是不会熄地。</li>\n<li>靓女又怎么样，我是读书人。</li>\n<li>少林功夫加唱歌跳舞你说有没有搞头？</li>\n<li>从他们整齐的制服，友善的眼神，我完全可以感受到那份诚意，和体育精神。</li>\n<li>你快点回火星吧，地球是很危险的！</li>\n<li>除了唱歌，我想不到其它的方法来表达内心地兴奋和对你的仰慕。</li>\n</ul>\n<p><strong>功夫熊猫</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1783457/\">https://movie.douban.com/subject/1783457/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>俗语说，昨天已经过去，明天一切未知，但今天是上帝赐给我们的礼物。</li>\n</ul>\n<h1 id=\"喜剧电影\"><a href=\"#喜剧电影\" class=\"headerlink\" title=\"喜剧电影\"></a>喜剧电影</h1><p><strong>喜剧之王</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1302425/\">https://movie.douban.com/subject/1302425/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>喂，前面漆黑一片，什么都看不到。不会，天亮之后，就会很美。</li>\n<li>我养你啊！</li>\n<li>努力，奋斗！</li>\n</ul>\n<p><strong>让子弹飞</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3742360/\">https://movie.douban.com/subject/3742360/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>让子弹飞一会儿！</li>\n<li>他要是体面，你就让他体面，他要是不体面，你就帮他体面。</li>\n<li>如果你活着，早晚都会死，如果你死了，你就永远活着。</li>\n<li>你和钱对我都不重要，没有你对我很重要。</li>\n<li>黄四郎：师爷高！县长硬！师爷、张麻子：黄老爷又高又硬！</li>\n</ul>\n<p><strong>九品芝麻官</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297518/\">https://movie.douban.com/subject/1297518/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>经典段子密集，建议全文背诵！</li>\n</ul>\n<p><strong>唐伯虎点秋香</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1306249/\">https://movie.douban.com/subject/1306249/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>看一次笑崩一次，特别推荐不开心的时候看看！</li>\n</ul>\n<p><strong>疯狂的石头</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1862151/\">https://movie.douban.com/subject/1862151/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>黑色幽默的经典之作，环环相扣的叙事手法，加上荒诞而又严谨的故事情节。</li>\n</ul>\n<p><strong>鬼子来了</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291858/\">https://movie.douban.com/subject/1291858/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>姜文，中国最有想法的导演！</li>\n</ul>\n<h1 id=\"爱情电影\"><a href=\"#爱情电影\" class=\"headerlink\" title=\"爱情电影\"></a>爱情电影</h1><p><strong>大话西游之大圣娶亲</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292213/\">https://movie.douban.com/subject/1292213/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>曾经有一分真诚的爱情放在我面前，我没有珍惜……….</li>\n<li>爱一个人需要理由吗？需要吗？不需要吗？需要吗？</li>\n<li>原来那个女孩子在我心里留下了一滴眼泪，我完全可以感受到当时她是多么的伤心。</li>\n<li>那个人好像一条狗啊。</li>\n</ul>\n<p><strong>泰坦尼克号</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292722/\">https://movie.douban.com/subject/1292722/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>You Jump，I Jump！</li>\n<li>当你一无所有，你没有什么可以失去。</li>\n</ul>\n<p><strong>那些年，我们一起追的女孩</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/4920528/\">https://movie.douban.com/subject/4920528/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>沒有遗憾的青春是不完整的。</li>\n</ul>\n<h1 id=\"励志电影\"><a href=\"#励志电影\" class=\"headerlink\" title=\"励志电影\"></a>励志电影</h1><p><strong>三傻大闹宝莱坞</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3793023/\">https://movie.douban.com/subject/3793023/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>All Is Well（一切皆好）！</li>\n<li>追求卓越，成功就会出其不意的找上门。</li>\n<li>总是担心明天，又怎能把握好今天。</li>\n</ul>\n<p><strong>阿甘正传</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292720/\">https://movie.douban.com/subject/1292720/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>生活就像一盒巧克力，你永远不知道下一块是什么味道。</li>\n<li>奇迹每天都在发生。</li>\n<li>你只有忘记以往的事情，才能够继续前进。</li>\n</ul>\n<p><strong>当幸福来敲门</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1849031/\">https://movie.douban.com/subject/1849031/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>机会总是留给有准备的人，但那往往是努力的人剩下来的。</li>\n<li>当你最认为困难的时候，其实就是你最接近成功的时候。</li>\n<li>别让别人告诉你你成不了才，即使是我也不行。</li>\n<li>那些一事无成的人总是告诉你，你也成不了大器。</li>\n</ul>\n<p><strong>摔跤吧！爸爸</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/26387939/\">https://movie.douban.com/subject/26387939/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>永远不要忘记，你是如何走到这一步。</li>\n</ul>\n<p><strong>百万美元宝贝</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1309016/\">https://movie.douban.com/subject/1309016/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>电影说的是两三个小时的悲剧，其中有太多的泪点，看到的是小人物身上为梦想的奋斗，为梦想的死亡。</li>\n</ul>\n<h1 id=\"科幻电影\"><a href=\"#科幻电影\" class=\"headerlink\" title=\"科幻电影\"></a>科幻电影</h1><p><strong>回到未来</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1300555/\">https://movie.douban.com/subject/1300555/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>路？我们要去的地方不需要路。</li>\n<li>每一个人的未来全靠自己去奋斗，这才能创造出一个美好的未来。</li>\n</ul>\n<p><strong>钢铁侠</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1432146/\">https://movie.douban.com/subject/1432146/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>开创漫威宇宙的电影，这部电影拯救了漫威！</li>\n</ul>\n<p><strong>黑客帝国</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291843/\">https://movie.douban.com/subject/1291843/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>很经典的科幻类型电影，既被片中震撼的打斗特效镜头所折服，又被其中蕴含的哲学思想所吸引。</li>\n</ul>\n<p><strong>阿凡达</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1652587/\">https://movie.douban.com/subject/1652587/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>电影隐喻了希望人类既拥有现代的科技头脑，又拥有古人的信仰灵魂。</li>\n</ul>\n<p><strong>头号玩家</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/4920389/\">https://movie.douban.com/subject/4920389/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>一个人有朋友就不算失败。</li>\n<li>是甘于现实，还是征战未来？</li>\n<li>不管你喜不喜欢，该往前的不会后退。</li>\n<li>只有生活，才是唯一真实的东西。</li>\n</ul>\n<p><strong>复仇者联盟4：终局之战</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/26100958/\">https://movie.douban.com/subject/26100958/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>作为系列的最终篇，确实已经努力做到最好了，有笑点、有泪点、也有燃点。</li>\n</ul>\n<h1 id=\"剧情电影\"><a href=\"#剧情电影\" class=\"headerlink\" title=\"剧情电影\"></a>剧情电影</h1><p><strong>我不是药神</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/26752088/\">https://movie.douban.com/subject/26752088/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>我卖药这么多年，发现这世上只有一种病，穷病，这种病你没法治，你也治不过来。</li>\n<li>命就是钱！</li>\n</ul>\n<p><strong>熔炉</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/5912992/\">https://movie.douban.com/subject/5912992/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>这部电影可以说是有史以来最让我震撼的一部巨作，尤其是一想到此片还是以真实事件改编的，就更加让我感到痛心疾首。</li>\n</ul>\n<p><strong>素媛</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/21937452/\">https://movie.douban.com/subject/21937452/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>和《熔炉》不同，这部电影有温暖的部分，自然而然地带动观者情绪。</li>\n</ul>\n<p><strong>82年生的金智英</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/30327842/\">https://movie.douban.com/subject/30327842/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>成年后的女性生活看似由无数无关紧要的事所组成，实则每件小事都可能成为压垮骆驼的最后一根稻草。</li>\n</ul>\n<p><strong>无名之辈</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/27110296/\">https://movie.douban.com/subject/27110296/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>从对方最不堪的痛苦开始，才能触碰到彼此灵魂最深的爱。</li>\n<li>一个人对生活绝望，不是因为病痛和折磨，而是觉得没了尊严和爱。</li>\n</ul>\n<p><strong>驴得水</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/25921812\">https://movie.douban.com/subject/25921812</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>开心麻花出品的最好的电影。</li>\n</ul>\n<p><strong>贫民窟的百万富翁</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2209573/\">https://movie.douban.com/subject/2209573/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>非常现实主义的剧情，最后有一个浪漫主义的结局。</li>\n</ul>\n<p><strong>低俗小说</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1291832/\">https://movie.douban.com/subject/1291832/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>结构上的巧妙和深意，特别精彩。</li>\n</ul>\n<h1 id=\"悬疑电影\"><a href=\"#悬疑电影\" class=\"headerlink\" title=\"悬疑电影\"></a>悬疑电影</h1><p><strong>盗梦空间</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/3541415/\">https://movie.douban.com/subject/3541415/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>愿我们每一个人都能够分清现实与梦境，愿我们扎根现实，走好自己的每一步，度过属于自己的一生。</li>\n</ul>\n<p><strong>搏击俱乐部</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292000/\">https://movie.douban.com/subject/1292000/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>最好的人格分裂电影！</li>\n</ul>\n<p><strong>禁闭岛</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2334904/\">https://movie.douban.com/subject/2334904/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>一部让我回味了很久的电影，充满逻辑，又布满悬念。</li>\n</ul>\n<p><strong>神探</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/2027938/\">https://movie.douban.com/subject/2027938/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为最好的国产悬疑电影，最后的换枪情节，奠定了此片神作的地位！</li>\n</ul>\n<h1 id=\"恐怖电影\"><a href=\"#恐怖电影\" class=\"headerlink\" title=\"恐怖电影\"></a>恐怖电影</h1><p><strong>回魂夜</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1299765/\">https://movie.douban.com/subject/1299765/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>恐怖+喜剧的结合，想象力与无厘头的极致，周星驰最被低估的一部电影！</li>\n</ul>\n<p><strong>倩女幽魂</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297447/\">https://movie.douban.com/subject/1297447/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>此后人们心目中所有善良的女鬼都叫小倩！</li>\n</ul>\n<h1 id=\"战争电影\"><a href=\"#战争电影\" class=\"headerlink\" title=\"战争电影\"></a>战争电影</h1><p><strong>美丽人生</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292063/\">https://movie.douban.com/subject/1292063/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>没有谁的人生是完美的，但生命的每一刻都是美丽的。</li>\n</ul>\n<p><strong>拯救大兵瑞恩</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1292849/\">https://movie.douban.com/subject/1292849/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为最好看最真实的战争片，这部电影每个细节都很值得注意。</li>\n</ul>\n<p><strong>勇敢的心</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1294639\">https://movie.douban.com/subject/1294639</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>这部影片从史实角度看完全不及格，但从史诗角度看绝对堪称经典。</li>\n</ul>\n<h1 id=\"传记电影\"><a href=\"#传记电影\" class=\"headerlink\" title=\"传记电影\"></a>传记电影</h1><p><strong>美丽心灵</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1306029/\">https://movie.douban.com/subject/1306029/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>没有什么事情是肯定的，这也是唯一我能肯定的事情。</li>\n<li>我需要相信奇迹是可能的。</li>\n</ul>\n<p><strong>模仿游戏</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/10463953/\">https://movie.douban.com/subject/10463953/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>阿兰·图灵的陨落，对于一个民族、国家，乃至世界都是一种损失，更可悲的是这种损失完全可以避免，却因为人们的偏见让这位英雄含恨而终。</li>\n</ul>\n<h1 id=\"犯罪电影\"><a href=\"#犯罪电影\" class=\"headerlink\" title=\"犯罪电影\"></a>犯罪电影</h1><p><strong>无间道</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1307914/\">https://movie.douban.com/subject/1307914/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>影片着力于人物内心的刻画，给人很强的代入感，最后又给观众一个意料之外，情理之中的结局。</li>\n</ul>\n<p><strong>杀人回忆</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1300299/\">https://movie.douban.com/subject/1300299/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>现实中不了了之的案子实在太多，可电影中几乎很少看到。</li>\n</ul>\n<p><strong>猫鼠游戏</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1305487/\">https://movie.douban.com/subject/1305487/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>每个人内心都存有一份善良，希望法律森严的外表下留有一份人道主义。</li>\n</ul>\n<p><strong>无人区</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/\">https://movie.douban.com/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>我个人认为最好的犯罪公路电影，没有之一。</li>\n</ul>\n<p><strong>这个杀手不太冷</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1295644/\">https://movie.douban.com/subject/1295644/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>人生总是如此艰难，还是只有童年如此？总是如此！</li>\n<li>事情总是这样的 ，只有当你真正感受到对死亡的恐惧，你才会学到要珍惜生命 。</li>\n</ul>\n<p><strong>烈日灼心</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/24719063/\">https://movie.douban.com/subject/24719063/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>这部电影故事不算吸引人，不过演员演技都很不错，很多细节把握很好。</li>\n</ul>\n<p><strong>英雄本色</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/1297574/\">https://movie.douban.com/subject/1297574/</a></li>\n</ul>\n<p>我喜欢的台词：</p>\n<ul>\n<li>我等了三年，就是要等一个机会，我要争一口气，不是想证明我了不起；我是要告诉人家，我失去的东西一定要拿回来！</li>\n</ul>\n<h1 id=\"灾难电影\"><a href=\"#灾难电影\" class=\"headerlink\" title=\"灾难电影\"></a>灾难电影</h1><p><strong>釜山行</strong></p>\n<ul>\n<li>豆瓣地址：<a href=\"https://movie.douban.com/subject/25986180/\">https://movie.douban.com/subject/25986180/</a></li>\n</ul>\n<p>观后感：</p>\n<ul>\n<li>一部结合亲情、爱情、友情的电影，给丧尸类电影赋予更好地生命。</li>\n</ul>\n"},{"title":"内推","date":"2020-12-03T03:29:32.000Z","_content":"\n# 美团\n\n按照以下方式都可以进行美团的内推投递（投递后，有问题可以微信私聊我，确认是否内推成功）\n\n**PC端**\n\n进内推系统，登录美团招聘官网：https://campus.meituan.com/ ，填入文字内推码，「XIQBmzq」 ，即可完成内推！\n\n**手机端**\n\n方式一：用手机扫下面的二维码，进入内推系统；\n\n<img src=\"https://img-blog.csdnimg.cn/f5eba0407a7e459fb8195999c9dfd0b4.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/d2f7745d86b64c1aacab6d89dc93d755.png\" style=\"zoom:32%;\" />\n\n方式二：用手机点击此处链接，用手机浏览器进入内推系统：\n\nhttps://campus.meituan.com/bole/wechat?staffSsoId=5236707&appKey=hiring-campus-portal；\n\n> 进入美团的内推系统后，选择校招/社招类型  > 选择身份 > 选择意向岗位 > 点击立即申请 > 填写投递信息 > 点击确认申请 > 完善简历；\n\n","source":"neitui/index.md","raw":"---\ntitle: 内推\ndate: 2020-12-03 11:29:32\n---\n\n# 美团\n\n按照以下方式都可以进行美团的内推投递（投递后，有问题可以微信私聊我，确认是否内推成功）\n\n**PC端**\n\n进内推系统，登录美团招聘官网：https://campus.meituan.com/ ，填入文字内推码，「XIQBmzq」 ，即可完成内推！\n\n**手机端**\n\n方式一：用手机扫下面的二维码，进入内推系统；\n\n<img src=\"https://img-blog.csdnimg.cn/f5eba0407a7e459fb8195999c9dfd0b4.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/d2f7745d86b64c1aacab6d89dc93d755.png\" style=\"zoom:32%;\" />\n\n方式二：用手机点击此处链接，用手机浏览器进入内推系统：\n\nhttps://campus.meituan.com/bole/wechat?staffSsoId=5236707&appKey=hiring-campus-portal；\n\n> 进入美团的内推系统后，选择校招/社招类型  > 选择身份 > 选择意向岗位 > 点击立即申请 > 填写投递信息 > 点击确认申请 > 完善简历；\n\n","updated":"2021-12-11T19:53:36.007Z","path":"neitui/index.html","comments":1,"layout":"page","_id":"cl0trzwdy0009fhji79kdepj9","content":"<h1 id=\"美团\"><a href=\"#美团\" class=\"headerlink\" title=\"美团\"></a>美团</h1><p>按照以下方式都可以进行美团的内推投递（投递后，有问题可以微信私聊我，确认是否内推成功）</p>\n<p><strong>PC端</strong></p>\n<p>进内推系统，登录美团招聘官网：<a href=\"https://campus.meituan.com/\">https://campus.meituan.com/</a> ，填入文字内推码，「XIQBmzq」 ，即可完成内推！</p>\n<p><strong>手机端</strong></p>\n<p>方式一：用手机扫下面的二维码，进入内推系统；</p>\n<img src=\"https://img-blog.csdnimg.cn/f5eba0407a7e459fb8195999c9dfd0b4.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/d2f7745d86b64c1aacab6d89dc93d755.png\" style=\"zoom:32%;\" />\n\n<p>方式二：用手机点击此处链接，用手机浏览器进入内推系统：</p>\n<p><a href=\"https://campus.meituan.com/bole/wechat?staffSsoId=5236707&amp;appKey=hiring-campus-portal%EF%BC%9B\">https://campus.meituan.com/bole/wechat?staffSsoId=5236707&amp;appKey=hiring-campus-portal；</a></p>\n<blockquote>\n<p>进入美团的内推系统后，选择校招&#x2F;社招类型  &gt; 选择身份 &gt; 选择意向岗位 &gt; 点击立即申请 &gt; 填写投递信息 &gt; 点击确认申请 &gt; 完善简历；</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"美团\"><a href=\"#美团\" class=\"headerlink\" title=\"美团\"></a>美团</h1><p>按照以下方式都可以进行美团的内推投递（投递后，有问题可以微信私聊我，确认是否内推成功）</p>\n<p><strong>PC端</strong></p>\n<p>进内推系统，登录美团招聘官网：<a href=\"https://campus.meituan.com/\">https://campus.meituan.com/</a> ，填入文字内推码，「XIQBmzq」 ，即可完成内推！</p>\n<p><strong>手机端</strong></p>\n<p>方式一：用手机扫下面的二维码，进入内推系统；</p>\n<img src=\"https://img-blog.csdnimg.cn/f5eba0407a7e459fb8195999c9dfd0b4.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/d2f7745d86b64c1aacab6d89dc93d755.png\" style=\"zoom:32%;\" />\n\n<p>方式二：用手机点击此处链接，用手机浏览器进入内推系统：</p>\n<p><a href=\"https://campus.meituan.com/bole/wechat?staffSsoId=5236707&amp;appKey=hiring-campus-portal%EF%BC%9B\">https://campus.meituan.com/bole/wechat?staffSsoId=5236707&amp;appKey=hiring-campus-portal；</a></p>\n<blockquote>\n<p>进入美团的内推系统后，选择校招&#x2F;社招类型  &gt; 选择身份 &gt; 选择意向岗位 &gt; 点击立即申请 &gt; 填写投递信息 &gt; 点击确认申请 &gt; 完善简历；</p>\n</blockquote>\n"},{"title":"学习资源","date":"2020-12-03T03:29:32.000Z","_content":"\n百度云链接分享很快会失效，所以需要以下资源的，公众号（月伴飞鱼）后台回复数字获取\n\n资源会定期更新，也欢迎加群，日常分享免费学习资源\n\n","source":"rescource/index.md","raw":"---\ntitle: 学习资源\ndate: 2020-12-03 11:29:32\n---\n\n百度云链接分享很快会失效，所以需要以下资源的，公众号（月伴飞鱼）后台回复数字获取\n\n资源会定期更新，也欢迎加群，日常分享免费学习资源\n\n","updated":"2021-09-01T05:22:18.222Z","path":"rescource/index.html","comments":1,"layout":"page","_id":"cl0trzwe0000cfhjictgg2soi","content":"<p>百度云链接分享很快会失效，所以需要以下资源的，公众号（月伴飞鱼）后台回复数字获取</p>\n<p>资源会定期更新，也欢迎加群，日常分享免费学习资源</p>\n","site":{"data":{}},"excerpt":"","more":"<p>百度云链接分享很快会失效，所以需要以下资源的，公众号（月伴飞鱼）后台回复数字获取</p>\n<p>资源会定期更新，也欢迎加群，日常分享免费学习资源</p>\n"}],"Post":[{"title":"创建和销毁对象","_content":"\n书籍地址：https://book.douban.com/subject/30412517/\n\n# 静态工厂方法\n\n静态工厂方法，也就是提供一个静态方法，可以返回类的一个实例。\n\n例如，下面是一个简单的提供Boolean类实例化方法：\n\n```java\npublic static Boolean valueOf(boolean b){\n    return b ? Boolean.TRUE : Boolean.FALSE;\n}\n```\n\n一个类除了提供公共的构造方法外，还可以使用静态工厂方法提供其实例。而使用静态工厂方法提供实例既有优点也有缺点。\n\n**优点一：**与构造方法不同的是静态工厂方法有自己的方法名。\n\n例如构造方法 `BigInteger(int, int, Random)` 返回一个很大的近似素数，这并不容易让人理解，改成`BigInteger.probablePrime`则\n\n相对来说易于理解许多。\n\n如果一个类需要多个特征相同的构造方法的话，那么使用静态工厂方法代替是一个很好的选择。\n\n**优点二：**与构造方法不同的时，静态工厂方法在调用的时候不会每次都创建一个新的对象。\n\n`Boolean.valueOf(boolean)`方法就是这种情况：它从来不创造对象。这个特性与享元模式（Flyweight Pattern）类似。\n\n**优点三：**与构造方法不同的是，静态工厂方法可以返回任意返回类的子类。这保证了你可以灵活的选择返回对象。\n\n**优点四：**返回对象的类型可以根据参数的不同而不同。\n\n# Builder模式\n\nBuilder通常都是一个静态的成员类：\n\n```java\n// Builder Pattern\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n    public static class Builder {\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n        // Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n        public Builder calories(int val) { \n            calories = val; \n            return this; \n        }\n        public Builder fat(int val) { \n            fat = val; \n            return this; \n        }\n        public Builder sodium(int val) { \n            sodium = val; \n            return this; \n        }\n        public Builder carbohydrate(int val) { \n            carbohydrate = val; \n            return this; \n        }\n        public NutritionFacts build() { \n            return new NutritionFacts(this);\n        }\n    } \n    private NutritionFacts(Builder builder) {\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    }\n}\n```\n\n这个NutritionFacts就是不可变类，所有的默认参数都在一个地方。\n\nbuilder的setter方法返回builder本身从而使得可以链式调用API：\n\n```java\nNutritionFacts cocaCola = new NutritionFacts.Builder(240,8).calories(100).sodium(35).carbohydrate(27).build();\n```\n\n为了尽快的检测到无效的参数，可以在builder的构造器和方法中检验。\n\n检查有build方法调用的构造方法涉及到多个参数的不可变量。\n\n为了防止这些不可变量收到攻击，从builder中复制参数后对对象字段进行检验。\n\n如果检测失败，抛出IllegalArgumentException异常，可以显示哪些参数是无效的。\n\n**用私有构造器或者枚举类型强化Singleton**\n\n单元素的枚举类型是实现Singleton的最佳方法\n\n**通过私有构造器强化不可实例化的能力**\n\n有时候，你可能需要编写只包含静态方法和静态域的类作为工具类，这样的工具类不希望被实例化，实例化对它没有任何意义。\n\n然而，在缺少显示构造器的情况下，编译器会提供一个公有的、无参的缺省构造器，这个构造器与其它构造器没有任何区别。\n\n在已发行的API中常常可以看到一些被无意识地实例化的类。\n\n错误做法：将这种类做成抽象类来强制该类不可被实例化。\n\n这是行不通的，该类可以被子类化，并且该子类也可以被实例化。这样做甚至会误导用户，以为这种类是专门为了被继承而设计的。\n\n解决办法：让这个类包含私有构造器\n\n**优先考虑依赖注人来引用资源**\n\n有许多类需要依赖底层资源，比如我们有个类需要依赖底层的字典资源，像下面这样做成静态域的，或者把类做成Singleton的都是很常见的。\n\n```java\npublic class Word {\n    private static final Dictionary DICTIONARY = new Dictionary();\n}\n```\n\n但是这只是作为有一本字典的情况下，当我们在不同的情况下需要用不同语言的字典时，这样子就显然不行了，所以静态工具类和Singleton是不适合引用底层资源的。\n\n在这里需要的是支持类的多个实例，每一个实例都代表一种底层资源，在类初始化的适合我们就应该将依赖传入到他们的构造器当中，这种方式就是依赖注入\n\n```java\npublic class Word{\n    private final Dictionary DICTIONARY ;\n\n    public Word(Dictionary dictionary) {\n        this.DICTIONARY = dictionary;\n    }\n}\n```\n\n\n依赖注入是我们平常最常见的，他大大的提升了类的灵活性，可重用性和测试性。\n\n**避免创建不必要的对象**\n\n- 不需要`new String(\"str\")`，因为 \"str\" 本身就是一个String对象，这一条语句其实新建了两个String对象。\n- 如果对象提供静态工厂方法，则尽量优先使用静态工厂方法，静态工厂方法中可能提供对象的缓存，但使用构造函数则总会新建一个对象。（如果有其他方法新建对象，则尽可能的不要使用 new 关键字）\n- 可以通过延迟初始化来减少对象的新建。\n- 尽管本条说的是尽可能重用对象而不是重建，但请尽量不要自己专门实现对象缓冲池，因为这会过于复杂而影响程序的风格和性能。\n\n**消除过期的对象引用**\n\n- 本条在代码上的表现是，如果声明的一个变量不再使用，并且你无法明确其可以被自动释放，请将其主动赋值为 null\n- 尤其需要注意 Collections/Array或者对象容器中的对象引用（因为容易被忽略）\n- 尤其需要注意缓存，因为其意义本身就在于其较长的生命周期，请确保一个对象在不使用的时候同时也在缓存中被清除，否则因为缓存中的引用，该对象将无法被自动回收（考虑使用WeakHashMap）\n- 但这种主动设置的代码应该是个例外，因为对象的生命周期往往不应该太长。这样你就可以确定对象会随着代码的运行而被自动回收。\n\n**避免使用终结方法和清除方法**\n\n在java9中用cleaner代替了finalizer。\n\n使用这个方法也就是标记让清除对象而已，但是这个方法的运行往往是不可预测，效率低下的，有可能会发生奇怪的现象，所以想用的人还是慎重。\n\n对象回收就交给垃圾回收器就行了，如果想要释放资源，往往我们用try-finally来实现就行了。\n\n**try-with-resources优先于try-finally**\n\n```java\n    public static void copy(String src, String dst) throws IOException {\n\n        try (InputStream in = new FileInputStream(src);\n             OutputStream out = new FileOutputStream(dst);) {\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) >= 0) {\n                out.write(buf, 0, n);\n            }\n        }\n    }\n```\n\n将要关闭的资源放在了try后面的括号里面，自己就会在用完的时候释放资源。\n\n> try-with-resource对close方法进行了异常抑制：\n\n当对外部资源进行处理（例如读或写）时，如果遭遇了异常，且在随后的关闭外部资源过程中，又遭遇了异常，那么你catch到的将会是对外部资源进行处理时遭遇的异常，关闭资源时遭遇的异常将被**抑制**但不是丢弃，通过异常的getSuppressed方法，可以提取出被抑制的异常。这样能够让开发者更快的定位到异常。","source":"_posts/Effective Java/创建和销毁对象.md","raw":"---\ntitle: 创建和销毁对象\ncategories: \n- Effective Java\n---\n\n书籍地址：https://book.douban.com/subject/30412517/\n\n# 静态工厂方法\n\n静态工厂方法，也就是提供一个静态方法，可以返回类的一个实例。\n\n例如，下面是一个简单的提供Boolean类实例化方法：\n\n```java\npublic static Boolean valueOf(boolean b){\n    return b ? Boolean.TRUE : Boolean.FALSE;\n}\n```\n\n一个类除了提供公共的构造方法外，还可以使用静态工厂方法提供其实例。而使用静态工厂方法提供实例既有优点也有缺点。\n\n**优点一：**与构造方法不同的是静态工厂方法有自己的方法名。\n\n例如构造方法 `BigInteger(int, int, Random)` 返回一个很大的近似素数，这并不容易让人理解，改成`BigInteger.probablePrime`则\n\n相对来说易于理解许多。\n\n如果一个类需要多个特征相同的构造方法的话，那么使用静态工厂方法代替是一个很好的选择。\n\n**优点二：**与构造方法不同的时，静态工厂方法在调用的时候不会每次都创建一个新的对象。\n\n`Boolean.valueOf(boolean)`方法就是这种情况：它从来不创造对象。这个特性与享元模式（Flyweight Pattern）类似。\n\n**优点三：**与构造方法不同的是，静态工厂方法可以返回任意返回类的子类。这保证了你可以灵活的选择返回对象。\n\n**优点四：**返回对象的类型可以根据参数的不同而不同。\n\n# Builder模式\n\nBuilder通常都是一个静态的成员类：\n\n```java\n// Builder Pattern\npublic class NutritionFacts {\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n    public static class Builder {\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n        // Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n        public Builder(int servingSize, int servings) {\n            this.servingSize = servingSize;\n            this.servings = servings;\n        }\n        public Builder calories(int val) { \n            calories = val; \n            return this; \n        }\n        public Builder fat(int val) { \n            fat = val; \n            return this; \n        }\n        public Builder sodium(int val) { \n            sodium = val; \n            return this; \n        }\n        public Builder carbohydrate(int val) { \n            carbohydrate = val; \n            return this; \n        }\n        public NutritionFacts build() { \n            return new NutritionFacts(this);\n        }\n    } \n    private NutritionFacts(Builder builder) {\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    }\n}\n```\n\n这个NutritionFacts就是不可变类，所有的默认参数都在一个地方。\n\nbuilder的setter方法返回builder本身从而使得可以链式调用API：\n\n```java\nNutritionFacts cocaCola = new NutritionFacts.Builder(240,8).calories(100).sodium(35).carbohydrate(27).build();\n```\n\n为了尽快的检测到无效的参数，可以在builder的构造器和方法中检验。\n\n检查有build方法调用的构造方法涉及到多个参数的不可变量。\n\n为了防止这些不可变量收到攻击，从builder中复制参数后对对象字段进行检验。\n\n如果检测失败，抛出IllegalArgumentException异常，可以显示哪些参数是无效的。\n\n**用私有构造器或者枚举类型强化Singleton**\n\n单元素的枚举类型是实现Singleton的最佳方法\n\n**通过私有构造器强化不可实例化的能力**\n\n有时候，你可能需要编写只包含静态方法和静态域的类作为工具类，这样的工具类不希望被实例化，实例化对它没有任何意义。\n\n然而，在缺少显示构造器的情况下，编译器会提供一个公有的、无参的缺省构造器，这个构造器与其它构造器没有任何区别。\n\n在已发行的API中常常可以看到一些被无意识地实例化的类。\n\n错误做法：将这种类做成抽象类来强制该类不可被实例化。\n\n这是行不通的，该类可以被子类化，并且该子类也可以被实例化。这样做甚至会误导用户，以为这种类是专门为了被继承而设计的。\n\n解决办法：让这个类包含私有构造器\n\n**优先考虑依赖注人来引用资源**\n\n有许多类需要依赖底层资源，比如我们有个类需要依赖底层的字典资源，像下面这样做成静态域的，或者把类做成Singleton的都是很常见的。\n\n```java\npublic class Word {\n    private static final Dictionary DICTIONARY = new Dictionary();\n}\n```\n\n但是这只是作为有一本字典的情况下，当我们在不同的情况下需要用不同语言的字典时，这样子就显然不行了，所以静态工具类和Singleton是不适合引用底层资源的。\n\n在这里需要的是支持类的多个实例，每一个实例都代表一种底层资源，在类初始化的适合我们就应该将依赖传入到他们的构造器当中，这种方式就是依赖注入\n\n```java\npublic class Word{\n    private final Dictionary DICTIONARY ;\n\n    public Word(Dictionary dictionary) {\n        this.DICTIONARY = dictionary;\n    }\n}\n```\n\n\n依赖注入是我们平常最常见的，他大大的提升了类的灵活性，可重用性和测试性。\n\n**避免创建不必要的对象**\n\n- 不需要`new String(\"str\")`，因为 \"str\" 本身就是一个String对象，这一条语句其实新建了两个String对象。\n- 如果对象提供静态工厂方法，则尽量优先使用静态工厂方法，静态工厂方法中可能提供对象的缓存，但使用构造函数则总会新建一个对象。（如果有其他方法新建对象，则尽可能的不要使用 new 关键字）\n- 可以通过延迟初始化来减少对象的新建。\n- 尽管本条说的是尽可能重用对象而不是重建，但请尽量不要自己专门实现对象缓冲池，因为这会过于复杂而影响程序的风格和性能。\n\n**消除过期的对象引用**\n\n- 本条在代码上的表现是，如果声明的一个变量不再使用，并且你无法明确其可以被自动释放，请将其主动赋值为 null\n- 尤其需要注意 Collections/Array或者对象容器中的对象引用（因为容易被忽略）\n- 尤其需要注意缓存，因为其意义本身就在于其较长的生命周期，请确保一个对象在不使用的时候同时也在缓存中被清除，否则因为缓存中的引用，该对象将无法被自动回收（考虑使用WeakHashMap）\n- 但这种主动设置的代码应该是个例外，因为对象的生命周期往往不应该太长。这样你就可以确定对象会随着代码的运行而被自动回收。\n\n**避免使用终结方法和清除方法**\n\n在java9中用cleaner代替了finalizer。\n\n使用这个方法也就是标记让清除对象而已，但是这个方法的运行往往是不可预测，效率低下的，有可能会发生奇怪的现象，所以想用的人还是慎重。\n\n对象回收就交给垃圾回收器就行了，如果想要释放资源，往往我们用try-finally来实现就行了。\n\n**try-with-resources优先于try-finally**\n\n```java\n    public static void copy(String src, String dst) throws IOException {\n\n        try (InputStream in = new FileInputStream(src);\n             OutputStream out = new FileOutputStream(dst);) {\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) >= 0) {\n                out.write(buf, 0, n);\n            }\n        }\n    }\n```\n\n将要关闭的资源放在了try后面的括号里面，自己就会在用完的时候释放资源。\n\n> try-with-resource对close方法进行了异常抑制：\n\n当对外部资源进行处理（例如读或写）时，如果遭遇了异常，且在随后的关闭外部资源过程中，又遭遇了异常，那么你catch到的将会是对外部资源进行处理时遭遇的异常，关闭资源时遭遇的异常将被**抑制**但不是丢弃，通过异常的getSuppressed方法，可以提取出被抑制的异常。这样能够让开发者更快的定位到异常。","slug":"Effective Java/创建和销毁对象","published":1,"date":"2021-12-26T08:28:08.244Z","updated":"2021-12-26T09:33:26.136Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwei001nfhjif298dgi2","content":"<p>书籍地址：<a href=\"https://book.douban.com/subject/30412517/\">https://book.douban.com/subject/30412517/</a></p>\n<h1 id=\"静态工厂方法\"><a href=\"#静态工厂方法\" class=\"headerlink\" title=\"静态工厂方法\"></a>静态工厂方法</h1><p>静态工厂方法，也就是提供一个静态方法，可以返回类的一个实例。</p>\n<p>例如，下面是一个简单的提供Boolean类实例化方法：</p>\n<pre><code class=\"java\">public static Boolean valueOf(boolean b)&#123;\n    return b ? Boolean.TRUE : Boolean.FALSE;\n&#125;\n</code></pre>\n<p>一个类除了提供公共的构造方法外，还可以使用静态工厂方法提供其实例。而使用静态工厂方法提供实例既有优点也有缺点。</p>\n<p><strong>优点一：</strong>与构造方法不同的是静态工厂方法有自己的方法名。</p>\n<p>例如构造方法 <code>BigInteger(int, int, Random)</code> 返回一个很大的近似素数，这并不容易让人理解，改成<code>BigInteger.probablePrime</code>则</p>\n<p>相对来说易于理解许多。</p>\n<p>如果一个类需要多个特征相同的构造方法的话，那么使用静态工厂方法代替是一个很好的选择。</p>\n<p><strong>优点二：</strong>与构造方法不同的时，静态工厂方法在调用的时候不会每次都创建一个新的对象。</p>\n<p><code>Boolean.valueOf(boolean)</code>方法就是这种情况：它从来不创造对象。这个特性与享元模式（Flyweight Pattern）类似。</p>\n<p><strong>优点三：</strong>与构造方法不同的是，静态工厂方法可以返回任意返回类的子类。这保证了你可以灵活的选择返回对象。</p>\n<p><strong>优点四：</strong>返回对象的类型可以根据参数的不同而不同。</p>\n<h1 id=\"Builder模式\"><a href=\"#Builder模式\" class=\"headerlink\" title=\"Builder模式\"></a>Builder模式</h1><p>Builder通常都是一个静态的成员类：</p>\n<pre><code class=\"java\">// Builder Pattern\npublic class NutritionFacts &#123;\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n    public static class Builder &#123;\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n        // Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n        public Builder(int servingSize, int servings) &#123;\n            this.servingSize = servingSize;\n            this.servings = servings;\n        &#125;\n        public Builder calories(int val) &#123; \n            calories = val; \n            return this; \n        &#125;\n        public Builder fat(int val) &#123; \n            fat = val; \n            return this; \n        &#125;\n        public Builder sodium(int val) &#123; \n            sodium = val; \n            return this; \n        &#125;\n        public Builder carbohydrate(int val) &#123; \n            carbohydrate = val; \n            return this; \n        &#125;\n        public NutritionFacts build() &#123; \n            return new NutritionFacts(this);\n        &#125;\n    &#125; \n    private NutritionFacts(Builder builder) &#123;\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    &#125;\n&#125;\n</code></pre>\n<p>这个NutritionFacts就是不可变类，所有的默认参数都在一个地方。</p>\n<p>builder的setter方法返回builder本身从而使得可以链式调用API：</p>\n<pre><code class=\"java\">NutritionFacts cocaCola = new NutritionFacts.Builder(240,8).calories(100).sodium(35).carbohydrate(27).build();\n</code></pre>\n<p>为了尽快的检测到无效的参数，可以在builder的构造器和方法中检验。</p>\n<p>检查有build方法调用的构造方法涉及到多个参数的不可变量。</p>\n<p>为了防止这些不可变量收到攻击，从builder中复制参数后对对象字段进行检验。</p>\n<p>如果检测失败，抛出IllegalArgumentException异常，可以显示哪些参数是无效的。</p>\n<p><strong>用私有构造器或者枚举类型强化Singleton</strong></p>\n<p>单元素的枚举类型是实现Singleton的最佳方法</p>\n<p><strong>通过私有构造器强化不可实例化的能力</strong></p>\n<p>有时候，你可能需要编写只包含静态方法和静态域的类作为工具类，这样的工具类不希望被实例化，实例化对它没有任何意义。</p>\n<p>然而，在缺少显示构造器的情况下，编译器会提供一个公有的、无参的缺省构造器，这个构造器与其它构造器没有任何区别。</p>\n<p>在已发行的API中常常可以看到一些被无意识地实例化的类。</p>\n<p>错误做法：将这种类做成抽象类来强制该类不可被实例化。</p>\n<p>这是行不通的，该类可以被子类化，并且该子类也可以被实例化。这样做甚至会误导用户，以为这种类是专门为了被继承而设计的。</p>\n<p>解决办法：让这个类包含私有构造器</p>\n<p><strong>优先考虑依赖注人来引用资源</strong></p>\n<p>有许多类需要依赖底层资源，比如我们有个类需要依赖底层的字典资源，像下面这样做成静态域的，或者把类做成Singleton的都是很常见的。</p>\n<pre><code class=\"java\">public class Word &#123;\n    private static final Dictionary DICTIONARY = new Dictionary();\n&#125;\n</code></pre>\n<p>但是这只是作为有一本字典的情况下，当我们在不同的情况下需要用不同语言的字典时，这样子就显然不行了，所以静态工具类和Singleton是不适合引用底层资源的。</p>\n<p>在这里需要的是支持类的多个实例，每一个实例都代表一种底层资源，在类初始化的适合我们就应该将依赖传入到他们的构造器当中，这种方式就是依赖注入</p>\n<pre><code class=\"java\">public class Word&#123;\n    private final Dictionary DICTIONARY ;\n\n    public Word(Dictionary dictionary) &#123;\n        this.DICTIONARY = dictionary;\n    &#125;\n&#125;\n</code></pre>\n<p>依赖注入是我们平常最常见的，他大大的提升了类的灵活性，可重用性和测试性。</p>\n<p><strong>避免创建不必要的对象</strong></p>\n<ul>\n<li>不需要<code>new String(&quot;str&quot;)</code>，因为 “str” 本身就是一个String对象，这一条语句其实新建了两个String对象。</li>\n<li>如果对象提供静态工厂方法，则尽量优先使用静态工厂方法，静态工厂方法中可能提供对象的缓存，但使用构造函数则总会新建一个对象。（如果有其他方法新建对象，则尽可能的不要使用 new 关键字）</li>\n<li>可以通过延迟初始化来减少对象的新建。</li>\n<li>尽管本条说的是尽可能重用对象而不是重建，但请尽量不要自己专门实现对象缓冲池，因为这会过于复杂而影响程序的风格和性能。</li>\n</ul>\n<p><strong>消除过期的对象引用</strong></p>\n<ul>\n<li>本条在代码上的表现是，如果声明的一个变量不再使用，并且你无法明确其可以被自动释放，请将其主动赋值为 null</li>\n<li>尤其需要注意 Collections&#x2F;Array或者对象容器中的对象引用（因为容易被忽略）</li>\n<li>尤其需要注意缓存，因为其意义本身就在于其较长的生命周期，请确保一个对象在不使用的时候同时也在缓存中被清除，否则因为缓存中的引用，该对象将无法被自动回收（考虑使用WeakHashMap）</li>\n<li>但这种主动设置的代码应该是个例外，因为对象的生命周期往往不应该太长。这样你就可以确定对象会随着代码的运行而被自动回收。</li>\n</ul>\n<p><strong>避免使用终结方法和清除方法</strong></p>\n<p>在java9中用cleaner代替了finalizer。</p>\n<p>使用这个方法也就是标记让清除对象而已，但是这个方法的运行往往是不可预测，效率低下的，有可能会发生奇怪的现象，所以想用的人还是慎重。</p>\n<p>对象回收就交给垃圾回收器就行了，如果想要释放资源，往往我们用try-finally来实现就行了。</p>\n<p><strong>try-with-resources优先于try-finally</strong></p>\n<pre><code class=\"java\">    public static void copy(String src, String dst) throws IOException &#123;\n\n        try (InputStream in = new FileInputStream(src);\n             OutputStream out = new FileOutputStream(dst);) &#123;\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) &gt;= 0) &#123;\n                out.write(buf, 0, n);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>将要关闭的资源放在了try后面的括号里面，自己就会在用完的时候释放资源。</p>\n<blockquote>\n<p>try-with-resource对close方法进行了异常抑制：</p>\n</blockquote>\n<p>当对外部资源进行处理（例如读或写）时，如果遭遇了异常，且在随后的关闭外部资源过程中，又遭遇了异常，那么你catch到的将会是对外部资源进行处理时遭遇的异常，关闭资源时遭遇的异常将被<strong>抑制</strong>但不是丢弃，通过异常的getSuppressed方法，可以提取出被抑制的异常。这样能够让开发者更快的定位到异常。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>书籍地址：<a href=\"https://book.douban.com/subject/30412517/\">https://book.douban.com/subject/30412517/</a></p>\n<h1 id=\"静态工厂方法\"><a href=\"#静态工厂方法\" class=\"headerlink\" title=\"静态工厂方法\"></a>静态工厂方法</h1><p>静态工厂方法，也就是提供一个静态方法，可以返回类的一个实例。</p>\n<p>例如，下面是一个简单的提供Boolean类实例化方法：</p>\n<pre><code class=\"java\">public static Boolean valueOf(boolean b)&#123;\n    return b ? Boolean.TRUE : Boolean.FALSE;\n&#125;\n</code></pre>\n<p>一个类除了提供公共的构造方法外，还可以使用静态工厂方法提供其实例。而使用静态工厂方法提供实例既有优点也有缺点。</p>\n<p><strong>优点一：</strong>与构造方法不同的是静态工厂方法有自己的方法名。</p>\n<p>例如构造方法 <code>BigInteger(int, int, Random)</code> 返回一个很大的近似素数，这并不容易让人理解，改成<code>BigInteger.probablePrime</code>则</p>\n<p>相对来说易于理解许多。</p>\n<p>如果一个类需要多个特征相同的构造方法的话，那么使用静态工厂方法代替是一个很好的选择。</p>\n<p><strong>优点二：</strong>与构造方法不同的时，静态工厂方法在调用的时候不会每次都创建一个新的对象。</p>\n<p><code>Boolean.valueOf(boolean)</code>方法就是这种情况：它从来不创造对象。这个特性与享元模式（Flyweight Pattern）类似。</p>\n<p><strong>优点三：</strong>与构造方法不同的是，静态工厂方法可以返回任意返回类的子类。这保证了你可以灵活的选择返回对象。</p>\n<p><strong>优点四：</strong>返回对象的类型可以根据参数的不同而不同。</p>\n<h1 id=\"Builder模式\"><a href=\"#Builder模式\" class=\"headerlink\" title=\"Builder模式\"></a>Builder模式</h1><p>Builder通常都是一个静态的成员类：</p>\n<pre><code class=\"java\">// Builder Pattern\npublic class NutritionFacts &#123;\n    private final int servingSize;\n    private final int servings;\n    private final int calories;\n    private final int fat;\n    private final int sodium;\n    private final int carbohydrate;\n    public static class Builder &#123;\n        // Required parameters\n        private final int servingSize;\n        private final int servings;\n        // Optional parameters - initialized to default values\n        private int calories = 0;\n        private int fat = 0;\n        private int sodium = 0;\n        private int carbohydrate = 0;\n        public Builder(int servingSize, int servings) &#123;\n            this.servingSize = servingSize;\n            this.servings = servings;\n        &#125;\n        public Builder calories(int val) &#123; \n            calories = val; \n            return this; \n        &#125;\n        public Builder fat(int val) &#123; \n            fat = val; \n            return this; \n        &#125;\n        public Builder sodium(int val) &#123; \n            sodium = val; \n            return this; \n        &#125;\n        public Builder carbohydrate(int val) &#123; \n            carbohydrate = val; \n            return this; \n        &#125;\n        public NutritionFacts build() &#123; \n            return new NutritionFacts(this);\n        &#125;\n    &#125; \n    private NutritionFacts(Builder builder) &#123;\n        servingSize = builder.servingSize;\n        servings = builder.servings;\n        calories = builder.calories;\n        fat = builder.fat;\n        sodium = builder.sodium;\n        carbohydrate = builder.carbohydrate;\n    &#125;\n&#125;\n</code></pre>\n<p>这个NutritionFacts就是不可变类，所有的默认参数都在一个地方。</p>\n<p>builder的setter方法返回builder本身从而使得可以链式调用API：</p>\n<pre><code class=\"java\">NutritionFacts cocaCola = new NutritionFacts.Builder(240,8).calories(100).sodium(35).carbohydrate(27).build();\n</code></pre>\n<p>为了尽快的检测到无效的参数，可以在builder的构造器和方法中检验。</p>\n<p>检查有build方法调用的构造方法涉及到多个参数的不可变量。</p>\n<p>为了防止这些不可变量收到攻击，从builder中复制参数后对对象字段进行检验。</p>\n<p>如果检测失败，抛出IllegalArgumentException异常，可以显示哪些参数是无效的。</p>\n<p><strong>用私有构造器或者枚举类型强化Singleton</strong></p>\n<p>单元素的枚举类型是实现Singleton的最佳方法</p>\n<p><strong>通过私有构造器强化不可实例化的能力</strong></p>\n<p>有时候，你可能需要编写只包含静态方法和静态域的类作为工具类，这样的工具类不希望被实例化，实例化对它没有任何意义。</p>\n<p>然而，在缺少显示构造器的情况下，编译器会提供一个公有的、无参的缺省构造器，这个构造器与其它构造器没有任何区别。</p>\n<p>在已发行的API中常常可以看到一些被无意识地实例化的类。</p>\n<p>错误做法：将这种类做成抽象类来强制该类不可被实例化。</p>\n<p>这是行不通的，该类可以被子类化，并且该子类也可以被实例化。这样做甚至会误导用户，以为这种类是专门为了被继承而设计的。</p>\n<p>解决办法：让这个类包含私有构造器</p>\n<p><strong>优先考虑依赖注人来引用资源</strong></p>\n<p>有许多类需要依赖底层资源，比如我们有个类需要依赖底层的字典资源，像下面这样做成静态域的，或者把类做成Singleton的都是很常见的。</p>\n<pre><code class=\"java\">public class Word &#123;\n    private static final Dictionary DICTIONARY = new Dictionary();\n&#125;\n</code></pre>\n<p>但是这只是作为有一本字典的情况下，当我们在不同的情况下需要用不同语言的字典时，这样子就显然不行了，所以静态工具类和Singleton是不适合引用底层资源的。</p>\n<p>在这里需要的是支持类的多个实例，每一个实例都代表一种底层资源，在类初始化的适合我们就应该将依赖传入到他们的构造器当中，这种方式就是依赖注入</p>\n<pre><code class=\"java\">public class Word&#123;\n    private final Dictionary DICTIONARY ;\n\n    public Word(Dictionary dictionary) &#123;\n        this.DICTIONARY = dictionary;\n    &#125;\n&#125;\n</code></pre>\n<p>依赖注入是我们平常最常见的，他大大的提升了类的灵活性，可重用性和测试性。</p>\n<p><strong>避免创建不必要的对象</strong></p>\n<ul>\n<li>不需要<code>new String(&quot;str&quot;)</code>，因为 “str” 本身就是一个String对象，这一条语句其实新建了两个String对象。</li>\n<li>如果对象提供静态工厂方法，则尽量优先使用静态工厂方法，静态工厂方法中可能提供对象的缓存，但使用构造函数则总会新建一个对象。（如果有其他方法新建对象，则尽可能的不要使用 new 关键字）</li>\n<li>可以通过延迟初始化来减少对象的新建。</li>\n<li>尽管本条说的是尽可能重用对象而不是重建，但请尽量不要自己专门实现对象缓冲池，因为这会过于复杂而影响程序的风格和性能。</li>\n</ul>\n<p><strong>消除过期的对象引用</strong></p>\n<ul>\n<li>本条在代码上的表现是，如果声明的一个变量不再使用，并且你无法明确其可以被自动释放，请将其主动赋值为 null</li>\n<li>尤其需要注意 Collections&#x2F;Array或者对象容器中的对象引用（因为容易被忽略）</li>\n<li>尤其需要注意缓存，因为其意义本身就在于其较长的生命周期，请确保一个对象在不使用的时候同时也在缓存中被清除，否则因为缓存中的引用，该对象将无法被自动回收（考虑使用WeakHashMap）</li>\n<li>但这种主动设置的代码应该是个例外，因为对象的生命周期往往不应该太长。这样你就可以确定对象会随着代码的运行而被自动回收。</li>\n</ul>\n<p><strong>避免使用终结方法和清除方法</strong></p>\n<p>在java9中用cleaner代替了finalizer。</p>\n<p>使用这个方法也就是标记让清除对象而已，但是这个方法的运行往往是不可预测，效率低下的，有可能会发生奇怪的现象，所以想用的人还是慎重。</p>\n<p>对象回收就交给垃圾回收器就行了，如果想要释放资源，往往我们用try-finally来实现就行了。</p>\n<p><strong>try-with-resources优先于try-finally</strong></p>\n<pre><code class=\"java\">    public static void copy(String src, String dst) throws IOException &#123;\n\n        try (InputStream in = new FileInputStream(src);\n             OutputStream out = new FileOutputStream(dst);) &#123;\n            byte[] buf = new byte[1024];\n            int n;\n            while ((n = in.read(buf)) &gt;= 0) &#123;\n                out.write(buf, 0, n);\n            &#125;\n        &#125;\n    &#125;\n</code></pre>\n<p>将要关闭的资源放在了try后面的括号里面，自己就会在用完的时候释放资源。</p>\n<blockquote>\n<p>try-with-resource对close方法进行了异常抑制：</p>\n</blockquote>\n<p>当对外部资源进行处理（例如读或写）时，如果遭遇了异常，且在随后的关闭外部资源过程中，又遭遇了异常，那么你catch到的将会是对外部资源进行处理时遭遇的异常，关闭资源时遭遇的异常将被<strong>抑制</strong>但不是丢弃，通过异常的getSuppressed方法，可以提取出被抑制的异常。这样能够让开发者更快的定位到异常。</p>\n"},{"title":"类和接口","_content":"\n**使类和成员的可访问性最小化**\n\n尽可能地使每个类或者成员不被外界访问。\n\nJava中可以通过**包**、**访问修饰符**（private protected public）控制类、接口和成员的`可访问性（accessibility）` \n\n除了应该暴露的API之外，我们应该尽可能少的开放访问权。 因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。\n\n可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？\n\n所以**不要去暴露那些不该暴露的类、接口、成员** \n\n> 作者在最后给了小结：\n\n应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的。\n\n**在公有类中使用访问方法而非公有域**\n\n```java\npublic class Point{\n   public double x;\n   public double y;\n}\n```\n\n作者的意思是不应该直接暴露`x y`，要为它们提供`getter`、`setter`方法，这样有利于添加约束条件，辅助行为。\n\n**使可变性最小化**\n\n> 不可变类：实例不能被修改的类。**每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变**。如：String、基本类型的包装类、BigInteger和BigDecimal。\n\n不可变类的五条规则：\n\n1. 不要提供任何会修改对象状态的方法。\n2. 保证类不会被扩展。 一般用final修饰\n3. 使所有的域都是final的。\n4. 使所有的域都成为私有的。（降低访问权限）\n\n**不可变类的优缺点**\n\n> 线程安全\n\n不要求同步，无惧多线程并发访问\n\n> 不可变对象可以被自由地共享\n\n所以不需要保护性拷贝（如String类的拷贝构造器） 也可以重复利用，如:`Boolean.FALSE/TRUE`\n\n> 唯一的缺点：对于每个不同的值都需要一个单独的对象\n\n如FALSE TRUE ，不过如果值少，到也没什么关系，但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好）\n\n> 小结\n\n除非有很好的理由要让类成为可变的类，否则就应该是不可变的。 \n\n如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性）\n\n**复合优先于继承**\n\n**要么为继承而设计，并提供文档说明，要么就禁止继承**\n\n**接口优于抽象类**\n\nJava提供两种机制用来定义允许多个实现的类型：`接口`和`抽象类`。\n\n> 区别\n\n接口和抽象类的区别有很多，其中 **最为明显** 的区别是： **抽象类可以包含某些方法的实现，而接口不允许，即接口都是抽象方法** \n\n> 接口的优势\n\n- 现有的类可以很容易被更新，以实现新的接口，当需要增加方法的时候只需要`implements`具体的接口即可，非常方便，而如果通过抽象类来实现，则需要在抽象类里新增方法，而这会导致其他继承该抽象类的类也被强制加上额外的方法！\n\n我的理解是:**一个类，利用实现多个接口可以达到混合类型的目的，而利用抽象类只能继承一个类，则不能达到混合类型的效果！** \n\n**类层次优于标签类**\n\n**标签类**， 我的理解是一个类，拥有多个风格，通过一个属性来区分不同的风格，类里充斥着`if else`或者`switch case` \n\n举个例子：\n\n```java\nclass Person{\n   boolean isMan;\n   String sayHi(){\n       if (isMan) {\n           return \"Yo hi man!~\";\n       }else{\n           return \"Hello\";\n       }\n   }\n}\n```\n\nPerson类，通过`isMan`属性来区分是男的还是女的，`sayHi()`方法针对男女有不同的表现，这个就是一个非常简单的标签类。\n\n标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入bug，非常难以维护。\n\n这个时候，将标签类转变成类层次就非常方便了：\n\n```java\nabstract class Person{\n   abstract String sayHi();\n}\nclass Man extends Person{\n   @Override\n   String sayHi() {\n       return \"Yo hi man!~\";\n   }\n}\nclass Woman extends Person{\n   @Override\n   String sayHi() {\n       return \"Hello\";\n   }\n}\n```\n\n抽象出一个`Person`类，定义`Man`和`Woman`类继承它，根据自己的需求实现`sayHi()`方法，当需要修改`Man`的行为时，你不需要也不用担心会破坏`Woman`的代码，代码可读性，可维护性一下子高了很多！\n\n**优先考虑静态成员类**","source":"_posts/Effective Java/类和接口.md","raw":"---\ntitle: 类和接口\ncategories: \n- Effective Java\n---\n\n**使类和成员的可访问性最小化**\n\n尽可能地使每个类或者成员不被外界访问。\n\nJava中可以通过**包**、**访问修饰符**（private protected public）控制类、接口和成员的`可访问性（accessibility）` \n\n除了应该暴露的API之外，我们应该尽可能少的开放访问权。 因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。\n\n可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？\n\n所以**不要去暴露那些不该暴露的类、接口、成员** \n\n> 作者在最后给了小结：\n\n应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的。\n\n**在公有类中使用访问方法而非公有域**\n\n```java\npublic class Point{\n   public double x;\n   public double y;\n}\n```\n\n作者的意思是不应该直接暴露`x y`，要为它们提供`getter`、`setter`方法，这样有利于添加约束条件，辅助行为。\n\n**使可变性最小化**\n\n> 不可变类：实例不能被修改的类。**每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变**。如：String、基本类型的包装类、BigInteger和BigDecimal。\n\n不可变类的五条规则：\n\n1. 不要提供任何会修改对象状态的方法。\n2. 保证类不会被扩展。 一般用final修饰\n3. 使所有的域都是final的。\n4. 使所有的域都成为私有的。（降低访问权限）\n\n**不可变类的优缺点**\n\n> 线程安全\n\n不要求同步，无惧多线程并发访问\n\n> 不可变对象可以被自由地共享\n\n所以不需要保护性拷贝（如String类的拷贝构造器） 也可以重复利用，如:`Boolean.FALSE/TRUE`\n\n> 唯一的缺点：对于每个不同的值都需要一个单独的对象\n\n如FALSE TRUE ，不过如果值少，到也没什么关系，但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好）\n\n> 小结\n\n除非有很好的理由要让类成为可变的类，否则就应该是不可变的。 \n\n如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性）\n\n**复合优先于继承**\n\n**要么为继承而设计，并提供文档说明，要么就禁止继承**\n\n**接口优于抽象类**\n\nJava提供两种机制用来定义允许多个实现的类型：`接口`和`抽象类`。\n\n> 区别\n\n接口和抽象类的区别有很多，其中 **最为明显** 的区别是： **抽象类可以包含某些方法的实现，而接口不允许，即接口都是抽象方法** \n\n> 接口的优势\n\n- 现有的类可以很容易被更新，以实现新的接口，当需要增加方法的时候只需要`implements`具体的接口即可，非常方便，而如果通过抽象类来实现，则需要在抽象类里新增方法，而这会导致其他继承该抽象类的类也被强制加上额外的方法！\n\n我的理解是:**一个类，利用实现多个接口可以达到混合类型的目的，而利用抽象类只能继承一个类，则不能达到混合类型的效果！** \n\n**类层次优于标签类**\n\n**标签类**， 我的理解是一个类，拥有多个风格，通过一个属性来区分不同的风格，类里充斥着`if else`或者`switch case` \n\n举个例子：\n\n```java\nclass Person{\n   boolean isMan;\n   String sayHi(){\n       if (isMan) {\n           return \"Yo hi man!~\";\n       }else{\n           return \"Hello\";\n       }\n   }\n}\n```\n\nPerson类，通过`isMan`属性来区分是男的还是女的，`sayHi()`方法针对男女有不同的表现，这个就是一个非常简单的标签类。\n\n标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入bug，非常难以维护。\n\n这个时候，将标签类转变成类层次就非常方便了：\n\n```java\nabstract class Person{\n   abstract String sayHi();\n}\nclass Man extends Person{\n   @Override\n   String sayHi() {\n       return \"Yo hi man!~\";\n   }\n}\nclass Woman extends Person{\n   @Override\n   String sayHi() {\n       return \"Hello\";\n   }\n}\n```\n\n抽象出一个`Person`类，定义`Man`和`Woman`类继承它，根据自己的需求实现`sayHi()`方法，当需要修改`Man`的行为时，你不需要也不用担心会破坏`Woman`的代码，代码可读性，可维护性一下子高了很多！\n\n**优先考虑静态成员类**","slug":"Effective Java/类和接口","published":1,"date":"2022-02-07T16:05:28.532Z","updated":"2022-02-07T16:37:45.603Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwei001qfhji7by71yww","content":"<p><strong>使类和成员的可访问性最小化</strong></p>\n<p>尽可能地使每个类或者成员不被外界访问。</p>\n<p>Java中可以通过<strong>包</strong>、<strong>访问修饰符</strong>（private protected public）控制类、接口和成员的<code>可访问性（accessibility）</code> </p>\n<p>除了应该暴露的API之外，我们应该尽可能少的开放访问权。 因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。</p>\n<p>可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？</p>\n<p>所以<strong>不要去暴露那些不该暴露的类、接口、成员</strong> </p>\n<blockquote>\n<p>作者在最后给了小结：</p>\n</blockquote>\n<p>应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的。</p>\n<p><strong>在公有类中使用访问方法而非公有域</strong></p>\n<pre><code class=\"java\">public class Point&#123;\n   public double x;\n   public double y;\n&#125;\n</code></pre>\n<p>作者的意思是不应该直接暴露<code>x y</code>，要为它们提供<code>getter</code>、<code>setter</code>方法，这样有利于添加约束条件，辅助行为。</p>\n<p><strong>使可变性最小化</strong></p>\n<blockquote>\n<p>不可变类：实例不能被修改的类。<strong>每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变</strong>。如：String、基本类型的包装类、BigInteger和BigDecimal。</p>\n</blockquote>\n<p>不可变类的五条规则：</p>\n<ol>\n<li>不要提供任何会修改对象状态的方法。</li>\n<li>保证类不会被扩展。 一般用final修饰</li>\n<li>使所有的域都是final的。</li>\n<li>使所有的域都成为私有的。（降低访问权限）</li>\n</ol>\n<p><strong>不可变类的优缺点</strong></p>\n<blockquote>\n<p>线程安全</p>\n</blockquote>\n<p>不要求同步，无惧多线程并发访问</p>\n<blockquote>\n<p>不可变对象可以被自由地共享</p>\n</blockquote>\n<p>所以不需要保护性拷贝（如String类的拷贝构造器） 也可以重复利用，如:<code>Boolean.FALSE/TRUE</code></p>\n<blockquote>\n<p>唯一的缺点：对于每个不同的值都需要一个单独的对象</p>\n</blockquote>\n<p>如FALSE TRUE ，不过如果值少，到也没什么关系，但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好）</p>\n<blockquote>\n<p>小结</p>\n</blockquote>\n<p>除非有很好的理由要让类成为可变的类，否则就应该是不可变的。 </p>\n<p>如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性）</p>\n<p><strong>复合优先于继承</strong></p>\n<p><strong>要么为继承而设计，并提供文档说明，要么就禁止继承</strong></p>\n<p><strong>接口优于抽象类</strong></p>\n<p>Java提供两种机制用来定义允许多个实现的类型：<code>接口</code>和<code>抽象类</code>。</p>\n<blockquote>\n<p>区别</p>\n</blockquote>\n<p>接口和抽象类的区别有很多，其中 <strong>最为明显</strong> 的区别是： <strong>抽象类可以包含某些方法的实现，而接口不允许，即接口都是抽象方法</strong> </p>\n<blockquote>\n<p>接口的优势</p>\n</blockquote>\n<ul>\n<li>现有的类可以很容易被更新，以实现新的接口，当需要增加方法的时候只需要<code>implements</code>具体的接口即可，非常方便，而如果通过抽象类来实现，则需要在抽象类里新增方法，而这会导致其他继承该抽象类的类也被强制加上额外的方法！</li>\n</ul>\n<p>我的理解是:<strong>一个类，利用实现多个接口可以达到混合类型的目的，而利用抽象类只能继承一个类，则不能达到混合类型的效果！</strong> </p>\n<p><strong>类层次优于标签类</strong></p>\n<p><strong>标签类</strong>， 我的理解是一个类，拥有多个风格，通过一个属性来区分不同的风格，类里充斥着<code>if else</code>或者<code>switch case</code> </p>\n<p>举个例子：</p>\n<pre><code class=\"java\">class Person&#123;\n   boolean isMan;\n   String sayHi()&#123;\n       if (isMan) &#123;\n           return &quot;Yo hi man!~&quot;;\n       &#125;else&#123;\n           return &quot;Hello&quot;;\n       &#125;\n   &#125;\n&#125;\n</code></pre>\n<p>Person类，通过<code>isMan</code>属性来区分是男的还是女的，<code>sayHi()</code>方法针对男女有不同的表现，这个就是一个非常简单的标签类。</p>\n<p>标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入bug，非常难以维护。</p>\n<p>这个时候，将标签类转变成类层次就非常方便了：</p>\n<pre><code class=\"java\">abstract class Person&#123;\n   abstract String sayHi();\n&#125;\nclass Man extends Person&#123;\n   @Override\n   String sayHi() &#123;\n       return &quot;Yo hi man!~&quot;;\n   &#125;\n&#125;\nclass Woman extends Person&#123;\n   @Override\n   String sayHi() &#123;\n       return &quot;Hello&quot;;\n   &#125;\n&#125;\n</code></pre>\n<p>抽象出一个<code>Person</code>类，定义<code>Man</code>和<code>Woman</code>类继承它，根据自己的需求实现<code>sayHi()</code>方法，当需要修改<code>Man</code>的行为时，你不需要也不用担心会破坏<code>Woman</code>的代码，代码可读性，可维护性一下子高了很多！</p>\n<p><strong>优先考虑静态成员类</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>使类和成员的可访问性最小化</strong></p>\n<p>尽可能地使每个类或者成员不被外界访问。</p>\n<p>Java中可以通过<strong>包</strong>、<strong>访问修饰符</strong>（private protected public）控制类、接口和成员的<code>可访问性（accessibility）</code> </p>\n<p>除了应该暴露的API之外，我们应该尽可能少的开放访问权。 因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。</p>\n<p>可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？</p>\n<p>所以<strong>不要去暴露那些不该暴露的类、接口、成员</strong> </p>\n<blockquote>\n<p>作者在最后给了小结：</p>\n</blockquote>\n<p>应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的。</p>\n<p><strong>在公有类中使用访问方法而非公有域</strong></p>\n<pre><code class=\"java\">public class Point&#123;\n   public double x;\n   public double y;\n&#125;\n</code></pre>\n<p>作者的意思是不应该直接暴露<code>x y</code>，要为它们提供<code>getter</code>、<code>setter</code>方法，这样有利于添加约束条件，辅助行为。</p>\n<p><strong>使可变性最小化</strong></p>\n<blockquote>\n<p>不可变类：实例不能被修改的类。<strong>每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变</strong>。如：String、基本类型的包装类、BigInteger和BigDecimal。</p>\n</blockquote>\n<p>不可变类的五条规则：</p>\n<ol>\n<li>不要提供任何会修改对象状态的方法。</li>\n<li>保证类不会被扩展。 一般用final修饰</li>\n<li>使所有的域都是final的。</li>\n<li>使所有的域都成为私有的。（降低访问权限）</li>\n</ol>\n<p><strong>不可变类的优缺点</strong></p>\n<blockquote>\n<p>线程安全</p>\n</blockquote>\n<p>不要求同步，无惧多线程并发访问</p>\n<blockquote>\n<p>不可变对象可以被自由地共享</p>\n</blockquote>\n<p>所以不需要保护性拷贝（如String类的拷贝构造器） 也可以重复利用，如:<code>Boolean.FALSE/TRUE</code></p>\n<blockquote>\n<p>唯一的缺点：对于每个不同的值都需要一个单独的对象</p>\n</blockquote>\n<p>如FALSE TRUE ，不过如果值少，到也没什么关系，但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好）</p>\n<blockquote>\n<p>小结</p>\n</blockquote>\n<p>除非有很好的理由要让类成为可变的类，否则就应该是不可变的。 </p>\n<p>如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性）</p>\n<p><strong>复合优先于继承</strong></p>\n<p><strong>要么为继承而设计，并提供文档说明，要么就禁止继承</strong></p>\n<p><strong>接口优于抽象类</strong></p>\n<p>Java提供两种机制用来定义允许多个实现的类型：<code>接口</code>和<code>抽象类</code>。</p>\n<blockquote>\n<p>区别</p>\n</blockquote>\n<p>接口和抽象类的区别有很多，其中 <strong>最为明显</strong> 的区别是： <strong>抽象类可以包含某些方法的实现，而接口不允许，即接口都是抽象方法</strong> </p>\n<blockquote>\n<p>接口的优势</p>\n</blockquote>\n<ul>\n<li>现有的类可以很容易被更新，以实现新的接口，当需要增加方法的时候只需要<code>implements</code>具体的接口即可，非常方便，而如果通过抽象类来实现，则需要在抽象类里新增方法，而这会导致其他继承该抽象类的类也被强制加上额外的方法！</li>\n</ul>\n<p>我的理解是:<strong>一个类，利用实现多个接口可以达到混合类型的目的，而利用抽象类只能继承一个类，则不能达到混合类型的效果！</strong> </p>\n<p><strong>类层次优于标签类</strong></p>\n<p><strong>标签类</strong>， 我的理解是一个类，拥有多个风格，通过一个属性来区分不同的风格，类里充斥着<code>if else</code>或者<code>switch case</code> </p>\n<p>举个例子：</p>\n<pre><code class=\"java\">class Person&#123;\n   boolean isMan;\n   String sayHi()&#123;\n       if (isMan) &#123;\n           return &quot;Yo hi man!~&quot;;\n       &#125;else&#123;\n           return &quot;Hello&quot;;\n       &#125;\n   &#125;\n&#125;\n</code></pre>\n<p>Person类，通过<code>isMan</code>属性来区分是男的还是女的，<code>sayHi()</code>方法针对男女有不同的表现，这个就是一个非常简单的标签类。</p>\n<p>标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入bug，非常难以维护。</p>\n<p>这个时候，将标签类转变成类层次就非常方便了：</p>\n<pre><code class=\"java\">abstract class Person&#123;\n   abstract String sayHi();\n&#125;\nclass Man extends Person&#123;\n   @Override\n   String sayHi() &#123;\n       return &quot;Yo hi man!~&quot;;\n   &#125;\n&#125;\nclass Woman extends Person&#123;\n   @Override\n   String sayHi() &#123;\n       return &quot;Hello&quot;;\n   &#125;\n&#125;\n</code></pre>\n<p>抽象出一个<code>Person</code>类，定义<code>Man</code>和<code>Woman</code>类继承它，根据自己的需求实现<code>sayHi()</code>方法，当需要修改<code>Man</code>的行为时，你不需要也不用担心会破坏<code>Woman</code>的代码，代码可读性，可维护性一下子高了很多！</p>\n<p><strong>优先考虑静态成员类</strong></p>\n"},{"title":"通用方法","_content":"\n**覆盖equals时请遵守通用约定**\n\n> 什么时候应该覆盖equals\n\n当类需要逻辑相等这个概念的时候就应该覆盖equals，比如要判断两个`student`是否是同一个人，这个时候我们就需要按需重写equals\n\n> 逻辑相等，就是逻辑上是相等的，比如id一样，判定它们相等，即使它们是两个不同的对象\n\n> 通用约定\n\n重写equals的时候就必须要遵守它的通用约定：\n\n- 自反性(reflexive)，对于任何非null的引用值x，`x.equals(x)`必须返回true\n- 对称性(symmetric)，对于任何非null的引用值x和y，当且仅当`y.equals(x)`返回true时，`x.equals(y)`必须返回true\n- 传递性(transitive)，对于任何非null的引用值x，y，z，如果`x.equals(y)`为true，并且`y.equals(z)`也返回true，那么`x.equals(z)`也必须返回true\n- 一致性(consistent)，对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用\t`x.equals(y)`就会一致地返回true，或者false\n- 对于任何非null的引用值x，`x.equals(null)`必须返回false\n\n> 对equals提了几点建议:\n\n1. 使用`==`操作符检查**参数是否为这个对象的引用**，如果是，则返回true，这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做\n2. 使用`instanceof`操作符检查**参数是否为正确的类型**，如果不是，则返回false。\n3. 把参数装换成正确的类型。\n4. 对于该类中的每个关键域，检查参数中的域是否与对象中对应的域相配。(比如学生类有学号，班级，姓名这些重要的属性，我们都需要去比对)\n\n用一个`Student`类来总结一下equals的写法：\n\n```java\npublic class Student {\n   public String name;\n   public String className;\n   @Override\n   public boolean equals(Object obj) {\n       //对于一个null的对象 我们总是返回false\n       if (null == obj) {\n           return false;\n       }\n       // 利用instanceof检查类型后,强转\n       if (obj instanceof Student){\n           Student other = (Student) obj;\n           //再对关键的属性做比较 得出结论\n           if (name.equals(other.name) && className.equals(other.className)) {\n               return true;\n           }\n       }\n       return false;\n   }\n}\n```\n\n**覆盖equals时总要覆盖hashCode**\n\n> 不重写`hashCode`带来的问题\n\nhashCode其实主要用于基于散列的集合，如HashMap会把**相同的hashCode的对象放在同一个散列桶**(hash bucket)中，那么即使equals相同而hashCode不相等，那么跟HashMap一起使用，则**会得到与预期不相同的结果**.\n\n**始终要覆盖toString**\n\nObject类默认toString的实现方法是这样的：\n\n```java\npublic String toString() {\n\treturn getClass().getName() + '@' + Integer.toHexString(hashCode());\n}\n```\n\n它只有**类名+@+散列值**，`toString`的通用约定指出，被返回的字符串应该是一个简洁的，但信息丰富，并且易于阅读的表达形式。\n\n虽然够简单，但是信息并不丰富，而且更多时候我们更希望`toString`**返回对象中包含的所有值得关注的信息**，当属性多了，只显示信息重要的即可。\n\n**谨慎地覆盖clone**\n\nObject的`clone`方法，当我们尝试调用一个没有实现**`Cloneable`**接口的类的clone方法时，clone会抛出`CloneNotSupportedException`\n\n```java\n    protected Object clone() throws CloneNotSupportedException {\n       if (!(this instanceof Cloneable)) {\n           throw new CloneNotSupportedException(\"Class \" + getClass().getName() +\n                                                \" doesn't implement Cloneable\");\n       }\n       return internalClone();\n   }\n```\n\n**考虑实现Comparable接口**\n\n注意`compareTo`不是Object的方法，而是`Comparable`接口的方法：\n\n```java\npublic interface Comparable<T>{\n   int compareTo(T t);\n}\n```\n\n如果不想写compareTo或者类并没有实现Comparable接口的，可以自定义一个`Comparator`类来进行比较。","source":"_posts/Effective Java/通用方法.md","raw":"---\ntitle: 通用方法\ncategories: \n- Effective Java\n---\n\n**覆盖equals时请遵守通用约定**\n\n> 什么时候应该覆盖equals\n\n当类需要逻辑相等这个概念的时候就应该覆盖equals，比如要判断两个`student`是否是同一个人，这个时候我们就需要按需重写equals\n\n> 逻辑相等，就是逻辑上是相等的，比如id一样，判定它们相等，即使它们是两个不同的对象\n\n> 通用约定\n\n重写equals的时候就必须要遵守它的通用约定：\n\n- 自反性(reflexive)，对于任何非null的引用值x，`x.equals(x)`必须返回true\n- 对称性(symmetric)，对于任何非null的引用值x和y，当且仅当`y.equals(x)`返回true时，`x.equals(y)`必须返回true\n- 传递性(transitive)，对于任何非null的引用值x，y，z，如果`x.equals(y)`为true，并且`y.equals(z)`也返回true，那么`x.equals(z)`也必须返回true\n- 一致性(consistent)，对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用\t`x.equals(y)`就会一致地返回true，或者false\n- 对于任何非null的引用值x，`x.equals(null)`必须返回false\n\n> 对equals提了几点建议:\n\n1. 使用`==`操作符检查**参数是否为这个对象的引用**，如果是，则返回true，这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做\n2. 使用`instanceof`操作符检查**参数是否为正确的类型**，如果不是，则返回false。\n3. 把参数装换成正确的类型。\n4. 对于该类中的每个关键域，检查参数中的域是否与对象中对应的域相配。(比如学生类有学号，班级，姓名这些重要的属性，我们都需要去比对)\n\n用一个`Student`类来总结一下equals的写法：\n\n```java\npublic class Student {\n   public String name;\n   public String className;\n   @Override\n   public boolean equals(Object obj) {\n       //对于一个null的对象 我们总是返回false\n       if (null == obj) {\n           return false;\n       }\n       // 利用instanceof检查类型后,强转\n       if (obj instanceof Student){\n           Student other = (Student) obj;\n           //再对关键的属性做比较 得出结论\n           if (name.equals(other.name) && className.equals(other.className)) {\n               return true;\n           }\n       }\n       return false;\n   }\n}\n```\n\n**覆盖equals时总要覆盖hashCode**\n\n> 不重写`hashCode`带来的问题\n\nhashCode其实主要用于基于散列的集合，如HashMap会把**相同的hashCode的对象放在同一个散列桶**(hash bucket)中，那么即使equals相同而hashCode不相等，那么跟HashMap一起使用，则**会得到与预期不相同的结果**.\n\n**始终要覆盖toString**\n\nObject类默认toString的实现方法是这样的：\n\n```java\npublic String toString() {\n\treturn getClass().getName() + '@' + Integer.toHexString(hashCode());\n}\n```\n\n它只有**类名+@+散列值**，`toString`的通用约定指出，被返回的字符串应该是一个简洁的，但信息丰富，并且易于阅读的表达形式。\n\n虽然够简单，但是信息并不丰富，而且更多时候我们更希望`toString`**返回对象中包含的所有值得关注的信息**，当属性多了，只显示信息重要的即可。\n\n**谨慎地覆盖clone**\n\nObject的`clone`方法，当我们尝试调用一个没有实现**`Cloneable`**接口的类的clone方法时，clone会抛出`CloneNotSupportedException`\n\n```java\n    protected Object clone() throws CloneNotSupportedException {\n       if (!(this instanceof Cloneable)) {\n           throw new CloneNotSupportedException(\"Class \" + getClass().getName() +\n                                                \" doesn't implement Cloneable\");\n       }\n       return internalClone();\n   }\n```\n\n**考虑实现Comparable接口**\n\n注意`compareTo`不是Object的方法，而是`Comparable`接口的方法：\n\n```java\npublic interface Comparable<T>{\n   int compareTo(T t);\n}\n```\n\n如果不想写compareTo或者类并没有实现Comparable接口的，可以自定义一个`Comparator`类来进行比较。","slug":"Effective Java/通用方法","published":1,"date":"2022-02-06T08:58:44.756Z","updated":"2022-02-06T09:06:34.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwej001sfhjidpso9f1p","content":"<p><strong>覆盖equals时请遵守通用约定</strong></p>\n<blockquote>\n<p>什么时候应该覆盖equals</p>\n</blockquote>\n<p>当类需要逻辑相等这个概念的时候就应该覆盖equals，比如要判断两个<code>student</code>是否是同一个人，这个时候我们就需要按需重写equals</p>\n<blockquote>\n<p>逻辑相等，就是逻辑上是相等的，比如id一样，判定它们相等，即使它们是两个不同的对象</p>\n</blockquote>\n<blockquote>\n<p>通用约定</p>\n</blockquote>\n<p>重写equals的时候就必须要遵守它的通用约定：</p>\n<ul>\n<li>自反性(reflexive)，对于任何非null的引用值x，<code>x.equals(x)</code>必须返回true</li>\n<li>对称性(symmetric)，对于任何非null的引用值x和y，当且仅当<code>y.equals(x)</code>返回true时，<code>x.equals(y)</code>必须返回true</li>\n<li>传递性(transitive)，对于任何非null的引用值x，y，z，如果<code>x.equals(y)</code>为true，并且<code>y.equals(z)</code>也返回true，那么<code>x.equals(z)</code>也必须返回true</li>\n<li>一致性(consistent)，对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用    <code>x.equals(y)</code>就会一致地返回true，或者false</li>\n<li>对于任何非null的引用值x，<code>x.equals(null)</code>必须返回false</li>\n</ul>\n<blockquote>\n<p>对equals提了几点建议:</p>\n</blockquote>\n<ol>\n<li>使用<code>==</code>操作符检查<strong>参数是否为这个对象的引用</strong>，如果是，则返回true，这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做</li>\n<li>使用<code>instanceof</code>操作符检查<strong>参数是否为正确的类型</strong>，如果不是，则返回false。</li>\n<li>把参数装换成正确的类型。</li>\n<li>对于该类中的每个关键域，检查参数中的域是否与对象中对应的域相配。(比如学生类有学号，班级，姓名这些重要的属性，我们都需要去比对)</li>\n</ol>\n<p>用一个<code>Student</code>类来总结一下equals的写法：</p>\n<pre><code class=\"java\">public class Student &#123;\n   public String name;\n   public String className;\n   @Override\n   public boolean equals(Object obj) &#123;\n       //对于一个null的对象 我们总是返回false\n       if (null == obj) &#123;\n           return false;\n       &#125;\n       // 利用instanceof检查类型后,强转\n       if (obj instanceof Student)&#123;\n           Student other = (Student) obj;\n           //再对关键的属性做比较 得出结论\n           if (name.equals(other.name) &amp;&amp; className.equals(other.className)) &#123;\n               return true;\n           &#125;\n       &#125;\n       return false;\n   &#125;\n&#125;\n</code></pre>\n<p><strong>覆盖equals时总要覆盖hashCode</strong></p>\n<blockquote>\n<p>不重写<code>hashCode</code>带来的问题</p>\n</blockquote>\n<p>hashCode其实主要用于基于散列的集合，如HashMap会把<strong>相同的hashCode的对象放在同一个散列桶</strong>(hash bucket)中，那么即使equals相同而hashCode不相等，那么跟HashMap一起使用，则<strong>会得到与预期不相同的结果</strong>.</p>\n<p><strong>始终要覆盖toString</strong></p>\n<p>Object类默认toString的实现方法是这样的：</p>\n<pre><code class=\"java\">public String toString() &#123;\n    return getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode());\n&#125;\n</code></pre>\n<p>它只有<strong>类名+@+散列值</strong>，<code>toString</code>的通用约定指出，被返回的字符串应该是一个简洁的，但信息丰富，并且易于阅读的表达形式。</p>\n<p>虽然够简单，但是信息并不丰富，而且更多时候我们更希望<code>toString</code><strong>返回对象中包含的所有值得关注的信息</strong>，当属性多了，只显示信息重要的即可。</p>\n<p><strong>谨慎地覆盖clone</strong></p>\n<p>Object的<code>clone</code>方法，当我们尝试调用一个没有实现**<code>Cloneable</code>**接口的类的clone方法时，clone会抛出<code>CloneNotSupportedException</code></p>\n<pre><code class=\"java\">    protected Object clone() throws CloneNotSupportedException &#123;\n       if (!(this instanceof Cloneable)) &#123;\n           throw new CloneNotSupportedException(&quot;Class &quot; + getClass().getName() +\n                                                &quot; doesn&#39;t implement Cloneable&quot;);\n       &#125;\n       return internalClone();\n   &#125;\n</code></pre>\n<p><strong>考虑实现Comparable接口</strong></p>\n<p>注意<code>compareTo</code>不是Object的方法，而是<code>Comparable</code>接口的方法：</p>\n<pre><code class=\"java\">public interface Comparable&lt;T&gt;&#123;\n   int compareTo(T t);\n&#125;\n</code></pre>\n<p>如果不想写compareTo或者类并没有实现Comparable接口的，可以自定义一个<code>Comparator</code>类来进行比较。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>覆盖equals时请遵守通用约定</strong></p>\n<blockquote>\n<p>什么时候应该覆盖equals</p>\n</blockquote>\n<p>当类需要逻辑相等这个概念的时候就应该覆盖equals，比如要判断两个<code>student</code>是否是同一个人，这个时候我们就需要按需重写equals</p>\n<blockquote>\n<p>逻辑相等，就是逻辑上是相等的，比如id一样，判定它们相等，即使它们是两个不同的对象</p>\n</blockquote>\n<blockquote>\n<p>通用约定</p>\n</blockquote>\n<p>重写equals的时候就必须要遵守它的通用约定：</p>\n<ul>\n<li>自反性(reflexive)，对于任何非null的引用值x，<code>x.equals(x)</code>必须返回true</li>\n<li>对称性(symmetric)，对于任何非null的引用值x和y，当且仅当<code>y.equals(x)</code>返回true时，<code>x.equals(y)</code>必须返回true</li>\n<li>传递性(transitive)，对于任何非null的引用值x，y，z，如果<code>x.equals(y)</code>为true，并且<code>y.equals(z)</code>也返回true，那么<code>x.equals(z)</code>也必须返回true</li>\n<li>一致性(consistent)，对于任何非null的引用值x和y，只要equals的比较操作在对象中所用的信息没有被修改，多次调用    <code>x.equals(y)</code>就会一致地返回true，或者false</li>\n<li>对于任何非null的引用值x，<code>x.equals(null)</code>必须返回false</li>\n</ul>\n<blockquote>\n<p>对equals提了几点建议:</p>\n</blockquote>\n<ol>\n<li>使用<code>==</code>操作符检查<strong>参数是否为这个对象的引用</strong>，如果是，则返回true，这只不过是一种性能优化，如果比较操作有可能很昂贵，就值得这么做</li>\n<li>使用<code>instanceof</code>操作符检查<strong>参数是否为正确的类型</strong>，如果不是，则返回false。</li>\n<li>把参数装换成正确的类型。</li>\n<li>对于该类中的每个关键域，检查参数中的域是否与对象中对应的域相配。(比如学生类有学号，班级，姓名这些重要的属性，我们都需要去比对)</li>\n</ol>\n<p>用一个<code>Student</code>类来总结一下equals的写法：</p>\n<pre><code class=\"java\">public class Student &#123;\n   public String name;\n   public String className;\n   @Override\n   public boolean equals(Object obj) &#123;\n       //对于一个null的对象 我们总是返回false\n       if (null == obj) &#123;\n           return false;\n       &#125;\n       // 利用instanceof检查类型后,强转\n       if (obj instanceof Student)&#123;\n           Student other = (Student) obj;\n           //再对关键的属性做比较 得出结论\n           if (name.equals(other.name) &amp;&amp; className.equals(other.className)) &#123;\n               return true;\n           &#125;\n       &#125;\n       return false;\n   &#125;\n&#125;\n</code></pre>\n<p><strong>覆盖equals时总要覆盖hashCode</strong></p>\n<blockquote>\n<p>不重写<code>hashCode</code>带来的问题</p>\n</blockquote>\n<p>hashCode其实主要用于基于散列的集合，如HashMap会把<strong>相同的hashCode的对象放在同一个散列桶</strong>(hash bucket)中，那么即使equals相同而hashCode不相等，那么跟HashMap一起使用，则<strong>会得到与预期不相同的结果</strong>.</p>\n<p><strong>始终要覆盖toString</strong></p>\n<p>Object类默认toString的实现方法是这样的：</p>\n<pre><code class=\"java\">public String toString() &#123;\n    return getClass().getName() + &#39;@&#39; + Integer.toHexString(hashCode());\n&#125;\n</code></pre>\n<p>它只有<strong>类名+@+散列值</strong>，<code>toString</code>的通用约定指出，被返回的字符串应该是一个简洁的，但信息丰富，并且易于阅读的表达形式。</p>\n<p>虽然够简单，但是信息并不丰富，而且更多时候我们更希望<code>toString</code><strong>返回对象中包含的所有值得关注的信息</strong>，当属性多了，只显示信息重要的即可。</p>\n<p><strong>谨慎地覆盖clone</strong></p>\n<p>Object的<code>clone</code>方法，当我们尝试调用一个没有实现**<code>Cloneable</code>**接口的类的clone方法时，clone会抛出<code>CloneNotSupportedException</code></p>\n<pre><code class=\"java\">    protected Object clone() throws CloneNotSupportedException &#123;\n       if (!(this instanceof Cloneable)) &#123;\n           throw new CloneNotSupportedException(&quot;Class &quot; + getClass().getName() +\n                                                &quot; doesn&#39;t implement Cloneable&quot;);\n       &#125;\n       return internalClone();\n   &#125;\n</code></pre>\n<p><strong>考虑实现Comparable接口</strong></p>\n<p>注意<code>compareTo</code>不是Object的方法，而是<code>Comparable</code>接口的方法：</p>\n<pre><code class=\"java\">public interface Comparable&lt;T&gt;&#123;\n   int compareTo(T t);\n&#125;\n</code></pre>\n<p>如果不想写compareTo或者类并没有实现Comparable接口的，可以自定义一个<code>Comparator</code>类来进行比较。</p>\n"},{"title":"ER模型","_content":"\nER模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。\n\n在开发基于数据库的信息系统的设计阶段，通常用ER模型来描述信息需求和信息特性，帮我们理清业务逻辑，从而设计出优秀的数据库。\n\n**在ER模型里面，有三个要素，分别是实体、属性和关系**。\n\n- 实体，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。比如，连锁超市就可以看做一个实体。\n- 在ER模型中，用矩形来表示。实体分为两类，分别是**强实体和弱实体。**强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。\n- 属性，则是指实体的特性。比如超市的地址、联系电话、员工数等。在ER模型中用椭圆形来表示。\n- 关系，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在ER模型中用菱形来表示。\n\n> 需要注意的是，有的时候，实体和属性不容易区分。\n>\n> 比如刚刚商品信息表中的商品的单位，到底是实体还是属性呢？\n\n如果从进货的角度出发，单位是商品的属性，但是从超市信息系统的整体出发，单位可以看做一个实体。\n\n**如何区分实体和属性呢？**\n\n我们要从系统整体的角度出发去看，**可以独立存在的是实体，不可再分的是属性**。\n\n* 也就是说，属性不需要进一步描述，不能包含其他属性。\n\n在ER模型的3个要素中，关系又可以分为3种类型，分别是**1对1、1对多和多对多**。\n\n1. 1对1：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是1对1的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。\n2. 1对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如超市与超市里的收款机之间的从属关系，超市可以拥有多台收款机，但是每一条收款机只能从属于一个超市。\n3. 多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。\n\n给超市业务创建ER模型，如下图所示：\n\n<img src=\"https://img-blog.csdnimg.cn/7355718ee89e4afe8a4d3969a933d121.png\" style=\"zoom:25%;\" />\n\n在这个图中，供货商和超市之间的供货关系，两边的数字都不是1，表示多对多的关系。\n\n* 同样，超市和顾客之间的零售关系，也是多对多的关系。\n\n这个ER模型，包括了3个实体之间的2种关系：\n\n1. 超市从供货商那里采购商品；\n2. 超市把商品卖给顾客。\n\n**ER模型的细化**\n\n超市业务模型，包括了两个模块，分别是进货模块和销售模块。\n\n<img src=\"https://img-blog.csdnimg.cn/ee25c201ebaf43658696262b7708aab1.png\" style=\"zoom:25%;\" />\n\n**如何把ER模型图转换成数据表？**\n\n**转换的原则**\n\n1. 一个实体通常转换成一个数据表；\n2. 一个多对多的关系，通常也转换成一个数据表；\n3. 一个1对1，或者1对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；\n4. 属性转换成表的字段。","source":"_posts/MySQL必知必会/ER模型.md","raw":"---\ntitle: ER模型\ncategories: \n- MySQL必知必会\n---\n\nER模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。\n\n在开发基于数据库的信息系统的设计阶段，通常用ER模型来描述信息需求和信息特性，帮我们理清业务逻辑，从而设计出优秀的数据库。\n\n**在ER模型里面，有三个要素，分别是实体、属性和关系**。\n\n- 实体，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。比如，连锁超市就可以看做一个实体。\n- 在ER模型中，用矩形来表示。实体分为两类，分别是**强实体和弱实体。**强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。\n- 属性，则是指实体的特性。比如超市的地址、联系电话、员工数等。在ER模型中用椭圆形来表示。\n- 关系，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在ER模型中用菱形来表示。\n\n> 需要注意的是，有的时候，实体和属性不容易区分。\n>\n> 比如刚刚商品信息表中的商品的单位，到底是实体还是属性呢？\n\n如果从进货的角度出发，单位是商品的属性，但是从超市信息系统的整体出发，单位可以看做一个实体。\n\n**如何区分实体和属性呢？**\n\n我们要从系统整体的角度出发去看，**可以独立存在的是实体，不可再分的是属性**。\n\n* 也就是说，属性不需要进一步描述，不能包含其他属性。\n\n在ER模型的3个要素中，关系又可以分为3种类型，分别是**1对1、1对多和多对多**。\n\n1. 1对1：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是1对1的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。\n2. 1对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如超市与超市里的收款机之间的从属关系，超市可以拥有多台收款机，但是每一条收款机只能从属于一个超市。\n3. 多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。\n\n给超市业务创建ER模型，如下图所示：\n\n<img src=\"https://img-blog.csdnimg.cn/7355718ee89e4afe8a4d3969a933d121.png\" style=\"zoom:25%;\" />\n\n在这个图中，供货商和超市之间的供货关系，两边的数字都不是1，表示多对多的关系。\n\n* 同样，超市和顾客之间的零售关系，也是多对多的关系。\n\n这个ER模型，包括了3个实体之间的2种关系：\n\n1. 超市从供货商那里采购商品；\n2. 超市把商品卖给顾客。\n\n**ER模型的细化**\n\n超市业务模型，包括了两个模块，分别是进货模块和销售模块。\n\n<img src=\"https://img-blog.csdnimg.cn/ee25c201ebaf43658696262b7708aab1.png\" style=\"zoom:25%;\" />\n\n**如何把ER模型图转换成数据表？**\n\n**转换的原则**\n\n1. 一个实体通常转换成一个数据表；\n2. 一个多对多的关系，通常也转换成一个数据表；\n3. 一个1对1，或者1对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；\n4. 属性转换成表的字段。","slug":"MySQL必知必会/ER模型","published":1,"date":"2022-03-13T17:42:13.168Z","updated":"2022-03-14T01:33:42.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwf6003vfhji95g42rkm","content":"<p>ER模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。</p>\n<p>在开发基于数据库的信息系统的设计阶段，通常用ER模型来描述信息需求和信息特性，帮我们理清业务逻辑，从而设计出优秀的数据库。</p>\n<p><strong>在ER模型里面，有三个要素，分别是实体、属性和关系</strong>。</p>\n<ul>\n<li>实体，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。比如，连锁超市就可以看做一个实体。</li>\n<li>在ER模型中，用矩形来表示。实体分为两类，分别是<strong>强实体和弱实体。</strong>强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</li>\n<li>属性，则是指实体的特性。比如超市的地址、联系电话、员工数等。在ER模型中用椭圆形来表示。</li>\n<li>关系，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在ER模型中用菱形来表示。</li>\n</ul>\n<blockquote>\n<p>需要注意的是，有的时候，实体和属性不容易区分。</p>\n<p>比如刚刚商品信息表中的商品的单位，到底是实体还是属性呢？</p>\n</blockquote>\n<p>如果从进货的角度出发，单位是商品的属性，但是从超市信息系统的整体出发，单位可以看做一个实体。</p>\n<p><strong>如何区分实体和属性呢？</strong></p>\n<p>我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。</p>\n<ul>\n<li>也就是说，属性不需要进一步描述，不能包含其他属性。</li>\n</ul>\n<p>在ER模型的3个要素中，关系又可以分为3种类型，分别是<strong>1对1、1对多和多对多</strong>。</p>\n<ol>\n<li>1对1：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是1对1的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</li>\n<li>1对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如超市与超市里的收款机之间的从属关系，超市可以拥有多台收款机，但是每一条收款机只能从属于一个超市。</li>\n<li>多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。</li>\n</ol>\n<p>给超市业务创建ER模型，如下图所示：</p>\n<img src=\"https://img-blog.csdnimg.cn/7355718ee89e4afe8a4d3969a933d121.png\" style=\"zoom:25%;\" />\n\n<p>在这个图中，供货商和超市之间的供货关系，两边的数字都不是1，表示多对多的关系。</p>\n<ul>\n<li>同样，超市和顾客之间的零售关系，也是多对多的关系。</li>\n</ul>\n<p>这个ER模型，包括了3个实体之间的2种关系：</p>\n<ol>\n<li>超市从供货商那里采购商品；</li>\n<li>超市把商品卖给顾客。</li>\n</ol>\n<p><strong>ER模型的细化</strong></p>\n<p>超市业务模型，包括了两个模块，分别是进货模块和销售模块。</p>\n<img src=\"https://img-blog.csdnimg.cn/ee25c201ebaf43658696262b7708aab1.png\" style=\"zoom:25%;\" />\n\n<p><strong>如何把ER模型图转换成数据表？</strong></p>\n<p><strong>转换的原则</strong></p>\n<ol>\n<li>一个实体通常转换成一个数据表；</li>\n<li>一个多对多的关系，通常也转换成一个数据表；</li>\n<li>一个1对1，或者1对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；</li>\n<li>属性转换成表的字段。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>ER模型也叫作实体关系模型，是用来描述现实生活中客观存在的事物、事物的属性，以及事物之间关系的一种数据模型。</p>\n<p>在开发基于数据库的信息系统的设计阶段，通常用ER模型来描述信息需求和信息特性，帮我们理清业务逻辑，从而设计出优秀的数据库。</p>\n<p><strong>在ER模型里面，有三个要素，分别是实体、属性和关系</strong>。</p>\n<ul>\n<li>实体，可以看做是数据对象，往往对应于现实生活中的真实存在的个体。比如，连锁超市就可以看做一个实体。</li>\n<li>在ER模型中，用矩形来表示。实体分为两类，分别是<strong>强实体和弱实体。</strong>强实体是指不依赖于其他实体的实体；弱实体是指对另一个实体有很强的依赖关系的实体。</li>\n<li>属性，则是指实体的特性。比如超市的地址、联系电话、员工数等。在ER模型中用椭圆形来表示。</li>\n<li>关系，则是指实体之间的联系。比如超市把商品卖给顾客，就是一种超市与顾客之间的联系。在ER模型中用菱形来表示。</li>\n</ul>\n<blockquote>\n<p>需要注意的是，有的时候，实体和属性不容易区分。</p>\n<p>比如刚刚商品信息表中的商品的单位，到底是实体还是属性呢？</p>\n</blockquote>\n<p>如果从进货的角度出发，单位是商品的属性，但是从超市信息系统的整体出发，单位可以看做一个实体。</p>\n<p><strong>如何区分实体和属性呢？</strong></p>\n<p>我们要从系统整体的角度出发去看，<strong>可以独立存在的是实体，不可再分的是属性</strong>。</p>\n<ul>\n<li>也就是说，属性不需要进一步描述，不能包含其他属性。</li>\n</ul>\n<p>在ER模型的3个要素中，关系又可以分为3种类型，分别是<strong>1对1、1对多和多对多</strong>。</p>\n<ol>\n<li>1对1：指实体之间的关系是一一对应的，比如个人与身份证信息之间的关系就是1对1的关系。一个人只能有一个身份证信息，一个身份证信息也只属于一个人。</li>\n<li>1对多：指一边的实体通过关系，可以对应多个另外一边的实体。相反，另外一边的实体通过这个关系，则只能对应唯一的一边的实体。比如超市与超市里的收款机之间的从属关系，超市可以拥有多台收款机，但是每一条收款机只能从属于一个超市。</li>\n<li>多对多：指关系两边的实体都可以通过关系对应多个对方的实体。比如在进货模块中，供货商与超市之间的关系就是多对多的关系，一个供货商可以给多个超市供货，一个超市也可以从多个供货商那里采购商品。</li>\n</ol>\n<p>给超市业务创建ER模型，如下图所示：</p>\n<img src=\"https://img-blog.csdnimg.cn/7355718ee89e4afe8a4d3969a933d121.png\" style=\"zoom:25%;\" />\n\n<p>在这个图中，供货商和超市之间的供货关系，两边的数字都不是1，表示多对多的关系。</p>\n<ul>\n<li>同样，超市和顾客之间的零售关系，也是多对多的关系。</li>\n</ul>\n<p>这个ER模型，包括了3个实体之间的2种关系：</p>\n<ol>\n<li>超市从供货商那里采购商品；</li>\n<li>超市把商品卖给顾客。</li>\n</ol>\n<p><strong>ER模型的细化</strong></p>\n<p>超市业务模型，包括了两个模块，分别是进货模块和销售模块。</p>\n<img src=\"https://img-blog.csdnimg.cn/ee25c201ebaf43658696262b7708aab1.png\" style=\"zoom:25%;\" />\n\n<p><strong>如何把ER模型图转换成数据表？</strong></p>\n<p><strong>转换的原则</strong></p>\n<ol>\n<li>一个实体通常转换成一个数据表；</li>\n<li>一个多对多的关系，通常也转换成一个数据表；</li>\n<li>一个1对1，或者1对多的关系，往往通过表的外键来表达，而不是设计一个新的数据表；</li>\n<li>属性转换成表的字段。</li>\n</ol>\n"},{"title":"字段类型","_content":"\n**整数类型**\n\n整数类型一共有5种，包括TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和BIGINT，它们的区别如下表所示：\n\n<img src=\"https://img-blog.csdnimg.cn/d571dc2c3fac4381b484f0a07c2138e6.png\" style=\"zoom:15%;\" />\n\n**浮点数类型和定点数类型**\n\nMySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL。\n\n- FLOAT表示单精度浮点数；\n- DOUBLE表示双精度浮点数；\n- REAL默认就是DOUBLE。\n\nFLOAT和DOUBLE这两种数据类型的区别是啥呢？\n\n> 其实就是，FLOAT占用字节数少，取值范围小；DOUBLE占用字节数多，取值范围也大。\n\n<img src=\"https://img-blog.csdnimg.cn/645cfcf4bff540dfbfa7432de56c0284.png\" style=\"zoom:15%;\" />\n\n**浮点数类型有个缺陷，就是不精准**。\n\n因此，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。\n\nMySQL精准的数据类型：定点数类型：DECIMAL。\n\nMySQL用DECIMAL（M,D）的方式表示高精度小数。\n\n> 其中，M表示整数部分加小数部分，一共有多少位，M<=65。D表示小数部分位数。\n\n**浮点数和定点数的特点：**\n\n* 浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）；\n\n* 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景（比如涉及金额计算的场景）。\n\n**文本类型**\n\nMySQL支持TEXT，CHAR、VARCHAR、ENUM和SET等文本类型。\n\n- CHAR(M)：固定长度字符串。CHAR(M)类型必须预先定义字符串长度。如果太短，数据可能会超出范围；如果太长，又浪费存储空间。\n- VARCHAR(M)： 可变长度字符串。VARCHAR(M)也需要预先知道字符串的最大长度，不过只要不超过这个最大长度，具体存储的时候，是按照实际字符串长度存储的。\n- TEXT：字符串。系统自动按照实际长度存储，不需要预先定义长度。\n- ENUM： 枚举类型，取值必须是预先设定的一组字符串值范围之内的一个，必须要知道字符串所有可能的取值。\n- SET：是一个字符串对象，取值必须是在预先设定的字符串值范围之内的0个或多个，也必须知道字符串所有可能的取值。\n\nTEXT类型也有4种，它们的区别就是最大长度不同。\n\n- TINYTEXT：255字符（这里假设字符是ASCII码，一个字符占用一个字节，下同）。\n- TEXT： 65535字符。\n- MEDIUMTEXT：16777215字符。\n- LONGTEXT： 4294967295字符（相当于4GB）。\n\nTEXT也有一个问题：\n\n* **由于实际存储的长度不确定，MySQL不允许TEXT类型的字段做主键。遇到这种情况，你只能采用CHAR(M)，或者VARCHAR(M)。**\n\n建议，在项目中只要不是主键字段，就可以按照数据可能的最大长度，选择这几种TEXT类型中的的一种，作为存储字符串的数据类型。\n\n**日期与时间类型**\n\n**用得最多的日期时间类型，是DATETIME**。\n\n虽然MySQL支持YEAR（年）、TIME（时间）、DATE（日期），TIMESTAMP类型，但是**建议在实际项目中，尽量用DATETIME类型**。\n\n* 因为这个数据类型包括了完整的日期和时间信息，使用起来比较方便。\n\n* 如果日期时间信息分散在好几个字段，就会很不容易记，而且查询的时候，SQL语句也会更加复杂。\n\n<img src=\"https://img-blog.csdnimg.cn/ed98493cc8474921bfc02db83e40339a.png\" style=\"zoom:15%;\" />\n\n可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。\n\n**一条小建议：**\n\n* 为了确保数据的完整性和系统的稳定性，优先考虑使用DATETIME类型。因为虽然DATETIME类型占用的存储空间最多，但是它表达的时间最为完整，取值范围也最大。","source":"_posts/MySQL必知必会/字段类型.md","raw":"---\ntitle: 字段类型\ncategories: \n- MySQL必知必会\n---\n\n**整数类型**\n\n整数类型一共有5种，包括TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和BIGINT，它们的区别如下表所示：\n\n<img src=\"https://img-blog.csdnimg.cn/d571dc2c3fac4381b484f0a07c2138e6.png\" style=\"zoom:15%;\" />\n\n**浮点数类型和定点数类型**\n\nMySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL。\n\n- FLOAT表示单精度浮点数；\n- DOUBLE表示双精度浮点数；\n- REAL默认就是DOUBLE。\n\nFLOAT和DOUBLE这两种数据类型的区别是啥呢？\n\n> 其实就是，FLOAT占用字节数少，取值范围小；DOUBLE占用字节数多，取值范围也大。\n\n<img src=\"https://img-blog.csdnimg.cn/645cfcf4bff540dfbfa7432de56c0284.png\" style=\"zoom:15%;\" />\n\n**浮点数类型有个缺陷，就是不精准**。\n\n因此，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。\n\nMySQL精准的数据类型：定点数类型：DECIMAL。\n\nMySQL用DECIMAL（M,D）的方式表示高精度小数。\n\n> 其中，M表示整数部分加小数部分，一共有多少位，M<=65。D表示小数部分位数。\n\n**浮点数和定点数的特点：**\n\n* 浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）；\n\n* 定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景（比如涉及金额计算的场景）。\n\n**文本类型**\n\nMySQL支持TEXT，CHAR、VARCHAR、ENUM和SET等文本类型。\n\n- CHAR(M)：固定长度字符串。CHAR(M)类型必须预先定义字符串长度。如果太短，数据可能会超出范围；如果太长，又浪费存储空间。\n- VARCHAR(M)： 可变长度字符串。VARCHAR(M)也需要预先知道字符串的最大长度，不过只要不超过这个最大长度，具体存储的时候，是按照实际字符串长度存储的。\n- TEXT：字符串。系统自动按照实际长度存储，不需要预先定义长度。\n- ENUM： 枚举类型，取值必须是预先设定的一组字符串值范围之内的一个，必须要知道字符串所有可能的取值。\n- SET：是一个字符串对象，取值必须是在预先设定的字符串值范围之内的0个或多个，也必须知道字符串所有可能的取值。\n\nTEXT类型也有4种，它们的区别就是最大长度不同。\n\n- TINYTEXT：255字符（这里假设字符是ASCII码，一个字符占用一个字节，下同）。\n- TEXT： 65535字符。\n- MEDIUMTEXT：16777215字符。\n- LONGTEXT： 4294967295字符（相当于4GB）。\n\nTEXT也有一个问题：\n\n* **由于实际存储的长度不确定，MySQL不允许TEXT类型的字段做主键。遇到这种情况，你只能采用CHAR(M)，或者VARCHAR(M)。**\n\n建议，在项目中只要不是主键字段，就可以按照数据可能的最大长度，选择这几种TEXT类型中的的一种，作为存储字符串的数据类型。\n\n**日期与时间类型**\n\n**用得最多的日期时间类型，是DATETIME**。\n\n虽然MySQL支持YEAR（年）、TIME（时间）、DATE（日期），TIMESTAMP类型，但是**建议在实际项目中，尽量用DATETIME类型**。\n\n* 因为这个数据类型包括了完整的日期和时间信息，使用起来比较方便。\n\n* 如果日期时间信息分散在好几个字段，就会很不容易记，而且查询的时候，SQL语句也会更加复杂。\n\n<img src=\"https://img-blog.csdnimg.cn/ed98493cc8474921bfc02db83e40339a.png\" style=\"zoom:15%;\" />\n\n可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。\n\n**一条小建议：**\n\n* 为了确保数据的完整性和系统的稳定性，优先考虑使用DATETIME类型。因为虽然DATETIME类型占用的存储空间最多，但是它表达的时间最为完整，取值范围也最大。","slug":"MySQL必知必会/字段类型","published":1,"date":"2022-03-07T15:24:31.559Z","updated":"2022-03-07T15:41:14.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwf6003wfhjih3t376hs","content":"<p><strong>整数类型</strong></p>\n<p>整数类型一共有5种，包括TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和BIGINT，它们的区别如下表所示：</p>\n<img src=\"https://img-blog.csdnimg.cn/d571dc2c3fac4381b484f0a07c2138e6.png\" style=\"zoom:15%;\" />\n\n<p><strong>浮点数类型和定点数类型</strong></p>\n<p>MySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL。</p>\n<ul>\n<li>FLOAT表示单精度浮点数；</li>\n<li>DOUBLE表示双精度浮点数；</li>\n<li>REAL默认就是DOUBLE。</li>\n</ul>\n<p>FLOAT和DOUBLE这两种数据类型的区别是啥呢？</p>\n<blockquote>\n<p>其实就是，FLOAT占用字节数少，取值范围小；DOUBLE占用字节数多，取值范围也大。</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/645cfcf4bff540dfbfa7432de56c0284.png\" style=\"zoom:15%;\" />\n\n<p><strong>浮点数类型有个缺陷，就是不精准</strong>。</p>\n<p>因此，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。</p>\n<p>MySQL精准的数据类型：定点数类型：DECIMAL。</p>\n<p>MySQL用DECIMAL（M,D）的方式表示高精度小数。</p>\n<blockquote>\n<p>其中，M表示整数部分加小数部分，一共有多少位，M&lt;&#x3D;65。D表示小数部分位数。</p>\n</blockquote>\n<p><strong>浮点数和定点数的特点：</strong></p>\n<ul>\n<li><p>浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）；</p>\n</li>\n<li><p>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景（比如涉及金额计算的场景）。</p>\n</li>\n</ul>\n<p><strong>文本类型</strong></p>\n<p>MySQL支持TEXT，CHAR、VARCHAR、ENUM和SET等文本类型。</p>\n<ul>\n<li>CHAR(M)：固定长度字符串。CHAR(M)类型必须预先定义字符串长度。如果太短，数据可能会超出范围；如果太长，又浪费存储空间。</li>\n<li>VARCHAR(M)： 可变长度字符串。VARCHAR(M)也需要预先知道字符串的最大长度，不过只要不超过这个最大长度，具体存储的时候，是按照实际字符串长度存储的。</li>\n<li>TEXT：字符串。系统自动按照实际长度存储，不需要预先定义长度。</li>\n<li>ENUM： 枚举类型，取值必须是预先设定的一组字符串值范围之内的一个，必须要知道字符串所有可能的取值。</li>\n<li>SET：是一个字符串对象，取值必须是在预先设定的字符串值范围之内的0个或多个，也必须知道字符串所有可能的取值。</li>\n</ul>\n<p>TEXT类型也有4种，它们的区别就是最大长度不同。</p>\n<ul>\n<li>TINYTEXT：255字符（这里假设字符是ASCII码，一个字符占用一个字节，下同）。</li>\n<li>TEXT： 65535字符。</li>\n<li>MEDIUMTEXT：16777215字符。</li>\n<li>LONGTEXT： 4294967295字符（相当于4GB）。</li>\n</ul>\n<p>TEXT也有一个问题：</p>\n<ul>\n<li><strong>由于实际存储的长度不确定，MySQL不允许TEXT类型的字段做主键。遇到这种情况，你只能采用CHAR(M)，或者VARCHAR(M)。</strong></li>\n</ul>\n<p>建议，在项目中只要不是主键字段，就可以按照数据可能的最大长度，选择这几种TEXT类型中的的一种，作为存储字符串的数据类型。</p>\n<p><strong>日期与时间类型</strong></p>\n<p><strong>用得最多的日期时间类型，是DATETIME</strong>。</p>\n<p>虽然MySQL支持YEAR（年）、TIME（时间）、DATE（日期），TIMESTAMP类型，但是<strong>建议在实际项目中，尽量用DATETIME类型</strong>。</p>\n<ul>\n<li><p>因为这个数据类型包括了完整的日期和时间信息，使用起来比较方便。</p>\n</li>\n<li><p>如果日期时间信息分散在好几个字段，就会很不容易记，而且查询的时候，SQL语句也会更加复杂。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/ed98493cc8474921bfc02db83e40339a.png\" style=\"zoom:15%;\" />\n\n<p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p>\n<p><strong>一条小建议：</strong></p>\n<ul>\n<li>为了确保数据的完整性和系统的稳定性，优先考虑使用DATETIME类型。因为虽然DATETIME类型占用的存储空间最多，但是它表达的时间最为完整，取值范围也最大。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>整数类型</strong></p>\n<p>整数类型一共有5种，包括TINYINT、SMALLINT、MEDIUMINT、INT（INTEGER）和BIGINT，它们的区别如下表所示：</p>\n<img src=\"https://img-blog.csdnimg.cn/d571dc2c3fac4381b484f0a07c2138e6.png\" style=\"zoom:15%;\" />\n\n<p><strong>浮点数类型和定点数类型</strong></p>\n<p>MySQL支持的浮点数类型，分别是FLOAT、DOUBLE、REAL。</p>\n<ul>\n<li>FLOAT表示单精度浮点数；</li>\n<li>DOUBLE表示双精度浮点数；</li>\n<li>REAL默认就是DOUBLE。</li>\n</ul>\n<p>FLOAT和DOUBLE这两种数据类型的区别是啥呢？</p>\n<blockquote>\n<p>其实就是，FLOAT占用字节数少，取值范围小；DOUBLE占用字节数多，取值范围也大。</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/645cfcf4bff540dfbfa7432de56c0284.png\" style=\"zoom:15%;\" />\n\n<p><strong>浮点数类型有个缺陷，就是不精准</strong>。</p>\n<p>因此，在一些对精确度要求较高的项目中，千万不要使用浮点数，不然会导致结果错误，甚至是造成不可挽回的损失。</p>\n<p>MySQL精准的数据类型：定点数类型：DECIMAL。</p>\n<p>MySQL用DECIMAL（M,D）的方式表示高精度小数。</p>\n<blockquote>\n<p>其中，M表示整数部分加小数部分，一共有多少位，M&lt;&#x3D;65。D表示小数部分位数。</p>\n</blockquote>\n<p><strong>浮点数和定点数的特点：</strong></p>\n<ul>\n<li><p>浮点类型取值范围大，但是不精准，适用于需要取值范围大，又可以容忍微小误差的科学计算场景（比如计算化学、分子建模、流体动力学等）；</p>\n</li>\n<li><p>定点数类型取值范围相对小，但是精准，没有误差，适合于对精度要求极高的场景（比如涉及金额计算的场景）。</p>\n</li>\n</ul>\n<p><strong>文本类型</strong></p>\n<p>MySQL支持TEXT，CHAR、VARCHAR、ENUM和SET等文本类型。</p>\n<ul>\n<li>CHAR(M)：固定长度字符串。CHAR(M)类型必须预先定义字符串长度。如果太短，数据可能会超出范围；如果太长，又浪费存储空间。</li>\n<li>VARCHAR(M)： 可变长度字符串。VARCHAR(M)也需要预先知道字符串的最大长度，不过只要不超过这个最大长度，具体存储的时候，是按照实际字符串长度存储的。</li>\n<li>TEXT：字符串。系统自动按照实际长度存储，不需要预先定义长度。</li>\n<li>ENUM： 枚举类型，取值必须是预先设定的一组字符串值范围之内的一个，必须要知道字符串所有可能的取值。</li>\n<li>SET：是一个字符串对象，取值必须是在预先设定的字符串值范围之内的0个或多个，也必须知道字符串所有可能的取值。</li>\n</ul>\n<p>TEXT类型也有4种，它们的区别就是最大长度不同。</p>\n<ul>\n<li>TINYTEXT：255字符（这里假设字符是ASCII码，一个字符占用一个字节，下同）。</li>\n<li>TEXT： 65535字符。</li>\n<li>MEDIUMTEXT：16777215字符。</li>\n<li>LONGTEXT： 4294967295字符（相当于4GB）。</li>\n</ul>\n<p>TEXT也有一个问题：</p>\n<ul>\n<li><strong>由于实际存储的长度不确定，MySQL不允许TEXT类型的字段做主键。遇到这种情况，你只能采用CHAR(M)，或者VARCHAR(M)。</strong></li>\n</ul>\n<p>建议，在项目中只要不是主键字段，就可以按照数据可能的最大长度，选择这几种TEXT类型中的的一种，作为存储字符串的数据类型。</p>\n<p><strong>日期与时间类型</strong></p>\n<p><strong>用得最多的日期时间类型，是DATETIME</strong>。</p>\n<p>虽然MySQL支持YEAR（年）、TIME（时间）、DATE（日期），TIMESTAMP类型，但是<strong>建议在实际项目中，尽量用DATETIME类型</strong>。</p>\n<ul>\n<li><p>因为这个数据类型包括了完整的日期和时间信息，使用起来比较方便。</p>\n</li>\n<li><p>如果日期时间信息分散在好几个字段，就会很不容易记，而且查询的时候，SQL语句也会更加复杂。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/ed98493cc8474921bfc02db83e40339a.png\" style=\"zoom:15%;\" />\n\n<p>可以看到，不同数据类型表示的时间内容不同、取值范围不同，而且占用的字节数也不一样，你要根据实际需要灵活选取。</p>\n<p><strong>一条小建议：</strong></p>\n<ul>\n<li>为了确保数据的完整性和系统的稳定性，优先考虑使用DATETIME类型。因为虽然DATETIME类型占用的存储空间最多，但是它表达的时间最为完整，取值范围也最大。</li>\n</ul>\n"},{"title":"数据备份","_content":"\nMySQL的数据备份有2种，一种是物理备份，通过把数据文件复制出来，达到备份的目的；另外一种是逻辑备份，通过把描述数据库结构和内容的信息保存起来，达到备份的目的。\n\n逻辑备份这种方式是免费的，广泛得到使用；而物理备份的方式需要收费，用得比较少。\n\n**如何备份数据库中的表？**\n\n使用mysqldump备份数据库中的表：\n\n```\nmysqldump -h 服务器 -u 用户 -p 密码 数据库名称 [表名称 … ] > 备份文件名称\n```\n\n**如何备份数据库？**\n\n```\nmysqldump -h 服务器 -u 用户 -p 密码 --databases 数据库名称 … > 备份文件名\n```\n\n**如何备份整个数据库服务器？**\n\n```\nmysqldump -h 服务器 -u 用户 -p 密码 --all-databases > 备份文件名\n```\n\n**如何进行数据恢复？**\n\n数据恢复的方法主要有2种：\n\n- 使用mysql命令行客户端工具进行数据恢复；\n- 使用SOURCE语句进行数据恢复。\n\n```\nH:>mysql -u root -p demo < test.sql\n```\n\n```\nSOURCE 备份文件名\n```\n\n**如何导出和导入表里的数据？**\n\n> SELECT语句导出数据\n\n使用`SELECT … INTO OUTFILE`语句导出数据表\n\n```\nSELECT 字段列表 INTO OUTFILE 文件名称\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符\nFROM 表名;\n```\n\n> 使用LOAD DATA语句导入数据\n\n```\nLOAD DATA INFILE 文件名\nINTO TABLE 表名\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符;\n```","source":"_posts/MySQL必知必会/数据备份.md","raw":"---\ntitle: 数据备份\ncategories: \n- MySQL必知必会\n---\n\nMySQL的数据备份有2种，一种是物理备份，通过把数据文件复制出来，达到备份的目的；另外一种是逻辑备份，通过把描述数据库结构和内容的信息保存起来，达到备份的目的。\n\n逻辑备份这种方式是免费的，广泛得到使用；而物理备份的方式需要收费，用得比较少。\n\n**如何备份数据库中的表？**\n\n使用mysqldump备份数据库中的表：\n\n```\nmysqldump -h 服务器 -u 用户 -p 密码 数据库名称 [表名称 … ] > 备份文件名称\n```\n\n**如何备份数据库？**\n\n```\nmysqldump -h 服务器 -u 用户 -p 密码 --databases 数据库名称 … > 备份文件名\n```\n\n**如何备份整个数据库服务器？**\n\n```\nmysqldump -h 服务器 -u 用户 -p 密码 --all-databases > 备份文件名\n```\n\n**如何进行数据恢复？**\n\n数据恢复的方法主要有2种：\n\n- 使用mysql命令行客户端工具进行数据恢复；\n- 使用SOURCE语句进行数据恢复。\n\n```\nH:>mysql -u root -p demo < test.sql\n```\n\n```\nSOURCE 备份文件名\n```\n\n**如何导出和导入表里的数据？**\n\n> SELECT语句导出数据\n\n使用`SELECT … INTO OUTFILE`语句导出数据表\n\n```\nSELECT 字段列表 INTO OUTFILE 文件名称\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符\nFROM 表名;\n```\n\n> 使用LOAD DATA语句导入数据\n\n```\nLOAD DATA INFILE 文件名\nINTO TABLE 表名\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符;\n```","slug":"MySQL必知必会/数据备份","published":1,"date":"2022-03-13T03:23:23.813Z","updated":"2022-03-13T03:32:18.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwf7003zfhji7rqnaz6c","content":"<p>MySQL的数据备份有2种，一种是物理备份，通过把数据文件复制出来，达到备份的目的；另外一种是逻辑备份，通过把描述数据库结构和内容的信息保存起来，达到备份的目的。</p>\n<p>逻辑备份这种方式是免费的，广泛得到使用；而物理备份的方式需要收费，用得比较少。</p>\n<p><strong>如何备份数据库中的表？</strong></p>\n<p>使用mysqldump备份数据库中的表：</p>\n<pre><code>mysqldump -h 服务器 -u 用户 -p 密码 数据库名称 [表名称 … ] &gt; 备份文件名称\n</code></pre>\n<p><strong>如何备份数据库？</strong></p>\n<pre><code>mysqldump -h 服务器 -u 用户 -p 密码 --databases 数据库名称 … &gt; 备份文件名\n</code></pre>\n<p><strong>如何备份整个数据库服务器？</strong></p>\n<pre><code>mysqldump -h 服务器 -u 用户 -p 密码 --all-databases &gt; 备份文件名\n</code></pre>\n<p><strong>如何进行数据恢复？</strong></p>\n<p>数据恢复的方法主要有2种：</p>\n<ul>\n<li>使用mysql命令行客户端工具进行数据恢复；</li>\n<li>使用SOURCE语句进行数据恢复。</li>\n</ul>\n<pre><code>H:&gt;mysql -u root -p demo &lt; test.sql\n</code></pre>\n<pre><code>SOURCE 备份文件名\n</code></pre>\n<p><strong>如何导出和导入表里的数据？</strong></p>\n<blockquote>\n<p>SELECT语句导出数据</p>\n</blockquote>\n<p>使用<code>SELECT … INTO OUTFILE</code>语句导出数据表</p>\n<pre><code>SELECT 字段列表 INTO OUTFILE 文件名称\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符\nFROM 表名;\n</code></pre>\n<blockquote>\n<p>使用LOAD DATA语句导入数据</p>\n</blockquote>\n<pre><code>LOAD DATA INFILE 文件名\nINTO TABLE 表名\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL的数据备份有2种，一种是物理备份，通过把数据文件复制出来，达到备份的目的；另外一种是逻辑备份，通过把描述数据库结构和内容的信息保存起来，达到备份的目的。</p>\n<p>逻辑备份这种方式是免费的，广泛得到使用；而物理备份的方式需要收费，用得比较少。</p>\n<p><strong>如何备份数据库中的表？</strong></p>\n<p>使用mysqldump备份数据库中的表：</p>\n<pre><code>mysqldump -h 服务器 -u 用户 -p 密码 数据库名称 [表名称 … ] &gt; 备份文件名称\n</code></pre>\n<p><strong>如何备份数据库？</strong></p>\n<pre><code>mysqldump -h 服务器 -u 用户 -p 密码 --databases 数据库名称 … &gt; 备份文件名\n</code></pre>\n<p><strong>如何备份整个数据库服务器？</strong></p>\n<pre><code>mysqldump -h 服务器 -u 用户 -p 密码 --all-databases &gt; 备份文件名\n</code></pre>\n<p><strong>如何进行数据恢复？</strong></p>\n<p>数据恢复的方法主要有2种：</p>\n<ul>\n<li>使用mysql命令行客户端工具进行数据恢复；</li>\n<li>使用SOURCE语句进行数据恢复。</li>\n</ul>\n<pre><code>H:&gt;mysql -u root -p demo &lt; test.sql\n</code></pre>\n<pre><code>SOURCE 备份文件名\n</code></pre>\n<p><strong>如何导出和导入表里的数据？</strong></p>\n<blockquote>\n<p>SELECT语句导出数据</p>\n</blockquote>\n<p>使用<code>SELECT … INTO OUTFILE</code>语句导出数据表</p>\n<pre><code>SELECT 字段列表 INTO OUTFILE 文件名称\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符\nFROM 表名;\n</code></pre>\n<blockquote>\n<p>使用LOAD DATA语句导入数据</p>\n</blockquote>\n<pre><code>LOAD DATA INFILE 文件名\nINTO TABLE 表名\nFIELDS TERMINATED BY 字符\nLINES TERMINATED BY 字符;\n</code></pre>\n"},{"title":"日志查看","_content":"\n**通用查询日志**\n\n通用查询日志记录了所有用户的连接开始时间和截止时间，以及发给MySQL数据库服务器的所有SQL指令。\n\n查询一下通用查询日志的状态：\n\n```\nmysql> SHOW VARIABLES LIKE '%general%';\n+------------------+--------------+\n| Variable_name | Value |\n+------------------+--------------+\n| general_log | ON | -- 通用查询日志开启\n| general_log_file | H:mytest.log |  -- 日志名称也改过了\n+------------------+--------------+\n2 rows in set, 1 warning (0.00 sec)\n```\n\n通用查询日志的内容，包括都有哪些连接，什么时候登录了数据库，都做了哪些操作等信息。\n\n```\n2021-04-05T06:39:53.621980Z 28 Connect zhangsan@localhost on using SSL/TLS   -- 账号zhangsan从本地登录\n2021-04-05T06:39:53.622085Z 28 Connect Access denied for user 'zhangsan'@'localhost' (using password: NO)  -- 没有使用密码，连接被拒绝了\n2021-04-05T06:40:02.522303Z 29 Connect zhangsan@localhost on using SSL/TLS\n2021-04-05T06:40:02.522913Z 29 Query select @@version_comment limit 1\n2021-04-05T06:40:14.211511Z 29 Query SELECT *\nFROM demo.invcount                         -- 查询数据表demo.invcount内容\n2021-04-05T06:40:37.647625Z 29 Query UPDATE demo.invcount\nSET plquant = - 5                          -- 更新数据表demo.invcount\nWHERE itemnumber = 1\n2021-04-05T06:41:15.047067Z 29 Query SELECT *\nFROM demo.goodsmaster                      -- 查询数据表demo.goodsmaster\n```\n\n在通用查询日志里面，我们可以清楚地看到，账号zhangsan是什么时间登录的服务器，登录之后做了什么SQL操作，针对的是哪个数据表等信息。\n\n**慢查询日志**\n\n慢查询日志用来记录执行时间超过指定时长的查询。\n\n慢查询日志变量的相关设定：\n\n```\nslow-query-log=1 -- 表示开启慢查询日志，系统将会对慢查询进行记录。\n \nslow_query_log_file=\"GJTECH-PC-slow.log\"  -- 表示慢查询日志的名称是\"GJTECH-PC-slow.log\"。\n \nlong_query_time=10  -- 表示慢查询的标准是查询执行时间超过10秒\n\nmin_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。\n```\n\n如果查询扫描过的记录数大于等于变量`min_examined_row_limit`的值，并且查询执行时间超过`long_query_time`的值，那么这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。\n\n查看当前系统变量的值：\n\n```\nmysql> show variables like 'min%';\n+------------------------+-------+\n| Variable_name | Value |\n+------------------------+-------+\n| min_examined_row_limit | 0 |\n+------------------------+-------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n下面这个例子记录了一个运行时间超过10秒的慢查询的发生时间、连接所属的用户、执行的时长、锁表的时长和扫描过的记录数等相关信息。\n\n```\nC:Program FilesMySQLMySQL Server 8.0binmysqld.exe, Version: 8.0.23 (MySQL Community Server - GPL). started with:\nTCP Port: 3306, Named Pipe: MySQL\nTime Id Command Argument\n# Time: 2021-03-25T07:20:33.412260Z     -- 执行开始时间\n# User@Host: root[root] @ localhost [::1] Id: 13   -- 用户\n# Query_time: 10.166435 Lock_time: 0.000000 Rows_sent: 0  Rows_examined: 0                        -- 执行时长、锁表时长、检查的记录数\nuse demo;\nSET timestamp=1616656823;\n```\n\n通过这个慢查询日志的记录，我们就可以发现是哪个查询消耗了大量的系统资源，是哪个连接里面的查询，具体什么时间开始的。\n\n有了这些信息，我们就可以对慢查询进行分析，决定优化的方式，避免出现同样的问题。\n\n**错误日志**\n\n错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示等。\n\n当我们的数据库服务器发生系统故障时，错误日志是发现问题、解决故障的首选。\n\n我们查看一下错误日志的内容：\n\n```\n2021-02-28T08:07:07.228880Z 0 [System] [MY-010116] [Server] C:Program FilesMySQLMySQL Server 8.0binmysqld.exe (mysqld 8.0.23) starting as process 7652\n2021-02-28T08:07:07.270982Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.\n2021-02-28T08:07:08.116433Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.\n```\n\n可以看到，错误日志文件中记录了服务器启动的时间，以及存储引擎InnoDB启动和停止的时间等。\n\n**二进制日志**\n\n**二进制日志主要记录数据库的更新事件**，比如创建数据表、更新表中的数据、数据更新所花费的时长等信息。\n\n* 二进制日志是进行数据恢复和数据复制的利器。\n\n**用二进制日志恢复数据**\n\n我们可以用mysqlbinlog工具进行数据恢复：\n\n```\nmysqlbinlog –start-positon=xxx –end-position=yyy 二进制文件名 | mysql -u 用户 -p\n```\n\n这条命令的意思是，执行二进制日志中从位置xxx开始，到yyy截止的所有数据更新操作。\n\n这里的截止位置也可以不写，意思是从位置xxx开始，执行二进制文件中的所有数据更新操作。\n\n* 二进制日志还有一个重要的功能，就是在主从服务器的架构中，把主服务器的操作复制到从服务器。\n\n而这个操作要借助中继日志一起完成。\n\n**中继日志**\n\n中继日志只在主从服务器架构的从服务器上存在。\n\n从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。\n\n然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。\n\n**回滚日志**\n\n回滚日志的作用是进行事务回滚。\n\n* 当事务执行的时候，回滚日志中记录了事务中每次数据更新前的状态。\n\n* 当事务需要回滚的时候，可以通过读取回滚日志，恢复到指定的位置。\n\n另一方面，回滚日志也可以让其他的事务读取到这个事务对数据更改之前的值，从而确保了其他事务可以不受这个事务修改数据的影响。\n\n**重做日志**\n\n重做日志是存储在磁盘上的一种日志文件，主要有2个作用。\n\n* 在系统遇到故障的恢复过程中，可以修复被未完成的事务修改的数据。\n\n* MySQL为了提高数据存取的效率，减少磁盘操作的频率，对数据的更新操作不会立即写到磁盘上，而是把数据更新先保存在内存中，积累到一定程度，再集中进行磁盘读写操作。\n\n这样就存在一个问题：一旦出现宕机或者停电等异常情况，内存中保存的数据更新操作可能会丢失。\n\n这个时候就可以通过读取重做日志中记录的数据更新操作，把没来得及写到磁盘上的数据更新写到磁盘上，确保数据的完整性。","source":"_posts/MySQL必知必会/日志查看.md","raw":"---\ntitle: 日志查看\ncategories: \n- MySQL必知必会\n---\n\n**通用查询日志**\n\n通用查询日志记录了所有用户的连接开始时间和截止时间，以及发给MySQL数据库服务器的所有SQL指令。\n\n查询一下通用查询日志的状态：\n\n```\nmysql> SHOW VARIABLES LIKE '%general%';\n+------------------+--------------+\n| Variable_name | Value |\n+------------------+--------------+\n| general_log | ON | -- 通用查询日志开启\n| general_log_file | H:mytest.log |  -- 日志名称也改过了\n+------------------+--------------+\n2 rows in set, 1 warning (0.00 sec)\n```\n\n通用查询日志的内容，包括都有哪些连接，什么时候登录了数据库，都做了哪些操作等信息。\n\n```\n2021-04-05T06:39:53.621980Z 28 Connect zhangsan@localhost on using SSL/TLS   -- 账号zhangsan从本地登录\n2021-04-05T06:39:53.622085Z 28 Connect Access denied for user 'zhangsan'@'localhost' (using password: NO)  -- 没有使用密码，连接被拒绝了\n2021-04-05T06:40:02.522303Z 29 Connect zhangsan@localhost on using SSL/TLS\n2021-04-05T06:40:02.522913Z 29 Query select @@version_comment limit 1\n2021-04-05T06:40:14.211511Z 29 Query SELECT *\nFROM demo.invcount                         -- 查询数据表demo.invcount内容\n2021-04-05T06:40:37.647625Z 29 Query UPDATE demo.invcount\nSET plquant = - 5                          -- 更新数据表demo.invcount\nWHERE itemnumber = 1\n2021-04-05T06:41:15.047067Z 29 Query SELECT *\nFROM demo.goodsmaster                      -- 查询数据表demo.goodsmaster\n```\n\n在通用查询日志里面，我们可以清楚地看到，账号zhangsan是什么时间登录的服务器，登录之后做了什么SQL操作，针对的是哪个数据表等信息。\n\n**慢查询日志**\n\n慢查询日志用来记录执行时间超过指定时长的查询。\n\n慢查询日志变量的相关设定：\n\n```\nslow-query-log=1 -- 表示开启慢查询日志，系统将会对慢查询进行记录。\n \nslow_query_log_file=\"GJTECH-PC-slow.log\"  -- 表示慢查询日志的名称是\"GJTECH-PC-slow.log\"。\n \nlong_query_time=10  -- 表示慢查询的标准是查询执行时间超过10秒\n\nmin_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。\n```\n\n如果查询扫描过的记录数大于等于变量`min_examined_row_limit`的值，并且查询执行时间超过`long_query_time`的值，那么这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。\n\n查看当前系统变量的值：\n\n```\nmysql> show variables like 'min%';\n+------------------------+-------+\n| Variable_name | Value |\n+------------------------+-------+\n| min_examined_row_limit | 0 |\n+------------------------+-------+\n1 row in set, 1 warning (0.00 sec)\n```\n\n下面这个例子记录了一个运行时间超过10秒的慢查询的发生时间、连接所属的用户、执行的时长、锁表的时长和扫描过的记录数等相关信息。\n\n```\nC:Program FilesMySQLMySQL Server 8.0binmysqld.exe, Version: 8.0.23 (MySQL Community Server - GPL). started with:\nTCP Port: 3306, Named Pipe: MySQL\nTime Id Command Argument\n# Time: 2021-03-25T07:20:33.412260Z     -- 执行开始时间\n# User@Host: root[root] @ localhost [::1] Id: 13   -- 用户\n# Query_time: 10.166435 Lock_time: 0.000000 Rows_sent: 0  Rows_examined: 0                        -- 执行时长、锁表时长、检查的记录数\nuse demo;\nSET timestamp=1616656823;\n```\n\n通过这个慢查询日志的记录，我们就可以发现是哪个查询消耗了大量的系统资源，是哪个连接里面的查询，具体什么时间开始的。\n\n有了这些信息，我们就可以对慢查询进行分析，决定优化的方式，避免出现同样的问题。\n\n**错误日志**\n\n错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示等。\n\n当我们的数据库服务器发生系统故障时，错误日志是发现问题、解决故障的首选。\n\n我们查看一下错误日志的内容：\n\n```\n2021-02-28T08:07:07.228880Z 0 [System] [MY-010116] [Server] C:Program FilesMySQLMySQL Server 8.0binmysqld.exe (mysqld 8.0.23) starting as process 7652\n2021-02-28T08:07:07.270982Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.\n2021-02-28T08:07:08.116433Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.\n```\n\n可以看到，错误日志文件中记录了服务器启动的时间，以及存储引擎InnoDB启动和停止的时间等。\n\n**二进制日志**\n\n**二进制日志主要记录数据库的更新事件**，比如创建数据表、更新表中的数据、数据更新所花费的时长等信息。\n\n* 二进制日志是进行数据恢复和数据复制的利器。\n\n**用二进制日志恢复数据**\n\n我们可以用mysqlbinlog工具进行数据恢复：\n\n```\nmysqlbinlog –start-positon=xxx –end-position=yyy 二进制文件名 | mysql -u 用户 -p\n```\n\n这条命令的意思是，执行二进制日志中从位置xxx开始，到yyy截止的所有数据更新操作。\n\n这里的截止位置也可以不写，意思是从位置xxx开始，执行二进制文件中的所有数据更新操作。\n\n* 二进制日志还有一个重要的功能，就是在主从服务器的架构中，把主服务器的操作复制到从服务器。\n\n而这个操作要借助中继日志一起完成。\n\n**中继日志**\n\n中继日志只在主从服务器架构的从服务器上存在。\n\n从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。\n\n然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。\n\n**回滚日志**\n\n回滚日志的作用是进行事务回滚。\n\n* 当事务执行的时候，回滚日志中记录了事务中每次数据更新前的状态。\n\n* 当事务需要回滚的时候，可以通过读取回滚日志，恢复到指定的位置。\n\n另一方面，回滚日志也可以让其他的事务读取到这个事务对数据更改之前的值，从而确保了其他事务可以不受这个事务修改数据的影响。\n\n**重做日志**\n\n重做日志是存储在磁盘上的一种日志文件，主要有2个作用。\n\n* 在系统遇到故障的恢复过程中，可以修复被未完成的事务修改的数据。\n\n* MySQL为了提高数据存取的效率，减少磁盘操作的频率，对数据的更新操作不会立即写到磁盘上，而是把数据更新先保存在内存中，积累到一定程度，再集中进行磁盘读写操作。\n\n这样就存在一个问题：一旦出现宕机或者停电等异常情况，内存中保存的数据更新操作可能会丢失。\n\n这个时候就可以通过读取重做日志中记录的数据更新操作，把没来得及写到磁盘上的数据更新写到磁盘上，确保数据的完整性。","slug":"MySQL必知必会/日志查看","published":1,"date":"2022-03-12T02:36:28.465Z","updated":"2022-03-12T03:20:09.970Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwf80040fhjicsg231fx","content":"<p><strong>通用查询日志</strong></p>\n<p>通用查询日志记录了所有用户的连接开始时间和截止时间，以及发给MySQL数据库服务器的所有SQL指令。</p>\n<p>查询一下通用查询日志的状态：</p>\n<pre><code>mysql&gt; SHOW VARIABLES LIKE &#39;%general%&#39;;\n+------------------+--------------+\n| Variable_name | Value |\n+------------------+--------------+\n| general_log | ON | -- 通用查询日志开启\n| general_log_file | H:mytest.log |  -- 日志名称也改过了\n+------------------+--------------+\n2 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<p>通用查询日志的内容，包括都有哪些连接，什么时候登录了数据库，都做了哪些操作等信息。</p>\n<pre><code>2021-04-05T06:39:53.621980Z 28 Connect zhangsan@localhost on using SSL/TLS   -- 账号zhangsan从本地登录\n2021-04-05T06:39:53.622085Z 28 Connect Access denied for user &#39;zhangsan&#39;@&#39;localhost&#39; (using password: NO)  -- 没有使用密码，连接被拒绝了\n2021-04-05T06:40:02.522303Z 29 Connect zhangsan@localhost on using SSL/TLS\n2021-04-05T06:40:02.522913Z 29 Query select @@version_comment limit 1\n2021-04-05T06:40:14.211511Z 29 Query SELECT *\nFROM demo.invcount                         -- 查询数据表demo.invcount内容\n2021-04-05T06:40:37.647625Z 29 Query UPDATE demo.invcount\nSET plquant = - 5                          -- 更新数据表demo.invcount\nWHERE itemnumber = 1\n2021-04-05T06:41:15.047067Z 29 Query SELECT *\nFROM demo.goodsmaster                      -- 查询数据表demo.goodsmaster\n</code></pre>\n<p>在通用查询日志里面，我们可以清楚地看到，账号zhangsan是什么时间登录的服务器，登录之后做了什么SQL操作，针对的是哪个数据表等信息。</p>\n<p><strong>慢查询日志</strong></p>\n<p>慢查询日志用来记录执行时间超过指定时长的查询。</p>\n<p>慢查询日志变量的相关设定：</p>\n<pre><code>slow-query-log=1 -- 表示开启慢查询日志，系统将会对慢查询进行记录。\n \nslow_query_log_file=&quot;GJTECH-PC-slow.log&quot;  -- 表示慢查询日志的名称是&quot;GJTECH-PC-slow.log&quot;。\n \nlong_query_time=10  -- 表示慢查询的标准是查询执行时间超过10秒\n\nmin_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。\n</code></pre>\n<p>如果查询扫描过的记录数大于等于变量<code>min_examined_row_limit</code>的值，并且查询执行时间超过<code>long_query_time</code>的值，那么这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。</p>\n<p>查看当前系统变量的值：</p>\n<pre><code>mysql&gt; show variables like &#39;min%&#39;;\n+------------------------+-------+\n| Variable_name | Value |\n+------------------------+-------+\n| min_examined_row_limit | 0 |\n+------------------------+-------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<p>下面这个例子记录了一个运行时间超过10秒的慢查询的发生时间、连接所属的用户、执行的时长、锁表的时长和扫描过的记录数等相关信息。</p>\n<pre><code>C:Program FilesMySQLMySQL Server 8.0binmysqld.exe, Version: 8.0.23 (MySQL Community Server - GPL). started with:\nTCP Port: 3306, Named Pipe: MySQL\nTime Id Command Argument\n# Time: 2021-03-25T07:20:33.412260Z     -- 执行开始时间\n# User@Host: root[root] @ localhost [::1] Id: 13   -- 用户\n# Query_time: 10.166435 Lock_time: 0.000000 Rows_sent: 0  Rows_examined: 0                        -- 执行时长、锁表时长、检查的记录数\nuse demo;\nSET timestamp=1616656823;\n</code></pre>\n<p>通过这个慢查询日志的记录，我们就可以发现是哪个查询消耗了大量的系统资源，是哪个连接里面的查询，具体什么时间开始的。</p>\n<p>有了这些信息，我们就可以对慢查询进行分析，决定优化的方式，避免出现同样的问题。</p>\n<p><strong>错误日志</strong></p>\n<p>错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示等。</p>\n<p>当我们的数据库服务器发生系统故障时，错误日志是发现问题、解决故障的首选。</p>\n<p>我们查看一下错误日志的内容：</p>\n<pre><code>2021-02-28T08:07:07.228880Z 0 [System] [MY-010116] [Server] C:Program FilesMySQLMySQL Server 8.0binmysqld.exe (mysqld 8.0.23) starting as process 7652\n2021-02-28T08:07:07.270982Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.\n2021-02-28T08:07:08.116433Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.\n</code></pre>\n<p>可以看到，错误日志文件中记录了服务器启动的时间，以及存储引擎InnoDB启动和停止的时间等。</p>\n<p><strong>二进制日志</strong></p>\n<p><strong>二进制日志主要记录数据库的更新事件</strong>，比如创建数据表、更新表中的数据、数据更新所花费的时长等信息。</p>\n<ul>\n<li>二进制日志是进行数据恢复和数据复制的利器。</li>\n</ul>\n<p><strong>用二进制日志恢复数据</strong></p>\n<p>我们可以用mysqlbinlog工具进行数据恢复：</p>\n<pre><code>mysqlbinlog –start-positon=xxx –end-position=yyy 二进制文件名 | mysql -u 用户 -p\n</code></pre>\n<p>这条命令的意思是，执行二进制日志中从位置xxx开始，到yyy截止的所有数据更新操作。</p>\n<p>这里的截止位置也可以不写，意思是从位置xxx开始，执行二进制文件中的所有数据更新操作。</p>\n<ul>\n<li>二进制日志还有一个重要的功能，就是在主从服务器的架构中，把主服务器的操作复制到从服务器。</li>\n</ul>\n<p>而这个操作要借助中继日志一起完成。</p>\n<p><strong>中继日志</strong></p>\n<p>中继日志只在主从服务器架构的从服务器上存在。</p>\n<p>从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。</p>\n<p>然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p>\n<p><strong>回滚日志</strong></p>\n<p>回滚日志的作用是进行事务回滚。</p>\n<ul>\n<li><p>当事务执行的时候，回滚日志中记录了事务中每次数据更新前的状态。</p>\n</li>\n<li><p>当事务需要回滚的时候，可以通过读取回滚日志，恢复到指定的位置。</p>\n</li>\n</ul>\n<p>另一方面，回滚日志也可以让其他的事务读取到这个事务对数据更改之前的值，从而确保了其他事务可以不受这个事务修改数据的影响。</p>\n<p><strong>重做日志</strong></p>\n<p>重做日志是存储在磁盘上的一种日志文件，主要有2个作用。</p>\n<ul>\n<li><p>在系统遇到故障的恢复过程中，可以修复被未完成的事务修改的数据。</p>\n</li>\n<li><p>MySQL为了提高数据存取的效率，减少磁盘操作的频率，对数据的更新操作不会立即写到磁盘上，而是把数据更新先保存在内存中，积累到一定程度，再集中进行磁盘读写操作。</p>\n</li>\n</ul>\n<p>这样就存在一个问题：一旦出现宕机或者停电等异常情况，内存中保存的数据更新操作可能会丢失。</p>\n<p>这个时候就可以通过读取重做日志中记录的数据更新操作，把没来得及写到磁盘上的数据更新写到磁盘上，确保数据的完整性。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>通用查询日志</strong></p>\n<p>通用查询日志记录了所有用户的连接开始时间和截止时间，以及发给MySQL数据库服务器的所有SQL指令。</p>\n<p>查询一下通用查询日志的状态：</p>\n<pre><code>mysql&gt; SHOW VARIABLES LIKE &#39;%general%&#39;;\n+------------------+--------------+\n| Variable_name | Value |\n+------------------+--------------+\n| general_log | ON | -- 通用查询日志开启\n| general_log_file | H:mytest.log |  -- 日志名称也改过了\n+------------------+--------------+\n2 rows in set, 1 warning (0.00 sec)\n</code></pre>\n<p>通用查询日志的内容，包括都有哪些连接，什么时候登录了数据库，都做了哪些操作等信息。</p>\n<pre><code>2021-04-05T06:39:53.621980Z 28 Connect zhangsan@localhost on using SSL/TLS   -- 账号zhangsan从本地登录\n2021-04-05T06:39:53.622085Z 28 Connect Access denied for user &#39;zhangsan&#39;@&#39;localhost&#39; (using password: NO)  -- 没有使用密码，连接被拒绝了\n2021-04-05T06:40:02.522303Z 29 Connect zhangsan@localhost on using SSL/TLS\n2021-04-05T06:40:02.522913Z 29 Query select @@version_comment limit 1\n2021-04-05T06:40:14.211511Z 29 Query SELECT *\nFROM demo.invcount                         -- 查询数据表demo.invcount内容\n2021-04-05T06:40:37.647625Z 29 Query UPDATE demo.invcount\nSET plquant = - 5                          -- 更新数据表demo.invcount\nWHERE itemnumber = 1\n2021-04-05T06:41:15.047067Z 29 Query SELECT *\nFROM demo.goodsmaster                      -- 查询数据表demo.goodsmaster\n</code></pre>\n<p>在通用查询日志里面，我们可以清楚地看到，账号zhangsan是什么时间登录的服务器，登录之后做了什么SQL操作，针对的是哪个数据表等信息。</p>\n<p><strong>慢查询日志</strong></p>\n<p>慢查询日志用来记录执行时间超过指定时长的查询。</p>\n<p>慢查询日志变量的相关设定：</p>\n<pre><code>slow-query-log=1 -- 表示开启慢查询日志，系统将会对慢查询进行记录。\n \nslow_query_log_file=&quot;GJTECH-PC-slow.log&quot;  -- 表示慢查询日志的名称是&quot;GJTECH-PC-slow.log&quot;。\n \nlong_query_time=10  -- 表示慢查询的标准是查询执行时间超过10秒\n\nmin_examined_row_limit。这个变量的意思是，查询扫描过的最少记录数。\n</code></pre>\n<p>如果查询扫描过的记录数大于等于变量<code>min_examined_row_limit</code>的值，并且查询执行时间超过<code>long_query_time</code>的值，那么这个查询就被记录到慢查询日志中；反之，则不被记录到慢查询日志中。</p>\n<p>查看当前系统变量的值：</p>\n<pre><code>mysql&gt; show variables like &#39;min%&#39;;\n+------------------------+-------+\n| Variable_name | Value |\n+------------------------+-------+\n| min_examined_row_limit | 0 |\n+------------------------+-------+\n1 row in set, 1 warning (0.00 sec)\n</code></pre>\n<p>下面这个例子记录了一个运行时间超过10秒的慢查询的发生时间、连接所属的用户、执行的时长、锁表的时长和扫描过的记录数等相关信息。</p>\n<pre><code>C:Program FilesMySQLMySQL Server 8.0binmysqld.exe, Version: 8.0.23 (MySQL Community Server - GPL). started with:\nTCP Port: 3306, Named Pipe: MySQL\nTime Id Command Argument\n# Time: 2021-03-25T07:20:33.412260Z     -- 执行开始时间\n# User@Host: root[root] @ localhost [::1] Id: 13   -- 用户\n# Query_time: 10.166435 Lock_time: 0.000000 Rows_sent: 0  Rows_examined: 0                        -- 执行时长、锁表时长、检查的记录数\nuse demo;\nSET timestamp=1616656823;\n</code></pre>\n<p>通过这个慢查询日志的记录，我们就可以发现是哪个查询消耗了大量的系统资源，是哪个连接里面的查询，具体什么时间开始的。</p>\n<p>有了这些信息，我们就可以对慢查询进行分析，决定优化的方式，避免出现同样的问题。</p>\n<p><strong>错误日志</strong></p>\n<p>错误日志记录了MySQL服务器启动、停止运行的时间，以及系统启动、运行和停止过程中的诊断信息，包括错误、警告和提示等。</p>\n<p>当我们的数据库服务器发生系统故障时，错误日志是发现问题、解决故障的首选。</p>\n<p>我们查看一下错误日志的内容：</p>\n<pre><code>2021-02-28T08:07:07.228880Z 0 [System] [MY-010116] [Server] C:Program FilesMySQLMySQL Server 8.0binmysqld.exe (mysqld 8.0.23) starting as process 7652\n2021-02-28T08:07:07.270982Z 1 [System] [MY-013576] [InnoDB] InnoDB initialization has started.\n2021-02-28T08:07:08.116433Z 1 [System] [MY-013577] [InnoDB] InnoDB initialization has ended.\n</code></pre>\n<p>可以看到，错误日志文件中记录了服务器启动的时间，以及存储引擎InnoDB启动和停止的时间等。</p>\n<p><strong>二进制日志</strong></p>\n<p><strong>二进制日志主要记录数据库的更新事件</strong>，比如创建数据表、更新表中的数据、数据更新所花费的时长等信息。</p>\n<ul>\n<li>二进制日志是进行数据恢复和数据复制的利器。</li>\n</ul>\n<p><strong>用二进制日志恢复数据</strong></p>\n<p>我们可以用mysqlbinlog工具进行数据恢复：</p>\n<pre><code>mysqlbinlog –start-positon=xxx –end-position=yyy 二进制文件名 | mysql -u 用户 -p\n</code></pre>\n<p>这条命令的意思是，执行二进制日志中从位置xxx开始，到yyy截止的所有数据更新操作。</p>\n<p>这里的截止位置也可以不写，意思是从位置xxx开始，执行二进制文件中的所有数据更新操作。</p>\n<ul>\n<li>二进制日志还有一个重要的功能，就是在主从服务器的架构中，把主服务器的操作复制到从服务器。</li>\n</ul>\n<p>而这个操作要借助中继日志一起完成。</p>\n<p><strong>中继日志</strong></p>\n<p>中继日志只在主从服务器架构的从服务器上存在。</p>\n<p>从服务器为了与主服务器保持一致，要从主服务器读取二进制日志的内容，并且把读取到的信息写入本地的日志文件中，这个从服务器本地的日志文件就叫中继日志。</p>\n<p>然后，从服务器读取中继日志，并根据中继日志的内容对从服务器的数据进行更新，完成主从服务器的数据同步。</p>\n<p><strong>回滚日志</strong></p>\n<p>回滚日志的作用是进行事务回滚。</p>\n<ul>\n<li><p>当事务执行的时候，回滚日志中记录了事务中每次数据更新前的状态。</p>\n</li>\n<li><p>当事务需要回滚的时候，可以通过读取回滚日志，恢复到指定的位置。</p>\n</li>\n</ul>\n<p>另一方面，回滚日志也可以让其他的事务读取到这个事务对数据更改之前的值，从而确保了其他事务可以不受这个事务修改数据的影响。</p>\n<p><strong>重做日志</strong></p>\n<p>重做日志是存储在磁盘上的一种日志文件，主要有2个作用。</p>\n<ul>\n<li><p>在系统遇到故障的恢复过程中，可以修复被未完成的事务修改的数据。</p>\n</li>\n<li><p>MySQL为了提高数据存取的效率，减少磁盘操作的频率，对数据的更新操作不会立即写到磁盘上，而是把数据更新先保存在内存中，积累到一定程度，再集中进行磁盘读写操作。</p>\n</li>\n</ul>\n<p>这样就存在一个问题：一旦出现宕机或者停电等异常情况，内存中保存的数据更新操作可能会丢失。</p>\n<p>这个时候就可以通过读取重做日志中记录的数据更新操作，把没来得及写到磁盘上的数据更新写到磁盘上，确保数据的完整性。</p>\n"},{"title":"100相同的树","_content":"\n题目地址：https://leetcode-cn.com/problems/same-tree/\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        }\n        if(p == null || q == null) {\n            return false;\n        }\n        if(p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n时间复杂度：`O(min(m,n))`，其中 m 和 n 分别是两个二叉树的节点数\n\n对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\n\n空间复杂度：`O(min(m,n))`，其中 m 和 n 分别是两个二叉树的节点数\n\n空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。","source":"_posts/LeetCode/100相同的树.md","raw":"---\ntitle: 100相同的树\ncategories:\n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/same-tree/\n\n```java\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p == null && q == null) {\n            return true;\n        }\n        if(p == null || q == null) {\n            return false;\n        }\n        if(p.val != q.val) {\n            return false;\n        }\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}\n```\n\n时间复杂度：`O(min(m,n))`，其中 m 和 n 分别是两个二叉树的节点数\n\n对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\n\n空间复杂度：`O(min(m,n))`，其中 m 和 n 分别是两个二叉树的节点数\n\n空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。","slug":"LeetCode/100相同的树","published":1,"date":"2021-09-01T05:22:18.203Z","updated":"2022-01-28T16:15:02.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfh004sfhji4fvp3b06","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/same-tree/\">https://leetcode-cn.com/problems/same-tree/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isSameTree(TreeNode p, TreeNode q) &#123;\n        if(p == null &amp;&amp; q == null) &#123;\n            return true;\n        &#125;\n        if(p == null || q == null) &#123;\n            return false;\n        &#125;\n        if(p.val != q.val) &#123;\n            return false;\n        &#125;\n        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(min(m,n))</code>，其中 m 和 n 分别是两个二叉树的节点数</p>\n<p>对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</p>\n<p>空间复杂度：<code>O(min(m,n))</code>，其中 m 和 n 分别是两个二叉树的节点数</p>\n<p>空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/same-tree/\">https://leetcode-cn.com/problems/same-tree/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isSameTree(TreeNode p, TreeNode q) &#123;\n        if(p == null &amp;&amp; q == null) &#123;\n            return true;\n        &#125;\n        if(p == null || q == null) &#123;\n            return false;\n        &#125;\n        if(p.val != q.val) &#123;\n            return false;\n        &#125;\n        return isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(min(m,n))</code>，其中 m 和 n 分别是两个二叉树的节点数</p>\n<p>对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。</p>\n<p>空间复杂度：<code>O(min(m,n))</code>，其中 m 和 n 分别是两个二叉树的节点数</p>\n<p>空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。</p>\n"},{"title":"1014最佳观光组合","_content":"\n题目地址：https://leetcode-cn.com/problems/best-sightseeing-pair/\n\n```java\nclass Solution {\n    public int maxScoreSightseeingPair(int[] values) {\n        int result = 0, max = values[0] + 0;\n        for (int j = 1; j < values.length; ++j) {\n            result = Math.max(result, max + values[j] - j);\n            max = Math.max(max, values[j] + j);\n        }\n        return result;\n    }\n}\n```\n\n复杂度分析\n\n* 时间复杂度：O(n)，其中 nn 为数组 values 的大小。我们只需要遍历一遍数组即可。\n\n* 空间复杂度：O(1)。我们只需要常数空间来存放若干变量。\n\n","source":"_posts/LeetCode/1014最佳观光组合.md","raw":"---\ntitle: 1014最佳观光组合\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/best-sightseeing-pair/\n\n```java\nclass Solution {\n    public int maxScoreSightseeingPair(int[] values) {\n        int result = 0, max = values[0] + 0;\n        for (int j = 1; j < values.length; ++j) {\n            result = Math.max(result, max + values[j] - j);\n            max = Math.max(max, values[j] + j);\n        }\n        return result;\n    }\n}\n```\n\n复杂度分析\n\n* 时间复杂度：O(n)，其中 nn 为数组 values 的大小。我们只需要遍历一遍数组即可。\n\n* 空间复杂度：O(1)。我们只需要常数空间来存放若干变量。\n\n","slug":"LeetCode/1014最佳观光组合","published":1,"date":"2021-11-27T06:22:11.505Z","updated":"2022-01-28T16:15:08.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfi004tfhji0ii74g5x","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/best-sightseeing-pair/\">https://leetcode-cn.com/problems/best-sightseeing-pair/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxScoreSightseeingPair(int[] values) &#123;\n        int result = 0, max = values[0] + 0;\n        for (int j = 1; j &lt; values.length; ++j) &#123;\n            result = Math.max(result, max + values[j] - j);\n            max = Math.max(max, values[j] + j);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>复杂度分析</p>\n<ul>\n<li><p>时间复杂度：O(n)，其中 nn 为数组 values 的大小。我们只需要遍历一遍数组即可。</p>\n</li>\n<li><p>空间复杂度：O(1)。我们只需要常数空间来存放若干变量。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/best-sightseeing-pair/\">https://leetcode-cn.com/problems/best-sightseeing-pair/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxScoreSightseeingPair(int[] values) &#123;\n        int result = 0, max = values[0] + 0;\n        for (int j = 1; j &lt; values.length; ++j) &#123;\n            result = Math.max(result, max + values[j] - j);\n            max = Math.max(max, values[j] + j);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>复杂度分析</p>\n<ul>\n<li><p>时间复杂度：O(n)，其中 nn 为数组 values 的大小。我们只需要遍历一遍数组即可。</p>\n</li>\n<li><p>空间复杂度：O(1)。我们只需要常数空间来存放若干变量。</p>\n</li>\n</ul>\n"},{"title":"101对称二叉树","_content":"\n题目地址：https://leetcode-cn.com/problems/symmetric-tree/\n\n通过同步移动两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return check(root, root);\n    }\n\n    public boolean check(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);\n    }\n}\n```\n\n假设树上一共 n 个节点。\n\n时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。\n\n空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。","source":"_posts/LeetCode/101对称二叉树.md","raw":"---\ntitle: 101对称二叉树\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/symmetric-tree/\n\n通过同步移动两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。\n\n```java\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return check(root, root);\n    }\n\n    public boolean check(TreeNode p, TreeNode q) {\n        if (p == null && q == null) {\n            return true;\n        }\n        if (p == null || q == null) {\n            return false;\n        }\n        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);\n    }\n}\n```\n\n假设树上一共 n 个节点。\n\n时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。\n\n空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。","slug":"LeetCode/101对称二叉树","published":1,"date":"2021-09-01T05:22:18.203Z","updated":"2022-01-28T16:15:13.627Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfi004wfhjia4y0cxrs","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/symmetric-tree/\">https://leetcode-cn.com/problems/symmetric-tree/</a></p>\n<p>通过同步移动两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isSymmetric(TreeNode root) &#123;\n        return check(root, root);\n    &#125;\n\n    public boolean check(TreeNode p, TreeNode q) &#123;\n        if (p == null &amp;&amp; q == null) &#123;\n            return true;\n        &#125;\n        if (p == null || q == null) &#123;\n            return false;\n        &#125;\n        return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);\n    &#125;\n&#125;\n</code></pre>\n<p>假设树上一共 n 个节点。</p>\n<p>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</p>\n<p>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/symmetric-tree/\">https://leetcode-cn.com/problems/symmetric-tree/</a></p>\n<p>通过同步移动两个指针的方法来遍历这棵树，p 指针和 q 指针一开始都指向这棵树的根，随后 p 右移时，q 左移，p 左移时，q 右移。每次检查当前 p 和 q 节点的值是否相等，如果相等再判断左右子树是否对称。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isSymmetric(TreeNode root) &#123;\n        return check(root, root);\n    &#125;\n\n    public boolean check(TreeNode p, TreeNode q) &#123;\n        if (p == null &amp;&amp; q == null) &#123;\n            return true;\n        &#125;\n        if (p == null || q == null) &#123;\n            return false;\n        &#125;\n        return p.val == q.val &amp;&amp; check(p.left, q.right) &amp;&amp; check(p.right, q.left);\n    &#125;\n&#125;\n</code></pre>\n<p>假设树上一共 n 个节点。</p>\n<p>时间复杂度：这里遍历了这棵树，渐进时间复杂度为 O(n)。</p>\n<p>空间复杂度：这里的空间复杂度和递归使用的栈空间有关，这里递归层数不超过 n，故渐进空间复杂度为 O(n)。</p>\n"},{"title":"102二叉树的层序遍历","_content":"\n题目地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\n\n# 迭代\n\n```java\nimport java.util.*;\nclass Solution {\n\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList<List<Integer>>();\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (queue.size() > 0) {\n            int size = queue.size();\n            List<Integer> tmp = new ArrayList<>();\n            for (int i = 0; i < size; ++i) {\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if (node.left != null) {\n                    queue.add(node.left);\n                }\n                if (node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n时间复杂度：每个点进队出队各一次，时间复杂度为 O(n)\n\n空间复杂度：队列中元素的个数不超过 n 个，空间复杂度为 O(n)","source":"_posts/LeetCode/102二叉树的层序遍历.md","raw":"---\ntitle: 102二叉树的层序遍历\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\n\n# 迭代\n\n```java\nimport java.util.*;\nclass Solution {\n\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        if (root == null) {\n            return new ArrayList<List<Integer>>();\n        }\n\n        List<List<Integer>> res = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n\n        while (queue.size() > 0) {\n            int size = queue.size();\n            List<Integer> tmp = new ArrayList<>();\n            for (int i = 0; i < size; ++i) {\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if (node.left != null) {\n                    queue.add(node.left);\n                }\n                if (node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n时间复杂度：每个点进队出队各一次，时间复杂度为 O(n)\n\n空间复杂度：队列中元素的个数不超过 n 个，空间复杂度为 O(n)","slug":"LeetCode/102二叉树的层序遍历","published":1,"date":"2021-09-01T05:22:18.203Z","updated":"2022-01-28T16:15:17.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfj004xfhjia0k17dv0","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">import java.util.*;\nclass Solution &#123;\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        if (root == null) &#123;\n            return new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        &#125;\n\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n\n        while (queue.size() &gt; 0) &#123;\n            int size = queue.size();\n            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n            for (int i = 0; i &lt; size; ++i) &#123;\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if (node.left != null) &#123;\n                    queue.add(node.left);\n                &#125;\n                if (node.right != null) &#123;\n                    queue.add(node.right);\n                &#125;\n            &#125;\n            res.add(tmp);\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：每个点进队出队各一次，时间复杂度为 O(n)</p>\n<p>空间复杂度：队列中元素的个数不超过 n 个，空间复杂度为 O(n)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-level-order-traversal/\">https://leetcode-cn.com/problems/binary-tree-level-order-traversal/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">import java.util.*;\nclass Solution &#123;\n\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        if (root == null) &#123;\n            return new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        &#125;\n\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n\n        while (queue.size() &gt; 0) &#123;\n            int size = queue.size();\n            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n            for (int i = 0; i &lt; size; ++i) &#123;\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if (node.left != null) &#123;\n                    queue.add(node.left);\n                &#125;\n                if (node.right != null) &#123;\n                    queue.add(node.right);\n                &#125;\n            &#125;\n            res.add(tmp);\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：每个点进队出队各一次，时间复杂度为 O(n)</p>\n<p>空间复杂度：队列中元素的个数不超过 n 个，空间复杂度为 O(n)</p>\n"},{"title":"104二叉树的最大深度","_content":"\n题目地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftHeight = maxDepth(root.left);\n        int rightHeight = maxDepth(root.right);\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n\n空间复杂度：O(height)，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n","source":"_posts/LeetCode/104二叉树的最大深度.md","raw":"---\ntitle: 104二叉树的最大深度\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftHeight = maxDepth(root.left);\n        int rightHeight = maxDepth(root.right);\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n\n空间复杂度：O(height)，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n","slug":"LeetCode/104二叉树的最大深度","published":1,"date":"2021-09-01T05:22:18.203Z","updated":"2022-01-28T16:15:22.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfl0050fhjibuj29jry","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val = val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int leftHeight = maxDepth(root.left);\n        int rightHeight = maxDepth(root.right);\n        return Math.max(leftHeight, rightHeight) + 1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p>\n<p>空间复杂度：O(height)，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/\">https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/</a></p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val = val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int leftHeight = maxDepth(root.left);\n        int rightHeight = maxDepth(root.right);\n        return Math.max(leftHeight, rightHeight) + 1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。</p>\n<p>空间复杂度：O(height)，其中height 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。</p>\n"},{"title":"110平衡二叉树","_content":"\n题目地址：https://leetcode-cn.com/problems/balanced-binary-tree/\n\n# 自底向上递归\n\n自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。\n\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return height(root) != -1;\n    }\n    \n    private int height(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        } else {\n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。\n\n空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。","source":"_posts/LeetCode/110平衡二叉树.md","raw":"---\ntitle: 110平衡二叉树\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/balanced-binary-tree/\n\n# 自底向上递归\n\n自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。\n\n```java\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return height(root) != -1;\n    }\n    \n    private int height(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) > 1) {\n            return -1;\n        } else {\n            return Math.max(leftHeight, rightHeight) + 1;\n        }\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。\n\n空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。","slug":"LeetCode/110平衡二叉树","published":1,"date":"2021-09-01T05:22:18.204Z","updated":"2022-01-28T16:15:26.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfl0051fhjihnn8ap0j","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>\n<h1 id=\"自底向上递归\"><a href=\"#自底向上递归\" class=\"headerlink\" title=\"自底向上递归\"></a>自底向上递归</h1><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isBalanced(TreeNode root) &#123;\n        return height(root) != -1;\n    &#125;\n    \n    private int height(TreeNode root) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;\n            return -1;\n        &#125; else &#123;\n            return Math.max(leftHeight, rightHeight) + 1;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。</p>\n<p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/balanced-binary-tree/\">https://leetcode-cn.com/problems/balanced-binary-tree/</a></p>\n<h1 id=\"自底向上递归\"><a href=\"#自底向上递归\" class=\"headerlink\" title=\"自底向上递归\"></a>自底向上递归</h1><p>自底向上递归的做法类似于后序遍历，对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isBalanced(TreeNode root) &#123;\n        return height(root) != -1;\n    &#125;\n    \n    private int height(TreeNode root) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int leftHeight = height(root.left);\n        int rightHeight = height(root.right);\n        if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;\n            return -1;\n        &#125; else &#123;\n            return Math.max(leftHeight, rightHeight) + 1;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。</p>\n<p>空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。</p>\n"},{"title":"112路径总和","_content":"\n题目地址：https://leetcode-cn.com/problems/path-sum/\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n      public boolean hasPathSum(TreeNode root, int sum) {\n        if(root==null) {\n            return false;\n        }\n        if(root.left==null&&root.right==null) {\n            return sum-root.val == 0;\n        } \n        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);\n    }\n}\n```\n\n时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。","source":"_posts/LeetCode/112路径总和.md","raw":"---\ntitle: 112路径总和\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/path-sum/\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n      public boolean hasPathSum(TreeNode root, int sum) {\n        if(root==null) {\n            return false;\n        }\n        if(root.left==null&&root.right==null) {\n            return sum-root.val == 0;\n        } \n        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);\n    }\n}\n```\n\n时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。","slug":"LeetCode/112路径总和","published":1,"date":"2021-09-01T05:22:18.204Z","updated":"2022-01-28T16:15:30.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfm0054fhjid4gp9kqg","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/path-sum/\">https://leetcode-cn.com/problems/path-sum/</a></p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n      public boolean hasPathSum(TreeNode root, int sum) &#123;\n        if(root==null) &#123;\n            return false;\n        &#125;\n        if(root.left==null&amp;&amp;root.right==null) &#123;\n            return sum-root.val == 0;\n        &#125; \n        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/path-sum/\">https://leetcode-cn.com/problems/path-sum/</a></p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n      public boolean hasPathSum(TreeNode root, int sum) &#123;\n        if(root==null) &#123;\n            return false;\n        &#125;\n        if(root.left==null&amp;&amp;root.right==null) &#123;\n            return sum-root.val == 0;\n        &#125; \n        return hasPathSum(root.left,sum-root.val)||hasPathSum(root.right,sum-root.val);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)，其中 N 是树的节点数。对每个节点访问一次。</p>\n"},{"title":"1137第N个泰波那契数","_content":"\n题目地址：https://leetcode-cn.com/problems/n-th-tribonacci-number/\n\n# 动态规划\n\n每一项的和都等于前三项的和，因此有如下递推关系：\n\n```\nT(n)=T(n-1)+T(n-2)+T(n-3)\n```\n\n由于泰波那契数存在递推关系，因此可以使用动态规划求解。\n\n动态规划的状态转移方程即为上述递推关系，边界条件为 T(0)、T(1)和 T(2)。\n\n根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)的实现。\n\n由于 T(n) 只和前三项有关，因此可以使用**滚动数组思想**将空间复杂度优化成 O(1)。\n\n````java\nclass Solution {\n    public int tribonacci(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        if (n <= 2) {\n            return 1;\n        }\n        int n1 = 0, n2 = 0, n3 = 1, result = 1;\n        for (int i = 3; i <= n; ++i) {\n            n1 = n2;\n            n2 = n3;\n            n3 = result;\n            result = n1 + n2 + n3;\n        }\n        return result;\n    }\n}\n````\n\n**复杂度分析**\n\n- 时间复杂度：O(n)。\n- 空间复杂度：O(1)。\n\n","source":"_posts/LeetCode/1137第N个泰波那契数.md","raw":"---\ntitle: 1137第N个泰波那契数\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/n-th-tribonacci-number/\n\n# 动态规划\n\n每一项的和都等于前三项的和，因此有如下递推关系：\n\n```\nT(n)=T(n-1)+T(n-2)+T(n-3)\n```\n\n由于泰波那契数存在递推关系，因此可以使用动态规划求解。\n\n动态规划的状态转移方程即为上述递推关系，边界条件为 T(0)、T(1)和 T(2)。\n\n根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)的实现。\n\n由于 T(n) 只和前三项有关，因此可以使用**滚动数组思想**将空间复杂度优化成 O(1)。\n\n````java\nclass Solution {\n    public int tribonacci(int n) {\n        if (n == 0) {\n            return 0;\n        }\n        if (n <= 2) {\n            return 1;\n        }\n        int n1 = 0, n2 = 0, n3 = 1, result = 1;\n        for (int i = 3; i <= n; ++i) {\n            n1 = n2;\n            n2 = n3;\n            n3 = result;\n            result = n1 + n2 + n3;\n        }\n        return result;\n    }\n}\n````\n\n**复杂度分析**\n\n- 时间复杂度：O(n)。\n- 空间复杂度：O(1)。\n\n","slug":"LeetCode/1137第N个泰波那契数","published":1,"date":"2021-11-21T07:37:31.889Z","updated":"2022-01-28T16:15:35.634Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfm0055fhjidkaogyli","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number/\">https://leetcode-cn.com/problems/n-th-tribonacci-number/</a></p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>每一项的和都等于前三项的和，因此有如下递推关系：</p>\n<pre><code>T(n)=T(n-1)+T(n-2)+T(n-3)\n</code></pre>\n<p>由于泰波那契数存在递推关系，因此可以使用动态规划求解。</p>\n<p>动态规划的状态转移方程即为上述递推关系，边界条件为 T(0)、T(1)和 T(2)。</p>\n<p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)的实现。</p>\n<p>由于 T(n) 只和前三项有关，因此可以使用<strong>滚动数组思想</strong>将空间复杂度优化成 O(1)。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int tribonacci(int n) &#123;\n        if (n == 0) &#123;\n            return 0;\n        &#125;\n        if (n &lt;= 2) &#123;\n            return 1;\n        &#125;\n        int n1 = 0, n2 = 0, n3 = 1, result = 1;\n        for (int i = 3; i &lt;= n; ++i) &#123;\n            n1 = n2;\n            n2 = n3;\n            n3 = result;\n            result = n1 + n2 + n3;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(n)。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/n-th-tribonacci-number/\">https://leetcode-cn.com/problems/n-th-tribonacci-number/</a></p>\n<h1 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h1><p>每一项的和都等于前三项的和，因此有如下递推关系：</p>\n<pre><code>T(n)=T(n-1)+T(n-2)+T(n-3)\n</code></pre>\n<p>由于泰波那契数存在递推关系，因此可以使用动态规划求解。</p>\n<p>动态规划的状态转移方程即为上述递推关系，边界条件为 T(0)、T(1)和 T(2)。</p>\n<p>根据状态转移方程和边界条件，可以得到时间复杂度和空间复杂度都是 O(n)的实现。</p>\n<p>由于 T(n) 只和前三项有关，因此可以使用<strong>滚动数组思想</strong>将空间复杂度优化成 O(1)。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int tribonacci(int n) &#123;\n        if (n == 0) &#123;\n            return 0;\n        &#125;\n        if (n &lt;= 2) &#123;\n            return 1;\n        &#125;\n        int n1 = 0, n2 = 0, n3 = 1, result = 1;\n        for (int i = 3; i &lt;= n; ++i) &#123;\n            n1 = n2;\n            n2 = n3;\n            n3 = result;\n            result = n1 + n2 + n3;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(n)。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n"},{"title":"113路径总和II","_content":"\n题目地址：https://leetcode-cn.com/problems/path-sum-ii/\n\n我们可以采用深度优先搜索的方式，遍历每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<List<Integer>> result = new ArrayList<List<Integer>>();\n    List<Integer> list = new ArrayList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        dfs(root, sum);\n        return result;\n    }\n\n    public void dfs(TreeNode root, int sum) {\n        if (root == null) {\n            return;\n        }\n        list.add(root.val);\n        sum = sum - root.val;\n\n        if (root.left == null && root.right == null && sum == 0) {\n            result.add(new ArrayList<>(list));\n        }\n\n        dfs(root.left, sum);\n        dfs(root.right, sum);\n\n        list.remove(list.size() - 1);\n    }\n}\n```\n\n时间复杂度：O(N^2)，其中 N 是树的节点数。\n\n空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。","source":"_posts/LeetCode/113路径总和II.md","raw":"---\ntitle: 113路径总和II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/path-sum-ii/\n\n我们可以采用深度优先搜索的方式，遍历每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    List<List<Integer>> result = new ArrayList<List<Integer>>();\n    List<Integer> list = new ArrayList<>();\n    public List<List<Integer>> pathSum(TreeNode root, int sum) {\n        dfs(root, sum);\n        return result;\n    }\n\n    public void dfs(TreeNode root, int sum) {\n        if (root == null) {\n            return;\n        }\n        list.add(root.val);\n        sum = sum - root.val;\n\n        if (root.left == null && root.right == null && sum == 0) {\n            result.add(new ArrayList<>(list));\n        }\n\n        dfs(root.left, sum);\n        dfs(root.right, sum);\n\n        list.remove(list.size() - 1);\n    }\n}\n```\n\n时间复杂度：O(N^2)，其中 N 是树的节点数。\n\n空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。","slug":"LeetCode/113路径总和II","published":1,"date":"2021-09-01T05:22:18.204Z","updated":"2022-01-28T16:15:40.845Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfn0058fhji2ggy2dcj","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/path-sum-ii/\">https://leetcode-cn.com/problems/path-sum-ii/</a></p>\n<p>我们可以采用深度优先搜索的方式，遍历每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;\n        dfs(root, sum);\n        return result;\n    &#125;\n\n    public void dfs(TreeNode root, int sum) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        list.add(root.val);\n        sum = sum - root.val;\n\n        if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == 0) &#123;\n            result.add(new ArrayList&lt;&gt;(list));\n        &#125;\n\n        dfs(root.left, sum);\n        dfs(root.right, sum);\n\n        list.remove(list.size() - 1);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N^2)，其中 N 是树的节点数。</p>\n<p>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/path-sum-ii/\">https://leetcode-cn.com/problems/path-sum-ii/</a></p>\n<p>我们可以采用深度优先搜索的方式，遍历每一条从根节点到叶子节点的路径。当我们遍历到叶子节点，且此时路径和恰为目标和时，我们就找到了一条满足条件的路径。</p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;\n        dfs(root, sum);\n        return result;\n    &#125;\n\n    public void dfs(TreeNode root, int sum) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        list.add(root.val);\n        sum = sum - root.val;\n\n        if (root.left == null &amp;&amp; root.right == null &amp;&amp; sum == 0) &#123;\n            result.add(new ArrayList&lt;&gt;(list));\n        &#125;\n\n        dfs(root.left, sum);\n        dfs(root.right, sum);\n\n        list.remove(list.size() - 1);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N^2)，其中 N 是树的节点数。</p>\n<p>空间复杂度：O(N)，其中 N 是树的节点数。空间复杂度主要取决于栈空间的开销，栈中的元素个数不会超过树的节点数。</p>\n"},{"title":"1143最长公共子序列","_content":"\n题目地址：https://leetcode-cn.com/problems/longest-common-subsequence/\n\n对于两个子序列 S1 和 S2，找出它们最长的公共子序列。\n\n定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 `dp[i][j]` 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：\n\n* 当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 `dp[i][j] = dp[i-1][j-1] + 1`。\n\n* 当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 `dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }`。\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int n1 = text1.length(), n2 = text2.length();\n        int[][] dp = new int[n1+1][n2+1];\n        for (int i = 1;i <= n1;i++) {\n            for (int j = 1;j<=n2;j++) {\n                if(text1.charAt(i-1) == text2.charAt(j-1)) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n}\n```\n\n","source":"_posts/LeetCode/1143最长公共子序列.md","raw":"---\ntitle: 1143最长公共子序列\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/longest-common-subsequence/\n\n对于两个子序列 S1 和 S2，找出它们最长的公共子序列。\n\n定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 `dp[i][j]` 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：\n\n* 当 S1i==S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 `dp[i][j] = dp[i-1][j-1] + 1`。\n\n* 当 S1i != S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 `dp[i][j] = max{ dp[i-1][j], dp[i][j-1] }`。\n\n```java\nclass Solution {\n    public int longestCommonSubsequence(String text1, String text2) {\n        int n1 = text1.length(), n2 = text2.length();\n        int[][] dp = new int[n1+1][n2+1];\n        for (int i = 1;i <= n1;i++) {\n            for (int j = 1;j<=n2;j++) {\n                if(text1.charAt(i-1) == text2.charAt(j-1)) {\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                } else {\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n                }\n            }\n        }\n        return dp[n1][n2];\n    }\n}\n```\n\n","slug":"LeetCode/1143最长公共子序列","published":1,"date":"2021-09-01T05:22:18.204Z","updated":"2022-01-28T16:15:45.099Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfo0059fhjiatrobi4s","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p>\n<p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>\n<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 <code>dp[i][j]</code> 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p>\n<ul>\n<li><p>当 S1i&#x3D;&#x3D;S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</p>\n</li>\n<li><p>当 S1i !&#x3D; S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 <code>dp[i][j] = max&#123; dp[i-1][j], dp[i][j-1] &#125;</code>。</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int longestCommonSubsequence(String text1, String text2) &#123;\n        int n1 = text1.length(), n2 = text2.length();\n        int[][] dp = new int[n1+1][n2+1];\n        for (int i = 1;i &lt;= n1;i++) &#123;\n            for (int j = 1;j&lt;=n2;j++) &#123;\n                if(text1.charAt(i-1) == text2.charAt(j-1)) &#123;\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                &#125; else &#123;\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n1][n2];\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-common-subsequence/\">https://leetcode-cn.com/problems/longest-common-subsequence/</a></p>\n<p>对于两个子序列 S1 和 S2，找出它们最长的公共子序列。</p>\n<p>定义一个二维数组 dp 用来存储最长公共子序列的长度，其中 <code>dp[i][j]</code> 表示 S1 的前 i 个字符与 S2 的前 j 个字符最长公共子序列的长度。考虑 S1i 与 S2j 值是否相等，分为两种情况：</p>\n<ul>\n<li><p>当 S1i&#x3D;&#x3D;S2j 时，那么就能在 S1 的前 i-1 个字符与 S2 的前 j-1 个字符最长公共子序列的基础上再加上 S1i 这个值，最长公共子序列长度加 1，即 <code>dp[i][j] = dp[i-1][j-1] + 1</code>。</p>\n</li>\n<li><p>当 S1i !&#x3D; S2j 时，此时最长公共子序列为 S1 的前 i-1 个字符和 S2 的前 j 个字符最长公共子序列，或者 S1 的前 i 个字符和 S2 的前 j-1 个字符最长公共子序列，取它们的最大者，即 <code>dp[i][j] = max&#123; dp[i-1][j], dp[i][j-1] &#125;</code>。</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int longestCommonSubsequence(String text1, String text2) &#123;\n        int n1 = text1.length(), n2 = text2.length();\n        int[][] dp = new int[n1+1][n2+1];\n        for (int i = 1;i &lt;= n1;i++) &#123;\n            for (int j = 1;j&lt;=n2;j++) &#123;\n                if(text1.charAt(i-1) == text2.charAt(j-1)) &#123;\n                    dp[i][j] = dp[i-1][j-1] + 1;\n                &#125; else &#123;\n                    dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n                &#125;\n            &#125;\n        &#125;\n        return dp[n1][n2];\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"11盛最多水的容器","_content":"\n题目地址：https://leetcode-cn.com/problems/container-with-most-water/\n\n# 双指针\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }\n        int l = 0,r = height.length - 1;\n        int result = 0;\n        while(l < r) {\n            int area = Math.min(height[l], height[r]) * (r - l);\n            result = Math.max(area, result);\n            if (height[l] <= height[r]) {\n                l++;\n            } else {\n                r--;\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(N)，双指针总计最多遍历整个数组一次。\n\n空间复杂度：O(1)，只需要额外的常数级别的空间","source":"_posts/LeetCode/11盛最多水的容器.md","raw":"---\ntitle: 11盛最多水的容器\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/container-with-most-water/\n\n# 双指针\n\n```java\nclass Solution {\n    public int maxArea(int[] height) {\n        if (height == null || height.length == 0) {\n            return 0;\n        }\n        int l = 0,r = height.length - 1;\n        int result = 0;\n        while(l < r) {\n            int area = Math.min(height[l], height[r]) * (r - l);\n            result = Math.max(area, result);\n            if (height[l] <= height[r]) {\n                l++;\n            } else {\n                r--;\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(N)，双指针总计最多遍历整个数组一次。\n\n空间复杂度：O(1)，只需要额外的常数级别的空间","slug":"LeetCode/11盛最多水的容器","published":1,"date":"2021-09-01T05:22:18.204Z","updated":"2021-12-28T01:09:49.381Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfo005cfhjiguoz757u","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/container-with-most-water/\">https://leetcode-cn.com/problems/container-with-most-water/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><pre><code class=\"java\">class Solution &#123;\n    public int maxArea(int[] height) &#123;\n        if (height == null || height.length == 0) &#123;\n            return 0;\n        &#125;\n        int l = 0,r = height.length - 1;\n        int result = 0;\n        while(l &lt; r) &#123;\n            int area = Math.min(height[l], height[r]) * (r - l);\n            result = Math.max(area, result);\n            if (height[l] &lt;= height[r]) &#123;\n                l++;\n            &#125; else &#123;\n                r--;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</p>\n<p>空间复杂度：O(1)，只需要额外的常数级别的空间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/container-with-most-water/\">https://leetcode-cn.com/problems/container-with-most-water/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><pre><code class=\"java\">class Solution &#123;\n    public int maxArea(int[] height) &#123;\n        if (height == null || height.length == 0) &#123;\n            return 0;\n        &#125;\n        int l = 0,r = height.length - 1;\n        int result = 0;\n        while(l &lt; r) &#123;\n            int area = Math.min(height[l], height[r]) * (r - l);\n            result = Math.max(area, result);\n            if (height[l] &lt;= height[r]) &#123;\n                l++;\n            &#125; else &#123;\n                r--;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)，双指针总计最多遍历整个数组一次。</p>\n<p>空间复杂度：O(1)，只需要额外的常数级别的空间</p>\n"},{"title":"121买卖股票的最佳时机","_content":"\n题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\n\n```java\npublic class Solution {\n    public int maxProfit(int prices[]) {\n        int minPrice = Integer.MAX_VALUE;\n        int maxProfit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i];\n            } else if (prices[i] - minPrice > maxProfit) {\n                maxProfit = prices[i] - minPrice;\n            }\n        }\n        return maxProfit;\n    }\n}\n```\n\n时间复杂度：O(n)，只需要遍历一次。\n\n空间复杂度：O(1)，只使用了常数个变量。","source":"_posts/LeetCode/121买卖股票的最佳时机.md","raw":"---\ntitle: 121买卖股票的最佳时机\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\n\n```java\npublic class Solution {\n    public int maxProfit(int prices[]) {\n        int minPrice = Integer.MAX_VALUE;\n        int maxProfit = 0;\n        for (int i = 0; i < prices.length; i++) {\n            if (prices[i] < minPrice) {\n                minPrice = prices[i];\n            } else if (prices[i] - minPrice > maxProfit) {\n                maxProfit = prices[i] - minPrice;\n            }\n        }\n        return maxProfit;\n    }\n}\n```\n\n时间复杂度：O(n)，只需要遍历一次。\n\n空间复杂度：O(1)，只使用了常数个变量。","slug":"LeetCode/121买卖股票的最佳时机","published":1,"date":"2021-09-01T05:22:18.204Z","updated":"2022-01-28T16:15:51.863Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfp005dfhjicjdzh1dc","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public int maxProfit(int prices[]) &#123;\n        int minPrice = Integer.MAX_VALUE;\n        int maxProfit = 0;\n        for (int i = 0; i &lt; prices.length; i++) &#123;\n            if (prices[i] &lt; minPrice) &#123;\n                minPrice = prices[i];\n            &#125; else if (prices[i] - minPrice &gt; maxProfit) &#123;\n                maxProfit = prices[i] - minPrice;\n            &#125;\n        &#125;\n        return maxProfit;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，只需要遍历一次。</p>\n<p>空间复杂度：O(1)，只使用了常数个变量。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public int maxProfit(int prices[]) &#123;\n        int minPrice = Integer.MAX_VALUE;\n        int maxProfit = 0;\n        for (int i = 0; i &lt; prices.length; i++) &#123;\n            if (prices[i] &lt; minPrice) &#123;\n                minPrice = prices[i];\n            &#125; else if (prices[i] - minPrice &gt; maxProfit) &#123;\n                maxProfit = prices[i] - minPrice;\n            &#125;\n        &#125;\n        return maxProfit;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，只需要遍历一次。</p>\n<p>空间复杂度：O(1)，只使用了常数个变量。</p>\n"},{"title":"122买卖股票的最佳时机II","_content":"\n题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\n\n**算法流程：**\n\n设 temp 为第` i-1` 日买入与第 i 日卖出赚取的利润，即` temp = prices[i] - prices[i - 1]` ；\n\n当该天利润为正` temp > 0`，则将利润加入总利润 `profit`；当利润为 0 或为负，则直接跳过；\n\n遍历完成后，返回总利润 profit\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int profit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            int temp = prices[i] - prices[i - 1];\n            if (temp > 0) {\n                profit += temp;\n            }\n        }\n        return profit;\n    }\n}\n```\n\n","source":"_posts/LeetCode/122买卖股票的最佳时机II.md","raw":"---\ntitle: 122买卖股票的最佳时机II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\n\n**算法流程：**\n\n设 temp 为第` i-1` 日买入与第 i 日卖出赚取的利润，即` temp = prices[i] - prices[i - 1]` ；\n\n当该天利润为正` temp > 0`，则将利润加入总利润 `profit`；当利润为 0 或为负，则直接跳过；\n\n遍历完成后，返回总利润 profit\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        int profit = 0;\n        for (int i = 1; i < prices.length; i++) {\n            int temp = prices[i] - prices[i - 1];\n            if (temp > 0) {\n                profit += temp;\n            }\n        }\n        return profit;\n    }\n}\n```\n\n","slug":"LeetCode/122买卖股票的最佳时机II","published":1,"date":"2021-09-01T05:22:18.205Z","updated":"2022-01-28T16:15:56.104Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfq005gfhjiag3j3a4d","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>\n<p><strong>算法流程：</strong></p>\n<p>设 temp 为第<code> i-1</code> 日买入与第 i 日卖出赚取的利润，即<code> temp = prices[i] - prices[i - 1]</code> ；</p>\n<p>当该天利润为正<code> temp &gt; 0</code>，则将利润加入总利润 <code>profit</code>；当利润为 0 或为负，则直接跳过；</p>\n<p>遍历完成后，返回总利润 profit</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        int profit = 0;\n        for (int i = 1; i &lt; prices.length; i++) &#123;\n            int temp = prices[i] - prices[i - 1];\n            if (temp &gt; 0) &#123;\n                profit += temp;\n            &#125;\n        &#125;\n        return profit;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\">https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/</a></p>\n<p><strong>算法流程：</strong></p>\n<p>设 temp 为第<code> i-1</code> 日买入与第 i 日卖出赚取的利润，即<code> temp = prices[i] - prices[i - 1]</code> ；</p>\n<p>当该天利润为正<code> temp &gt; 0</code>，则将利润加入总利润 <code>profit</code>；当利润为 0 或为负，则直接跳过；</p>\n<p>遍历完成后，返回总利润 profit</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        int profit = 0;\n        for (int i = 1; i &lt; prices.length; i++) &#123;\n            int temp = prices[i] - prices[i - 1];\n            if (temp &gt; 0) &#123;\n                profit += temp;\n            &#125;\n        &#125;\n        return profit;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"125验证回文串","_content":"\n题目地址：https://leetcode-cn.com/problems/valid-palindrome/\n\n我们直接在原字符串 s 上使用双指针。在移动任意一个指针时，需要不断地向另一指针的方向移动，直到遇到一个字母或数字字符，或者两指针重合为止。也就是说，我们每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() -1;\n        while(left<right) {\n            while(left<right&&!Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            while(left<right&&!Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            if (left<right&&Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n```\n\n","source":"_posts/LeetCode/125验证回文串.md","raw":"---\ntitle: 125验证回文串\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/valid-palindrome/\n\n我们直接在原字符串 s 上使用双指针。在移动任意一个指针时，需要不断地向另一指针的方向移动，直到遇到一个字母或数字字符，或者两指针重合为止。也就是说，我们每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同\n\n```java\nclass Solution {\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() -1;\n        while(left<right) {\n            while(left<right&&!Character.isLetterOrDigit(s.charAt(left))) {\n                left++;\n            }\n            while(left<right&&!Character.isLetterOrDigit(s.charAt(right))) {\n                right--;\n            }\n            if (left<right&&Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n}\n```\n\n","slug":"LeetCode/125验证回文串","published":1,"date":"2021-09-01T05:22:18.205Z","updated":"2022-01-28T16:16:00.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfr005hfhji35ki5umj","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/valid-palindrome/\">https://leetcode-cn.com/problems/valid-palindrome/</a></p>\n<p>我们直接在原字符串 s 上使用双指针。在移动任意一个指针时，需要不断地向另一指针的方向移动，直到遇到一个字母或数字字符，或者两指针重合为止。也就是说，我们每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isPalindrome(String s) &#123;\n        int left = 0, right = s.length() -1;\n        while(left&lt;right) &#123;\n            while(left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(left))) &#123;\n                left++;\n            &#125;\n            while(left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(right))) &#123;\n                right--;\n            &#125;\n            if (left&lt;right&amp;&amp;Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))) &#123;\n                return false;\n            &#125;\n            left++;\n            right--;\n        &#125;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/valid-palindrome/\">https://leetcode-cn.com/problems/valid-palindrome/</a></p>\n<p>我们直接在原字符串 s 上使用双指针。在移动任意一个指针时，需要不断地向另一指针的方向移动，直到遇到一个字母或数字字符，或者两指针重合为止。也就是说，我们每次将指针移到下一个字母字符或数字字符，再判断这两个指针指向的字符是否相同</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isPalindrome(String s) &#123;\n        int left = 0, right = s.length() -1;\n        while(left&lt;right) &#123;\n            while(left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(left))) &#123;\n                left++;\n            &#125;\n            while(left&lt;right&amp;&amp;!Character.isLetterOrDigit(s.charAt(right))) &#123;\n                right--;\n            &#125;\n            if (left&lt;right&amp;&amp;Character.toLowerCase(s.charAt(left))!=Character.toLowerCase(s.charAt(right))) &#123;\n                return false;\n            &#125;\n            left++;\n            right--;\n        &#125;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"129求根节点到叶节点数字之和","_content":"\n题目地址：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。\n\n如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。\n\n空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。\n","source":"_posts/LeetCode/129求根节点到叶节点数字之和.md","raw":"---\ntitle: 129求根节点到叶节点数字之和\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\n\n从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。\n\n如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    public int dfs(TreeNode root, int prevSum) {\n        if (root == null) {\n            return 0;\n        }\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null && root.right == null) {\n            return sum;\n        } else {\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        }\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。\n\n空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。\n","slug":"LeetCode/129求根节点到叶节点数字之和","published":1,"date":"2021-09-01T05:22:18.205Z","updated":"2022-01-28T16:16:05.006Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfs005kfhjihfri6nwt","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a></p>\n<p>从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。</p>\n<p>如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历</p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val = val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public int sumNumbers(TreeNode root) &#123;\n        return dfs(root, 0);\n    &#125;\n\n    public int dfs(TreeNode root, int prevSum) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null &amp;&amp; root.right == null) &#123;\n            return sum;\n        &#125; else &#123;\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p>\n<p>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/\">https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/</a></p>\n<p>从根节点开始，遍历每个节点，如果遇到叶子节点，则将叶子节点对应的数字加到数字之和。</p>\n<p>如果当前节点不是叶子节点，则计算其子节点对应的数字，然后对子节点递归遍历</p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val = val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public int sumNumbers(TreeNode root) &#123;\n        return dfs(root, 0);\n    &#125;\n\n    public int dfs(TreeNode root, int prevSum) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int sum = prevSum * 10 + root.val;\n        if (root.left == null &amp;&amp; root.right == null) &#123;\n            return sum;\n        &#125; else &#123;\n            return dfs(root.left, sum) + dfs(root.right, sum);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</p>\n<p>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。</p>\n"},{"title":"136只出现一次的数字","_content":"\n题目地址:https://leetcode-cn.com/problems/single-number/\n\n一个数和0做异或运算等于本身\n\n一个数和其本身做异或运算等于 0\n\n将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int result = 0;\n        for(int num : nums) {\n            result = result ^ num;\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)，空间复杂度：O(1)","source":"_posts/LeetCode/136只出现一次的数字.md","raw":"---\ntitle: 136只出现一次的数字\ncategories: \n- LeetCode\n---\n\n题目地址:https://leetcode-cn.com/problems/single-number/\n\n一个数和0做异或运算等于本身\n\n一个数和其本身做异或运算等于 0\n\n将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字\n\n```java\nclass Solution {\n    public int singleNumber(int[] nums) {\n        int result = 0;\n        for(int num : nums) {\n            result = result ^ num;\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)，空间复杂度：O(1)","slug":"LeetCode/136只出现一次的数字","published":1,"date":"2021-09-01T05:22:18.205Z","updated":"2022-01-28T16:16:10.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwft005lfhjifu7l53sm","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/single-number/\">https://leetcode-cn.com/problems/single-number/</a></p>\n<p>一个数和0做异或运算等于本身</p>\n<p>一个数和其本身做异或运算等于 0</p>\n<p>将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int singleNumber(int[] nums) &#123;\n        int result = 0;\n        for(int num : nums) &#123;\n            result = result ^ num;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，空间复杂度：O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/single-number/\">https://leetcode-cn.com/problems/single-number/</a></p>\n<p>一个数和0做异或运算等于本身</p>\n<p>一个数和其本身做异或运算等于 0</p>\n<p>将所有数字按照顺序做抑或运算，最后剩下的结果即为唯一的数字</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int singleNumber(int[] nums) &#123;\n        int result = 0;\n        for(int num : nums) &#123;\n            result = result ^ num;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，空间复杂度：O(1)</p>\n"},{"title":"13罗马数字转整数","_content":"\n题目地址：https://leetcode-cn.com/problems/roman-to-integer/\n\n按照题目的描述，可以总结如下规则：\n\n- 当小值在大值的左边，则减小值，如 IV=5-1=4；\n- 当小值在大值的右边，则加小值，如 VI=5+1=6；\n\n```java\nclass Solution {\n    public int romanToInt(String s) {\n        int sum = 0;\n        int preNum = getValue(s.charAt(0));\n        for(int i = 1;i < s.length(); i ++) {\n            int num = getValue(s.charAt(i));\n            //当小值在大值的左边，则减小值\n            if(preNum < num) {\n                sum -= preNum;\n            } else {//当小值在大值的右边，则加小值\n                sum += preNum;\n            }\n            preNum = num;\n        }\n        //加上最后一个元素\n        sum += preNum;\n        return sum;\n    }\n\n    private int getValue(char c) {\n        switch(c) {\n            case 'I': return 1;\n            case 'V': return 5;\n            case 'X': return 10;\n            case 'L': return 50;\n            case 'C': return 100;\n            case 'D': return 500;\n            case 'M': return 1000;\n            default: return 0;\n        }\n    }\n}\n```\n\n","source":"_posts/LeetCode/13罗马数字转整数.md","raw":"---\ntitle: 13罗马数字转整数\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/roman-to-integer/\n\n按照题目的描述，可以总结如下规则：\n\n- 当小值在大值的左边，则减小值，如 IV=5-1=4；\n- 当小值在大值的右边，则加小值，如 VI=5+1=6；\n\n```java\nclass Solution {\n    public int romanToInt(String s) {\n        int sum = 0;\n        int preNum = getValue(s.charAt(0));\n        for(int i = 1;i < s.length(); i ++) {\n            int num = getValue(s.charAt(i));\n            //当小值在大值的左边，则减小值\n            if(preNum < num) {\n                sum -= preNum;\n            } else {//当小值在大值的右边，则加小值\n                sum += preNum;\n            }\n            preNum = num;\n        }\n        //加上最后一个元素\n        sum += preNum;\n        return sum;\n    }\n\n    private int getValue(char c) {\n        switch(c) {\n            case 'I': return 1;\n            case 'V': return 5;\n            case 'X': return 10;\n            case 'L': return 50;\n            case 'C': return 100;\n            case 'D': return 500;\n            case 'M': return 1000;\n            default: return 0;\n        }\n    }\n}\n```\n\n","slug":"LeetCode/13罗马数字转整数","published":1,"date":"2021-09-01T05:22:18.205Z","updated":"2021-12-29T06:44:29.218Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwft005ofhjia2fscwx6","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/roman-to-integer/\">https://leetcode-cn.com/problems/roman-to-integer/</a></p>\n<p>按照题目的描述，可以总结如下规则：</p>\n<ul>\n<li>当小值在大值的左边，则减小值，如 IV&#x3D;5-1&#x3D;4；</li>\n<li>当小值在大值的右边，则加小值，如 VI&#x3D;5+1&#x3D;6；</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int romanToInt(String s) &#123;\n        int sum = 0;\n        int preNum = getValue(s.charAt(0));\n        for(int i = 1;i &lt; s.length(); i ++) &#123;\n            int num = getValue(s.charAt(i));\n            //当小值在大值的左边，则减小值\n            if(preNum &lt; num) &#123;\n                sum -= preNum;\n            &#125; else &#123;//当小值在大值的右边，则加小值\n                sum += preNum;\n            &#125;\n            preNum = num;\n        &#125;\n        //加上最后一个元素\n        sum += preNum;\n        return sum;\n    &#125;\n\n    private int getValue(char c) &#123;\n        switch(c) &#123;\n            case &#39;I&#39;: return 1;\n            case &#39;V&#39;: return 5;\n            case &#39;X&#39;: return 10;\n            case &#39;L&#39;: return 50;\n            case &#39;C&#39;: return 100;\n            case &#39;D&#39;: return 500;\n            case &#39;M&#39;: return 1000;\n            default: return 0;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/roman-to-integer/\">https://leetcode-cn.com/problems/roman-to-integer/</a></p>\n<p>按照题目的描述，可以总结如下规则：</p>\n<ul>\n<li>当小值在大值的左边，则减小值，如 IV&#x3D;5-1&#x3D;4；</li>\n<li>当小值在大值的右边，则加小值，如 VI&#x3D;5+1&#x3D;6；</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int romanToInt(String s) &#123;\n        int sum = 0;\n        int preNum = getValue(s.charAt(0));\n        for(int i = 1;i &lt; s.length(); i ++) &#123;\n            int num = getValue(s.charAt(i));\n            //当小值在大值的左边，则减小值\n            if(preNum &lt; num) &#123;\n                sum -= preNum;\n            &#125; else &#123;//当小值在大值的右边，则加小值\n                sum += preNum;\n            &#125;\n            preNum = num;\n        &#125;\n        //加上最后一个元素\n        sum += preNum;\n        return sum;\n    &#125;\n\n    private int getValue(char c) &#123;\n        switch(c) &#123;\n            case &#39;I&#39;: return 1;\n            case &#39;V&#39;: return 5;\n            case &#39;X&#39;: return 10;\n            case &#39;L&#39;: return 50;\n            case &#39;C&#39;: return 100;\n            case &#39;D&#39;: return 500;\n            case &#39;M&#39;: return 1000;\n            default: return 0;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"141环形链表","_content":"\n题目地址：https://leetcode-cn.com/problems/linked-list-cycle/\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n```\n\n","source":"_posts/LeetCode/141环形链表.md","raw":"---\ntitle: 141环形链表\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/linked-list-cycle/\n\n```java\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}\n```\n\n","slug":"LeetCode/141环形链表","published":1,"date":"2021-09-01T05:22:18.206Z","updated":"2022-01-28T16:16:18.642Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfu005pfhjier0na23q","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public boolean hasCycle(ListNode head) &#123;\n        if (head == null || head.next == null) &#123;\n            return false;\n        &#125;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) &#123;\n            if (fast == null || fast.next == null) &#123;\n                return false;\n            &#125;\n            slow = slow.next;\n            fast = fast.next.next;\n        &#125;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">https://leetcode-cn.com/problems/linked-list-cycle/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public boolean hasCycle(ListNode head) &#123;\n        if (head == null || head.next == null) &#123;\n            return false;\n        &#125;\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) &#123;\n            if (fast == null || fast.next == null) &#123;\n                return false;\n            &#125;\n            slow = slow.next;\n            fast = fast.next.next;\n        &#125;\n        return true;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"142环形链表II","_content":"\n题目地址：https://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while(true) {\n            if (fast == null || fast.next == null) {\n                return null;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                break;\n            }\n        }\n        fast = head;\n        while(slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return fast;\n    }\n}\n```\n\n","source":"_posts/LeetCode/142环形链表II.md","raw":"---\ntitle: 142环形链表II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/linked-list-cycle-ii/\n\n```java\npublic class Solution {\n    public ListNode detectCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return null;\n        }\n        ListNode slow = head, fast = head;\n        while(true) {\n            if (fast == null || fast.next == null) {\n                return null;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                break;\n            }\n        }\n        fast = head;\n        while(slow != fast) {\n            slow = slow.next;\n            fast = fast.next;\n        }\n        return fast;\n    }\n}\n```\n\n","slug":"LeetCode/142环形链表II","published":1,"date":"2021-09-01T05:22:18.206Z","updated":"2022-01-28T16:16:22.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfv005sfhjic0yh1e7d","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public ListNode detectCycle(ListNode head) &#123;\n        if (head == null || head.next == null) &#123;\n            return null;\n        &#125;\n        ListNode slow = head, fast = head;\n        while(true) &#123;\n            if (fast == null || fast.next == null) &#123;\n                return null;\n            &#125;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) &#123;\n                break;\n            &#125;\n        &#125;\n        fast = head;\n        while(slow != fast) &#123;\n            slow = slow.next;\n            fast = fast.next;\n        &#125;\n        return fast;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">https://leetcode-cn.com/problems/linked-list-cycle-ii/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public ListNode detectCycle(ListNode head) &#123;\n        if (head == null || head.next == null) &#123;\n            return null;\n        &#125;\n        ListNode slow = head, fast = head;\n        while(true) &#123;\n            if (fast == null || fast.next == null) &#123;\n                return null;\n            &#125;\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) &#123;\n                break;\n            &#125;\n        &#125;\n        fast = head;\n        while(slow != fast) &#123;\n            slow = slow.next;\n            fast = fast.next;\n        &#125;\n        return fast;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"143重排链表","_content":"\n题目地址：https://leetcode-cn.com/problems/reorder-list/\n\n**注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果**\n\n这样我们的任务即可划分为几步：\n\n* 找到原链表的中点\n\n* 我们可以使用快慢指针来 O(N)找到链表的中间节点\n\n* 将原链表的右半端反转\n\n* 将原链表的两端合并\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null) {\n            return;\n        }\n        //1.找到链表中间节点\n        ListNode mid = middleNode(head);\n        ListNode l1 = head;\n        ListNode l2 = mid.next;\n        mid.next = null;\n        //2.反转右端链表节点\n        l2 = reverseList(l2);\n        //3.链表两端合并\n        mergeList(l1, l2);\n    }\n\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while (cur != null) {\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n\n    public void mergeList(ListNode l1, ListNode l2) {\n        ListNode tempL1;\n        ListNode tempL2;\n        while (l1 != null && l2 != null) {\n            tempL1 = l1.next;\n            tempL2 = l2.next;\n\n            l1.next = l2;\n            l1 = tempL1;\n\n            l2.next = l1;\n            l2 = tempL2;\n        }\n    }\n}\n```\n\n时间复杂度：O(N)，其中 N是链表中的节点数\n\n空间复杂度：O(1)","source":"_posts/LeetCode/143重排链表.md","raw":"---\ntitle: 143重排链表\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/reorder-list/\n\n**注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果**\n\n这样我们的任务即可划分为几步：\n\n* 找到原链表的中点\n\n* 我们可以使用快慢指针来 O(N)找到链表的中间节点\n\n* 将原链表的右半端反转\n\n* 将原链表的两端合并\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null) {\n            return;\n        }\n        //1.找到链表中间节点\n        ListNode mid = middleNode(head);\n        ListNode l1 = head;\n        ListNode l2 = mid.next;\n        mid.next = null;\n        //2.反转右端链表节点\n        l2 = reverseList(l2);\n        //3.链表两端合并\n        mergeList(l1, l2);\n    }\n\n    public ListNode middleNode(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return slow;\n    }\n\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while (cur != null) {\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n\n    public void mergeList(ListNode l1, ListNode l2) {\n        ListNode tempL1;\n        ListNode tempL2;\n        while (l1 != null && l2 != null) {\n            tempL1 = l1.next;\n            tempL2 = l2.next;\n\n            l1.next = l2;\n            l1 = tempL1;\n\n            l2.next = l1;\n            l2 = tempL2;\n        }\n    }\n}\n```\n\n时间复杂度：O(N)，其中 N是链表中的节点数\n\n空间复杂度：O(1)","slug":"LeetCode/143重排链表","published":1,"date":"2021-09-01T05:22:18.206Z","updated":"2022-01-28T16:16:30.982Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfv005tfhji3xu5egpv","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reorder-list/\">https://leetcode-cn.com/problems/reorder-list/</a></p>\n<p><strong>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果</strong></p>\n<p>这样我们的任务即可划分为几步：</p>\n<ul>\n<li><p>找到原链表的中点</p>\n</li>\n<li><p>我们可以使用快慢指针来 O(N)找到链表的中间节点</p>\n</li>\n<li><p>将原链表的右半端反转</p>\n</li>\n<li><p>将原链表的两端合并</p>\n</li>\n</ul>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public void reorderList(ListNode head) &#123;\n        if (head == null) &#123;\n            return;\n        &#125;\n        //1.找到链表中间节点\n        ListNode mid = middleNode(head);\n        ListNode l1 = head;\n        ListNode l2 = mid.next;\n        mid.next = null;\n        //2.反转右端链表节点\n        l2 = reverseList(l2);\n        //3.链表两端合并\n        mergeList(l1, l2);\n    &#125;\n\n    public ListNode middleNode(ListNode head) &#123;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;\n            slow = slow.next;\n            fast = fast.next.next;\n        &#125;\n        return slow;\n    &#125;\n\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre = null;\n        ListNode cur = head;\n        while (cur != null) &#123;\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        &#125;\n        return pre;\n    &#125;\n\n    public void mergeList(ListNode l1, ListNode l2) &#123;\n        ListNode tempL1;\n        ListNode tempL2;\n        while (l1 != null &amp;&amp; l2 != null) &#123;\n            tempL1 = l1.next;\n            tempL2 = l2.next;\n\n            l1.next = l2;\n            l1 = tempL1;\n\n            l2.next = l1;\n            l2 = tempL2;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)，其中 N是链表中的节点数</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reorder-list/\">https://leetcode-cn.com/problems/reorder-list/</a></p>\n<p><strong>注意到目标链表即为将原链表的左半端和反转后的右半端合并后的结果</strong></p>\n<p>这样我们的任务即可划分为几步：</p>\n<ul>\n<li><p>找到原链表的中点</p>\n</li>\n<li><p>我们可以使用快慢指针来 O(N)找到链表的中间节点</p>\n</li>\n<li><p>将原链表的右半端反转</p>\n</li>\n<li><p>将原链表的两端合并</p>\n</li>\n</ul>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public void reorderList(ListNode head) &#123;\n        if (head == null) &#123;\n            return;\n        &#125;\n        //1.找到链表中间节点\n        ListNode mid = middleNode(head);\n        ListNode l1 = head;\n        ListNode l2 = mid.next;\n        mid.next = null;\n        //2.反转右端链表节点\n        l2 = reverseList(l2);\n        //3.链表两端合并\n        mergeList(l1, l2);\n    &#125;\n\n    public ListNode middleNode(ListNode head) &#123;\n        ListNode slow = head;\n        ListNode fast = head;\n        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;\n            slow = slow.next;\n            fast = fast.next.next;\n        &#125;\n        return slow;\n    &#125;\n\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre = null;\n        ListNode cur = head;\n        while (cur != null) &#123;\n            ListNode temp = cur.next;\n            cur.next = pre;\n            pre = cur;\n            cur = temp;\n        &#125;\n        return pre;\n    &#125;\n\n    public void mergeList(ListNode l1, ListNode l2) &#123;\n        ListNode tempL1;\n        ListNode tempL2;\n        while (l1 != null &amp;&amp; l2 != null) &#123;\n            tempL1 = l1.next;\n            tempL2 = l2.next;\n\n            l1.next = l2;\n            l1 = tempL1;\n\n            l2.next = l1;\n            l2 = tempL2;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)，其中 N是链表中的节点数</p>\n<p>空间复杂度：O(1)</p>\n"},{"title":"144二叉树的前序遍历","_content":"\n题目地址：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\n\n# 递归\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        preorder(root, result);\n        return result;\n    }\n\n    public void preorder(TreeNode root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    }\n}\n```\n\n# 栈\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        Stack<TreeNode> stack = new Stack<>();\n        while (root != null || !stack.isEmpty()) {\n            while(root!=null) {\n                result.add(root.val);\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            root = root.right;\n        }\n        return result;\n    }\n}\n```\n\n","source":"_posts/LeetCode/144二叉树的前序遍历.md","raw":"---\ntitle: 144二叉树的前序遍历\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\n\n# 递归\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        preorder(root, result);\n        return result;\n    }\n\n    public void preorder(TreeNode root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    }\n}\n```\n\n# 栈\n\n```java\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        Stack<TreeNode> stack = new Stack<>();\n        while (root != null || !stack.isEmpty()) {\n            while(root!=null) {\n                result.add(root.val);\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            root = root.right;\n        }\n        return result;\n    }\n}\n```\n\n","slug":"LeetCode/144二叉树的前序遍历","published":1,"date":"2021-09-01T05:22:18.206Z","updated":"2022-01-28T16:16:34.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfw005wfhjiannif64i","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        while (root != null || !stack.isEmpty()) &#123;\n            while(root!=null) &#123;\n                result.add(root.val);\n                stack.push(root);\n                root = root.left;\n            &#125;\n            root = stack.pop();\n            root = root.right;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-preorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        preorder(root, result);\n        return result;\n    &#125;\n\n    public void preorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        result.add(root.val);\n        preorder(root.left, result);\n        preorder(root.right, result);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        while (root != null || !stack.isEmpty()) &#123;\n            while(root!=null) &#123;\n                result.add(root.val);\n                stack.push(root);\n                root = root.left;\n            &#125;\n            root = stack.pop();\n            root = root.right;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"145二叉树的后序遍历","_content":"\n题目地址：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\n\n# 递归\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        postorder(root, result);\n        return result;\n    }\n\n    public void postorder(TreeNode root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        postorder(root.left, result);\n        postorder(root.right, result);\n        result.add(root.val);\n    }\n}\n```\n\n# 栈\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        //左，右，根\n        List<Integer> result = new ArrayList<Integer>();\n        Stack<TreeNode> stack = new Stack<>();\n        while (root!=null || !stack.isEmpty()) {\n            while(root!=null) {\n                result.add(root.val);\n                stack.push(root);\n                root = root.right;\n            }\n            root = stack.pop();\n            root = root.left;\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n```","source":"_posts/LeetCode/145二叉树的后序遍历.md","raw":"---\ntitle: 145二叉树的后序遍历\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\n\n# 递归\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<Integer>();\n        postorder(root, result);\n        return result;\n    }\n\n    public void postorder(TreeNode root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        postorder(root.left, result);\n        postorder(root.right, result);\n        result.add(root.val);\n    }\n}\n```\n\n# 栈\n\n```java\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        //左，右，根\n        List<Integer> result = new ArrayList<Integer>();\n        Stack<TreeNode> stack = new Stack<>();\n        while (root!=null || !stack.isEmpty()) {\n            while(root!=null) {\n                result.add(root.val);\n                stack.push(root);\n                root = root.right;\n            }\n            root = stack.pop();\n            root = root.left;\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n```","slug":"LeetCode/145二叉树的后序遍历","published":1,"date":"2021-09-01T05:22:18.206Z","updated":"2022-01-28T16:16:39.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfx005xfhjidn8b907a","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        postorder(root, result);\n        return result;\n    &#125;\n\n    public void postorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        postorder(root.left, result);\n        postorder(root.right, result);\n        result.add(root.val);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        //左，右，根\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        while (root!=null || !stack.isEmpty()) &#123;\n            while(root!=null) &#123;\n                result.add(root.val);\n                stack.push(root);\n                root = root.right;\n            &#125;\n            root = stack.pop();\n            root = root.left;\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-postorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-postorder-traversal/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        postorder(root, result);\n        return result;\n    &#125;\n\n    public void postorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        postorder(root.left, result);\n        postorder(root.right, result);\n        result.add(root.val);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;\n        //左，右，根\n        List&lt;Integer&gt; result = new ArrayList&lt;Integer&gt;();\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        while (root!=null || !stack.isEmpty()) &#123;\n            while(root!=null) &#123;\n                result.add(root.val);\n                stack.push(root);\n                root = root.right;\n            &#125;\n            root = stack.pop();\n            root = root.left;\n        &#125;\n        Collections.reverse(result);\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"146LRU缓存机制","_content":"\n题目地址：https://leetcode-cn.com/problems/lru-cache/\n\n```java\nclass DLinkedNode {\n    int key;\n    int value;\n    DLinkedNode prev;\n    DLinkedNode next;\n    public DLinkedNode() {}\n    public DLinkedNode(int key, int value) {\n        this.key = key; \n        this.value = value;\n    }\n}\n\npublic class LRUCache {\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        } else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```\n\n","source":"_posts/LeetCode/146LRU缓存机制.md","raw":"---\ntitle: 146LRU缓存机制\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/lru-cache/\n\n```java\nclass DLinkedNode {\n    int key;\n    int value;\n    DLinkedNode prev;\n    DLinkedNode next;\n    public DLinkedNode() {}\n    public DLinkedNode(int key, int value) {\n        this.key = key; \n        this.value = value;\n    }\n}\n\npublic class LRUCache {\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        } else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n```\n\n","slug":"LeetCode/146LRU缓存机制","published":1,"date":"2021-09-01T05:22:18.206Z","updated":"2022-01-28T16:16:43.414Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfy0060fhji0dls62gg","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/lru-cache/\">https://leetcode-cn.com/problems/lru-cache/</a></p>\n<pre><code class=\"java\">class DLinkedNode &#123;\n    int key;\n    int value;\n    DLinkedNode prev;\n    DLinkedNode next;\n    public DLinkedNode() &#123;&#125;\n    public DLinkedNode(int key, int value) &#123;\n        this.key = key; \n        this.value = value;\n    &#125;\n&#125;\n\npublic class LRUCache &#123;\n\n    private Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;Integer, DLinkedNode&gt;();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) &#123;\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    &#125;\n\n    public int get(int key) &#123;\n        DLinkedNode node = cache.get(key);\n        if (node == null) &#123;\n            return -1;\n        &#125;\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    &#125;\n\n    public void put(int key, int value) &#123;\n        DLinkedNode node = cache.get(key);\n        if (node == null) &#123;\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size &gt; capacity) &#123;\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            &#125;\n        &#125; else &#123;\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        &#125;\n    &#125;\n\n    private void addToHead(DLinkedNode node) &#123;\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    &#125;\n\n    private void removeNode(DLinkedNode node) &#123;\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    &#125;\n\n    private void moveToHead(DLinkedNode node) &#123;\n        removeNode(node);\n        addToHead(node);\n    &#125;\n\n    private DLinkedNode removeTail() &#123;\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/lru-cache/\">https://leetcode-cn.com/problems/lru-cache/</a></p>\n<pre><code class=\"java\">class DLinkedNode &#123;\n    int key;\n    int value;\n    DLinkedNode prev;\n    DLinkedNode next;\n    public DLinkedNode() &#123;&#125;\n    public DLinkedNode(int key, int value) &#123;\n        this.key = key; \n        this.value = value;\n    &#125;\n&#125;\n\npublic class LRUCache &#123;\n\n    private Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;Integer, DLinkedNode&gt;();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) &#123;\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    &#125;\n\n    public int get(int key) &#123;\n        DLinkedNode node = cache.get(key);\n        if (node == null) &#123;\n            return -1;\n        &#125;\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    &#125;\n\n    public void put(int key, int value) &#123;\n        DLinkedNode node = cache.get(key);\n        if (node == null) &#123;\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size &gt; capacity) &#123;\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            &#125;\n        &#125; else &#123;\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        &#125;\n    &#125;\n\n    private void addToHead(DLinkedNode node) &#123;\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    &#125;\n\n    private void removeNode(DLinkedNode node) &#123;\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    &#125;\n\n    private void moveToHead(DLinkedNode node) &#123;\n        removeNode(node);\n        addToHead(node);\n    &#125;\n\n    private DLinkedNode removeTail() &#123;\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"148排序链表","_content":"\n题目地址：https://leetcode-cn.com/problems/sort-list/\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201223132526.png\" style=\"zoom:50%;\" />\n\n```java\nimport java.util.*;\npublic class Solution {\n    public ListNode sortList (ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        \n        //使用快慢指针找到中点\n        ListNode slow = head, fast = head.next;\n        while(fast!=null && fast.next !=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        //分割为两个链表\n        ListNode newList = slow.next;\n        slow.next = null;\n        \n        //将两个链表继续分割\n        ListNode left = sortList(head);\n        ListNode right = sortList(newList);\n\n        ListNode leftHead = new ListNode(-1);\n        ListNode result = leftHead;\n        \n        //归并排序\n        while(left != null && right != null){\n            if(left.val < right.val){\n                leftHead.next = left;\n                left = left.next;\n            } else{\n                leftHead.next = right;\n                right = right.next;\n            }\n            leftHead = leftHead.next;\n        }\n        \n        //判断左右链表是否为空\n        leftHead.next = (left != null ? left : right);\n        return result.next;\n    }\n}\n```\n\n时间复杂度：`O(nlogn)`，其中 n 是链表的长度。","source":"_posts/LeetCode/148排序链表.md","raw":"---\ntitle: 148排序链表\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/sort-list/\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201223132526.png\" style=\"zoom:50%;\" />\n\n```java\nimport java.util.*;\npublic class Solution {\n    public ListNode sortList (ListNode head) {\n        if(head == null || head.next == null) {\n            return head;\n        }\n        \n        //使用快慢指针找到中点\n        ListNode slow = head, fast = head.next;\n        while(fast!=null && fast.next !=null){\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        \n        //分割为两个链表\n        ListNode newList = slow.next;\n        slow.next = null;\n        \n        //将两个链表继续分割\n        ListNode left = sortList(head);\n        ListNode right = sortList(newList);\n\n        ListNode leftHead = new ListNode(-1);\n        ListNode result = leftHead;\n        \n        //归并排序\n        while(left != null && right != null){\n            if(left.val < right.val){\n                leftHead.next = left;\n                left = left.next;\n            } else{\n                leftHead.next = right;\n                right = right.next;\n            }\n            leftHead = leftHead.next;\n        }\n        \n        //判断左右链表是否为空\n        leftHead.next = (left != null ? left : right);\n        return result.next;\n    }\n}\n```\n\n时间复杂度：`O(nlogn)`，其中 n 是链表的长度。","slug":"LeetCode/148排序链表","published":1,"date":"2021-09-01T05:22:18.206Z","updated":"2022-01-28T16:16:51.705Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfy0061fhji08mm00k1","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sort-list/\">https://leetcode-cn.com/problems/sort-list/</a></p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201223132526.png\" style=\"zoom:50%;\" />\n\n<pre><code class=\"java\">import java.util.*;\npublic class Solution &#123;\n    public ListNode sortList (ListNode head) &#123;\n        if(head == null || head.next == null) &#123;\n            return head;\n        &#125;\n        \n        //使用快慢指针找到中点\n        ListNode slow = head, fast = head.next;\n        while(fast!=null &amp;&amp; fast.next !=null)&#123;\n            slow = slow.next;\n            fast = fast.next.next;\n        &#125;\n        \n        //分割为两个链表\n        ListNode newList = slow.next;\n        slow.next = null;\n        \n        //将两个链表继续分割\n        ListNode left = sortList(head);\n        ListNode right = sortList(newList);\n\n        ListNode leftHead = new ListNode(-1);\n        ListNode result = leftHead;\n        \n        //归并排序\n        while(left != null &amp;&amp; right != null)&#123;\n            if(left.val &lt; right.val)&#123;\n                leftHead.next = left;\n                left = left.next;\n            &#125; else&#123;\n                leftHead.next = right;\n                right = right.next;\n            &#125;\n            leftHead = leftHead.next;\n        &#125;\n        \n        //判断左右链表是否为空\n        leftHead.next = (left != null ? left : right);\n        return result.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(nlogn)</code>，其中 n 是链表的长度。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sort-list/\">https://leetcode-cn.com/problems/sort-list/</a></p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201223132526.png\" style=\"zoom:50%;\" />\n\n<pre><code class=\"java\">import java.util.*;\npublic class Solution &#123;\n    public ListNode sortList (ListNode head) &#123;\n        if(head == null || head.next == null) &#123;\n            return head;\n        &#125;\n        \n        //使用快慢指针找到中点\n        ListNode slow = head, fast = head.next;\n        while(fast!=null &amp;&amp; fast.next !=null)&#123;\n            slow = slow.next;\n            fast = fast.next.next;\n        &#125;\n        \n        //分割为两个链表\n        ListNode newList = slow.next;\n        slow.next = null;\n        \n        //将两个链表继续分割\n        ListNode left = sortList(head);\n        ListNode right = sortList(newList);\n\n        ListNode leftHead = new ListNode(-1);\n        ListNode result = leftHead;\n        \n        //归并排序\n        while(left != null &amp;&amp; right != null)&#123;\n            if(left.val &lt; right.val)&#123;\n                leftHead.next = left;\n                left = left.next;\n            &#125; else&#123;\n                leftHead.next = right;\n                right = right.next;\n            &#125;\n            leftHead = leftHead.next;\n        &#125;\n        \n        //判断左右链表是否为空\n        leftHead.next = (left != null ? left : right);\n        return result.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(nlogn)</code>，其中 n 是链表的长度。</p>\n"},{"title":"14最长公共前缀","_content":"\n题目地址：https://leetcode-cn.com/problems/longest-common-prefix/\n\n当字符串数组长度为 0 时则公共前缀为空，直接返回\n\n令最长公共前缀 result 的值为第一个字符串，进行初始化\n\n遍历后面的字符串，依次将其与 result 进行比较，两两找出公共前缀，最终结果即为最长公共前缀\n\n如果查找过程中出现了 result 为空的情况，则公共前缀不存在直接返回\n\n时间复杂度：O(s)，s 为所有字符串的长度之和\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return \"\";\n        }\n        String result = strs[0];\n        for (int i = 1;i<strs.length; i++) {\n            int j = 0;\n            for (j = 0;j<result.length()&&j<strs[i].length();j++) {\n                if (result.charAt(j) != strs[i].charAt(j)) {\n                    break;\n                }\n            }\n            result = result.substring(0, j);\n            if (\"\".equals(result)) {\n                return \"\";\n            }\n        }\n        return result;\n    }\n}\n```\n\n","source":"_posts/LeetCode/14最长公共前缀.md","raw":"---\ntitle: 14最长公共前缀\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/longest-common-prefix/\n\n当字符串数组长度为 0 时则公共前缀为空，直接返回\n\n令最长公共前缀 result 的值为第一个字符串，进行初始化\n\n遍历后面的字符串，依次将其与 result 进行比较，两两找出公共前缀，最终结果即为最长公共前缀\n\n如果查找过程中出现了 result 为空的情况，则公共前缀不存在直接返回\n\n时间复杂度：O(s)，s 为所有字符串的长度之和\n\n```java\nclass Solution {\n    public String longestCommonPrefix(String[] strs) {\n        if (strs == null || strs.length == 0) {\n            return \"\";\n        }\n        String result = strs[0];\n        for (int i = 1;i<strs.length; i++) {\n            int j = 0;\n            for (j = 0;j<result.length()&&j<strs[i].length();j++) {\n                if (result.charAt(j) != strs[i].charAt(j)) {\n                    break;\n                }\n            }\n            result = result.substring(0, j);\n            if (\"\".equals(result)) {\n                return \"\";\n            }\n        }\n        return result;\n    }\n}\n```\n\n","slug":"LeetCode/14最长公共前缀","published":1,"date":"2021-09-01T05:22:18.207Z","updated":"2021-12-29T06:50:50.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwfz0064fhji5umlegf8","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>\n<p>当字符串数组长度为 0 时则公共前缀为空，直接返回</p>\n<p>令最长公共前缀 result 的值为第一个字符串，进行初始化</p>\n<p>遍历后面的字符串，依次将其与 result 进行比较，两两找出公共前缀，最终结果即为最长公共前缀</p>\n<p>如果查找过程中出现了 result 为空的情况，则公共前缀不存在直接返回</p>\n<p>时间复杂度：O(s)，s 为所有字符串的长度之和</p>\n<pre><code class=\"java\">class Solution &#123;\n    public String longestCommonPrefix(String[] strs) &#123;\n        if (strs == null || strs.length == 0) &#123;\n            return &quot;&quot;;\n        &#125;\n        String result = strs[0];\n        for (int i = 1;i&lt;strs.length; i++) &#123;\n            int j = 0;\n            for (j = 0;j&lt;result.length()&amp;&amp;j&lt;strs[i].length();j++) &#123;\n                if (result.charAt(j) != strs[i].charAt(j)) &#123;\n                    break;\n                &#125;\n            &#125;\n            result = result.substring(0, j);\n            if (&quot;&quot;.equals(result)) &#123;\n                return &quot;&quot;;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-common-prefix/\">https://leetcode-cn.com/problems/longest-common-prefix/</a></p>\n<p>当字符串数组长度为 0 时则公共前缀为空，直接返回</p>\n<p>令最长公共前缀 result 的值为第一个字符串，进行初始化</p>\n<p>遍历后面的字符串，依次将其与 result 进行比较，两两找出公共前缀，最终结果即为最长公共前缀</p>\n<p>如果查找过程中出现了 result 为空的情况，则公共前缀不存在直接返回</p>\n<p>时间复杂度：O(s)，s 为所有字符串的长度之和</p>\n<pre><code class=\"java\">class Solution &#123;\n    public String longestCommonPrefix(String[] strs) &#123;\n        if (strs == null || strs.length == 0) &#123;\n            return &quot;&quot;;\n        &#125;\n        String result = strs[0];\n        for (int i = 1;i&lt;strs.length; i++) &#123;\n            int j = 0;\n            for (j = 0;j&lt;result.length()&amp;&amp;j&lt;strs[i].length();j++) &#123;\n                if (result.charAt(j) != strs[i].charAt(j)) &#123;\n                    break;\n                &#125;\n            &#125;\n            result = result.substring(0, j);\n            if (&quot;&quot;.equals(result)) &#123;\n                return &quot;&quot;;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"152乘积最大子数组","_content":"\n题目地址：https://leetcode-cn.com/problems/maximum-product-subarray/\n\n遍历数组时计算当前最大值，不断更新\n\n令imax为当前最大值，则当前最大值为` imax = max(imax * nums[i], nums[i])`\n\n由于存在负数，那么会导致最大的变最小的，最小的变最大的。\n\n因此还需要维护当前最小值imin，`imin = min(imin * nums[i], nums[i])`\n\n当负数出现时则imax与imin进行交换再进行下一步计算\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int max = Integer.MIN_VALUE, imax = 1, imin = 1;\n        for(int i=0; i<nums.length; i++){\n            if(nums[i] < 0){ \n              int tmp = imax;\n              imax = imin;\n              imin = tmp;\n            }\n            imax = Math.max(imax*nums[i], nums[i]);\n            imin = Math.min(imin*nums[i], nums[i]);\n            \n            max = Math.max(max, imax);\n        }\n        return max;\n    }\n}\n```\n\n时间复杂度：O(n)","source":"_posts/LeetCode/152乘积最大子数组.md","raw":"---\ntitle: 152乘积最大子数组\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/maximum-product-subarray/\n\n遍历数组时计算当前最大值，不断更新\n\n令imax为当前最大值，则当前最大值为` imax = max(imax * nums[i], nums[i])`\n\n由于存在负数，那么会导致最大的变最小的，最小的变最大的。\n\n因此还需要维护当前最小值imin，`imin = min(imin * nums[i], nums[i])`\n\n当负数出现时则imax与imin进行交换再进行下一步计算\n\n```java\nclass Solution {\n    public int maxProduct(int[] nums) {\n        int max = Integer.MIN_VALUE, imax = 1, imin = 1;\n        for(int i=0; i<nums.length; i++){\n            if(nums[i] < 0){ \n              int tmp = imax;\n              imax = imin;\n              imin = tmp;\n            }\n            imax = Math.max(imax*nums[i], nums[i]);\n            imin = Math.min(imin*nums[i], nums[i]);\n            \n            max = Math.max(max, imax);\n        }\n        return max;\n    }\n}\n```\n\n时间复杂度：O(n)","slug":"LeetCode/152乘积最大子数组","published":1,"date":"2021-11-26T13:23:27.495Z","updated":"2022-01-28T16:16:58.138Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg00065fhjicqyu2mcy","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/maximum-product-subarray/\">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p>\n<p>遍历数组时计算当前最大值，不断更新</p>\n<p>令imax为当前最大值，则当前最大值为<code> imax = max(imax * nums[i], nums[i])</code></p>\n<p>由于存在负数，那么会导致最大的变最小的，最小的变最大的。</p>\n<p>因此还需要维护当前最小值imin，<code>imin = min(imin * nums[i], nums[i])</code></p>\n<p>当负数出现时则imax与imin进行交换再进行下一步计算</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxProduct(int[] nums) &#123;\n        int max = Integer.MIN_VALUE, imax = 1, imin = 1;\n        for(int i=0; i&lt;nums.length; i++)&#123;\n            if(nums[i] &lt; 0)&#123; \n              int tmp = imax;\n              imax = imin;\n              imin = tmp;\n            &#125;\n            imax = Math.max(imax*nums[i], nums[i]);\n            imin = Math.min(imin*nums[i], nums[i]);\n            \n            max = Math.max(max, imax);\n        &#125;\n        return max;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/maximum-product-subarray/\">https://leetcode-cn.com/problems/maximum-product-subarray/</a></p>\n<p>遍历数组时计算当前最大值，不断更新</p>\n<p>令imax为当前最大值，则当前最大值为<code> imax = max(imax * nums[i], nums[i])</code></p>\n<p>由于存在负数，那么会导致最大的变最小的，最小的变最大的。</p>\n<p>因此还需要维护当前最小值imin，<code>imin = min(imin * nums[i], nums[i])</code></p>\n<p>当负数出现时则imax与imin进行交换再进行下一步计算</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxProduct(int[] nums) &#123;\n        int max = Integer.MIN_VALUE, imax = 1, imin = 1;\n        for(int i=0; i&lt;nums.length; i++)&#123;\n            if(nums[i] &lt; 0)&#123; \n              int tmp = imax;\n              imax = imin;\n              imin = tmp;\n            &#125;\n            imax = Math.max(imax*nums[i], nums[i]);\n            imin = Math.min(imin*nums[i], nums[i]);\n            \n            max = Math.max(max, imax);\n        &#125;\n        return max;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n"},{"title":"155最小栈","_content":"\n题目地址：https://leetcode-cn.com/problems/min-stack/\n\n```java\nclass MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n    public void push(int x) {\n        stack.push(x);\n        if(minStack.isEmpty() || x <= minStack.peek()) {\n            minStack.push(x);\n        }\n    }\n    public void pop() {\n        if(stack.pop().equals(minStack.peek())) {\n            minStack.pop();\n        }\n    }\n    public int top() {\n        return stack.peek();\n    }\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n```\n\n","source":"_posts/LeetCode/155最小栈.md","raw":"---\ntitle: 155最小栈\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/min-stack/\n\n```java\nclass MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n    public void push(int x) {\n        stack.push(x);\n        if(minStack.isEmpty() || x <= minStack.peek()) {\n            minStack.push(x);\n        }\n    }\n    public void pop() {\n        if(stack.pop().equals(minStack.peek())) {\n            minStack.pop();\n        }\n    }\n    public int top() {\n        return stack.peek();\n    }\n    public int getMin() {\n        return minStack.peek();\n    }\n}\n```\n\n","slug":"LeetCode/155最小栈","published":1,"date":"2021-09-01T05:22:18.207Z","updated":"2022-01-28T16:17:03.832Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg10068fhjie9ngcx6u","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/min-stack/\">https://leetcode-cn.com/problems/min-stack/</a></p>\n<pre><code class=\"java\">class MinStack &#123;\n    private Stack&lt;Integer&gt; stack;\n    private Stack&lt;Integer&gt; minStack;\n    public MinStack() &#123;\n        stack = new Stack&lt;&gt;();\n        minStack = new Stack&lt;&gt;();\n    &#125;\n    public void push(int x) &#123;\n        stack.push(x);\n        if(minStack.isEmpty() || x &lt;= minStack.peek()) &#123;\n            minStack.push(x);\n        &#125;\n    &#125;\n    public void pop() &#123;\n        if(stack.pop().equals(minStack.peek())) &#123;\n            minStack.pop();\n        &#125;\n    &#125;\n    public int top() &#123;\n        return stack.peek();\n    &#125;\n    public int getMin() &#123;\n        return minStack.peek();\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/min-stack/\">https://leetcode-cn.com/problems/min-stack/</a></p>\n<pre><code class=\"java\">class MinStack &#123;\n    private Stack&lt;Integer&gt; stack;\n    private Stack&lt;Integer&gt; minStack;\n    public MinStack() &#123;\n        stack = new Stack&lt;&gt;();\n        minStack = new Stack&lt;&gt;();\n    &#125;\n    public void push(int x) &#123;\n        stack.push(x);\n        if(minStack.isEmpty() || x &lt;= minStack.peek()) &#123;\n            minStack.push(x);\n        &#125;\n    &#125;\n    public void pop() &#123;\n        if(stack.pop().equals(minStack.peek())) &#123;\n            minStack.pop();\n        &#125;\n    &#125;\n    public int top() &#123;\n        return stack.peek();\n    &#125;\n    public int getMin() &#123;\n        return minStack.peek();\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"15三数之和","_content":"\n题目地址：https://leetcode-cn.com/problems/3sum/\n\n````java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums == null || nums.length < 3) {\n            return result;\n        }\n        Arrays.sort(nums);\n        for (int i =0;i<nums.length;i++) {\n            //如果当前数字大于0，则三数之和一定大于0，所以结束循环\n            if (nums[i] > 0) {\n                break;\n            }\n            if (i > 0 && nums[i] == nums[i-1]) {\n                continue;\n            }\n            int L = i + 1;\n            int R = nums.length - 1;\n            while (L < R) {\n                int sum = nums[i] + nums[L] + nums[R];\n                //同时左指针往右移动，右指针往左移动\n                //如果移动过程中碰到重复元素，则继续移动\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[L], nums[R]));\n                    // 去重\n                    while (L<R && nums[L] == nums[L+1]) {\n                        L++;\n                    }\n                    // 去重\n                    while(L<R && nums[R] == nums[R-1]) {\n                        R--;\n                    }\n                    L++;\n                    R--;\n                } else if (sum > 0) {\n                    R--;\n                } else {\n                    L++;\n                }\n            }\n        }\n        return result;\n    }\n}\n````\n\n","source":"_posts/LeetCode/15三数之和.md","raw":"---\ntitle: 15三数之和\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/3sum/\n\n````java\nclass Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums == null || nums.length < 3) {\n            return result;\n        }\n        Arrays.sort(nums);\n        for (int i =0;i<nums.length;i++) {\n            //如果当前数字大于0，则三数之和一定大于0，所以结束循环\n            if (nums[i] > 0) {\n                break;\n            }\n            if (i > 0 && nums[i] == nums[i-1]) {\n                continue;\n            }\n            int L = i + 1;\n            int R = nums.length - 1;\n            while (L < R) {\n                int sum = nums[i] + nums[L] + nums[R];\n                //同时左指针往右移动，右指针往左移动\n                //如果移动过程中碰到重复元素，则继续移动\n                if (sum == 0) {\n                    result.add(Arrays.asList(nums[i], nums[L], nums[R]));\n                    // 去重\n                    while (L<R && nums[L] == nums[L+1]) {\n                        L++;\n                    }\n                    // 去重\n                    while(L<R && nums[R] == nums[R-1]) {\n                        R--;\n                    }\n                    L++;\n                    R--;\n                } else if (sum > 0) {\n                    R--;\n                } else {\n                    L++;\n                }\n            }\n        }\n        return result;\n    }\n}\n````\n\n","slug":"LeetCode/15三数之和","published":1,"date":"2021-09-01T05:22:18.207Z","updated":"2021-12-30T04:33:22.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg10069fhji5p6pb2dc","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/3sum/\">https://leetcode-cn.com/problems/3sum/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length &lt; 3) &#123;\n            return result;\n        &#125;\n        Arrays.sort(nums);\n        for (int i =0;i&lt;nums.length;i++) &#123;\n            //如果当前数字大于0，则三数之和一定大于0，所以结束循环\n            if (nums[i] &gt; 0) &#123;\n                break;\n            &#125;\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123;\n                continue;\n            &#125;\n            int L = i + 1;\n            int R = nums.length - 1;\n            while (L &lt; R) &#123;\n                int sum = nums[i] + nums[L] + nums[R];\n                //同时左指针往右移动，右指针往左移动\n                //如果移动过程中碰到重复元素，则继续移动\n                if (sum == 0) &#123;\n                    result.add(Arrays.asList(nums[i], nums[L], nums[R]));\n                    // 去重\n                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) &#123;\n                        L++;\n                    &#125;\n                    // 去重\n                    while(L&lt;R &amp;&amp; nums[R] == nums[R-1]) &#123;\n                        R--;\n                    &#125;\n                    L++;\n                    R--;\n                &#125; else if (sum &gt; 0) &#123;\n                    R--;\n                &#125; else &#123;\n                    L++;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/3sum/\">https://leetcode-cn.com/problems/3sum/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length &lt; 3) &#123;\n            return result;\n        &#125;\n        Arrays.sort(nums);\n        for (int i =0;i&lt;nums.length;i++) &#123;\n            //如果当前数字大于0，则三数之和一定大于0，所以结束循环\n            if (nums[i] &gt; 0) &#123;\n                break;\n            &#125;\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i-1]) &#123;\n                continue;\n            &#125;\n            int L = i + 1;\n            int R = nums.length - 1;\n            while (L &lt; R) &#123;\n                int sum = nums[i] + nums[L] + nums[R];\n                //同时左指针往右移动，右指针往左移动\n                //如果移动过程中碰到重复元素，则继续移动\n                if (sum == 0) &#123;\n                    result.add(Arrays.asList(nums[i], nums[L], nums[R]));\n                    // 去重\n                    while (L&lt;R &amp;&amp; nums[L] == nums[L+1]) &#123;\n                        L++;\n                    &#125;\n                    // 去重\n                    while(L&lt;R &amp;&amp; nums[R] == nums[R-1]) &#123;\n                        R--;\n                    &#125;\n                    L++;\n                    R--;\n                &#125; else if (sum &gt; 0) &#123;\n                    R--;\n                &#125; else &#123;\n                    L++;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"16.06最小差","_content":"\n题目地址：https://leetcode-cn.com/problems/smallest-difference-lcci/\n\n对两个数组进行排序\n\n遍历两个数组，每次计算差值 就是对较小的那个进行迭代\n\n```java\nclass Solution {\n\n    public int smallestDifference(int[] a, int[] b) {\n        long result = Integer.MAX_VALUE;\n        Arrays.sort(a);\n        Arrays.sort(b);\n\n        for (int i = 0, j = 0; i < a.length && j < b.length; ) {\n            result = Math.min(result, Math.abs((long) a[i] - b[j]));\n            if (a[i] < b[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        return (int) result;\n    }\n}\n```\n\n\n\n","source":"_posts/LeetCode/16.06最小差.md","raw":"---\ntitle: 16.06最小差\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/smallest-difference-lcci/\n\n对两个数组进行排序\n\n遍历两个数组，每次计算差值 就是对较小的那个进行迭代\n\n```java\nclass Solution {\n\n    public int smallestDifference(int[] a, int[] b) {\n        long result = Integer.MAX_VALUE;\n        Arrays.sort(a);\n        Arrays.sort(b);\n\n        for (int i = 0, j = 0; i < a.length && j < b.length; ) {\n            result = Math.min(result, Math.abs((long) a[i] - b[j]));\n            if (a[i] < b[j]) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n\n        return (int) result;\n    }\n}\n```\n\n\n\n","slug":"LeetCode/16.06最小差","published":1,"date":"2021-09-01T05:22:18.217Z","updated":"2022-02-02T02:46:47.855Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg2006cfhjiefvedhj7","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/smallest-difference-lcci/\">https://leetcode-cn.com/problems/smallest-difference-lcci/</a></p>\n<p>对两个数组进行排序</p>\n<p>遍历两个数组，每次计算差值 就是对较小的那个进行迭代</p>\n<pre><code class=\"java\">class Solution &#123;\n\n    public int smallestDifference(int[] a, int[] b) &#123;\n        long result = Integer.MAX_VALUE;\n        Arrays.sort(a);\n        Arrays.sort(b);\n\n        for (int i = 0, j = 0; i &lt; a.length &amp;&amp; j &lt; b.length; ) &#123;\n            result = Math.min(result, Math.abs((long) a[i] - b[j]));\n            if (a[i] &lt; b[j]) &#123;\n                i++;\n            &#125; else &#123;\n                j++;\n            &#125;\n        &#125;\n\n        return (int) result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/smallest-difference-lcci/\">https://leetcode-cn.com/problems/smallest-difference-lcci/</a></p>\n<p>对两个数组进行排序</p>\n<p>遍历两个数组，每次计算差值 就是对较小的那个进行迭代</p>\n<pre><code class=\"java\">class Solution &#123;\n\n    public int smallestDifference(int[] a, int[] b) &#123;\n        long result = Integer.MAX_VALUE;\n        Arrays.sort(a);\n        Arrays.sort(b);\n\n        for (int i = 0, j = 0; i &lt; a.length &amp;&amp; j &lt; b.length; ) &#123;\n            result = Math.min(result, Math.abs((long) a[i] - b[j]));\n            if (a[i] &lt; b[j]) &#123;\n                i++;\n            &#125; else &#123;\n                j++;\n            &#125;\n        &#125;\n\n        return (int) result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"160相交链表","_content":"\n题目地址：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n# 双指针\n\n创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。\n\n当 pA到达链表的尾部时，将它重定位到链表 B 的头结点，类似的，当 pB到达链表的尾部时，将它重定位到链表 A 的头结点。\n\n若在某一时刻 pA和 pB 相遇，则 pA/pB为相交结点。\n\n可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 \n\n由于 `B.length (=4) < A.length (=6`)，pB比 pA少经过 2个结点，会先到达尾部。将 pB重定向到 A 的头结点，pA重定向到 B 的头结点后，pB要比 pA多走 2 个结点。因此，它们会同时到达交点。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode head1 = headA;\n        ListNode head2 = headB;\n\n        while (head1 != head2) {\n            if (head1 != null) {\n                head1 = head1.next;\n            } else {\n                head1 = headB;\n            }\n\n            if (head2 != null) {\n                head2 = head2.next;\n            } else {\n                head2 = headA;\n            }\n        }\n        return head1;\n    }\n}\n```\n\n时间复杂度 : O(m+n)。\n\n空间复杂度 : O(1)。","source":"_posts/LeetCode/160相交链表.md","raw":"---\ntitle: 160相交链表\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\n\n# 双指针\n\n创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。\n\n当 pA到达链表的尾部时，将它重定位到链表 B 的头结点，类似的，当 pB到达链表的尾部时，将它重定位到链表 A 的头结点。\n\n若在某一时刻 pA和 pB 相遇，则 pA/pB为相交结点。\n\n可以考虑以下两个链表: A={1,3,5,7,9,11} 和 B={2,4,9,11}，相交于结点 9。 \n\n由于 `B.length (=4) < A.length (=6`)，pB比 pA少经过 2个结点，会先到达尾部。将 pB重定向到 A 的头结点，pA重定向到 B 的头结点后，pB要比 pA多走 2 个结点。因此，它们会同时到达交点。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode head1 = headA;\n        ListNode head2 = headB;\n\n        while (head1 != head2) {\n            if (head1 != null) {\n                head1 = head1.next;\n            } else {\n                head1 = headB;\n            }\n\n            if (head2 != null) {\n                head2 = head2.next;\n            } else {\n                head2 = headA;\n            }\n        }\n        return head1;\n    }\n}\n```\n\n时间复杂度 : O(m+n)。\n\n空间复杂度 : O(1)。","slug":"LeetCode/160相交链表","published":1,"date":"2021-09-01T05:22:18.207Z","updated":"2022-01-28T16:17:10.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg3006dfhji0ji18dcp","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><p>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。</p>\n<p>当 pA到达链表的尾部时，将它重定位到链表 B 的头结点，类似的，当 pB到达链表的尾部时，将它重定位到链表 A 的头结点。</p>\n<p>若在某一时刻 pA和 pB 相遇，则 pA&#x2F;pB为相交结点。</p>\n<p>可以考虑以下两个链表: A&#x3D;{1,3,5,7,9,11} 和 B&#x3D;{2,4,9,11}，相交于结点 9。 </p>\n<p>由于 <code>B.length (=4) &lt; A.length (=6</code>)，pB比 pA少经过 2个结点，会先到达尾部。将 pB重定向到 A 的头结点，pA重定向到 B 的头结点后，pB要比 pA多走 2 个结点。因此，它们会同时到达交点。</p>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val = x;\n *         next = null;\n *     &#125;\n * &#125;\n */\npublic class Solution &#123;\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n        if (headA == null || headB == null) &#123;\n            return null;\n        &#125;\n\n        ListNode head1 = headA;\n        ListNode head2 = headB;\n\n        while (head1 != head2) &#123;\n            if (head1 != null) &#123;\n                head1 = head1.next;\n            &#125; else &#123;\n                head1 = headB;\n            &#125;\n\n            if (head2 != null) &#123;\n                head2 = head2.next;\n            &#125; else &#123;\n                head2 = headA;\n            &#125;\n        &#125;\n        return head1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 : O(m+n)。</p>\n<p>空间复杂度 : O(1)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/intersection-of-two-linked-lists/\">https://leetcode-cn.com/problems/intersection-of-two-linked-lists/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><p>创建两个指针 pA 和 pB，分别初始化为链表 A 和 B 的头结点。然后让它们向后逐结点遍历。</p>\n<p>当 pA到达链表的尾部时，将它重定位到链表 B 的头结点，类似的，当 pB到达链表的尾部时，将它重定位到链表 A 的头结点。</p>\n<p>若在某一时刻 pA和 pB 相遇，则 pA&#x2F;pB为相交结点。</p>\n<p>可以考虑以下两个链表: A&#x3D;{1,3,5,7,9,11} 和 B&#x3D;{2,4,9,11}，相交于结点 9。 </p>\n<p>由于 <code>B.length (=4) &lt; A.length (=6</code>)，pB比 pA少经过 2个结点，会先到达尾部。将 pB重定向到 A 的头结点，pA重定向到 B 的头结点后，pB要比 pA多走 2 个结点。因此，它们会同时到达交点。</p>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val = x;\n *         next = null;\n *     &#125;\n * &#125;\n */\npublic class Solution &#123;\n\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n        if (headA == null || headB == null) &#123;\n            return null;\n        &#125;\n\n        ListNode head1 = headA;\n        ListNode head2 = headB;\n\n        while (head1 != head2) &#123;\n            if (head1 != null) &#123;\n                head1 = head1.next;\n            &#125; else &#123;\n                head1 = headB;\n            &#125;\n\n            if (head2 != null) &#123;\n                head2 = head2.next;\n            &#125; else &#123;\n                head2 = headA;\n            &#125;\n        &#125;\n        return head1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 : O(m+n)。</p>\n<p>空间复杂度 : O(1)。</p>\n"},{"title":"162寻找峰值","_content":"\n题目地址：https://leetcode-cn.com/problems/find-peak-element/\n\n# 二分查找\n\n查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件\n\n根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m\n\n如果 m + 1 较大，则右侧存在峰值，l = m + 1\n\n```java\npublic class Solution {\n    public int findPeakElement(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] > nums[mid + 1]) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}\n```\n\n时间复杂度 : `O(log2(n))`\n\n空间复杂度 : `O(1)`\n\n","source":"_posts/LeetCode/162寻找峰值.md","raw":"---\ntitle: 162寻找峰值\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/find-peak-element/\n\n# 二分查找\n\n查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件\n\n根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r = m\n\n如果 m + 1 较大，则右侧存在峰值，l = m + 1\n\n```java\npublic class Solution {\n    public int findPeakElement(int[] nums) {\n        int l = 0, r = nums.length - 1;\n        while (l < r) {\n            int mid = (l + r) / 2;\n            if (nums[mid] > nums[mid + 1]) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l;\n    }\n}\n```\n\n时间复杂度 : `O(log2(n))`\n\n空间复杂度 : `O(1)`\n\n","slug":"LeetCode/162寻找峰值","published":1,"date":"2021-09-08T17:10:27.939Z","updated":"2022-01-28T16:17:14.881Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg4006gfhjiddxr8omg","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/find-peak-element/\">https://leetcode-cn.com/problems/find-peak-element/</a></p>\n<h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><p>查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件</p>\n<p>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r &#x3D; m</p>\n<p>如果 m + 1 较大，则右侧存在峰值，l &#x3D; m + 1</p>\n<pre><code class=\"java\">public class Solution &#123;\n    public int findPeakElement(int[] nums) &#123;\n        int l = 0, r = nums.length - 1;\n        while (l &lt; r) &#123;\n            int mid = (l + r) / 2;\n            if (nums[mid] &gt; nums[mid + 1]) &#123;\n                r = mid;\n            &#125; else &#123;\n                l = mid + 1;\n            &#125;\n        &#125;\n        return l;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 : <code>O(log2(n))</code></p>\n<p>空间复杂度 : <code>O(1)</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/find-peak-element/\">https://leetcode-cn.com/problems/find-peak-element/</a></p>\n<h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><p>查找时，左指针 l，右指针 r，以其保持左右顺序为循环条件</p>\n<p>根据左右指针计算中间位置 m，并比较 m 与 m+1 的值，如果 m 较大，则左侧存在峰值，r &#x3D; m</p>\n<p>如果 m + 1 较大，则右侧存在峰值，l &#x3D; m + 1</p>\n<pre><code class=\"java\">public class Solution &#123;\n    public int findPeakElement(int[] nums) &#123;\n        int l = 0, r = nums.length - 1;\n        while (l &lt; r) &#123;\n            int mid = (l + r) / 2;\n            if (nums[mid] &gt; nums[mid + 1]) &#123;\n                r = mid;\n            &#125; else &#123;\n                l = mid + 1;\n            &#125;\n        &#125;\n        return l;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 : <code>O(log2(n))</code></p>\n<p>空间复杂度 : <code>O(1)</code></p>\n"},{"title":"169多数元素","_content":"\n题目地址:https://leetcode-cn.com/problems/majority-element/\n\n**摩尔投票法原理**\n\n投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1\n\n且“多数元素”的个数`> n/2`，其余元素的个数总和`< n/2 `\n\n因此`“多数元素”的个数 - 其余元素的个数总和` 的结果 肯定 >= 1\n\n这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”\n\n无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int result = nums[0], count = 1;\n        for (int i = 1;i<nums.length;i++) {\n            if (result == nums[i]) {\n                count++;\n            } else {\n                count--;\n            }\n            if (count == 0) {\n                result = nums[i];\n                count=1;\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)，只对数组进行了一次遍历\n\n空间复杂度：O(1)","source":"_posts/LeetCode/169多数元素.md","raw":"---\ntitle: 169多数元素\ncategories: \n- LeetCode\n---\n\n题目地址:https://leetcode-cn.com/problems/majority-element/\n\n**摩尔投票法原理**\n\n投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1\n\n且“多数元素”的个数`> n/2`，其余元素的个数总和`< n/2 `\n\n因此`“多数元素”的个数 - 其余元素的个数总和` 的结果 肯定 >= 1\n\n这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”\n\n无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        int result = nums[0], count = 1;\n        for (int i = 1;i<nums.length;i++) {\n            if (result == nums[i]) {\n                count++;\n            } else {\n                count--;\n            }\n            if (count == 0) {\n                result = nums[i];\n                count=1;\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)，只对数组进行了一次遍历\n\n空间复杂度：O(1)","slug":"LeetCode/169多数元素","published":1,"date":"2021-09-01T05:22:18.207Z","updated":"2022-01-28T16:17:19.303Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg4006hfhji1m5lfslw","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/majority-element/\">https://leetcode-cn.com/problems/majority-element/</a></p>\n<p><strong>摩尔投票法原理</strong></p>\n<p>投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1</p>\n<p>且“多数元素”的个数<code>&gt; n/2</code>，其余元素的个数总和<code>&lt; n/2 </code></p>\n<p>因此<code>“多数元素”的个数 - 其余元素的个数总和</code> 的结果 肯定 &gt;&#x3D; 1</p>\n<p>这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”</p>\n<p>无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int majorityElement(int[] nums) &#123;\n        int result = nums[0], count = 1;\n        for (int i = 1;i&lt;nums.length;i++) &#123;\n            if (result == nums[i]) &#123;\n                count++;\n            &#125; else &#123;\n                count--;\n            &#125;\n            if (count == 0) &#123;\n                result = nums[i];\n                count=1;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，只对数组进行了一次遍历</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/majority-element/\">https://leetcode-cn.com/problems/majority-element/</a></p>\n<p><strong>摩尔投票法原理</strong></p>\n<p>投票法是遇到相同的则票数 + 1，遇到不同的则票数 - 1</p>\n<p>且“多数元素”的个数<code>&gt; n/2</code>，其余元素的个数总和<code>&lt; n/2 </code></p>\n<p>因此<code>“多数元素”的个数 - 其余元素的个数总和</code> 的结果 肯定 &gt;&#x3D; 1</p>\n<p>这就相当于每个“多数元素”和其他元素 两两相互抵消，抵消到最后肯定还剩余至少1个“多数元素”</p>\n<p>无论数组是1 2 1 2 1，亦或是1 2 2 1 1，总能得到正确的候选人</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int majorityElement(int[] nums) &#123;\n        int result = nums[0], count = 1;\n        for (int i = 1;i&lt;nums.length;i++) &#123;\n            if (result == nums[i]) &#123;\n                count++;\n            &#125; else &#123;\n                count--;\n            &#125;\n            if (count == 0) &#123;\n                result = nums[i];\n                count=1;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，只对数组进行了一次遍历</p>\n<p>空间复杂度：O(1)</p>\n"},{"title":"16最接近的三数之和","_content":"\n题目地址：https://leetcode-cn.com/problems/3sum-closest/\n\n首先进行数组排序，时间复杂度` O(nlogn)`\n\n在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 `nums[i]`\n\n再使用前指针指向 start = i + 1 处，后指针指向 `end = nums.length - 1` 处，也就是结尾处\n\n根据 `sum = nums[i] + nums[start] + nums[end]` 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans\n\n同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum > target 则 end--，如果 sum < target 则 start++，如果 sum == target 则说明距离为 0 直接返回结果\n\n总时间复杂度：`O(n^2)`\n\n```java\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int ans = nums[0] + nums[1] + nums[2];\n        for(int i=0;i<nums.length;i++) {\n            int start = i+1, end = nums.length - 1;\n            while(start < end) {\n                int sum = nums[start] + nums[end] + nums[i];\n                if(Math.abs(target - sum) < Math.abs(target - ans)) {\n                    ans = sum;\n                }\n                if(sum > target) {\n                    end--;\n                } else if(sum < target) {\n                    start++;\n                } else {\n                    return ans;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n\n\n","source":"_posts/LeetCode/16最接近的三数之和.md","raw":"---\ntitle: 16最接近的三数之和\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/3sum-closest/\n\n首先进行数组排序，时间复杂度` O(nlogn)`\n\n在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 `nums[i]`\n\n再使用前指针指向 start = i + 1 处，后指针指向 `end = nums.length - 1` 处，也就是结尾处\n\n根据 `sum = nums[i] + nums[start] + nums[end]` 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans\n\n同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum > target 则 end--，如果 sum < target 则 start++，如果 sum == target 则说明距离为 0 直接返回结果\n\n总时间复杂度：`O(n^2)`\n\n```java\nclass Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int ans = nums[0] + nums[1] + nums[2];\n        for(int i=0;i<nums.length;i++) {\n            int start = i+1, end = nums.length - 1;\n            while(start < end) {\n                int sum = nums[start] + nums[end] + nums[i];\n                if(Math.abs(target - sum) < Math.abs(target - ans)) {\n                    ans = sum;\n                }\n                if(sum > target) {\n                    end--;\n                } else if(sum < target) {\n                    start++;\n                } else {\n                    return ans;\n                }\n            }\n        }\n        return ans;\n    }\n}\n```\n\n\n\n","slug":"LeetCode/16最接近的三数之和","published":1,"date":"2021-11-30T15:15:38.558Z","updated":"2021-12-30T04:34:41.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg5006kfhji8ymw93bo","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/3sum-closest/\">https://leetcode-cn.com/problems/3sum-closest/</a></p>\n<p>首先进行数组排序，时间复杂度<code> O(nlogn)</code></p>\n<p>在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 <code>nums[i]</code></p>\n<p>再使用前指针指向 start &#x3D; i + 1 处，后指针指向 <code>end = nums.length - 1</code> 处，也就是结尾处</p>\n<p>根据 <code>sum = nums[i] + nums[start] + nums[end]</code> 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans</p>\n<p>同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end–，如果 sum &lt; target 则 start++，如果 sum &#x3D;&#x3D; target 则说明距离为 0 直接返回结果</p>\n<p>总时间复杂度：<code>O(n^2)</code></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int threeSumClosest(int[] nums, int target) &#123;\n        Arrays.sort(nums);\n        int ans = nums[0] + nums[1] + nums[2];\n        for(int i=0;i&lt;nums.length;i++) &#123;\n            int start = i+1, end = nums.length - 1;\n            while(start &lt; end) &#123;\n                int sum = nums[start] + nums[end] + nums[i];\n                if(Math.abs(target - sum) &lt; Math.abs(target - ans)) &#123;\n                    ans = sum;\n                &#125;\n                if(sum &gt; target) &#123;\n                    end--;\n                &#125; else if(sum &lt; target) &#123;\n                    start++;\n                &#125; else &#123;\n                    return ans;\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/3sum-closest/\">https://leetcode-cn.com/problems/3sum-closest/</a></p>\n<p>首先进行数组排序，时间复杂度<code> O(nlogn)</code></p>\n<p>在数组 nums 中，进行遍历，每遍历一个值利用其下标i，形成一个固定值 <code>nums[i]</code></p>\n<p>再使用前指针指向 start &#x3D; i + 1 处，后指针指向 <code>end = nums.length - 1</code> 处，也就是结尾处</p>\n<p>根据 <code>sum = nums[i] + nums[start] + nums[end]</code> 的结果，判断 sum 与目标 target 的距离，如果更近则更新结果 ans</p>\n<p>同时判断 sum 与 target 的大小关系，因为数组有序，如果 sum &gt; target 则 end–，如果 sum &lt; target 则 start++，如果 sum &#x3D;&#x3D; target 则说明距离为 0 直接返回结果</p>\n<p>总时间复杂度：<code>O(n^2)</code></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int threeSumClosest(int[] nums, int target) &#123;\n        Arrays.sort(nums);\n        int ans = nums[0] + nums[1] + nums[2];\n        for(int i=0;i&lt;nums.length;i++) &#123;\n            int start = i+1, end = nums.length - 1;\n            while(start &lt; end) &#123;\n                int sum = nums[start] + nums[end] + nums[i];\n                if(Math.abs(target - sum) &lt; Math.abs(target - ans)) &#123;\n                    ans = sum;\n                &#125;\n                if(sum &gt; target) &#123;\n                    end--;\n                &#125; else if(sum &lt; target) &#123;\n                    start++;\n                &#125; else &#123;\n                    return ans;\n                &#125;\n            &#125;\n        &#125;\n        return ans;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"17.14最小K个数","_content":"\n题目地址：https://leetcode-cn.com/problems/smallest-k-lcci/\n\n```java\nclass Solution {\n    public int[] smallestK(int[] arr, int k) {\n        if (k >= arr.length) {\n            return arr;\n        }\n\n        int low = 0;\n        int high = arr.length - 1;\n        while (low < high) {\n            int pos = partition(arr, low, high);\n            if (pos == k - 1) {\n                break;\n            } else if (pos < k - 1) {\n                low = pos + 1;\n            } else {\n                high = pos - 1;\n            }\n        }\n\n        int[] dest = new int[k];\n        System.arraycopy(arr, 0, dest, 0, k);\n        return dest;\n    }\n\n    private int partition(int[] arr, int low, int high) {\n        int pivot = arr[low];\n        while (low < high) {\n            while (low < high && arr[high] >= pivot) {\n                high--;\n            }\n\n            arr[low] = arr[high];\n            while (low < high && arr[low] <= pivot) {\n                low++;\n            }\n            arr[high] = arr[low];\n        }\n        arr[low] = pivot;\n        return low;\n    }\n}\n```\n\n","source":"_posts/LeetCode/17.14最小K个数.md","raw":"---\ntitle: 17.14最小K个数\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/smallest-k-lcci/\n\n```java\nclass Solution {\n    public int[] smallestK(int[] arr, int k) {\n        if (k >= arr.length) {\n            return arr;\n        }\n\n        int low = 0;\n        int high = arr.length - 1;\n        while (low < high) {\n            int pos = partition(arr, low, high);\n            if (pos == k - 1) {\n                break;\n            } else if (pos < k - 1) {\n                low = pos + 1;\n            } else {\n                high = pos - 1;\n            }\n        }\n\n        int[] dest = new int[k];\n        System.arraycopy(arr, 0, dest, 0, k);\n        return dest;\n    }\n\n    private int partition(int[] arr, int low, int high) {\n        int pivot = arr[low];\n        while (low < high) {\n            while (low < high && arr[high] >= pivot) {\n                high--;\n            }\n\n            arr[low] = arr[high];\n            while (low < high && arr[low] <= pivot) {\n                low++;\n            }\n            arr[high] = arr[low];\n        }\n        arr[low] = pivot;\n        return low;\n    }\n}\n```\n\n","slug":"LeetCode/17.14最小K个数","published":1,"date":"2021-09-01T05:22:18.217Z","updated":"2022-02-02T02:45:45.862Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg6006lfhji6oizfomc","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/smallest-k-lcci/\">https://leetcode-cn.com/problems/smallest-k-lcci/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] smallestK(int[] arr, int k) &#123;\n        if (k &gt;= arr.length) &#123;\n            return arr;\n        &#125;\n\n        int low = 0;\n        int high = arr.length - 1;\n        while (low &lt; high) &#123;\n            int pos = partition(arr, low, high);\n            if (pos == k - 1) &#123;\n                break;\n            &#125; else if (pos &lt; k - 1) &#123;\n                low = pos + 1;\n            &#125; else &#123;\n                high = pos - 1;\n            &#125;\n        &#125;\n\n        int[] dest = new int[k];\n        System.arraycopy(arr, 0, dest, 0, k);\n        return dest;\n    &#125;\n\n    private int partition(int[] arr, int low, int high) &#123;\n        int pivot = arr[low];\n        while (low &lt; high) &#123;\n            while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;\n                high--;\n            &#125;\n\n            arr[low] = arr[high];\n            while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;\n                low++;\n            &#125;\n            arr[high] = arr[low];\n        &#125;\n        arr[low] = pivot;\n        return low;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/smallest-k-lcci/\">https://leetcode-cn.com/problems/smallest-k-lcci/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] smallestK(int[] arr, int k) &#123;\n        if (k &gt;= arr.length) &#123;\n            return arr;\n        &#125;\n\n        int low = 0;\n        int high = arr.length - 1;\n        while (low &lt; high) &#123;\n            int pos = partition(arr, low, high);\n            if (pos == k - 1) &#123;\n                break;\n            &#125; else if (pos &lt; k - 1) &#123;\n                low = pos + 1;\n            &#125; else &#123;\n                high = pos - 1;\n            &#125;\n        &#125;\n\n        int[] dest = new int[k];\n        System.arraycopy(arr, 0, dest, 0, k);\n        return dest;\n    &#125;\n\n    private int partition(int[] arr, int low, int high) &#123;\n        int pivot = arr[low];\n        while (low &lt; high) &#123;\n            while (low &lt; high &amp;&amp; arr[high] &gt;= pivot) &#123;\n                high--;\n            &#125;\n\n            arr[low] = arr[high];\n            while (low &lt; high &amp;&amp; arr[low] &lt;= pivot) &#123;\n                low++;\n            &#125;\n            arr[high] = arr[low];\n        &#125;\n        arr[low] = pivot;\n        return low;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"18四数之和","_content":"\n题目地址：https://leetcode-cn.com/problems/4sum/\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        if (nums == null || nums.length < 4) {\n            return result;\n        }\n        Arrays.sort(nums);\n        int length = nums.length;\n        for (int i = 0; i < length - 3; i++) {\n            //重复项跳过\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            //在确定第一个数之后：说明此时剩下的三个数无论取什么值，四数之和一定大于target\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {\n                break;\n            }\n            //确定第一个数后：此时剩下的三个数无论取什么值，四数之和一定小于target\n            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {\n                continue;\n            }\n            for (int j = i + 1; j < length - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue;\n                }\n                //在确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定大于target\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\n                    break;\n                }\n                //确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定小于target\n                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {\n                    continue;\n                }\n                int left = j + 1, right = length - 1;\n                while (left < right) {\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                    if (sum == target) {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        while (left < right && nums[left] == nums[left + 1]) {\n                            left++;\n                        }\n                        left++;\n                        while (left < right && nums[right] == nums[right - 1]) {\n                            right--;\n                        }\n                        right--;\n                    } else if (sum < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：`O(n^3)`\n\n空间复杂度：`O(logn)`","source":"_posts/LeetCode/18四数之和.md","raw":"---\ntitle: 18四数之和\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/4sum/\n\n```java\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        if (nums == null || nums.length < 4) {\n            return result;\n        }\n        Arrays.sort(nums);\n        int length = nums.length;\n        for (int i = 0; i < length - 3; i++) {\n            //重复项跳过\n            if (i > 0 && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            //在确定第一个数之后：说明此时剩下的三个数无论取什么值，四数之和一定大于target\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {\n                break;\n            }\n            //确定第一个数后：此时剩下的三个数无论取什么值，四数之和一定小于target\n            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {\n                continue;\n            }\n            for (int j = i + 1; j < length - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) {\n                    continue;\n                }\n                //在确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定大于target\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\n                    break;\n                }\n                //确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定小于target\n                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {\n                    continue;\n                }\n                int left = j + 1, right = length - 1;\n                while (left < right) {\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                    if (sum == target) {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        while (left < right && nums[left] == nums[left + 1]) {\n                            left++;\n                        }\n                        left++;\n                        while (left < right && nums[right] == nums[right - 1]) {\n                            right--;\n                        }\n                        right--;\n                    } else if (sum < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：`O(n^3)`\n\n空间复杂度：`O(logn)`","slug":"LeetCode/18四数之和","published":1,"date":"2021-09-01T05:22:18.208Z","updated":"2022-01-01T07:53:34.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg6006ofhji69bmabjw","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/4sum/\">https://leetcode-cn.com/problems/4sum/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        if (nums == null || nums.length &lt; 4) &#123;\n            return result;\n        &#125;\n        Arrays.sort(nums);\n        int length = nums.length;\n        for (int i = 0; i &lt; length - 3; i++) &#123;\n            //重复项跳过\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            //在确定第一个数之后：说明此时剩下的三个数无论取什么值，四数之和一定大于target\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;\n                break;\n            &#125;\n            //确定第一个数后：此时剩下的三个数无论取什么值，四数之和一定小于target\n            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123;\n                continue;\n            &#125;\n            for (int j = i + 1; j &lt; length - 2; j++) &#123;\n                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;\n                    continue;\n                &#125;\n                //在确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定大于target\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;\n                    break;\n                &#125;\n                //确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定小于target\n                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123;\n                    continue;\n                &#125;\n                int left = j + 1, right = length - 1;\n                while (left &lt; right) &#123;\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                    if (sum == target) &#123;\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;\n                            left++;\n                        &#125;\n                        left++;\n                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;\n                            right--;\n                        &#125;\n                        right--;\n                    &#125; else if (sum &lt; target) &#123;\n                        left++;\n                    &#125; else &#123;\n                        right--;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(n^3)</code></p>\n<p>空间复杂度：<code>O(logn)</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/4sum/\">https://leetcode-cn.com/problems/4sum/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n        if (nums == null || nums.length &lt; 4) &#123;\n            return result;\n        &#125;\n        Arrays.sort(nums);\n        int length = nums.length;\n        for (int i = 0; i &lt; length - 3; i++) &#123;\n            //重复项跳过\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            //在确定第一个数之后：说明此时剩下的三个数无论取什么值，四数之和一定大于target\n            if (nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] &gt; target) &#123;\n                break;\n            &#125;\n            //确定第一个数后：此时剩下的三个数无论取什么值，四数之和一定小于target\n            if (nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] &lt; target) &#123;\n                continue;\n            &#125;\n            for (int j = i + 1; j &lt; length - 2; j++) &#123;\n                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;\n                    continue;\n                &#125;\n                //在确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定大于target\n                if (nums[i] + nums[j] + nums[j + 1] + nums[j + 2] &gt; target) &#123;\n                    break;\n                &#125;\n                //确定前两个数之后：说明此时剩下的两个数无论取什么值，四数之和一定小于target\n                if (nums[i] + nums[j] + nums[length - 2] + nums[length - 1] &lt; target) &#123;\n                    continue;\n                &#125;\n                int left = j + 1, right = length - 1;\n                while (left &lt; right) &#123;\n                    int sum = nums[i] + nums[j] + nums[left] + nums[right];\n                    if (sum == target) &#123;\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;\n                            left++;\n                        &#125;\n                        left++;\n                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;\n                            right--;\n                        &#125;\n                        right--;\n                    &#125; else if (sum &lt; target) &#123;\n                        left++;\n                    &#125; else &#123;\n                        right--;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(n^3)</code></p>\n<p>空间复杂度：<code>O(logn)</code></p>\n"},{"title":"198打家劫舍","_content":"\n题目地址：https://leetcode-cn.com/problems/house-robber/\n\n如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢\n\n**对于第 k~(k>2) 间房屋，有两个选项：**\n\n* 偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 `k-2`间房屋的最高总金额与第 k 间房屋的金额之和。\n\n* 不偷窃第 k 间房屋，偷窃总金额为前` k-1` 间房屋的最高总金额\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int length = nums.length;\n        if (length == 1) {\n            return nums[0];\n        }\n        int[] dp = new int[length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for (int i = 2; i < length; i++) {\n            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[length - 1];\n    }\n}\n```\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int length = nums.length;\n        if (length == 1) {\n            return nums[0];\n        }\n        int first = nums[0], second = Math.max(nums[0], nums[1]);\n        for (int i = 2; i < length; i++) {\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n}\n```\n\n","source":"_posts/LeetCode/198打家劫舍.md","raw":"---\ntitle: 198打家劫舍\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/house-robber/\n\n如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢\n\n**对于第 k~(k>2) 间房屋，有两个选项：**\n\n* 偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 `k-2`间房屋的最高总金额与第 k 间房屋的金额之和。\n\n* 不偷窃第 k 间房屋，偷窃总金额为前` k-1` 间房屋的最高总金额\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int length = nums.length;\n        if (length == 1) {\n            return nums[0];\n        }\n        int[] dp = new int[length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for (int i = 2; i < length; i++) {\n            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[length - 1];\n    }\n}\n```\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int length = nums.length;\n        if (length == 1) {\n            return nums[0];\n        }\n        int first = nums[0], second = Math.max(nums[0], nums[1]);\n        for (int i = 2; i < length; i++) {\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n}\n```\n\n","slug":"LeetCode/198打家劫舍","published":1,"date":"2021-09-01T05:22:18.208Z","updated":"2022-01-28T16:17:26.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg7006pfhji19lsd6lh","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/house-robber/\">https://leetcode-cn.com/problems/house-robber/</a></p>\n<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢</p>\n<p><strong>对于第 k~(k&gt;2) 间房屋，有两个选项：</strong></p>\n<ul>\n<li><p>偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 <code>k-2</code>间房屋的最高总金额与第 k 间房屋的金额之和。</p>\n</li>\n<li><p>不偷窃第 k 间房屋，偷窃总金额为前<code> k-1</code> 间房屋的最高总金额</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int length = nums.length;\n        if (length == 1) &#123;\n            return nums[0];\n        &#125;\n        int[] dp = new int[length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for (int i = 2; i &lt; length; i++) &#123;\n            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n        &#125;\n        return dp[length - 1];\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int length = nums.length;\n        if (length == 1) &#123;\n            return nums[0];\n        &#125;\n        int first = nums[0], second = Math.max(nums[0], nums[1]);\n        for (int i = 2; i &lt; length; i++) &#123;\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        &#125;\n        return second;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/house-robber/\">https://leetcode-cn.com/problems/house-robber/</a></p>\n<p>如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢</p>\n<p><strong>对于第 k~(k&gt;2) 间房屋，有两个选项：</strong></p>\n<ul>\n<li><p>偷窃第 k 间房屋，那么就不能偷窃第 k-1 间房屋，偷窃总金额为前 <code>k-2</code>间房屋的最高总金额与第 k 间房屋的金额之和。</p>\n</li>\n<li><p>不偷窃第 k 间房屋，偷窃总金额为前<code> k-1</code> 间房屋的最高总金额</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int length = nums.length;\n        if (length == 1) &#123;\n            return nums[0];\n        &#125;\n        int[] dp = new int[length];\n        dp[0] = nums[0];\n        dp[1] = Math.max(nums[0], nums[1]);\n        for (int i = 2; i &lt; length; i++) &#123;\n            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);\n        &#125;\n        return dp[length - 1];\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int length = nums.length;\n        if (length == 1) &#123;\n            return nums[0];\n        &#125;\n        int first = nums[0], second = Math.max(nums[0], nums[1]);\n        for (int i = 2; i &lt; length; i++) &#123;\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        &#125;\n        return second;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"199二叉树的右视图","_content":"\n题目地址：https://leetcode-cn.com/problems/binary-tree-right-side-view/\n\n# DFS\n\n思路： 我们按照 根结点 -> 右子树 -> 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点的。\n\n```java\nclass Solution {\n    List<Integer> result = new ArrayList<>();\n    public List<Integer> rightSideView(TreeNode root) {\n        dfs(root, 0);\n        return result;\n    }\n    private void dfs(TreeNode root, int depth) {\n        if (root == null) {\n            return;\n        }\n        //如果当前节点所在深度还没有出现在result里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入result中\n        if (depth == result.size()) {\n            result.add(root.val);\n        }\n        depth++;\n        dfs(root.right, depth);\n        dfs(root.left, depth);\n    }\n}\n```\n\n时间复杂度： O(N)，每个节点都访问了 1 次。\n\n空间复杂度： O(N)，因为这不是一棵平衡二叉树，二叉树的深度最少是 logN, 最坏的情况下会退化成一条链表，深度就是 N\n\n# BFS\n\n利用 BFS 进行层次遍历，记录下每层的最后一个元素。\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0;i<size;i++) {\n                TreeNode node = queue.poll();\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n                if (i == size - 1) {\n                    result.add(node.val);\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度： O(N)，每个节点都入队出队了 1 次。\n\n空间复杂度： O(N)，使用了额外的队列空间。","source":"_posts/LeetCode/199二叉树的右视图.md","raw":"---\ntitle: 199二叉树的右视图\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/binary-tree-right-side-view/\n\n# DFS\n\n思路： 我们按照 根结点 -> 右子树 -> 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点的。\n\n```java\nclass Solution {\n    List<Integer> result = new ArrayList<>();\n    public List<Integer> rightSideView(TreeNode root) {\n        dfs(root, 0);\n        return result;\n    }\n    private void dfs(TreeNode root, int depth) {\n        if (root == null) {\n            return;\n        }\n        //如果当前节点所在深度还没有出现在result里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入result中\n        if (depth == result.size()) {\n            result.add(root.val);\n        }\n        depth++;\n        dfs(root.right, depth);\n        dfs(root.left, depth);\n    }\n}\n```\n\n时间复杂度： O(N)，每个节点都访问了 1 次。\n\n空间复杂度： O(N)，因为这不是一棵平衡二叉树，二叉树的深度最少是 logN, 最坏的情况下会退化成一条链表，深度就是 N\n\n# BFS\n\n利用 BFS 进行层次遍历，记录下每层的最后一个元素。\n\n```java\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0;i<size;i++) {\n                TreeNode node = queue.poll();\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n                if (i == size - 1) {\n                    result.add(node.val);\n                }\n            }\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度： O(N)，每个节点都入队出队了 1 次。\n\n空间复杂度： O(N)，使用了额外的队列空间。","slug":"LeetCode/199二叉树的右视图","published":1,"date":"2021-09-01T05:22:18.208Z","updated":"2022-01-28T16:17:30.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg7006sfhji8y5z6tn3","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>\n<h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><p>思路： 我们按照 根结点 -&gt; 右子树 -&gt; 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点的。</p>\n<pre><code class=\"java\">class Solution &#123;\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;\n        dfs(root, 0);\n        return result;\n    &#125;\n    private void dfs(TreeNode root, int depth) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        //如果当前节点所在深度还没有出现在result里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入result中\n        if (depth == result.size()) &#123;\n            result.add(root.val);\n        &#125;\n        depth++;\n        dfs(root.right, depth);\n        dfs(root.left, depth);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度： O(N)，每个节点都访问了 1 次。</p>\n<p>空间复杂度： O(N)，因为这不是一棵平衡二叉树，二叉树的深度最少是 logN, 最坏的情况下会退化成一条链表，深度就是 N</p>\n<h1 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h1><p>利用 BFS 进行层次遍历，记录下每层的最后一个元素。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        if (root == null) &#123;\n            return result;\n        &#125;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        while(!queue.isEmpty()) &#123;\n            int size = queue.size();\n            for (int i = 0;i&lt;size;i++) &#123;\n                TreeNode node = queue.poll();\n                if (node.left != null) &#123;\n                    queue.offer(node.left);\n                &#125;\n                if (node.right != null) &#123;\n                    queue.offer(node.right);\n                &#125;\n                if (i == size - 1) &#123;\n                    result.add(node.val);\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度： O(N)，每个节点都入队出队了 1 次。</p>\n<p>空间复杂度： O(N)，使用了额外的队列空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-right-side-view/\">https://leetcode-cn.com/problems/binary-tree-right-side-view/</a></p>\n<h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><p>思路： 我们按照 根结点 -&gt; 右子树 -&gt; 左子树 的顺序访问，就可以保证每层都是最先访问最右边的节点的。</p>\n<pre><code class=\"java\">class Solution &#123;\n    List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;\n        dfs(root, 0);\n        return result;\n    &#125;\n    private void dfs(TreeNode root, int depth) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        //如果当前节点所在深度还没有出现在result里，说明在该深度下当前节点是第一个被访问的节点，因此将当前节点加入result中\n        if (depth == result.size()) &#123;\n            result.add(root.val);\n        &#125;\n        depth++;\n        dfs(root.right, depth);\n        dfs(root.left, depth);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度： O(N)，每个节点都访问了 1 次。</p>\n<p>空间复杂度： O(N)，因为这不是一棵平衡二叉树，二叉树的深度最少是 logN, 最坏的情况下会退化成一条链表，深度就是 N</p>\n<h1 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h1><p>利用 BFS 进行层次遍历，记录下每层的最后一个元素。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; rightSideView(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        if (root == null) &#123;\n            return result;\n        &#125;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        while(!queue.isEmpty()) &#123;\n            int size = queue.size();\n            for (int i = 0;i&lt;size;i++) &#123;\n                TreeNode node = queue.poll();\n                if (node.left != null) &#123;\n                    queue.offer(node.left);\n                &#125;\n                if (node.right != null) &#123;\n                    queue.offer(node.right);\n                &#125;\n                if (i == size - 1) &#123;\n                    result.add(node.val);\n                &#125;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度： O(N)，每个节点都入队出队了 1 次。</p>\n<p>空间复杂度： O(N)，使用了额外的队列空间。</p>\n"},{"title":"19删除链表的倒数第N个节点","_content":"\n题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\n\n整体思路是让前面的指针先移动n步，之后前后指针共同移动直到前面的指针到尾部为止\n\n首先设立预先指针 pre，预先指针是一个小技巧\n\n设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre\n\nstart 先向前移动n步\n\n之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点\n\n因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 `start.next != null`\n\n删除后返回 `pre.next`，为什么不直接返回 head 呢，因为 head 有可能是被删掉的点\n\n时间复杂度：O(n)\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode start = pre, end = pre;\n        while (n > 0 && start != null) {\n            start = start.next;\n            n--;\n        }\n        while (start.next != null) {\n            start = start.next;\n            end = end.next;\n        }\n        end.next = end.next.next;\n        return pre.next;\n    }\n}\n```\n\n","source":"_posts/LeetCode/19删除链表的倒数第N个节点.md","raw":"---\ntitle: 19删除链表的倒数第N个节点\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\n\n整体思路是让前面的指针先移动n步，之后前后指针共同移动直到前面的指针到尾部为止\n\n首先设立预先指针 pre，预先指针是一个小技巧\n\n设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre\n\nstart 先向前移动n步\n\n之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点\n\n因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 `start.next != null`\n\n删除后返回 `pre.next`，为什么不直接返回 head 呢，因为 head 有可能是被删掉的点\n\n时间复杂度：O(n)\n\n```java\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode start = pre, end = pre;\n        while (n > 0 && start != null) {\n            start = start.next;\n            n--;\n        }\n        while (start.next != null) {\n            start = start.next;\n            end = end.next;\n        }\n        end.next = end.next.next;\n        return pre.next;\n    }\n}\n```\n\n","slug":"LeetCode/19删除链表的倒数第N个节点","published":1,"date":"2021-09-01T05:22:18.208Z","updated":"2022-01-01T08:08:09.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg8006tfhji31fk9ewo","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>\n<p>整体思路是让前面的指针先移动n步，之后前后指针共同移动直到前面的指针到尾部为止</p>\n<p>首先设立预先指针 pre，预先指针是一个小技巧</p>\n<p>设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre</p>\n<p>start 先向前移动n步</p>\n<p>之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点</p>\n<p>因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 <code>start.next != null</code></p>\n<p>删除后返回 <code>pre.next</code>，为什么不直接返回 head 呢，因为 head 有可能是被删掉的点</p>\n<p>时间复杂度：O(n)</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode removeNthFromEnd(ListNode head, int n) &#123;\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode start = pre, end = pre;\n        while (n &gt; 0 &amp;&amp; start != null) &#123;\n            start = start.next;\n            n--;\n        &#125;\n        while (start.next != null) &#123;\n            start = start.next;\n            end = end.next;\n        &#125;\n        end.next = end.next.next;\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/\">https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/</a></p>\n<p>整体思路是让前面的指针先移动n步，之后前后指针共同移动直到前面的指针到尾部为止</p>\n<p>首先设立预先指针 pre，预先指针是一个小技巧</p>\n<p>设预先指针 pre 的下一个节点指向 head，设前指针为 start，后指针为 end，二者都等于 pre</p>\n<p>start 先向前移动n步</p>\n<p>之后 start 和 end 共同向前移动，此时二者的距离为 n，当 start 到尾部时，end 的位置恰好为倒数第 n 个节点</p>\n<p>因为要删除该节点，所以要移动到该节点的前一个才能删除，所以循环结束条件为 <code>start.next != null</code></p>\n<p>删除后返回 <code>pre.next</code>，为什么不直接返回 head 呢，因为 head 有可能是被删掉的点</p>\n<p>时间复杂度：O(n)</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode removeNthFromEnd(ListNode head, int n) &#123;\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode start = pre, end = pre;\n        while (n &gt; 0 &amp;&amp; start != null) &#123;\n            start = start.next;\n            n--;\n        &#125;\n        while (start.next != null) &#123;\n            start = start.next;\n            end = end.next;\n        &#125;\n        end.next = end.next.next;\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"1两数之和","_content":"\n题目地址:https://leetcode-cn.com/problems/two-sum/\n\n# 哈希表\n\n在进行迭代并将元素插入到表中的同时，我们可以回过头来检查表中是否已经存在当前元素所对应的目标元素\n\n如果它存在，那我们已经找到了对应解，并立即将其返回\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i<nums.length; i++) {\n            int current = target - nums[i];\n            if (map.containsKey(current)) {\n                return new int[]{map.get(current), i};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","source":"_posts/LeetCode/1两数之和.md","raw":"---\ntitle: 1两数之和\ncategories: \n- LeetCode\n---\n\n题目地址:https://leetcode-cn.com/problems/two-sum/\n\n# 哈希表\n\n在进行迭代并将元素插入到表中的同时，我们可以回过头来检查表中是否已经存在当前元素所对应的目标元素\n\n如果它存在，那我们已经找到了对应解，并立即将其返回\n\n```java\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int i = 0; i<nums.length; i++) {\n            int current = target - nums[i];\n            if (map.containsKey(current)) {\n                return new int[]{map.get(current), i};\n            }\n            map.put(nums[i], i);\n        }\n        return null;\n    }\n}\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","slug":"LeetCode/1两数之和","published":1,"date":"2021-09-01T05:22:18.208Z","updated":"2021-12-13T16:50:20.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwg9006wfhji6gm7bptr","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/two-sum/\">https://leetcode-cn.com/problems/two-sum/</a></p>\n<h1 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h1><p>在进行迭代并将元素插入到表中的同时，我们可以回过头来检查表中是否已经存在当前元素所对应的目标元素</p>\n<p>如果它存在，那我们已经找到了对应解，并立即将其返回</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return null;\n        &#125;\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i&lt;nums.length; i++) &#123;\n            int current = target - nums[i];\n            if (map.containsKey(current)) &#123;\n                return new int[]&#123;map.get(current), i&#125;;\n            &#125;\n            map.put(nums[i], i);\n        &#125;\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/two-sum/\">https://leetcode-cn.com/problems/two-sum/</a></p>\n<h1 id=\"哈希表\"><a href=\"#哈希表\" class=\"headerlink\" title=\"哈希表\"></a>哈希表</h1><p>在进行迭代并将元素插入到表中的同时，我们可以回过头来检查表中是否已经存在当前元素所对应的目标元素</p>\n<p>如果它存在，那我们已经找到了对应解，并立即将其返回</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] twoSum(int[] nums, int target) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return null;\n        &#125;\n        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\n        for (int i = 0; i&lt;nums.length; i++) &#123;\n            int current = target - nums[i];\n            if (map.containsKey(current)) &#123;\n                return new int[]&#123;map.get(current), i&#125;;\n            &#125;\n            map.put(nums[i], i);\n        &#125;\n        return null;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n"},{"title":"206反转链表","_content":"\n题目地址：[https://leetcode-cn.com/problems/reverse-linked-list/](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n# 迭代\n\n我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的\n第二个指针 cur 指向 head，然后不断遍历 cur\n每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位\n都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        //申请节点，pre和 cur，pre指向null\n        ListNode pre = null;\n        ListNode cur = head;\n        ListNode next = null;\n        while(cur!=null) {\n            //记录当前节点的下一个节点\n            next = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = next;\n        }\n        return pre;\n    }\n}\n```\n\n时间复杂度：O(n)，假设 n 是列表的长度 \n空间复杂度：O(1)\n\n# 递归\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) {\n            return head;\n        }\n        //这里的cur就是最后一个节点\n    //如果链表是 1->2->3->4->5，那么此时的cur就是5\n        ListNode cur = reverseList(head.next);\n        //而head是4，head的下一个是5，意思是5的下一个节点指向4，5->4\n        head.next.next = head;\n        //防止链表循环指向，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    }\n}\n```\n时间复杂度：O(n)，假设 n 是列表的长度 \n空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间，递归深度可能会达到 n 层\n","source":"_posts/LeetCode/206反转链表.md","raw":"---\ntitle: 206反转链表\ncategories: \n- LeetCode\n---\n\n题目地址：[https://leetcode-cn.com/problems/reverse-linked-list/](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n# 迭代\n\n我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的\n第二个指针 cur 指向 head，然后不断遍历 cur\n每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位\n都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        //申请节点，pre和 cur，pre指向null\n        ListNode pre = null;\n        ListNode cur = head;\n        ListNode next = null;\n        while(cur!=null) {\n            //记录当前节点的下一个节点\n            next = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = next;\n        }\n        return pre;\n    }\n}\n```\n\n时间复杂度：O(n)，假设 n 是列表的长度 \n空间复杂度：O(1)\n\n# 递归\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) {\n            return head;\n        }\n        //这里的cur就是最后一个节点\n    //如果链表是 1->2->3->4->5，那么此时的cur就是5\n        ListNode cur = reverseList(head.next);\n        //而head是4，head的下一个是5，意思是5的下一个节点指向4，5->4\n        head.next.next = head;\n        //防止链表循环指向，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    }\n}\n```\n时间复杂度：O(n)，假设 n 是列表的长度 \n空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间，递归深度可能会达到 n 层\n","slug":"LeetCode/206反转链表","published":1,"date":"2021-09-01T05:22:18.208Z","updated":"2022-01-28T16:17:38.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwga006xfhjia9tz3fxe","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><p>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的<br>第二个指针 cur 指向 head，然后不断遍历 cur<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        //申请节点，pre和 cur，pre指向null\n        ListNode pre = null;\n        ListNode cur = head;\n        ListNode next = null;\n        while(cur!=null) &#123;\n            //记录当前节点的下一个节点\n            next = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = next;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，假设 n 是列表的长度<br>空间复杂度：O(1)</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) &#123;\n            return head;\n        &#125;\n        //这里的cur就是最后一个节点\n    //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5\n        ListNode cur = reverseList(head.next);\n        //而head是4，head的下一个是5，意思是5的下一个节点指向4，5-&gt;4\n        head.next.next = head;\n        //防止链表循环指向，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，假设 n 是列表的长度<br>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间，递归深度可能会达到 n 层</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list/\">https://leetcode-cn.com/problems/reverse-linked-list/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><p>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的<br>第二个指针 cur 指向 head，然后不断遍历 cur<br>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位<br>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        //申请节点，pre和 cur，pre指向null\n        ListNode pre = null;\n        ListNode cur = head;\n        ListNode next = null;\n        while(cur!=null) &#123;\n            //记录当前节点的下一个节点\n            next = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = next;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，假设 n 是列表的长度<br>空间复杂度：O(1)</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) &#123;\n            return head;\n        &#125;\n        //这里的cur就是最后一个节点\n    //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5\n        ListNode cur = reverseList(head.next);\n        //而head是4，head的下一个是5，意思是5的下一个节点指向4，5-&gt;4\n        head.next.next = head;\n        //防止链表循环指向，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，假设 n 是列表的长度<br>空间复杂度：O(n)，由于使用递归，将会使用隐式栈空间，递归深度可能会达到 n 层</p>\n"},{"title":"20有效的括号","_content":"\n题目地址：https://leetcode-cn.com/problems/valid-parentheses/\n\n创建一个辅助栈：\n\n遍历，对每一个字符进行如下操作：\n\n* 若为左括号，则往栈中存放右括号\n\n* 若为右括号，如果 栈为空 或者 该右括号与取出的栈顶元素不一样，则返回false;\n\n* 返回栈是否为空的状态；\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        if (s == null || s.length() == 0) {\n            return true;\n        }\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                stack.push(')');\n            } else if (c == '{') {\n                stack.push('}');\n            } else if (c == '[') {\n                stack.push(']');\n            } else if (stack.isEmpty() || stack.pop() != c) {\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n","source":"_posts/LeetCode/20有效的括号.md","raw":"---\ntitle: 20有效的括号\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/valid-parentheses/\n\n创建一个辅助栈：\n\n遍历，对每一个字符进行如下操作：\n\n* 若为左括号，则往栈中存放右括号\n\n* 若为右括号，如果 栈为空 或者 该右括号与取出的栈顶元素不一样，则返回false;\n\n* 返回栈是否为空的状态；\n\n```java\nclass Solution {\n    public boolean isValid(String s) {\n        if (s == null || s.length() == 0) {\n            return true;\n        }\n        Stack<Character> stack = new Stack<>();\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                stack.push(')');\n            } else if (c == '{') {\n                stack.push('}');\n            } else if (c == '[') {\n                stack.push(']');\n            } else if (stack.isEmpty() || stack.pop() != c) {\n                return false;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n","slug":"LeetCode/20有效的括号","published":1,"date":"2021-09-01T05:22:18.208Z","updated":"2022-01-03T07:24:03.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgb0070fhji06qe87il","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">https://leetcode-cn.com/problems/valid-parentheses/</a></p>\n<p>创建一个辅助栈：</p>\n<p>遍历，对每一个字符进行如下操作：</p>\n<ul>\n<li><p>若为左括号，则往栈中存放右括号</p>\n</li>\n<li><p>若为右括号，如果 栈为空 或者 该右括号与取出的栈顶元素不一样，则返回false;</p>\n</li>\n<li><p>返回栈是否为空的状态；</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isValid(String s) &#123;\n        if (s == null || s.length() == 0) &#123;\n            return true;\n        &#125;\n        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();\n        for (char c : s.toCharArray()) &#123;\n            if (c == &#39;(&#39;) &#123;\n                stack.push(&#39;)&#39;);\n            &#125; else if (c == &#39;&#123;&#39;) &#123;\n                stack.push(&#39;&#125;&#39;);\n            &#125; else if (c == &#39;[&#39;) &#123;\n                stack.push(&#39;]&#39;);\n            &#125; else if (stack.isEmpty() || stack.pop() != c) &#123;\n                return false;\n            &#125;\n        &#125;\n        return stack.isEmpty();\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/valid-parentheses/\">https://leetcode-cn.com/problems/valid-parentheses/</a></p>\n<p>创建一个辅助栈：</p>\n<p>遍历，对每一个字符进行如下操作：</p>\n<ul>\n<li><p>若为左括号，则往栈中存放右括号</p>\n</li>\n<li><p>若为右括号，如果 栈为空 或者 该右括号与取出的栈顶元素不一样，则返回false;</p>\n</li>\n<li><p>返回栈是否为空的状态；</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isValid(String s) &#123;\n        if (s == null || s.length() == 0) &#123;\n            return true;\n        &#125;\n        Stack&lt;Character&gt; stack = new Stack&lt;&gt;();\n        for (char c : s.toCharArray()) &#123;\n            if (c == &#39;(&#39;) &#123;\n                stack.push(&#39;)&#39;);\n            &#125; else if (c == &#39;&#123;&#39;) &#123;\n                stack.push(&#39;&#125;&#39;);\n            &#125; else if (c == &#39;[&#39;) &#123;\n                stack.push(&#39;]&#39;);\n            &#125; else if (stack.isEmpty() || stack.pop() != c) &#123;\n                return false;\n            &#125;\n        &#125;\n        return stack.isEmpty();\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"213打家劫舍II","_content":"\n题目地址：https://leetcode-cn.com/problems/house-robber-ii/\n\n这个问题的重点是环形，所以有三种情况\n\n* 第一个房子不抢 最后一个房子抢\n* 第一个房子抢 最后一个房子不抢\n* 两个都不抢\n\n根据最优选择 我们只需要判断前两个选项就可以知道了\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        int length = nums.length;\n        if (length == 1) {\n            return nums[0];\n        } else if (length == 2) {\n            return Math.max(nums[0], nums[1]);\n        }\n        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n    private int robRange(int[] nums, int start, int end) {\n        int first = nums[start], second = Math.max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，其中 n 是数组长度。需要对数组遍历两次，计算可以偷窃到的最高总金额。\n- 空间复杂度：O(1)。","source":"_posts/LeetCode/213打家劫舍II.md","raw":"---\ntitle: 213打家劫舍II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/house-robber-ii/\n\n这个问题的重点是环形，所以有三种情况\n\n* 第一个房子不抢 最后一个房子抢\n* 第一个房子抢 最后一个房子不抢\n* 两个都不抢\n\n根据最优选择 我们只需要判断前两个选项就可以知道了\n\n```java\nclass Solution {\n    public int rob(int[] nums) {\n        int length = nums.length;\n        if (length == 1) {\n            return nums[0];\n        } else if (length == 2) {\n            return Math.max(nums[0], nums[1]);\n        }\n        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    }\n    private int robRange(int[] nums, int start, int end) {\n        int first = nums[start], second = Math.max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        }\n        return second;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，其中 n 是数组长度。需要对数组遍历两次，计算可以偷窃到的最高总金额。\n- 空间复杂度：O(1)。","slug":"LeetCode/213打家劫舍II","published":1,"date":"2021-11-23T01:56:45.149Z","updated":"2022-01-28T16:18:17.636Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgb0071fhjihwfcazwo","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">https://leetcode-cn.com/problems/house-robber-ii/</a></p>\n<p>这个问题的重点是环形，所以有三种情况</p>\n<ul>\n<li>第一个房子不抢 最后一个房子抢</li>\n<li>第一个房子抢 最后一个房子不抢</li>\n<li>两个都不抢</li>\n</ul>\n<p>根据最优选择 我们只需要判断前两个选项就可以知道了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        int length = nums.length;\n        if (length == 1) &#123;\n            return nums[0];\n        &#125; else if (length == 2) &#123;\n            return Math.max(nums[0], nums[1]);\n        &#125;\n        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    &#125;\n    private int robRange(int[] nums, int start, int end) &#123;\n        int first = nums[start], second = Math.max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i &lt;= end; i++) &#123;\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        &#125;\n        return second;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 是数组长度。需要对数组遍历两次，计算可以偷窃到的最高总金额。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/house-robber-ii/\">https://leetcode-cn.com/problems/house-robber-ii/</a></p>\n<p>这个问题的重点是环形，所以有三种情况</p>\n<ul>\n<li>第一个房子不抢 最后一个房子抢</li>\n<li>第一个房子抢 最后一个房子不抢</li>\n<li>两个都不抢</li>\n</ul>\n<p>根据最优选择 我们只需要判断前两个选项就可以知道了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int rob(int[] nums) &#123;\n        int length = nums.length;\n        if (length == 1) &#123;\n            return nums[0];\n        &#125; else if (length == 2) &#123;\n            return Math.max(nums[0], nums[1]);\n        &#125;\n        return Math.max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n    &#125;\n    private int robRange(int[] nums, int start, int end) &#123;\n        int first = nums[start], second = Math.max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i &lt;= end; i++) &#123;\n            int temp = second;\n            second = Math.max(first + nums[i], second);\n            first = temp;\n        &#125;\n        return second;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 是数组长度。需要对数组遍历两次，计算可以偷窃到的最高总金额。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n"},{"title":"215数组中的第K个最大元素","_content":"\n题目地址：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\n\n# 快速排序\n\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        return quickSort(nums, 0, nums.length - 1, nums.length - k);\n    }\n\n    public int partition(int[] nums, int left, int right){\n        int pivot = nums[left];\n\n        while(left < right){\n            while(left < right && nums[right] >= pivot){\n                right--;\n            }\n            nums[left] = nums[right];\n\n            while(left < right && nums[left] <= pivot){\n                left++;\n            }\n            nums[right] = nums[left];\n        }\n        nums[left] = pivot;\n        return left;\n    }\n\n    public int quickSort(int[] nums, int left, int right, int k){\n        // 如果经过一轮快排分区后pivot位置刚好是k，那么可以直接退出了\n        int mid = partition(nums, left, right);\n        if(mid == k){\n            return nums[k];\n        }else if(mid > k){\n            return quickSort(nums, left, mid - 1, k);\n        }else{\n            return quickSort(nums, mid + 1, right, k);\n        }\n    }\n}\n```\n\n时间复杂度 O(N)，空间复杂度 O(1)","source":"_posts/LeetCode/215数组中的第K个最大元素.md","raw":"---\ntitle: 215数组中的第K个最大元素\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\n\n# 快速排序\n\n```java\nclass Solution {\n    public int findKthLargest(int[] nums, int k) {\n        return quickSort(nums, 0, nums.length - 1, nums.length - k);\n    }\n\n    public int partition(int[] nums, int left, int right){\n        int pivot = nums[left];\n\n        while(left < right){\n            while(left < right && nums[right] >= pivot){\n                right--;\n            }\n            nums[left] = nums[right];\n\n            while(left < right && nums[left] <= pivot){\n                left++;\n            }\n            nums[right] = nums[left];\n        }\n        nums[left] = pivot;\n        return left;\n    }\n\n    public int quickSort(int[] nums, int left, int right, int k){\n        // 如果经过一轮快排分区后pivot位置刚好是k，那么可以直接退出了\n        int mid = partition(nums, left, right);\n        if(mid == k){\n            return nums[k];\n        }else if(mid > k){\n            return quickSort(nums, left, mid - 1, k);\n        }else{\n            return quickSort(nums, mid + 1, right, k);\n        }\n    }\n}\n```\n\n时间复杂度 O(N)，空间复杂度 O(1)","slug":"LeetCode/215数组中的第K个最大元素","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-28T16:18:22.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgc0074fhji74uk0kh3","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>\n<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><pre><code class=\"java\">class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        return quickSort(nums, 0, nums.length - 1, nums.length - k);\n    &#125;\n\n    public int partition(int[] nums, int left, int right)&#123;\n        int pivot = nums[left];\n\n        while(left &lt; right)&#123;\n            while(left &lt; right &amp;&amp; nums[right] &gt;= pivot)&#123;\n                right--;\n            &#125;\n            nums[left] = nums[right];\n\n            while(left &lt; right &amp;&amp; nums[left] &lt;= pivot)&#123;\n                left++;\n            &#125;\n            nums[right] = nums[left];\n        &#125;\n        nums[left] = pivot;\n        return left;\n    &#125;\n\n    public int quickSort(int[] nums, int left, int right, int k)&#123;\n        // 如果经过一轮快排分区后pivot位置刚好是k，那么可以直接退出了\n        int mid = partition(nums, left, right);\n        if(mid == k)&#123;\n            return nums[k];\n        &#125;else if(mid &gt; k)&#123;\n            return quickSort(nums, left, mid - 1, k);\n        &#125;else&#123;\n            return quickSort(nums, mid + 1, right, k);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)，空间复杂度 O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/kth-largest-element-in-an-array/\">https://leetcode-cn.com/problems/kth-largest-element-in-an-array/</a></p>\n<h1 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h1><pre><code class=\"java\">class Solution &#123;\n    public int findKthLargest(int[] nums, int k) &#123;\n        return quickSort(nums, 0, nums.length - 1, nums.length - k);\n    &#125;\n\n    public int partition(int[] nums, int left, int right)&#123;\n        int pivot = nums[left];\n\n        while(left &lt; right)&#123;\n            while(left &lt; right &amp;&amp; nums[right] &gt;= pivot)&#123;\n                right--;\n            &#125;\n            nums[left] = nums[right];\n\n            while(left &lt; right &amp;&amp; nums[left] &lt;= pivot)&#123;\n                left++;\n            &#125;\n            nums[right] = nums[left];\n        &#125;\n        nums[left] = pivot;\n        return left;\n    &#125;\n\n    public int quickSort(int[] nums, int left, int right, int k)&#123;\n        // 如果经过一轮快排分区后pivot位置刚好是k，那么可以直接退出了\n        int mid = partition(nums, left, right);\n        if(mid == k)&#123;\n            return nums[k];\n        &#125;else if(mid &gt; k)&#123;\n            return quickSort(nums, left, mid - 1, k);\n        &#125;else&#123;\n            return quickSort(nums, mid + 1, right, k);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)，空间复杂度 O(1)</p>\n"},{"title":"217存在重复元素","_content":"\n题目地址：https://leetcode-cn.com/problems/contains-duplicate/\n\n**排序**\n\n在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。\n\n因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i] == nums[i + 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n\n时间复杂度：`O(NlogN)`，其中 N 为数组的长度。需要对数组进行排序。\n\n空间复杂度：`O(logN)`，其中 N 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。\n\n**哈希表**\n\n对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<Integer>();\n        for (int x : nums) {\n            if (!set.add(x)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O*(*N)，其中 N 为数组的长度。\n- 空间复杂度：O*(*N)，其中 N 为数组的长度。","source":"_posts/LeetCode/217存在重复元素.md","raw":"---\ntitle: 217存在重复元素\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/contains-duplicate/\n\n**排序**\n\n在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。\n\n因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i < n - 1; i++) {\n            if (nums[i] == nums[i + 1]) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n\n时间复杂度：`O(NlogN)`，其中 N 为数组的长度。需要对数组进行排序。\n\n空间复杂度：`O(logN)`，其中 N 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。\n\n**哈希表**\n\n对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Set<Integer> set = new HashSet<Integer>();\n        for (int x : nums) {\n            if (!set.add(x)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O*(*N)，其中 N 为数组的长度。\n- 空间复杂度：O*(*N)，其中 N 为数组的长度。","slug":"LeetCode/217存在重复元素","published":1,"date":"2021-12-05T11:45:44.370Z","updated":"2022-01-28T16:18:29.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgd0075fhji3i8u00yi","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/contains-duplicate/\">https://leetcode-cn.com/problems/contains-duplicate/</a></p>\n<p><strong>排序</strong></p>\n<p>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。</p>\n<p>因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean containsDuplicate(int[] nums) &#123;\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i &lt; n - 1; i++) &#123;\n            if (nums[i] == nums[i + 1]) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<p>时间复杂度：<code>O(NlogN)</code>，其中 N 为数组的长度。需要对数组进行排序。</p>\n<p>空间复杂度：<code>O(logN)</code>，其中 N 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。</p>\n<p><strong>哈希表</strong></p>\n<p>对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean containsDuplicate(int[] nums) &#123;\n        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n        for (int x : nums) &#123;\n            if (!set.add(x)) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O*(*N)，其中 N 为数组的长度。</li>\n<li>空间复杂度：O*(*N)，其中 N 为数组的长度。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/contains-duplicate/\">https://leetcode-cn.com/problems/contains-duplicate/</a></p>\n<p><strong>排序</strong></p>\n<p>在对数字从小到大排序之后，数组的重复元素一定出现在相邻位置中。</p>\n<p>因此，我们可以扫描已排序的数组，每次判断相邻的两个元素是否相等，如果相等则说明存在重复的元素。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean containsDuplicate(int[] nums) &#123;\n        Arrays.sort(nums);\n        int n = nums.length;\n        for (int i = 0; i &lt; n - 1; i++) &#123;\n            if (nums[i] == nums[i + 1]) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<p>时间复杂度：<code>O(NlogN)</code>，其中 N 为数组的长度。需要对数组进行排序。</p>\n<p>空间复杂度：<code>O(logN)</code>，其中 N 为数组的长度。注意我们在这里应当考虑递归调用栈的深度。</p>\n<p><strong>哈希表</strong></p>\n<p>对于数组中每个元素，我们将它插入到哈希表中。如果插入一个元素时发现该元素已经存在于哈希表中，则说明存在重复的元素。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean containsDuplicate(int[] nums) &#123;\n        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n        for (int x : nums) &#123;\n            if (!set.add(x)) &#123;\n                return true;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O*(*N)，其中 N 为数组的长度。</li>\n<li>空间复杂度：O*(*N)，其中 N 为数组的长度。</li>\n</ul>\n"},{"title":"21合并两个有序链表","_content":"\n题目地址：https://leetcode-cn.com/problems/merge-two-sorted-lists/\n\n# 迭代\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode pre = new ListNode(-1);\n        ListNode cur = pre;\n        while(l1!=null && l2!=null) {\n            if (l1.val<=l2.val) {\n                cur.next=l1;\n                l1=l1.next;\n            } else {\n                cur.next=l2;\n                l2=l2.next;\n            }\n            cur=cur.next;\n        }\n        //合并后l1和l2最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可\n        cur.next=(l1==null?l2:l1);\n        return pre.next;\n    }\n}\n```\n\n时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。\n\n空间复杂度：O(1)。我们只需要常数的空间存放若干变量。\n\n# 递归\n\n终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束\n\n返回值：每一层调用都返回排序好的链表头\n\n递归内容：如果 l1 的 val 值更小，则将 `l1.next `与排序好的链表头相接，l2 同理\n\n时间复杂度：O(m+n)，m 为 l1的长度，n 为 l2 的长度\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        } else if (l2 == null) {\n            return l1;\n        } else if (l1.val <= l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n\n\n\n\n","source":"_posts/LeetCode/21合并两个有序链表.md","raw":"---\ntitle: 21合并两个有序链表\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/merge-two-sorted-lists/\n\n# 迭代\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode pre = new ListNode(-1);\n        ListNode cur = pre;\n        while(l1!=null && l2!=null) {\n            if (l1.val<=l2.val) {\n                cur.next=l1;\n                l1=l1.next;\n            } else {\n                cur.next=l2;\n                l2=l2.next;\n            }\n            cur=cur.next;\n        }\n        //合并后l1和l2最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可\n        cur.next=(l1==null?l2:l1);\n        return pre.next;\n    }\n}\n```\n\n时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。\n\n空间复杂度：O(1)。我们只需要常数的空间存放若干变量。\n\n# 递归\n\n终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束\n\n返回值：每一层调用都返回排序好的链表头\n\n递归内容：如果 l1 的 val 值更小，则将 `l1.next `与排序好的链表头相接，l2 同理\n\n时间复杂度：O(m+n)，m 为 l1的长度，n 为 l2 的长度\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        } else if (l2 == null) {\n            return l1;\n        } else if (l1.val <= l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n\n\n\n\n","slug":"LeetCode/21合并两个有序链表","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-03T07:24:45.915Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwge0078fhji3zm34ey4","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        ListNode pre = new ListNode(-1);\n        ListNode cur = pre;\n        while(l1!=null &amp;&amp; l2!=null) &#123;\n            if (l1.val&lt;=l2.val) &#123;\n                cur.next=l1;\n                l1=l1.next;\n            &#125; else &#123;\n                cur.next=l2;\n                l2=l2.next;\n            &#125;\n            cur=cur.next;\n        &#125;\n        //合并后l1和l2最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可\n        cur.next=(l1==null?l2:l1);\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。</p>\n<p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束</p>\n<p>返回值：每一层调用都返回排序好的链表头</p>\n<p>递归内容：如果 l1 的 val 值更小，则将 <code>l1.next </code>与排序好的链表头相接，l2 同理</p>\n<p>时间复杂度：O(m+n)，m 为 l1的长度，n 为 l2 的长度</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        if (l1 == null) &#123;\n            return l2;\n        &#125; else if (l2 == null) &#123;\n            return l1;\n        &#125; else if (l1.val &lt;= l2.val) &#123;\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        &#125; else &#123;\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/merge-two-sorted-lists/\">https://leetcode-cn.com/problems/merge-two-sorted-lists/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        ListNode pre = new ListNode(-1);\n        ListNode cur = pre;\n        while(l1!=null &amp;&amp; l2!=null) &#123;\n            if (l1.val&lt;=l2.val) &#123;\n                cur.next=l1;\n                l1=l1.next;\n            &#125; else &#123;\n                cur.next=l2;\n                l2=l2.next;\n            &#125;\n            cur=cur.next;\n        &#125;\n        //合并后l1和l2最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可\n        cur.next=(l1==null?l2:l1);\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n + m)，其中 n 和 m 分别为两个链表的长度。</p>\n<p>空间复杂度：O(1)。我们只需要常数的空间存放若干变量。</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>终止条件：两条链表分别名为 l1 和 l2，当 l1 为空或 l2 为空时结束</p>\n<p>返回值：每一层调用都返回排序好的链表头</p>\n<p>递归内容：如果 l1 的 val 值更小，则将 <code>l1.next </code>与排序好的链表头相接，l2 同理</p>\n<p>时间复杂度：O(m+n)，m 为 l1的长度，n 为 l2 的长度</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        if (l1 == null) &#123;\n            return l2;\n        &#125; else if (l2 == null) &#123;\n            return l1;\n        &#125; else if (l1.val &lt;= l2.val) &#123;\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        &#125; else &#123;\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"226翻转二叉树","_content":"\n题目地址：https://leetcode-cn.com/problems/invert-binary-tree/\n\n# 递归\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null) {\n            return null;\n        }\n        TreeNode tmp = root.right;\n        root.right = root.left;\n        root.left = tmp;\n        //递归交换当前节点的 左子树\n        invertTree(root.left);\n        //递归交换当前节点的 右子树\n        invertTree(root.right);\n        return root;\n    }\n}\n```\n\n# 迭代\n\n```java\nclass Solution {\n\tpublic TreeNode invertTree(TreeNode root) {\n\t\tif(root==null) {\n\t\t\treturn null;\n\t\t}\n\t\tLinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.add(root);\n\t\twhile(!queue.isEmpty()) {\n\t\t\t//每次都从队列中拿一个节点，并交换这个节点的左右子树\n\t\t\tTreeNode tmp = queue.poll();\n\t\t\tTreeNode left = tmp.left;\n\t\t\ttmp.left = tmp.right;\n\t\t\ttmp.right = left;\n\t\t\t//如果当前节点的左子树不为空，则放入队列等待后续处理\n\t\t\tif(tmp.left!=null) {\n\t\t\t\tqueue.add(tmp.left);\n\t\t\t}\n\t\t\t//如果当前节点的右子树不为空，则放入队列等待后续处理\n\t\t\tif(tmp.right!=null) {\n\t\t\t\tqueue.add(tmp.right);\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n}\n```\n\n","source":"_posts/LeetCode/226翻转二叉树.md","raw":"---\ntitle: 226翻转二叉树\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/invert-binary-tree/\n\n# 递归\n\n```java\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null) {\n            return null;\n        }\n        TreeNode tmp = root.right;\n        root.right = root.left;\n        root.left = tmp;\n        //递归交换当前节点的 左子树\n        invertTree(root.left);\n        //递归交换当前节点的 右子树\n        invertTree(root.right);\n        return root;\n    }\n}\n```\n\n# 迭代\n\n```java\nclass Solution {\n\tpublic TreeNode invertTree(TreeNode root) {\n\t\tif(root==null) {\n\t\t\treturn null;\n\t\t}\n\t\tLinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n\t\tqueue.add(root);\n\t\twhile(!queue.isEmpty()) {\n\t\t\t//每次都从队列中拿一个节点，并交换这个节点的左右子树\n\t\t\tTreeNode tmp = queue.poll();\n\t\t\tTreeNode left = tmp.left;\n\t\t\ttmp.left = tmp.right;\n\t\t\ttmp.right = left;\n\t\t\t//如果当前节点的左子树不为空，则放入队列等待后续处理\n\t\t\tif(tmp.left!=null) {\n\t\t\t\tqueue.add(tmp.left);\n\t\t\t}\n\t\t\t//如果当前节点的右子树不为空，则放入队列等待后续处理\n\t\t\tif(tmp.right!=null) {\n\t\t\t\tqueue.add(tmp.right);\n\t\t\t}\n\t\t}\n\t\treturn root;\n\t}\n}\n```\n\n","slug":"LeetCode/226翻转二叉树","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-28T16:18:35.971Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwge0079fhjianof20cj","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if(root==null) &#123;\n            return null;\n        &#125;\n        TreeNode tmp = root.right;\n        root.right = root.left;\n        root.left = tmp;\n        //递归交换当前节点的 左子树\n        invertTree(root.left);\n        //递归交换当前节点的 右子树\n        invertTree(root.right);\n        return root;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if(root==null) &#123;\n            return null;\n        &#125;\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n        queue.add(root);\n        while(!queue.isEmpty()) &#123;\n            //每次都从队列中拿一个节点，并交换这个节点的左右子树\n            TreeNode tmp = queue.poll();\n            TreeNode left = tmp.left;\n            tmp.left = tmp.right;\n            tmp.right = left;\n            //如果当前节点的左子树不为空，则放入队列等待后续处理\n            if(tmp.left!=null) &#123;\n                queue.add(tmp.left);\n            &#125;\n            //如果当前节点的右子树不为空，则放入队列等待后续处理\n            if(tmp.right!=null) &#123;\n                queue.add(tmp.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/invert-binary-tree/\">https://leetcode-cn.com/problems/invert-binary-tree/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if(root==null) &#123;\n            return null;\n        &#125;\n        TreeNode tmp = root.right;\n        root.right = root.left;\n        root.left = tmp;\n        //递归交换当前节点的 左子树\n        invertTree(root.left);\n        //递归交换当前节点的 右子树\n        invertTree(root.right);\n        return root;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode invertTree(TreeNode root) &#123;\n        if(root==null) &#123;\n            return null;\n        &#125;\n        LinkedList&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n        queue.add(root);\n        while(!queue.isEmpty()) &#123;\n            //每次都从队列中拿一个节点，并交换这个节点的左右子树\n            TreeNode tmp = queue.poll();\n            TreeNode left = tmp.left;\n            tmp.left = tmp.right;\n            tmp.right = left;\n            //如果当前节点的左子树不为空，则放入队列等待后续处理\n            if(tmp.left!=null) &#123;\n                queue.add(tmp.left);\n            &#125;\n            //如果当前节点的右子树不为空，则放入队列等待后续处理\n            if(tmp.right!=null) &#123;\n                queue.add(tmp.right);\n            &#125;\n        &#125;\n        return root;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"229求众数II","_content":"\n题目地址：https://leetcode-cn.com/problems/majority-element-ii/\n\n```java\nclass Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        if (nums == null || nums.length == 0) {\n            return res;\n        }\n        // 初始化两个候选人candidate，和他们的计票\n        int cand1 = nums[0], count1 = 0;\n        int cand2 = nums[0], count2 = 0;\n\n        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段\n        // 配对阶段\n        for (int num : nums) {\n            // 投票\n            if (cand1 == num) {\n                count1++;\n                continue;\n            }\n            if (cand2 == num) {\n                count2++;\n                continue;\n            }\n\n            // 第1个候选人配对\n            if (count1 == 0) {\n                cand1 = num;\n                count1++;\n                continue;\n            }\n            // 第2个候选人配对\n            if (count2 == 0) {\n                cand2 = num;\n                count2++;\n                continue;\n            }\n\n            count1--;\n            count2--;\n        }\n\n        // 计数阶段\n        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3\n        count1 = 0;\n        count2 = 0;\n        for (int num : nums) {\n            if (cand1 == num) {\n                count1++;\n            } else if (cand2 == num) {\n                count2++;\n            }\n        }\n\n        if (count1 > nums.length / 3) {\n            res.add(cand1);\n        }\n        if (count2 > nums.length / 3) {\n            res.add(cand2);\n        }\n\n        return res;\n    }\n}\n```\n\n","source":"_posts/LeetCode/229求众数II.md","raw":"---\ntitle: 229求众数II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/majority-element-ii/\n\n```java\nclass Solution {\n    public List<Integer> majorityElement(int[] nums) {\n        List<Integer> res = new ArrayList<>();\n        if (nums == null || nums.length == 0) {\n            return res;\n        }\n        // 初始化两个候选人candidate，和他们的计票\n        int cand1 = nums[0], count1 = 0;\n        int cand2 = nums[0], count2 = 0;\n\n        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段\n        // 配对阶段\n        for (int num : nums) {\n            // 投票\n            if (cand1 == num) {\n                count1++;\n                continue;\n            }\n            if (cand2 == num) {\n                count2++;\n                continue;\n            }\n\n            // 第1个候选人配对\n            if (count1 == 0) {\n                cand1 = num;\n                count1++;\n                continue;\n            }\n            // 第2个候选人配对\n            if (count2 == 0) {\n                cand2 = num;\n                count2++;\n                continue;\n            }\n\n            count1--;\n            count2--;\n        }\n\n        // 计数阶段\n        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3\n        count1 = 0;\n        count2 = 0;\n        for (int num : nums) {\n            if (cand1 == num) {\n                count1++;\n            } else if (cand2 == num) {\n                count2++;\n            }\n        }\n\n        if (count1 > nums.length / 3) {\n            res.add(cand1);\n        }\n        if (count2 > nums.length / 3) {\n            res.add(cand2);\n        }\n\n        return res;\n    }\n}\n```\n\n","slug":"LeetCode/229求众数II","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-28T16:18:39.516Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgf007cfhji2bbealqa","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/majority-element-ii/\">https://leetcode-cn.com/problems/majority-element-ii/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length == 0) &#123;\n            return res;\n        &#125;\n        // 初始化两个候选人candidate，和他们的计票\n        int cand1 = nums[0], count1 = 0;\n        int cand2 = nums[0], count2 = 0;\n\n        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段\n        // 配对阶段\n        for (int num : nums) &#123;\n            // 投票\n            if (cand1 == num) &#123;\n                count1++;\n                continue;\n            &#125;\n            if (cand2 == num) &#123;\n                count2++;\n                continue;\n            &#125;\n\n            // 第1个候选人配对\n            if (count1 == 0) &#123;\n                cand1 = num;\n                count1++;\n                continue;\n            &#125;\n            // 第2个候选人配对\n            if (count2 == 0) &#123;\n                cand2 = num;\n                count2++;\n                continue;\n            &#125;\n\n            count1--;\n            count2--;\n        &#125;\n\n        // 计数阶段\n        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3\n        count1 = 0;\n        count2 = 0;\n        for (int num : nums) &#123;\n            if (cand1 == num) &#123;\n                count1++;\n            &#125; else if (cand2 == num) &#123;\n                count2++;\n            &#125;\n        &#125;\n\n        if (count1 &gt; nums.length / 3) &#123;\n            res.add(cand1);\n        &#125;\n        if (count2 &gt; nums.length / 3) &#123;\n            res.add(cand2);\n        &#125;\n\n        return res;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/majority-element-ii/\">https://leetcode-cn.com/problems/majority-element-ii/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; majorityElement(int[] nums) &#123;\n        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length == 0) &#123;\n            return res;\n        &#125;\n        // 初始化两个候选人candidate，和他们的计票\n        int cand1 = nums[0], count1 = 0;\n        int cand2 = nums[0], count2 = 0;\n\n        // 摩尔投票法，分为两个阶段：配对阶段和计数阶段\n        // 配对阶段\n        for (int num : nums) &#123;\n            // 投票\n            if (cand1 == num) &#123;\n                count1++;\n                continue;\n            &#125;\n            if (cand2 == num) &#123;\n                count2++;\n                continue;\n            &#125;\n\n            // 第1个候选人配对\n            if (count1 == 0) &#123;\n                cand1 = num;\n                count1++;\n                continue;\n            &#125;\n            // 第2个候选人配对\n            if (count2 == 0) &#123;\n                cand2 = num;\n                count2++;\n                continue;\n            &#125;\n\n            count1--;\n            count2--;\n        &#125;\n\n        // 计数阶段\n        // 找到了两个候选人之后，需要确定票数是否满足大于 N/3\n        count1 = 0;\n        count2 = 0;\n        for (int num : nums) &#123;\n            if (cand1 == num) &#123;\n                count1++;\n            &#125; else if (cand2 == num) &#123;\n                count2++;\n            &#125;\n        &#125;\n\n        if (count1 &gt; nums.length / 3) &#123;\n            res.add(cand1);\n        &#125;\n        if (count2 &gt; nums.length / 3) &#123;\n            res.add(cand2);\n        &#125;\n\n        return res;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"230二叉搜索树中第K小的元素","_content":"\n题目地址：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\n\n朴素的做法是先对二叉树进行一次完整遍历，将所有节点存入列表中，最后对列表排序后返回目标值。\n\n树的遍历可以使用 `DFS` 或 `BFS`。\n\n```java\nclass Solution {\n    List<Integer> list = new ArrayList<>();\n    public int kthSmallest(TreeNode root, int k) {\n        dfs(root);\n        Collections.sort(list);\n        return list.get(k - 1);\n    }\n    void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        list.add(root.val);\n        dfs(root.left);\n        dfs(root.right);\n    }\n}\n```\n\n时间复杂度：树的遍历时间复杂度为 O(n)；排序的复杂度为 O(nlogn)。整体复杂度为 O(nlogn)\n\n空间复杂度：O(n)\n\n**中序遍历**\n\n我们知道，二叉搜索树的中序遍历是有序的，因此我们只需要对二叉搜索树执行中序遍历，并返回第 k 小的值即可。\n\n```java\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Deque<TreeNode> d = new ArrayDeque<>();\n        while (root != null || !d.isEmpty()) {\n            while (root != null) {\n                d.addLast(root);\n                root = root.left;\n            }\n            root = d.pollLast();\n            if (--k == 0) {\n                return root.val;\n            }\n            root = root.right;\n        }\n        return -1;\n    }\n}\n```\n\n时间复杂度：令 h 为树高，先到达叶子位置（最小节点位置），复杂度为 O(h)，然后找到第 k 小的元素，复杂度为 O(k)。\n\n整体复杂度为 O(h + k)\n\n空间复杂度：令 h 为树高，复杂度为 O(h)","source":"_posts/LeetCode/230二叉搜索树中第K小的元素.md","raw":"---\ntitle: 230二叉搜索树中第K小的元素\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\n\n朴素的做法是先对二叉树进行一次完整遍历，将所有节点存入列表中，最后对列表排序后返回目标值。\n\n树的遍历可以使用 `DFS` 或 `BFS`。\n\n```java\nclass Solution {\n    List<Integer> list = new ArrayList<>();\n    public int kthSmallest(TreeNode root, int k) {\n        dfs(root);\n        Collections.sort(list);\n        return list.get(k - 1);\n    }\n    void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        list.add(root.val);\n        dfs(root.left);\n        dfs(root.right);\n    }\n}\n```\n\n时间复杂度：树的遍历时间复杂度为 O(n)；排序的复杂度为 O(nlogn)。整体复杂度为 O(nlogn)\n\n空间复杂度：O(n)\n\n**中序遍历**\n\n我们知道，二叉搜索树的中序遍历是有序的，因此我们只需要对二叉搜索树执行中序遍历，并返回第 k 小的值即可。\n\n```java\nclass Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        Deque<TreeNode> d = new ArrayDeque<>();\n        while (root != null || !d.isEmpty()) {\n            while (root != null) {\n                d.addLast(root);\n                root = root.left;\n            }\n            root = d.pollLast();\n            if (--k == 0) {\n                return root.val;\n            }\n            root = root.right;\n        }\n        return -1;\n    }\n}\n```\n\n时间复杂度：令 h 为树高，先到达叶子位置（最小节点位置），复杂度为 O(h)，然后找到第 k 小的元素，复杂度为 O(k)。\n\n整体复杂度为 O(h + k)\n\n空间复杂度：令 h 为树高，复杂度为 O(h)","slug":"LeetCode/230二叉搜索树中第K小的元素","published":1,"date":"2021-12-06T04:48:42.529Z","updated":"2022-01-28T16:18:52.923Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgf007dfhjig8gm2r9z","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a></p>\n<p>朴素的做法是先对二叉树进行一次完整遍历，将所有节点存入列表中，最后对列表排序后返回目标值。</p>\n<p>树的遍历可以使用 <code>DFS</code> 或 <code>BFS</code>。</p>\n<pre><code class=\"java\">class Solution &#123;\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    public int kthSmallest(TreeNode root, int k) &#123;\n        dfs(root);\n        Collections.sort(list);\n        return list.get(k - 1);\n    &#125;\n    void dfs(TreeNode root) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        list.add(root.val);\n        dfs(root.left);\n        dfs(root.right);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：树的遍历时间复杂度为 O(n)；排序的复杂度为 O(nlogn)。整体复杂度为 O(nlogn)</p>\n<p>空间复杂度：O(n)</p>\n<p><strong>中序遍历</strong></p>\n<p>我们知道，二叉搜索树的中序遍历是有序的，因此我们只需要对二叉搜索树执行中序遍历，并返回第 k 小的值即可。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int kthSmallest(TreeNode root, int k) &#123;\n        Deque&lt;TreeNode&gt; d = new ArrayDeque&lt;&gt;();\n        while (root != null || !d.isEmpty()) &#123;\n            while (root != null) &#123;\n                d.addLast(root);\n                root = root.left;\n            &#125;\n            root = d.pollLast();\n            if (--k == 0) &#123;\n                return root.val;\n            &#125;\n            root = root.right;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：令 h 为树高，先到达叶子位置（最小节点位置），复杂度为 O(h)，然后找到第 k 小的元素，复杂度为 O(k)。</p>\n<p>整体复杂度为 O(h + k)</p>\n<p>空间复杂度：令 h 为树高，复杂度为 O(h)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/\">https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst/</a></p>\n<p>朴素的做法是先对二叉树进行一次完整遍历，将所有节点存入列表中，最后对列表排序后返回目标值。</p>\n<p>树的遍历可以使用 <code>DFS</code> 或 <code>BFS</code>。</p>\n<pre><code class=\"java\">class Solution &#123;\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    public int kthSmallest(TreeNode root, int k) &#123;\n        dfs(root);\n        Collections.sort(list);\n        return list.get(k - 1);\n    &#125;\n    void dfs(TreeNode root) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        list.add(root.val);\n        dfs(root.left);\n        dfs(root.right);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：树的遍历时间复杂度为 O(n)；排序的复杂度为 O(nlogn)。整体复杂度为 O(nlogn)</p>\n<p>空间复杂度：O(n)</p>\n<p><strong>中序遍历</strong></p>\n<p>我们知道，二叉搜索树的中序遍历是有序的，因此我们只需要对二叉搜索树执行中序遍历，并返回第 k 小的值即可。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int kthSmallest(TreeNode root, int k) &#123;\n        Deque&lt;TreeNode&gt; d = new ArrayDeque&lt;&gt;();\n        while (root != null || !d.isEmpty()) &#123;\n            while (root != null) &#123;\n                d.addLast(root);\n                root = root.left;\n            &#125;\n            root = d.pollLast();\n            if (--k == 0) &#123;\n                return root.val;\n            &#125;\n            root = root.right;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：令 h 为树高，先到达叶子位置（最小节点位置），复杂度为 O(h)，然后找到第 k 小的元素，复杂度为 O(k)。</p>\n<p>整体复杂度为 O(h + k)</p>\n<p>空间复杂度：令 h 为树高，复杂度为 O(h)</p>\n"},{"title":"234回文链表","_content":"\n题目地址：https://leetcode-cn.com/problems/palindrome-linked-list/\n\n**整个流程可以分为以下五个步骤：**\n\n1. 找到前半部分链表的尾节点。\n2. 反转后半部分链表。\n3. 判断是否回文。\n4. 恢复链表。\n5. 返回结果。\n\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null) {\n            return true;\n        }\n\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode firstHalfEnd = endOfFirstHalf(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n\n        // 判断是否回文\n        ListNode p1 = head;\n        ListNode p2 = secondHalfStart;\n        boolean result = true;\n        while (result && p2 != null) {\n            if (p1.val != p2.val) {\n                result = false;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }        \n\n        // 还原链表并返回结果\n        firstHalfEnd.next = reverseList(secondHalfStart);\n        return result;\n    }\n\n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    private ListNode endOfFirstHalf(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 指的是链表的大小。\n\n空间复杂度：O(1)","source":"_posts/LeetCode/234回文链表.md","raw":"---\ntitle: 234回文链表\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/palindrome-linked-list/\n\n**整个流程可以分为以下五个步骤：**\n\n1. 找到前半部分链表的尾节点。\n2. 反转后半部分链表。\n3. 判断是否回文。\n4. 恢复链表。\n5. 返回结果。\n\n```java\nclass Solution {\n    public boolean isPalindrome(ListNode head) {\n        if (head == null) {\n            return true;\n        }\n\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode firstHalfEnd = endOfFirstHalf(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n\n        // 判断是否回文\n        ListNode p1 = head;\n        ListNode p2 = secondHalfStart;\n        boolean result = true;\n        while (result && p2 != null) {\n            if (p1.val != p2.val) {\n                result = false;\n            }\n            p1 = p1.next;\n            p2 = p2.next;\n        }        \n\n        // 还原链表并返回结果\n        firstHalfEnd.next = reverseList(secondHalfStart);\n        return result;\n    }\n\n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        }\n        return prev;\n    }\n\n    private ListNode endOfFirstHalf(ListNode head) {\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast.next != null && fast.next.next != null) {\n            fast = fast.next.next;\n            slow = slow.next;\n        }\n        return slow;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 指的是链表的大小。\n\n空间复杂度：O(1)","slug":"LeetCode/234回文链表","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-28T16:19:01.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgi007gfhjia20s2mfy","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>\n<p><strong>整个流程可以分为以下五个步骤：</strong></p>\n<ol>\n<li>找到前半部分链表的尾节点。</li>\n<li>反转后半部分链表。</li>\n<li>判断是否回文。</li>\n<li>恢复链表。</li>\n<li>返回结果。</li>\n</ol>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isPalindrome(ListNode head) &#123;\n        if (head == null) &#123;\n            return true;\n        &#125;\n\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode firstHalfEnd = endOfFirstHalf(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n\n        // 判断是否回文\n        ListNode p1 = head;\n        ListNode p2 = secondHalfStart;\n        boolean result = true;\n        while (result &amp;&amp; p2 != null) &#123;\n            if (p1.val != p2.val) &#123;\n                result = false;\n            &#125;\n            p1 = p1.next;\n            p2 = p2.next;\n        &#125;        \n\n        // 还原链表并返回结果\n        firstHalfEnd.next = reverseList(secondHalfStart);\n        return result;\n    &#125;\n\n    private ListNode reverseList(ListNode head) &#123;\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) &#123;\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        &#125;\n        return prev;\n    &#125;\n\n    private ListNode endOfFirstHalf(ListNode head) &#123;\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;\n            fast = fast.next.next;\n            slow = slow.next;\n        &#125;\n        return slow;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 指的是链表的大小。</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/palindrome-linked-list/\">https://leetcode-cn.com/problems/palindrome-linked-list/</a></p>\n<p><strong>整个流程可以分为以下五个步骤：</strong></p>\n<ol>\n<li>找到前半部分链表的尾节点。</li>\n<li>反转后半部分链表。</li>\n<li>判断是否回文。</li>\n<li>恢复链表。</li>\n<li>返回结果。</li>\n</ol>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isPalindrome(ListNode head) &#123;\n        if (head == null) &#123;\n            return true;\n        &#125;\n\n        // 找到前半部分链表的尾节点并反转后半部分链表\n        ListNode firstHalfEnd = endOfFirstHalf(head);\n        ListNode secondHalfStart = reverseList(firstHalfEnd.next);\n\n        // 判断是否回文\n        ListNode p1 = head;\n        ListNode p2 = secondHalfStart;\n        boolean result = true;\n        while (result &amp;&amp; p2 != null) &#123;\n            if (p1.val != p2.val) &#123;\n                result = false;\n            &#125;\n            p1 = p1.next;\n            p2 = p2.next;\n        &#125;        \n\n        // 还原链表并返回结果\n        firstHalfEnd.next = reverseList(secondHalfStart);\n        return result;\n    &#125;\n\n    private ListNode reverseList(ListNode head) &#123;\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) &#123;\n            ListNode nextTemp = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextTemp;\n        &#125;\n        return prev;\n    &#125;\n\n    private ListNode endOfFirstHalf(ListNode head) &#123;\n        ListNode fast = head;\n        ListNode slow = head;\n        while (fast.next != null &amp;&amp; fast.next.next != null) &#123;\n            fast = fast.next.next;\n            slow = slow.next;\n        &#125;\n        return slow;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 指的是链表的大小。</p>\n<p>空间复杂度：O(1)</p>\n"},{"title":"237删除链表中的节点","_content":"\n题目地址：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\n\n对于一般性的链表删除操作而言，我们需要知道待删除节点的前一节点与后一节点，并对两者建立联系。\n\n对于本题，由于我们只知道待删除节点本身，同时该链表为单链表（无法访问前一节点），因此我们只能先将后一节点的值复制到当前节点，然后将后一节点当作「待删除节点」来进行常规删除。\n\n```java\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)。\n- 空间复杂度：O(1)。","source":"_posts/LeetCode/237删除链表中的节点.md","raw":"---\ntitle: 237删除链表中的节点\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\n\n对于一般性的链表删除操作而言，我们需要知道待删除节点的前一节点与后一节点，并对两者建立联系。\n\n对于本题，由于我们只知道待删除节点本身，同时该链表为单链表（无法访问前一节点），因此我们只能先将后一节点的值复制到当前节点，然后将后一节点当作「待删除节点」来进行常规删除。\n\n```java\nclass Solution {\n    public void deleteNode(ListNode node) {\n        node.val = node.next.val;\n        node.next = node.next.next;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(1)。\n- 空间复杂度：O(1)。","slug":"LeetCode/237删除链表中的节点","published":1,"date":"2021-12-07T01:38:10.033Z","updated":"2022-01-28T16:19:51.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgj007hfhjihs3p507q","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/</a></p>\n<p>对于一般性的链表删除操作而言，我们需要知道待删除节点的前一节点与后一节点，并对两者建立联系。</p>\n<p>对于本题，由于我们只知道待删除节点本身，同时该链表为单链表（无法访问前一节点），因此我们只能先将后一节点的值复制到当前节点，然后将后一节点当作「待删除节点」来进行常规删除。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public void deleteNode(ListNode node) &#123;\n        node.val = node.next.val;\n        node.next = node.next.next;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(1)。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/delete-node-in-a-linked-list/\">https://leetcode-cn.com/problems/delete-node-in-a-linked-list/</a></p>\n<p>对于一般性的链表删除操作而言，我们需要知道待删除节点的前一节点与后一节点，并对两者建立联系。</p>\n<p>对于本题，由于我们只知道待删除节点本身，同时该链表为单链表（无法访问前一节点），因此我们只能先将后一节点的值复制到当前节点，然后将后一节点当作「待删除节点」来进行常规删除。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public void deleteNode(ListNode node) &#123;\n        node.val = node.next.val;\n        node.next = node.next.next;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(1)。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n"},{"title":"240搜索二维矩阵II","_content":"\n题目地址：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\n\n因为每一行递增，每一列递增。\n\n所以本题的思路是从右上角往左下角找或者从左下角往右上角找。每次比较可以排除一行或者一列，时间复杂度为O(m+n)\n\n从右上角往左下角找的代码如下\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int x = 0, y = col - 1;\n        while(x < row && y >= 0) {\n            if (matrix[x][y] == target) {\n                return true;\n            } else if (matrix[x][y] > target) {\n                y--;\n            } else {\n                x++;\n            }\n        }\n        return false;\n    }\n}\n```\n\n","source":"_posts/LeetCode/240搜索二维矩阵II.md","raw":"---\ntitle: 240搜索二维矩阵II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\n\n因为每一行递增，每一列递增。\n\n所以本题的思路是从右上角往左下角找或者从左下角往右上角找。每次比较可以排除一行或者一列，时间复杂度为O(m+n)\n\n从右上角往左下角找的代码如下\n\n```java\nclass Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int x = 0, y = col - 1;\n        while(x < row && y >= 0) {\n            if (matrix[x][y] == target) {\n                return true;\n            } else if (matrix[x][y] > target) {\n                y--;\n            } else {\n                x++;\n            }\n        }\n        return false;\n    }\n}\n```\n\n","slug":"LeetCode/240搜索二维矩阵II","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-28T16:20:16.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgk007kfhjib4zz24y3","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>\n<p>因为每一行递增，每一列递增。</p>\n<p>所以本题的思路是从右上角往左下角找或者从左下角往右上角找。每次比较可以排除一行或者一列，时间复杂度为O(m+n)</p>\n<p>从右上角往左下角找的代码如下</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean searchMatrix(int[][] matrix, int target) &#123;\n        if (matrix == null || matrix.length == 0) &#123;\n            return false;\n        &#125;\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int x = 0, y = col - 1;\n        while(x &lt; row &amp;&amp; y &gt;= 0) &#123;\n            if (matrix[x][y] == target) &#123;\n                return true;\n            &#125; else if (matrix[x][y] &gt; target) &#123;\n                y--;\n            &#125; else &#123;\n                x++;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix-ii/\">https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</a></p>\n<p>因为每一行递增，每一列递增。</p>\n<p>所以本题的思路是从右上角往左下角找或者从左下角往右上角找。每次比较可以排除一行或者一列，时间复杂度为O(m+n)</p>\n<p>从右上角往左下角找的代码如下</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean searchMatrix(int[][] matrix, int target) &#123;\n        if (matrix == null || matrix.length == 0) &#123;\n            return false;\n        &#125;\n        int row = matrix.length;\n        int col = matrix[0].length;\n        int x = 0, y = col - 1;\n        while(x &lt; row &amp;&amp; y &gt;= 0) &#123;\n            if (matrix[x][y] == target) &#123;\n                return true;\n            &#125; else if (matrix[x][y] &gt; target) &#123;\n                y--;\n            &#125; else &#123;\n                x++;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"24两两交换链表中的节点","_content":"\n题目地址：https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n* 令 cur 表示当前到达的节点，初始时 cur = pre。\n\n* 每次需要交换 cur 后面的两个节点。\n\n* 如果 cur 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。\n\n* 否则，获得 cur 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。\n\n具体而言，交换之前的节点关系是 `cur -> node1 -> node2`，交换之后的节点关系要变成 `cur -> node2 -> node1`，因此需要进行如下操作。\n\n```java\nnode1.next = node2.next\ncur.next = node2\nnode2.next = node1\n```\n\n* 完成上述操作之后，节点关系即变成 `cur -> node2 -> node1`。\n\n* 再令 `cur = node1`，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。\n\n* 两两交换链表中的节点之后，新的链表的头节点是 `pre.next`，返回新的链表的头节点即可。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode cur = pre;\n\n        while(cur.next != null && cur.next.next != null) {\n            ListNode node1 = cur.next;\n            ListNode node2 = cur.next.next;\n            node1.next = node2.next;\n            cur.next = node2;\n            node2.next = node1;\n            cur = node1;\n        }\n        return pre.next;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n是链表的节点数量。需要对每个节点进行更新指针的操作。\n\n空间复杂度：O(1)。","source":"_posts/LeetCode/24两两交换链表中的节点.md","raw":"---\ntitle: 24两两交换链表中的节点\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/swap-nodes-in-pairs/\n\n* 令 cur 表示当前到达的节点，初始时 cur = pre。\n\n* 每次需要交换 cur 后面的两个节点。\n\n* 如果 cur 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。\n\n* 否则，获得 cur 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。\n\n具体而言，交换之前的节点关系是 `cur -> node1 -> node2`，交换之后的节点关系要变成 `cur -> node2 -> node1`，因此需要进行如下操作。\n\n```java\nnode1.next = node2.next\ncur.next = node2\nnode2.next = node1\n```\n\n* 完成上述操作之后，节点关系即变成 `cur -> node2 -> node1`。\n\n* 再令 `cur = node1`，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。\n\n* 两两交换链表中的节点之后，新的链表的头节点是 `pre.next`，返回新的链表的头节点即可。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode cur = pre;\n\n        while(cur.next != null && cur.next.next != null) {\n            ListNode node1 = cur.next;\n            ListNode node2 = cur.next.next;\n            node1.next = node2.next;\n            cur.next = node2;\n            node2.next = node1;\n            cur = node1;\n        }\n        return pre.next;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n是链表的节点数量。需要对每个节点进行更新指针的操作。\n\n空间复杂度：O(1)。","slug":"LeetCode/24两两交换链表中的节点","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-03T07:28:18.480Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgk007lfhji17jaf58a","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p>\n<ul>\n<li><p>令 cur 表示当前到达的节点，初始时 cur &#x3D; pre。</p>\n</li>\n<li><p>每次需要交换 cur 后面的两个节点。</p>\n</li>\n<li><p>如果 cur 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。</p>\n</li>\n<li><p>否则，获得 cur 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</p>\n</li>\n</ul>\n<p>具体而言，交换之前的节点关系是 <code>cur -&gt; node1 -&gt; node2</code>，交换之后的节点关系要变成 <code>cur -&gt; node2 -&gt; node1</code>，因此需要进行如下操作。</p>\n<pre><code class=\"java\">node1.next = node2.next\ncur.next = node2\nnode2.next = node1\n</code></pre>\n<ul>\n<li><p>完成上述操作之后，节点关系即变成 <code>cur -&gt; node2 -&gt; node1</code>。</p>\n</li>\n<li><p>再令 <code>cur = node1</code>，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p>\n</li>\n<li><p>两两交换链表中的节点之后，新的链表的头节点是 <code>pre.next</code>，返回新的链表的头节点即可。</p>\n</li>\n</ul>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public ListNode swapPairs(ListNode head) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode cur = pre;\n\n        while(cur.next != null &amp;&amp; cur.next.next != null) &#123;\n            ListNode node1 = cur.next;\n            ListNode node2 = cur.next.next;\n            node1.next = node2.next;\n            cur.next = node2;\n            node2.next = node1;\n            cur = node1;\n        &#125;\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n是链表的节点数量。需要对每个节点进行更新指针的操作。</p>\n<p>空间复杂度：O(1)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/swap-nodes-in-pairs/\">https://leetcode-cn.com/problems/swap-nodes-in-pairs/</a></p>\n<ul>\n<li><p>令 cur 表示当前到达的节点，初始时 cur &#x3D; pre。</p>\n</li>\n<li><p>每次需要交换 cur 后面的两个节点。</p>\n</li>\n<li><p>如果 cur 的后面没有节点或者只有一个节点，则没有更多的节点需要交换，因此结束交换。</p>\n</li>\n<li><p>否则，获得 cur 后面的两个节点 node1 和 node2，通过更新节点的指针关系实现两两交换节点。</p>\n</li>\n</ul>\n<p>具体而言，交换之前的节点关系是 <code>cur -&gt; node1 -&gt; node2</code>，交换之后的节点关系要变成 <code>cur -&gt; node2 -&gt; node1</code>，因此需要进行如下操作。</p>\n<pre><code class=\"java\">node1.next = node2.next\ncur.next = node2\nnode2.next = node1\n</code></pre>\n<ul>\n<li><p>完成上述操作之后，节点关系即变成 <code>cur -&gt; node2 -&gt; node1</code>。</p>\n</li>\n<li><p>再令 <code>cur = node1</code>，对链表中的其余节点进行两两交换，直到全部节点都被两两交换。</p>\n</li>\n<li><p>两两交换链表中的节点之后，新的链表的头节点是 <code>pre.next</code>，返回新的链表的头节点即可。</p>\n</li>\n</ul>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode() &#123;&#125;\n *     ListNode(int val) &#123; this.val = val; &#125;\n *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public ListNode swapPairs(ListNode head) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n\n        ListNode pre = new ListNode(-1);\n        pre.next = head;\n        ListNode cur = pre;\n\n        while(cur.next != null &amp;&amp; cur.next.next != null) &#123;\n            ListNode node1 = cur.next;\n            ListNode node2 = cur.next.next;\n            node1.next = node2.next;\n            cur.next = node2;\n            node2.next = node1;\n            cur = node1;\n        &#125;\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n是链表的节点数量。需要对每个节点进行更新指针的操作。</p>\n<p>空间复杂度：O(1)。</p>\n"},{"title":"257二叉树的所有路径","_content":"\n题目地址：https://leetcode-cn.com/problems/binary-tree-paths/s\n\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> paths = new ArrayList<String>();\n        constructPaths(root, \"\", paths);\n        return paths;\n    }\n\n    public void constructPaths(TreeNode root, String path, List<String> paths) {\n        if (root == null) {\n            return;\n        }\n        StringBuffer pathBuilder = new StringBuffer(path);\n        pathBuilder.append(String.valueOf(root.val));\n        if (root.left == null && root.right == null) {\n            paths.add(pathBuilder.toString());\n        } else {\n            pathBuilder.append(\"->\");\n            constructPaths(root.left, pathBuilder.toString(), paths);\n            constructPaths(root.right, pathBuilder.toString(), paths);\n        }\n    }\n}\n```\n\n时间复杂度：O(N^2)，其中 N表示节点数目\n\n空间复杂度：O(N^2)，其中 N表示节点数目","source":"_posts/LeetCode/257二叉树的所有路径.md","raw":"---\ntitle: 257二叉树的所有路径\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/binary-tree-paths/s\n\n```java\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> paths = new ArrayList<String>();\n        constructPaths(root, \"\", paths);\n        return paths;\n    }\n\n    public void constructPaths(TreeNode root, String path, List<String> paths) {\n        if (root == null) {\n            return;\n        }\n        StringBuffer pathBuilder = new StringBuffer(path);\n        pathBuilder.append(String.valueOf(root.val));\n        if (root.left == null && root.right == null) {\n            paths.add(pathBuilder.toString());\n        } else {\n            pathBuilder.append(\"->\");\n            constructPaths(root.left, pathBuilder.toString(), paths);\n            constructPaths(root.right, pathBuilder.toString(), paths);\n        }\n    }\n}\n```\n\n时间复杂度：O(N^2)，其中 N表示节点数目\n\n空间复杂度：O(N^2)，其中 N表示节点数目","slug":"LeetCode/257二叉树的所有路径","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-28T16:20:21.412Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgl007ofhji18em7df8","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-paths/s\">https://leetcode-cn.com/problems/binary-tree-paths/s</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;\n        List&lt;String&gt; paths = new ArrayList&lt;String&gt;();\n        constructPaths(root, &quot;&quot;, paths);\n        return paths;\n    &#125;\n\n    public void constructPaths(TreeNode root, String path, List&lt;String&gt; paths) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        StringBuffer pathBuilder = new StringBuffer(path);\n        pathBuilder.append(String.valueOf(root.val));\n        if (root.left == null &amp;&amp; root.right == null) &#123;\n            paths.add(pathBuilder.toString());\n        &#125; else &#123;\n            pathBuilder.append(&quot;-&gt;&quot;);\n            constructPaths(root.left, pathBuilder.toString(), paths);\n            constructPaths(root.right, pathBuilder.toString(), paths);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N^2)，其中 N表示节点数目</p>\n<p>空间复杂度：O(N^2)，其中 N表示节点数目</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-paths/s\">https://leetcode-cn.com/problems/binary-tree-paths/s</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;\n        List&lt;String&gt; paths = new ArrayList&lt;String&gt;();\n        constructPaths(root, &quot;&quot;, paths);\n        return paths;\n    &#125;\n\n    public void constructPaths(TreeNode root, String path, List&lt;String&gt; paths) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        StringBuffer pathBuilder = new StringBuffer(path);\n        pathBuilder.append(String.valueOf(root.val));\n        if (root.left == null &amp;&amp; root.right == null) &#123;\n            paths.add(pathBuilder.toString());\n        &#125; else &#123;\n            pathBuilder.append(&quot;-&gt;&quot;);\n            constructPaths(root.left, pathBuilder.toString(), paths);\n            constructPaths(root.right, pathBuilder.toString(), paths);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N^2)，其中 N表示节点数目</p>\n<p>空间复杂度：O(N^2)，其中 N表示节点数目</p>\n"},{"title":"26删除排序数组中的重复项","_content":"\n题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n# 双指针\n\n数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。\n\n* 只要 `nums[i] = nums[j]`，我们就增加 j 以跳过重复项。\n\n* 当我们遇到 `nums[j] !=nums[i]` 时，没有重复项，我们必须把它（`nums[j]`）的值复制到 `nums[i + 1]`。\n\n* 然后递增 i，直到 j 到达数组的末尾为止。\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int i = 0;\n        for (int j = 1; j<nums.length; j++) {\n            if (nums[i] != nums[j]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i+1;\n    }\n}\n```\n\n","source":"_posts/LeetCode/26删除排序数组中的重复项.md","raw":"---\ntitle: 26删除排序数组中的重复项\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\n\n# 双指针\n\n数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。\n\n* 只要 `nums[i] = nums[j]`，我们就增加 j 以跳过重复项。\n\n* 当我们遇到 `nums[j] !=nums[i]` 时，没有重复项，我们必须把它（`nums[j]`）的值复制到 `nums[i + 1]`。\n\n* 然后递增 i，直到 j 到达数组的末尾为止。\n\n```java\nclass Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) {\n            return 0;\n        }\n        int i = 0;\n        for (int j = 1; j<nums.length; j++) {\n            if (nums[i] != nums[j]) {\n                i++;\n                nums[i] = nums[j];\n            }\n        }\n        return i+1;\n    }\n}\n```\n\n","slug":"LeetCode/26删除排序数组中的重复项","published":1,"date":"2021-09-01T05:22:18.209Z","updated":"2022-01-03T07:29:29.128Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgl007pfhjih0aa9fhi","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><p>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。</p>\n<ul>\n<li><p>只要 <code>nums[i] = nums[j]</code>，我们就增加 j 以跳过重复项。</p>\n</li>\n<li><p>当我们遇到 <code>nums[j] !=nums[i]</code> 时，没有重复项，我们必须把它（<code>nums[j]</code>）的值复制到 <code>nums[i + 1]</code>。</p>\n</li>\n<li><p>然后递增 i，直到 j 到达数组的末尾为止。</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int removeDuplicates(int[] nums) &#123;\n        if (nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int i = 0;\n        for (int j = 1; j&lt;nums.length; j++) &#123;\n            if (nums[i] != nums[j]) &#123;\n                i++;\n                nums[i] = nums[j];\n            &#125;\n        &#125;\n        return i+1;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><p>数组完成排序后，我们可以放置两个指针 i 和 j，其中 i 是慢指针，而 j 是快指针。</p>\n<ul>\n<li><p>只要 <code>nums[i] = nums[j]</code>，我们就增加 j 以跳过重复项。</p>\n</li>\n<li><p>当我们遇到 <code>nums[j] !=nums[i]</code> 时，没有重复项，我们必须把它（<code>nums[j]</code>）的值复制到 <code>nums[i + 1]</code>。</p>\n</li>\n<li><p>然后递增 i，直到 j 到达数组的末尾为止。</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public int removeDuplicates(int[] nums) &#123;\n        if (nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int i = 0;\n        for (int j = 1; j&lt;nums.length; j++) &#123;\n            if (nums[i] != nums[j]) &#123;\n                i++;\n                nums[i] = nums[j];\n            &#125;\n        &#125;\n        return i+1;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"27移除元素","_content":"\n题目地址：https://leetcode-cn.com/problems/remove-element/\n\n# 双指针\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (nums[j] != val) {\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        return i;\n    }\n}\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","source":"_posts/LeetCode/27移除元素.md","raw":"---\ntitle: 27移除元素\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/remove-element/\n\n# 双指针\n\n```java\nclass Solution {\n    public int removeElement(int[] nums, int val) {\n        int i = 0;\n        for (int j = 0; j < nums.length; j++) {\n            if (nums[j] != val) {\n                nums[i] = nums[j];\n                i++;\n            }\n        }\n        return i;\n    }\n}\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(1)","slug":"LeetCode/27移除元素","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-12T01:05:03.449Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgm007sfhji0jibff7i","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-element/\">https://leetcode-cn.com/problems/remove-element/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><pre><code class=\"java\">class Solution &#123;\n    public int removeElement(int[] nums, int val) &#123;\n        int i = 0;\n        for (int j = 0; j &lt; nums.length; j++) &#123;\n            if (nums[j] != val) &#123;\n                nums[i] = nums[j];\n                i++;\n            &#125;\n        &#125;\n        return i;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(1)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-element/\">https://leetcode-cn.com/problems/remove-element/</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><pre><code class=\"java\">class Solution &#123;\n    public int removeElement(int[] nums, int val) &#123;\n        int i = 0;\n        for (int j = 0; j &lt; nums.length; j++) &#123;\n            if (nums[j] != val) &#123;\n                nums[i] = nums[j];\n                i++;\n            &#125;\n        &#125;\n        return i;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(1)</p>\n"},{"title":"2两数相加","_content":"\n题目地址：https://leetcode-cn.com/problems/add-two-numbers/\n\n将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 = 987 + 023 = 1010\n\n每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值\n\n如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1\n\n小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode pre = new ListNode(0);\n        ListNode cur = pre;\n        int carry = 0;\n        while(l1 != null || l2 != null) {\n            int x = (l1 == null ? 0 : l1.val);\n            int y = (l2 == null ? 0 : l2.val);\n            int sum = x + y + carry;\n            \n            carry = sum / 10;\n            sum = sum % 10;\n            cur.next = new ListNode(sum);\n\n            cur = cur.next;\n            if(l1 != null) {\n                l1 = l1.next;\n            }\n            if(l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if(carry == 1) {\n            cur.next = new ListNode(carry);\n        }\n        return pre.next;\n    }\n}\n```\n\n时间复杂度：`O(max(m,n))`，其中 m,n 为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间\n\n空间复杂度：`O(max(m,n))`\n\n","source":"_posts/LeetCode/2两数相加.md","raw":"---\ntitle: 2两数相加\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/add-two-numbers/\n\n将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 = 987 + 023 = 1010\n\n每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值\n\n如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1\n\n小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode pre = new ListNode(0);\n        ListNode cur = pre;\n        int carry = 0;\n        while(l1 != null || l2 != null) {\n            int x = (l1 == null ? 0 : l1.val);\n            int y = (l2 == null ? 0 : l2.val);\n            int sum = x + y + carry;\n            \n            carry = sum / 10;\n            sum = sum % 10;\n            cur.next = new ListNode(sum);\n\n            cur = cur.next;\n            if(l1 != null) {\n                l1 = l1.next;\n            }\n            if(l2 != null) {\n                l2 = l2.next;\n            }\n        }\n        if(carry == 1) {\n            cur.next = new ListNode(carry);\n        }\n        return pre.next;\n    }\n}\n```\n\n时间复杂度：`O(max(m,n))`，其中 m,n 为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间\n\n空间复杂度：`O(max(m,n))`\n\n","slug":"LeetCode/2两数相加","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2021-12-13T17:01:05.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgn007tfhji7n724shh","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">https://leetcode-cn.com/problems/add-two-numbers/</a></p>\n<p>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 &#x3D; 987 + 023 &#x3D; 1010</p>\n<p>每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值</p>\n<p>如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1</p>\n<p>小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</p>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;\n        ListNode pre = new ListNode(0);\n        ListNode cur = pre;\n        int carry = 0;\n        while(l1 != null || l2 != null) &#123;\n            int x = (l1 == null ? 0 : l1.val);\n            int y = (l2 == null ? 0 : l2.val);\n            int sum = x + y + carry;\n            \n            carry = sum / 10;\n            sum = sum % 10;\n            cur.next = new ListNode(sum);\n\n            cur = cur.next;\n            if(l1 != null) &#123;\n                l1 = l1.next;\n            &#125;\n            if(l2 != null) &#123;\n                l2 = l2.next;\n            &#125;\n        &#125;\n        if(carry == 1) &#123;\n            cur.next = new ListNode(carry);\n        &#125;\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(max(m,n))</code>，其中 m,n 为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间</p>\n<p>空间复杂度：<code>O(max(m,n))</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">https://leetcode-cn.com/problems/add-two-numbers/</a></p>\n<p>将两个链表看成是相同长度的进行遍历，如果一个链表较短则在前面补 00，比如 987 + 23 &#x3D; 987 + 023 &#x3D; 1010</p>\n<p>每一位计算的同时需要考虑上一位的进位问题，而当前位计算结束后同样需要更新进位值</p>\n<p>如果两个链表全部遍历完毕后，进位值为 1，则在新链表最前方添加节点 1</p>\n<p>小技巧：对于链表问题，返回结果为头结点时，通常需要先初始化一个预先指针 pre，该指针的下一个节点指向真正的头结点head。使用预先指针的目的在于链表初始化时无可用节点值，而且链表构造过程需要指针移动，进而会导致头指针丢失，无法返回结果。</p>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123; val = x; &#125;\n * &#125;\n */\nclass Solution &#123;\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;\n        ListNode pre = new ListNode(0);\n        ListNode cur = pre;\n        int carry = 0;\n        while(l1 != null || l2 != null) &#123;\n            int x = (l1 == null ? 0 : l1.val);\n            int y = (l2 == null ? 0 : l2.val);\n            int sum = x + y + carry;\n            \n            carry = sum / 10;\n            sum = sum % 10;\n            cur.next = new ListNode(sum);\n\n            cur = cur.next;\n            if(l1 != null) &#123;\n                l1 = l1.next;\n            &#125;\n            if(l2 != null) &#123;\n                l2 = l2.next;\n            &#125;\n        &#125;\n        if(carry == 1) &#123;\n            cur.next = new ListNode(carry);\n        &#125;\n        return pre.next;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(max(m,n))</code>，其中 m,n 为两个链表的长度。我们要遍历两个链表的全部位置，而处理每个位置只需要 O(1) 的时间</p>\n<p>空间复杂度：<code>O(max(m,n))</code></p>\n"},{"title":"300最长上升子序列","_content":"\n题目地址：https://leetcode-cn.com/problems/longest-increasing-subsequence/\n\ndp[i] 的值代表 `nums` 前 i 个数字的最长子序列长度。\n\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int[] dp = new int[nums.length];\n        Arrays.fill(dp, 1);\n        int result = 0;\n        for (int i = 0;i<nums.length;i++) {\n            for (int j = 0;j<i;j++) {\n                if (nums[j] < nums[i]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            result = Math.max(result, dp[i]);\n        }\n        return result;\n    }\n}\n```","source":"_posts/LeetCode/300最长上升子序列.md","raw":"---\ntitle: 300最长上升子序列\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/longest-increasing-subsequence/\n\ndp[i] 的值代表 `nums` 前 i 个数字的最长子序列长度。\n\n```java\nclass Solution {\n    public int lengthOfLIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int[] dp = new int[nums.length];\n        Arrays.fill(dp, 1);\n        int result = 0;\n        for (int i = 0;i<nums.length;i++) {\n            for (int j = 0;j<i;j++) {\n                if (nums[j] < nums[i]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            result = Math.max(result, dp[i]);\n        }\n        return result;\n    }\n}\n```","slug":"LeetCode/300最长上升子序列","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-28T16:20:29.866Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgn007wfhjihtw47iwh","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>\n<p>dp[i] 的值代表 <code>nums</code> 前 i 个数字的最长子序列长度。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int lengthOfLIS(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int[] dp = new int[nums.length];\n        Arrays.fill(dp, 1);\n        int result = 0;\n        for (int i = 0;i&lt;nums.length;i++) &#123;\n            for (int j = 0;j&lt;i;j++) &#123;\n                if (nums[j] &lt; nums[i]) &#123;\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                &#125;\n            &#125;\n            result = Math.max(result, dp[i]);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">https://leetcode-cn.com/problems/longest-increasing-subsequence/</a></p>\n<p>dp[i] 的值代表 <code>nums</code> 前 i 个数字的最长子序列长度。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int lengthOfLIS(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int[] dp = new int[nums.length];\n        Arrays.fill(dp, 1);\n        int result = 0;\n        for (int i = 0;i&lt;nums.length;i++) &#123;\n            for (int j = 0;j&lt;i;j++) &#123;\n                if (nums[j] &lt; nums[i]) &#123;\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                &#125;\n            &#125;\n            result = Math.max(result, dp[i]);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"31下一个排列","_content":"\n题目地址：https://leetcode-cn.com/problems/next-permutation/\n\n* 像 `[3,2,1]` 递减的，没有下一个排列，因为大的已经尽量往前排了，没法更大\n\n* 像`[1,5,2,4,3,2]` 这种，我们希望它稍微变大\n\n从低位挑一个大一点的数，换掉前面的小一点的一个数\n\n于是，从右往左，寻找第一个比右邻居小的数（把它换到后面去）\n\n* 找到 1 5 (2) 4 3 2 中间这个 2，让它和它身后的一个数交换，轻微变大\n\n* 还是从右往左，寻找第一个比这个 2 微大的数。15 (2) 4 (3) 2，交换，变成 15 (3) 4 (2) 2\n\n这并未结束，变大的幅度可以再小一点，后三位还可以小\n\n后三位是递减的，翻转，变成`[1,5,3,2,2,4`]，它就是`[1,5,2,4,3,2]`的下一个排列\n\n```java\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return;\n        }\n\n        int length = nums.length;\n        //从倒数第2个元素开始，向前遍历\n        int index1 = length - 2;\n\n        while (index1 >= 0) {\n            //若当前元素<后面的元素(存在下一个更大的排列)\n            if (nums[index1] < nums[index1 + 1]) {\n                int index2 = length - 1;\n                //找到大于当前元素的最后一个元素，记录其下标\n                while (index2 > index1 && nums[index2] <= nums[index1]) {\n                    index2--;\n                }\n                //交换选中的两个数组元素\n                exchange(nums, index1, index2);\n                //转置后续的元素(保证后续元素升序排列，即当前排列表示的数最小)\n                reverse(nums, index1 + 1, length - 1);\n                return;\n            }\n            index1--;\n        }\n        //若未找到，则当前排列为 最大排列，转置后返回即可\n        reverse(nums, 0, length - 1);\n    }\n\n    /**\n     * 将指定数组，从指定开始位置，到指定结束位置，进行原地转置\n     */\n    private void reverse(int[] nums, int startIndex, int endIndex) {\n        while (startIndex < endIndex) {\n            exchange(nums, startIndex++, endIndex--);\n        }\n    }\n\n    /**\n     * 将指定数组的指定下标的两个元素，进行原地交换\n     */\n    private void exchange(int[] nums, int index1, int index2) {\n        int temp = nums[index1];\n        nums[index1] = nums[index2];\n        nums[index2] = temp;\n    }\n}\n```\n\n\n\n","source":"_posts/LeetCode/31下一个排列.md","raw":"---\ntitle: 31下一个排列\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/next-permutation/\n\n* 像 `[3,2,1]` 递减的，没有下一个排列，因为大的已经尽量往前排了，没法更大\n\n* 像`[1,5,2,4,3,2]` 这种，我们希望它稍微变大\n\n从低位挑一个大一点的数，换掉前面的小一点的一个数\n\n于是，从右往左，寻找第一个比右邻居小的数（把它换到后面去）\n\n* 找到 1 5 (2) 4 3 2 中间这个 2，让它和它身后的一个数交换，轻微变大\n\n* 还是从右往左，寻找第一个比这个 2 微大的数。15 (2) 4 (3) 2，交换，变成 15 (3) 4 (2) 2\n\n这并未结束，变大的幅度可以再小一点，后三位还可以小\n\n后三位是递减的，翻转，变成`[1,5,3,2,2,4`]，它就是`[1,5,2,4,3,2]`的下一个排列\n\n```java\nclass Solution {\n    public void nextPermutation(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return;\n        }\n\n        int length = nums.length;\n        //从倒数第2个元素开始，向前遍历\n        int index1 = length - 2;\n\n        while (index1 >= 0) {\n            //若当前元素<后面的元素(存在下一个更大的排列)\n            if (nums[index1] < nums[index1 + 1]) {\n                int index2 = length - 1;\n                //找到大于当前元素的最后一个元素，记录其下标\n                while (index2 > index1 && nums[index2] <= nums[index1]) {\n                    index2--;\n                }\n                //交换选中的两个数组元素\n                exchange(nums, index1, index2);\n                //转置后续的元素(保证后续元素升序排列，即当前排列表示的数最小)\n                reverse(nums, index1 + 1, length - 1);\n                return;\n            }\n            index1--;\n        }\n        //若未找到，则当前排列为 最大排列，转置后返回即可\n        reverse(nums, 0, length - 1);\n    }\n\n    /**\n     * 将指定数组，从指定开始位置，到指定结束位置，进行原地转置\n     */\n    private void reverse(int[] nums, int startIndex, int endIndex) {\n        while (startIndex < endIndex) {\n            exchange(nums, startIndex++, endIndex--);\n        }\n    }\n\n    /**\n     * 将指定数组的指定下标的两个元素，进行原地交换\n     */\n    private void exchange(int[] nums, int index1, int index2) {\n        int temp = nums[index1];\n        nums[index1] = nums[index2];\n        nums[index2] = temp;\n    }\n}\n```\n\n\n\n","slug":"LeetCode/31下一个排列","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-11T13:22:49.903Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgo007xfhji8h9ba8gr","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/next-permutation/\">https://leetcode-cn.com/problems/next-permutation/</a></p>\n<ul>\n<li><p>像 <code>[3,2,1]</code> 递减的，没有下一个排列，因为大的已经尽量往前排了，没法更大</p>\n</li>\n<li><p>像<code>[1,5,2,4,3,2]</code> 这种，我们希望它稍微变大</p>\n</li>\n</ul>\n<p>从低位挑一个大一点的数，换掉前面的小一点的一个数</p>\n<p>于是，从右往左，寻找第一个比右邻居小的数（把它换到后面去）</p>\n<ul>\n<li><p>找到 1 5 (2) 4 3 2 中间这个 2，让它和它身后的一个数交换，轻微变大</p>\n</li>\n<li><p>还是从右往左，寻找第一个比这个 2 微大的数。15 (2) 4 (3) 2，交换，变成 15 (3) 4 (2) 2</p>\n</li>\n</ul>\n<p>这并未结束，变大的幅度可以再小一点，后三位还可以小</p>\n<p>后三位是递减的，翻转，变成<code>[1,5,3,2,2,4</code>]，它就是<code>[1,5,2,4,3,2]</code>的下一个排列</p>\n<pre><code class=\"java\">class Solution &#123;\n    public void nextPermutation(int[] nums) &#123;\n        if (nums == null || nums.length &lt; 2) &#123;\n            return;\n        &#125;\n\n        int length = nums.length;\n        //从倒数第2个元素开始，向前遍历\n        int index1 = length - 2;\n\n        while (index1 &gt;= 0) &#123;\n            //若当前元素&lt;后面的元素(存在下一个更大的排列)\n            if (nums[index1] &lt; nums[index1 + 1]) &#123;\n                int index2 = length - 1;\n                //找到大于当前元素的最后一个元素，记录其下标\n                while (index2 &gt; index1 &amp;&amp; nums[index2] &lt;= nums[index1]) &#123;\n                    index2--;\n                &#125;\n                //交换选中的两个数组元素\n                exchange(nums, index1, index2);\n                //转置后续的元素(保证后续元素升序排列，即当前排列表示的数最小)\n                reverse(nums, index1 + 1, length - 1);\n                return;\n            &#125;\n            index1--;\n        &#125;\n        //若未找到，则当前排列为 最大排列，转置后返回即可\n        reverse(nums, 0, length - 1);\n    &#125;\n\n    /**\n     * 将指定数组，从指定开始位置，到指定结束位置，进行原地转置\n     */\n    private void reverse(int[] nums, int startIndex, int endIndex) &#123;\n        while (startIndex &lt; endIndex) &#123;\n            exchange(nums, startIndex++, endIndex--);\n        &#125;\n    &#125;\n\n    /**\n     * 将指定数组的指定下标的两个元素，进行原地交换\n     */\n    private void exchange(int[] nums, int index1, int index2) &#123;\n        int temp = nums[index1];\n        nums[index1] = nums[index2];\n        nums[index2] = temp;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/next-permutation/\">https://leetcode-cn.com/problems/next-permutation/</a></p>\n<ul>\n<li><p>像 <code>[3,2,1]</code> 递减的，没有下一个排列，因为大的已经尽量往前排了，没法更大</p>\n</li>\n<li><p>像<code>[1,5,2,4,3,2]</code> 这种，我们希望它稍微变大</p>\n</li>\n</ul>\n<p>从低位挑一个大一点的数，换掉前面的小一点的一个数</p>\n<p>于是，从右往左，寻找第一个比右邻居小的数（把它换到后面去）</p>\n<ul>\n<li><p>找到 1 5 (2) 4 3 2 中间这个 2，让它和它身后的一个数交换，轻微变大</p>\n</li>\n<li><p>还是从右往左，寻找第一个比这个 2 微大的数。15 (2) 4 (3) 2，交换，变成 15 (3) 4 (2) 2</p>\n</li>\n</ul>\n<p>这并未结束，变大的幅度可以再小一点，后三位还可以小</p>\n<p>后三位是递减的，翻转，变成<code>[1,5,3,2,2,4</code>]，它就是<code>[1,5,2,4,3,2]</code>的下一个排列</p>\n<pre><code class=\"java\">class Solution &#123;\n    public void nextPermutation(int[] nums) &#123;\n        if (nums == null || nums.length &lt; 2) &#123;\n            return;\n        &#125;\n\n        int length = nums.length;\n        //从倒数第2个元素开始，向前遍历\n        int index1 = length - 2;\n\n        while (index1 &gt;= 0) &#123;\n            //若当前元素&lt;后面的元素(存在下一个更大的排列)\n            if (nums[index1] &lt; nums[index1 + 1]) &#123;\n                int index2 = length - 1;\n                //找到大于当前元素的最后一个元素，记录其下标\n                while (index2 &gt; index1 &amp;&amp; nums[index2] &lt;= nums[index1]) &#123;\n                    index2--;\n                &#125;\n                //交换选中的两个数组元素\n                exchange(nums, index1, index2);\n                //转置后续的元素(保证后续元素升序排列，即当前排列表示的数最小)\n                reverse(nums, index1 + 1, length - 1);\n                return;\n            &#125;\n            index1--;\n        &#125;\n        //若未找到，则当前排列为 最大排列，转置后返回即可\n        reverse(nums, 0, length - 1);\n    &#125;\n\n    /**\n     * 将指定数组，从指定开始位置，到指定结束位置，进行原地转置\n     */\n    private void reverse(int[] nums, int startIndex, int endIndex) &#123;\n        while (startIndex &lt; endIndex) &#123;\n            exchange(nums, startIndex++, endIndex--);\n        &#125;\n    &#125;\n\n    /**\n     * 将指定数组的指定下标的两个元素，进行原地交换\n     */\n    private void exchange(int[] nums, int index1, int index2) &#123;\n        int temp = nums[index1];\n        nums[index1] = nums[index2];\n        nums[index2] = temp;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"322零钱兑换","_content":"\n题目地址：https://leetcode-cn.com/problems/coin-change/\n\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(coins.length == 0){\n            return -1;\n        }\n\n        // dp[n]的值：表示的凑成总金额为n所需的最少的硬币个数\n        int[] dp = new int[amount+1];\n        // dp最多的硬币数就是全部使用面值1的硬币进行换\n        // amount + 1 是不可能达到的换取数量，于是使用其进行填充\n        Arrays.fill(dp, amount+1);\n        dp[0] = 0;\n        for(int i = 1; i <= amount;i++){\n            for(int j = 0;j < coins.length;j++){\n                if(i - coins[j] >= 0){\n                    // dp[i]有两种实现的方式\n                    // 一种是包含当前的coins[i],那么剩余钱就是 i-coins[i],这种操作要兑换的硬币数是 dp[i-coins[j]] + 1\n                    // 另一种就是不包含，dp[i]\n                    dp[i] = Math.min(dp[i],dp[i-coins[j]] + 1);\n                }\n            }\n        }\n\n        return (dp[amount] == (amount+1) ? -1 : dp[amount]);\n    }\n}\n```\n\n","source":"_posts/LeetCode/322零钱兑换.md","raw":"---\ntitle: 322零钱兑换\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/coin-change/\n\n```java\nclass Solution {\n    public int coinChange(int[] coins, int amount) {\n        if(coins.length == 0){\n            return -1;\n        }\n\n        // dp[n]的值：表示的凑成总金额为n所需的最少的硬币个数\n        int[] dp = new int[amount+1];\n        // dp最多的硬币数就是全部使用面值1的硬币进行换\n        // amount + 1 是不可能达到的换取数量，于是使用其进行填充\n        Arrays.fill(dp, amount+1);\n        dp[0] = 0;\n        for(int i = 1; i <= amount;i++){\n            for(int j = 0;j < coins.length;j++){\n                if(i - coins[j] >= 0){\n                    // dp[i]有两种实现的方式\n                    // 一种是包含当前的coins[i],那么剩余钱就是 i-coins[i],这种操作要兑换的硬币数是 dp[i-coins[j]] + 1\n                    // 另一种就是不包含，dp[i]\n                    dp[i] = Math.min(dp[i],dp[i-coins[j]] + 1);\n                }\n            }\n        }\n\n        return (dp[amount] == (amount+1) ? -1 : dp[amount]);\n    }\n}\n```\n\n","slug":"LeetCode/322零钱兑换","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-28T16:20:36.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgo0080fhjic3zhamwo","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/coin-change/\">https://leetcode-cn.com/problems/coin-change/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int coinChange(int[] coins, int amount) &#123;\n        if(coins.length == 0)&#123;\n            return -1;\n        &#125;\n\n        // dp[n]的值：表示的凑成总金额为n所需的最少的硬币个数\n        int[] dp = new int[amount+1];\n        // dp最多的硬币数就是全部使用面值1的硬币进行换\n        // amount + 1 是不可能达到的换取数量，于是使用其进行填充\n        Arrays.fill(dp, amount+1);\n        dp[0] = 0;\n        for(int i = 1; i &lt;= amount;i++)&#123;\n            for(int j = 0;j &lt; coins.length;j++)&#123;\n                if(i - coins[j] &gt;= 0)&#123;\n                    // dp[i]有两种实现的方式\n                    // 一种是包含当前的coins[i],那么剩余钱就是 i-coins[i],这种操作要兑换的硬币数是 dp[i-coins[j]] + 1\n                    // 另一种就是不包含，dp[i]\n                    dp[i] = Math.min(dp[i],dp[i-coins[j]] + 1);\n                &#125;\n            &#125;\n        &#125;\n\n        return (dp[amount] == (amount+1) ? -1 : dp[amount]);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/coin-change/\">https://leetcode-cn.com/problems/coin-change/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int coinChange(int[] coins, int amount) &#123;\n        if(coins.length == 0)&#123;\n            return -1;\n        &#125;\n\n        // dp[n]的值：表示的凑成总金额为n所需的最少的硬币个数\n        int[] dp = new int[amount+1];\n        // dp最多的硬币数就是全部使用面值1的硬币进行换\n        // amount + 1 是不可能达到的换取数量，于是使用其进行填充\n        Arrays.fill(dp, amount+1);\n        dp[0] = 0;\n        for(int i = 1; i &lt;= amount;i++)&#123;\n            for(int j = 0;j &lt; coins.length;j++)&#123;\n                if(i - coins[j] &gt;= 0)&#123;\n                    // dp[i]有两种实现的方式\n                    // 一种是包含当前的coins[i],那么剩余钱就是 i-coins[i],这种操作要兑换的硬币数是 dp[i-coins[j]] + 1\n                    // 另一种就是不包含，dp[i]\n                    dp[i] = Math.min(dp[i],dp[i-coins[j]] + 1);\n                &#125;\n            &#125;\n        &#125;\n\n        return (dp[amount] == (amount+1) ? -1 : dp[amount]);\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"328奇偶链表","_content":"\n题目地址：https://leetcode-cn.com/problems/odd-even-linked-list/\n\n原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 `evenHead = head.next`，则 evenHead 是偶数链表的头节点\n\n维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 `odd = head，even = evenHead`。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点\n\n更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 `odd.next = even.next`，然后令 `odd = odd.next`，此时 odd 变成 even 的后一个节点\n\n更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 `even.next = odd.next`，然后令 `even = even.next`，此时 even 变成 odd 的后一个节点\n\n在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 `even.next` 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）\n\n最后令 `odd.next = evenHead`，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head\n\n```java\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        ListNode evenHead = head.next;\n        //odd:奇数,even:偶数\n        ListNode odd = head, even = evenHead;\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        //将偶数链表连接在奇数链表之后\n        odd.next = evenHead;\n        return head;\n    }\n}\n```\n\n","source":"_posts/LeetCode/328奇偶链表.md","raw":"---\ntitle: 328奇偶链表\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/odd-even-linked-list/\n\n原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 `evenHead = head.next`，则 evenHead 是偶数链表的头节点\n\n维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 `odd = head，even = evenHead`。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点\n\n更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 `odd.next = even.next`，然后令 `odd = odd.next`，此时 odd 变成 even 的后一个节点\n\n更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 `even.next = odd.next`，然后令 `even = even.next`，此时 even 变成 odd 的后一个节点\n\n在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 `even.next` 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）\n\n最后令 `odd.next = evenHead`，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head\n\n```java\nclass Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null) {\n            return head;\n        }\n        ListNode evenHead = head.next;\n        //odd:奇数,even:偶数\n        ListNode odd = head, even = evenHead;\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n        //将偶数链表连接在奇数链表之后\n        odd.next = evenHead;\n        return head;\n    }\n}\n```\n\n","slug":"LeetCode/328奇偶链表","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-28T16:20:43.547Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgp0081fhjiaz5a4drr","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/odd-even-linked-list/\">https://leetcode-cn.com/problems/odd-even-linked-list/</a></p>\n<p>原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 <code>evenHead = head.next</code>，则 evenHead 是偶数链表的头节点</p>\n<p>维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 <code>odd = head，even = evenHead</code>。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点</p>\n<p>更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 <code>odd.next = even.next</code>，然后令 <code>odd = odd.next</code>，此时 odd 变成 even 的后一个节点</p>\n<p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 <code>even.next = odd.next</code>，然后令 <code>even = even.next</code>，此时 even 变成 odd 的后一个节点</p>\n<p>在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 <code>even.next</code> 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）</p>\n<p>最后令 <code>odd.next = evenHead</code>，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode oddEvenList(ListNode head) &#123;\n        if (head == null) &#123;\n            return head;\n        &#125;\n        ListNode evenHead = head.next;\n        //odd:奇数,even:偶数\n        ListNode odd = head, even = evenHead;\n        while (even != null &amp;&amp; even.next != null) &#123;\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        &#125;\n        //将偶数链表连接在奇数链表之后\n        odd.next = evenHead;\n        return head;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/odd-even-linked-list/\">https://leetcode-cn.com/problems/odd-even-linked-list/</a></p>\n<p>原始链表的头节点 head 也是奇数链表的头节点以及结果链表的头节点，head 的后一个节点是偶数链表的头节点。令 <code>evenHead = head.next</code>，则 evenHead 是偶数链表的头节点</p>\n<p>维护两个指针 odd 和 even 分别指向奇数节点和偶数节点，初始时 <code>odd = head，even = evenHead</code>。通过迭代的方式将奇数节点和偶数节点分离成两个链表，每一步首先更新奇数节点，然后更新偶数节点</p>\n<p>更新奇数节点时，奇数节点的后一个节点需要指向偶数节点的后一个节点，因此令 <code>odd.next = even.next</code>，然后令 <code>odd = odd.next</code>，此时 odd 变成 even 的后一个节点</p>\n<p>更新偶数节点时，偶数节点的后一个节点需要指向奇数节点的后一个节点，因此令 <code>even.next = odd.next</code>，然后令 <code>even = even.next</code>，此时 even 变成 odd 的后一个节点</p>\n<p>在上述操作之后，即完成了对一个奇数节点和一个偶数节点的分离。重复上述操作，直到全部节点分离完毕。全部节点分离完毕的条件是 even 为空节点或者 <code>even.next</code> 为空节点，此时 odd 指向最后一个奇数节点（即奇数链表的最后一个节点）</p>\n<p>最后令 <code>odd.next = evenHead</code>，将偶数链表连接在奇数链表之后，即完成了奇数链表和偶数链表的合并，结果链表的头节点仍然是 head</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode oddEvenList(ListNode head) &#123;\n        if (head == null) &#123;\n            return head;\n        &#125;\n        ListNode evenHead = head.next;\n        //odd:奇数,even:偶数\n        ListNode odd = head, even = evenHead;\n        while (even != null &amp;&amp; even.next != null) &#123;\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        &#125;\n        //将偶数链表连接在奇数链表之后\n        odd.next = evenHead;\n        return head;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"33搜索旋转排序数组","_content":"\n题目地址：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\n\n举个例子：\n\n1 2 3 4 5 6 7 可以大致分为两类\n\n* 第一类 2 3 4 5 6 7 1 这种，也就是 `nums[start] <= nums[mid]`。此例子中就是 2 <= 5。\n\n这种情况下，前半部分有序。因此如果 `nums[start] <=target<nums[mid]`，则在前半部分找，否则去后半部分找。\n\n* 第二类 6 7 1 2 3 4 5 这种，也就是 `nums[start] > nums[mid]`。此例子中就是 6 > 2。\n\n这种情况下，后半部分有序。因此如果 `nums[mid] <target<=nums[end]`，则在后半部分找，否则去前半部分找。\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int start = 0;\n        int end = nums.length - 1;\n        int mid;\n        while (start <= end) {\n            mid = start + (end - start) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            //前半部分有序,注意此处用小于等于\n            if (nums[start] <= nums[mid]) {\n                //target在前半部分\n                if (target >= nums[start] && target < nums[mid]) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            } else {\n                if (target <= nums[end] && target > nums[mid]) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n\n        }\n        return -1;\n\n    }\n}\n```\n\n","source":"_posts/LeetCode/33搜索旋转排序数组.md","raw":"---\ntitle: 33搜索旋转排序数组\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\n\n举个例子：\n\n1 2 3 4 5 6 7 可以大致分为两类\n\n* 第一类 2 3 4 5 6 7 1 这种，也就是 `nums[start] <= nums[mid]`。此例子中就是 2 <= 5。\n\n这种情况下，前半部分有序。因此如果 `nums[start] <=target<nums[mid]`，则在前半部分找，否则去后半部分找。\n\n* 第二类 6 7 1 2 3 4 5 这种，也就是 `nums[start] > nums[mid]`。此例子中就是 6 > 2。\n\n这种情况下，后半部分有序。因此如果 `nums[mid] <target<=nums[end]`，则在后半部分找，否则去前半部分找。\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int start = 0;\n        int end = nums.length - 1;\n        int mid;\n        while (start <= end) {\n            mid = start + (end - start) / 2;\n            if (nums[mid] == target) {\n                return mid;\n            }\n            //前半部分有序,注意此处用小于等于\n            if (nums[start] <= nums[mid]) {\n                //target在前半部分\n                if (target >= nums[start] && target < nums[mid]) {\n                    end = mid - 1;\n                } else {\n                    start = mid + 1;\n                }\n            } else {\n                if (target <= nums[end] && target > nums[mid]) {\n                    start = mid + 1;\n                } else {\n                    end = mid - 1;\n                }\n            }\n\n        }\n        return -1;\n\n    }\n}\n```\n\n","slug":"LeetCode/33搜索旋转排序数组","published":1,"date":"2021-12-01T01:56:13.188Z","updated":"2022-01-12T00:53:48.274Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgp0084fhjibsgq5xkj","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p>\n<p>举个例子：</p>\n<p>1 2 3 4 5 6 7 可以大致分为两类</p>\n<ul>\n<li>第一类 2 3 4 5 6 7 1 这种，也就是 <code>nums[start] &lt;= nums[mid]</code>。此例子中就是 2 &lt;&#x3D; 5。</li>\n</ul>\n<p>这种情况下，前半部分有序。因此如果 <code>nums[start] &lt;=target&lt;nums[mid]</code>，则在前半部分找，否则去后半部分找。</p>\n<ul>\n<li>第二类 6 7 1 2 3 4 5 这种，也就是 <code>nums[start] &gt; nums[mid]</code>。此例子中就是 6 &gt; 2。</li>\n</ul>\n<p>这种情况下，后半部分有序。因此如果 <code>nums[mid] &lt;target&lt;=nums[end]</code>，则在后半部分找，否则去前半部分找。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return -1;\n        &#125;\n        int start = 0;\n        int end = nums.length - 1;\n        int mid;\n        while (start &lt;= end) &#123;\n            mid = start + (end - start) / 2;\n            if (nums[mid] == target) &#123;\n                return mid;\n            &#125;\n            //前半部分有序,注意此处用小于等于\n            if (nums[start] &lt;= nums[mid]) &#123;\n                //target在前半部分\n                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;\n                    end = mid - 1;\n                &#125; else &#123;\n                    start = mid + 1;\n                &#125;\n            &#125; else &#123;\n                if (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;\n                    start = mid + 1;\n                &#125; else &#123;\n                    end = mid - 1;\n                &#125;\n            &#125;\n\n        &#125;\n        return -1;\n\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">https://leetcode-cn.com/problems/search-in-rotated-sorted-array/</a></p>\n<p>举个例子：</p>\n<p>1 2 3 4 5 6 7 可以大致分为两类</p>\n<ul>\n<li>第一类 2 3 4 5 6 7 1 这种，也就是 <code>nums[start] &lt;= nums[mid]</code>。此例子中就是 2 &lt;&#x3D; 5。</li>\n</ul>\n<p>这种情况下，前半部分有序。因此如果 <code>nums[start] &lt;=target&lt;nums[mid]</code>，则在前半部分找，否则去后半部分找。</p>\n<ul>\n<li>第二类 6 7 1 2 3 4 5 这种，也就是 <code>nums[start] &gt; nums[mid]</code>。此例子中就是 6 &gt; 2。</li>\n</ul>\n<p>这种情况下，后半部分有序。因此如果 <code>nums[mid] &lt;target&lt;=nums[end]</code>，则在后半部分找，否则去前半部分找。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return -1;\n        &#125;\n        int start = 0;\n        int end = nums.length - 1;\n        int mid;\n        while (start &lt;= end) &#123;\n            mid = start + (end - start) / 2;\n            if (nums[mid] == target) &#123;\n                return mid;\n            &#125;\n            //前半部分有序,注意此处用小于等于\n            if (nums[start] &lt;= nums[mid]) &#123;\n                //target在前半部分\n                if (target &gt;= nums[start] &amp;&amp; target &lt; nums[mid]) &#123;\n                    end = mid - 1;\n                &#125; else &#123;\n                    start = mid + 1;\n                &#125;\n            &#125; else &#123;\n                if (target &lt;= nums[end] &amp;&amp; target &gt; nums[mid]) &#123;\n                    start = mid + 1;\n                &#125; else &#123;\n                    end = mid - 1;\n                &#125;\n            &#125;\n\n        &#125;\n        return -1;\n\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"344反转字符串","_content":"\n题目地址：https://leetcode-cn.com/problems/reverse-string\n\n# 双指针\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int left = 0;\n        int right = s.length - 1;\n\n        while (left <= right) {\n            if (s[left] != s[right]) {\n                char tmp = s[left];\n                s[left] = s[right];\n                s[right] = tmp;\n            }\n            left++;\n            right--;\n        }\n    }\n}\n```\n\n","source":"_posts/LeetCode/344反转字符串.md","raw":"---\ntitle: 344反转字符串\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/reverse-string\n\n# 双指针\n\n```java\nclass Solution {\n    public void reverseString(char[] s) {\n        int left = 0;\n        int right = s.length - 1;\n\n        while (left <= right) {\n            if (s[left] != s[right]) {\n                char tmp = s[left];\n                s[left] = s[right];\n                s[right] = tmp;\n            }\n            left++;\n            right--;\n        }\n    }\n}\n```\n\n","slug":"LeetCode/344反转字符串","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-28T16:20:48.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgq0085fhjieazrcu1o","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-string\">https://leetcode-cn.com/problems/reverse-string</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><pre><code class=\"java\">class Solution &#123;\n    public void reverseString(char[] s) &#123;\n        int left = 0;\n        int right = s.length - 1;\n\n        while (left &lt;= right) &#123;\n            if (s[left] != s[right]) &#123;\n                char tmp = s[left];\n                s[left] = s[right];\n                s[right] = tmp;\n            &#125;\n            left++;\n            right--;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-string\">https://leetcode-cn.com/problems/reverse-string</a></p>\n<h1 id=\"双指针\"><a href=\"#双指针\" class=\"headerlink\" title=\"双指针\"></a>双指针</h1><pre><code class=\"java\">class Solution &#123;\n    public void reverseString(char[] s) &#123;\n        int left = 0;\n        int right = s.length - 1;\n\n        while (left &lt;= right) &#123;\n            if (s[left] != s[right]) &#123;\n                char tmp = s[left];\n                s[left] = s[right];\n                s[right] = tmp;\n            &#125;\n            left++;\n            right--;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"3无重复字符的最长子串","_content":"\n题目地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复\n\n我们定义不重复子串的开始位置为 start，结束位置为 end\n\n随着 end 不断遍历向后，会遇到与` [start, end] `区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时` [start, end]` 区间内不存在重复字符\n\n无论是否更新 start，都会更新其 map 数据结构和结果 result。\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        //key值为字符，value值为字符位置+1，加1表示从字符位置后一个才开始不重复\n        Map<Character, Integer> map = new HashMap<>();\n        int result = 0;\n        for (int start=0,end=0;end<s.length();end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                //出现重复，更新start\n                start = Math.max(start, map.get(c));\n            }\n            result = Math.max(result, end - start + 1);\n            map.put(s.charAt(end), end + 1);\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","source":"_posts/LeetCode/3无重复字符的最长子串.md","raw":"---\ntitle: 3无重复字符的最长子串\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\n\n定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复\n\n我们定义不重复子串的开始位置为 start，结束位置为 end\n\n随着 end 不断遍历向后，会遇到与` [start, end] `区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时` [start, end]` 区间内不存在重复字符\n\n无论是否更新 start，都会更新其 map 数据结构和结果 result。\n\n```java\nclass Solution {\n    public int lengthOfLongestSubstring(String s) {\n        if (s == null || s.length() == 0) {\n            return 0;\n        }\n        //key值为字符，value值为字符位置+1，加1表示从字符位置后一个才开始不重复\n        Map<Character, Integer> map = new HashMap<>();\n        int result = 0;\n        for (int start=0,end=0;end<s.length();end++) {\n            char c = s.charAt(end);\n            if (map.containsKey(c)) {\n                //出现重复，更新start\n                start = Math.max(start, map.get(c));\n            }\n            result = Math.max(result, end - start + 1);\n            map.put(s.charAt(end), end + 1);\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)\n\n空间复杂度：O(n)","slug":"LeetCode/3无重复字符的最长子串","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2021-12-13T17:02:35.464Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgq0087fhji11kjaqad","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>\n<p>定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复</p>\n<p>我们定义不重复子串的开始位置为 start，结束位置为 end</p>\n<p>随着 end 不断遍历向后，会遇到与<code>[start, end]</code>区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时<code> [start, end]</code> 区间内不存在重复字符</p>\n<p>无论是否更新 start，都会更新其 map 数据结构和结果 result。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int lengthOfLongestSubstring(String s) &#123;\n        if (s == null || s.length() == 0) &#123;\n            return 0;\n        &#125;\n        //key值为字符，value值为字符位置+1，加1表示从字符位置后一个才开始不重复\n        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n        int result = 0;\n        for (int start=0,end=0;end&lt;s.length();end++) &#123;\n            char c = s.charAt(end);\n            if (map.containsKey(c)) &#123;\n                //出现重复，更新start\n                start = Math.max(start, map.get(c));\n            &#125;\n            result = Math.max(result, end - start + 1);\n            map.put(s.charAt(end), end + 1);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/</a></p>\n<p>定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复</p>\n<p>我们定义不重复子串的开始位置为 start，结束位置为 end</p>\n<p>随着 end 不断遍历向后，会遇到与<code>[start, end]</code>区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时<code> [start, end]</code> 区间内不存在重复字符</p>\n<p>无论是否更新 start，都会更新其 map 数据结构和结果 result。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int lengthOfLongestSubstring(String s) &#123;\n        if (s == null || s.length() == 0) &#123;\n            return 0;\n        &#125;\n        //key值为字符，value值为字符位置+1，加1表示从字符位置后一个才开始不重复\n        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();\n        int result = 0;\n        for (int start=0,end=0;end&lt;s.length();end++) &#123;\n            char c = s.charAt(end);\n            if (map.containsKey(c)) &#123;\n                //出现重复，更新start\n                start = Math.max(start, map.get(c));\n            &#125;\n            result = Math.max(result, end - start + 1);\n            map.put(s.charAt(end), end + 1);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)</p>\n<p>空间复杂度：O(n)</p>\n"},{"title":"415字符串相加","_content":"\n题目地址：https://leetcode-cn.com/problems/add-strings/\n\n```java\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        StringBuilder result = new StringBuilder();\n        int l1 = num1.length() - 1, l2 = num2.length() - 1;\n        int carry = 0;\n        while (l1>=0 || l2>=0) {\n            int n1 = l1>=0?num1.charAt(l1) - '0':0;\n            int n2 = l2>=0?num2.charAt(l2) - '0':0;\n            int sum = n1 + n2 + carry;\n            result.append(sum%10);\n            carry = sum / 10;\n            l1--;\n            l2--;\n        }\n        if (carry==1) {\n            result.append(carry);\n        }\n        return result.reverse().toString();\n    }\n}\n```\n\n","source":"_posts/LeetCode/415字符串相加.md","raw":"---\ntitle: 415字符串相加\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/add-strings/\n\n```java\nclass Solution {\n    public String addStrings(String num1, String num2) {\n        StringBuilder result = new StringBuilder();\n        int l1 = num1.length() - 1, l2 = num2.length() - 1;\n        int carry = 0;\n        while (l1>=0 || l2>=0) {\n            int n1 = l1>=0?num1.charAt(l1) - '0':0;\n            int n2 = l2>=0?num2.charAt(l2) - '0':0;\n            int sum = n1 + n2 + carry;\n            result.append(sum%10);\n            carry = sum / 10;\n            l1--;\n            l2--;\n        }\n        if (carry==1) {\n            result.append(carry);\n        }\n        return result.reverse().toString();\n    }\n}\n```\n\n","slug":"LeetCode/415字符串相加","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-28T16:20:54.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgr0089fhji4za8ev67","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/add-strings/\">https://leetcode-cn.com/problems/add-strings/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public String addStrings(String num1, String num2) &#123;\n        StringBuilder result = new StringBuilder();\n        int l1 = num1.length() - 1, l2 = num2.length() - 1;\n        int carry = 0;\n        while (l1&gt;=0 || l2&gt;=0) &#123;\n            int n1 = l1&gt;=0?num1.charAt(l1) - &#39;0&#39;:0;\n            int n2 = l2&gt;=0?num2.charAt(l2) - &#39;0&#39;:0;\n            int sum = n1 + n2 + carry;\n            result.append(sum%10);\n            carry = sum / 10;\n            l1--;\n            l2--;\n        &#125;\n        if (carry==1) &#123;\n            result.append(carry);\n        &#125;\n        return result.reverse().toString();\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/add-strings/\">https://leetcode-cn.com/problems/add-strings/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public String addStrings(String num1, String num2) &#123;\n        StringBuilder result = new StringBuilder();\n        int l1 = num1.length() - 1, l2 = num2.length() - 1;\n        int carry = 0;\n        while (l1&gt;=0 || l2&gt;=0) &#123;\n            int n1 = l1&gt;=0?num1.charAt(l1) - &#39;0&#39;:0;\n            int n2 = l2&gt;=0?num2.charAt(l2) - &#39;0&#39;:0;\n            int sum = n1 + n2 + carry;\n            result.append(sum%10);\n            carry = sum / 10;\n            l1--;\n            l2--;\n        &#125;\n        if (carry==1) &#123;\n            result.append(carry);\n        &#125;\n        return result.reverse().toString();\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"45跳跃游戏II","_content":"\n题目地址：https://leetcode-cn.com/problems/jump-game-ii/submissions/\n\n```java\nclass Solution {\n    public int jump(int[] nums) {\n        int length = nums.length;\n        int end = 0;\n        int maxPosition = 0; \n        int steps = 0;\n        for (int i = 0; i < length - 1; i++) {\n            maxPosition = Math.max(maxPosition, i + nums[i]); \n            if (i == end) {\n                end = maxPosition;\n                steps++;\n            }\n        }\n        return steps;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，其中 n 是数组长度。\n- 空间复杂度：O(1)。","source":"_posts/LeetCode/45跳跃游戏II.md","raw":"---\ntitle: 45跳跃游戏II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/jump-game-ii/submissions/\n\n```java\nclass Solution {\n    public int jump(int[] nums) {\n        int length = nums.length;\n        int end = 0;\n        int maxPosition = 0; \n        int steps = 0;\n        for (int i = 0; i < length - 1; i++) {\n            maxPosition = Math.max(maxPosition, i + nums[i]); \n            if (i == end) {\n                end = maxPosition;\n                steps++;\n            }\n        }\n        return steps;\n    }\n}\n```\n\n**复杂度分析**\n\n- 时间复杂度：O(n)，其中 n 是数组长度。\n- 空间复杂度：O(1)。","slug":"LeetCode/45跳跃游戏II","published":1,"date":"2021-11-25T15:03:00.083Z","updated":"2022-01-12T00:54:30.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgr008afhjifd1h25y8","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/jump-game-ii/submissions/\">https://leetcode-cn.com/problems/jump-game-ii/submissions/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int jump(int[] nums) &#123;\n        int length = nums.length;\n        int end = 0;\n        int maxPosition = 0; \n        int steps = 0;\n        for (int i = 0; i &lt; length - 1; i++) &#123;\n            maxPosition = Math.max(maxPosition, i + nums[i]); \n            if (i == end) &#123;\n                end = maxPosition;\n                steps++;\n            &#125;\n        &#125;\n        return steps;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 是数组长度。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/jump-game-ii/submissions/\">https://leetcode-cn.com/problems/jump-game-ii/submissions/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int jump(int[] nums) &#123;\n        int length = nums.length;\n        int end = 0;\n        int maxPosition = 0; \n        int steps = 0;\n        for (int i = 0; i &lt; length - 1; i++) &#123;\n            maxPosition = Math.max(maxPosition, i + nums[i]); \n            if (i == end) &#123;\n                end = maxPosition;\n                steps++;\n            &#125;\n        &#125;\n        return steps;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li>时间复杂度：O(n)，其中 n 是数组长度。</li>\n<li>空间复杂度：O(1)。</li>\n</ul>\n"},{"title":"46全排列","_content":"\n题目地址：https://leetcode-cn.com/problems/permutations/\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201207132255.png\" style=\"zoom:30%;\" />\n\n```java\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        //表示该位置的数是否已经加入path\n        //如果某个位置的数加入path，used[该位置]将被设置为true，回退以后，used[该位置]将被设置为false\n        boolean[] used = new boolean[nums.length];\n        List<Integer> path = new ArrayList<>();\n        dfs(nums, nums.length, 0, used, path, result);\n        return result;\n    }\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, List<Integer> path, List<List<Integer>> result) {\n        //终止条件，到达最后一层\n        if (len == depth) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = 0; i < len; i++) {\n            if (used[i]) {\n                continue;\n            }\n            //加入\n            path.add(nums[i]);\n            used[i] = true;\n            dfs(nums, len, depth + 1, used, path, result);\n            //回退\n            path.remove(path.size()-1);\n            used[i] = false;\n        }\n    }\n}\n```\n\n时间复杂度：`O(n∗n!)`，其中 n 为序列的长度。\n\n空间复杂度：O(n)，其中 n 为序列的长度。","source":"_posts/LeetCode/46全排列.md","raw":"---\ntitle: 46全排列\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/permutations/\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201207132255.png\" style=\"zoom:30%;\" />\n\n```java\nclass Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums == null || nums.length == 0) {\n            return result;\n        }\n        //表示该位置的数是否已经加入path\n        //如果某个位置的数加入path，used[该位置]将被设置为true，回退以后，used[该位置]将被设置为false\n        boolean[] used = new boolean[nums.length];\n        List<Integer> path = new ArrayList<>();\n        dfs(nums, nums.length, 0, used, path, result);\n        return result;\n    }\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, List<Integer> path, List<List<Integer>> result) {\n        //终止条件，到达最后一层\n        if (len == depth) {\n            result.add(new ArrayList<>(path));\n            return;\n        }\n        for (int i = 0; i < len; i++) {\n            if (used[i]) {\n                continue;\n            }\n            //加入\n            path.add(nums[i]);\n            used[i] = true;\n            dfs(nums, len, depth + 1, used, path, result);\n            //回退\n            path.remove(path.size()-1);\n            used[i] = false;\n        }\n    }\n}\n```\n\n时间复杂度：`O(n∗n!)`，其中 n 为序列的长度。\n\n空间复杂度：O(n)，其中 n 为序列的长度。","slug":"LeetCode/46全排列","published":1,"date":"2021-09-01T05:22:18.210Z","updated":"2022-01-28T16:20:58.631Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgs008dfhji0rp470qq","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/permutations/\">https://leetcode-cn.com/problems/permutations/</a></p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201207132255.png\" style=\"zoom:30%;\" />\n\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length == 0) &#123;\n            return result;\n        &#125;\n        //表示该位置的数是否已经加入path\n        //如果某个位置的数加入path，used[该位置]将被设置为true，回退以后，used[该位置]将被设置为false\n        boolean[] used = new boolean[nums.length];\n        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();\n        dfs(nums, nums.length, 0, used, path, result);\n        return result;\n    &#125;\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result) &#123;\n        //终止条件，到达最后一层\n        if (len == depth) &#123;\n            result.add(new ArrayList&lt;&gt;(path));\n            return;\n        &#125;\n        for (int i = 0; i &lt; len; i++) &#123;\n            if (used[i]) &#123;\n                continue;\n            &#125;\n            //加入\n            path.add(nums[i]);\n            used[i] = true;\n            dfs(nums, len, depth + 1, used, path, result);\n            //回退\n            path.remove(path.size()-1);\n            used[i] = false;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(n∗n!)</code>，其中 n 为序列的长度。</p>\n<p>空间复杂度：O(n)，其中 n 为序列的长度。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/permutations/\">https://leetcode-cn.com/problems/permutations/</a></p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201207132255.png\" style=\"zoom:30%;\" />\n\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (nums == null || nums.length == 0) &#123;\n            return result;\n        &#125;\n        //表示该位置的数是否已经加入path\n        //如果某个位置的数加入path，used[该位置]将被设置为true，回退以后，used[该位置]将被设置为false\n        boolean[] used = new boolean[nums.length];\n        List&lt;Integer&gt; path = new ArrayList&lt;&gt;();\n        dfs(nums, nums.length, 0, used, path, result);\n        return result;\n    &#125;\n\n    private void dfs(int[] nums, int len, int depth, boolean[] used, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result) &#123;\n        //终止条件，到达最后一层\n        if (len == depth) &#123;\n            result.add(new ArrayList&lt;&gt;(path));\n            return;\n        &#125;\n        for (int i = 0; i &lt; len; i++) &#123;\n            if (used[i]) &#123;\n                continue;\n            &#125;\n            //加入\n            path.add(nums[i]);\n            used[i] = true;\n            dfs(nums, len, depth + 1, used, path, result);\n            //回退\n            path.remove(path.size()-1);\n            used[i] = false;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(n∗n!)</code>，其中 n 为序列的长度。</p>\n<p>空间复杂度：O(n)，其中 n 为序列的长度。</p>\n"},{"title":"470用Rand7()实现Rand10()","_content":"\n题目地址：https://leetcode-cn.com/problems/implement-rand10-using-rand7/\n\n(rand(7)-1)*7 + rand(7) 可以等概率生成[1,49]的数\n\n```java\nclass Solution extends SolBase {\n    public int rand10() {\n        int num = (rand7() - 1) * 7 + rand7();\n        // 只要它还大于40，就不断生成\n        while (num > 40) {\n            num = (rand7() - 1) * 7 + rand7();\n        }\n        // 返回结果，+1是为了解决 40%10为0的情况\n        return 1 + num % 10;\n    }\n}\n```\n\n","source":"_posts/LeetCode/470用Rand7()实现Rand10().md","raw":"---\ntitle: 470用Rand7()实现Rand10()\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/implement-rand10-using-rand7/\n\n(rand(7)-1)*7 + rand(7) 可以等概率生成[1,49]的数\n\n```java\nclass Solution extends SolBase {\n    public int rand10() {\n        int num = (rand7() - 1) * 7 + rand7();\n        // 只要它还大于40，就不断生成\n        while (num > 40) {\n            num = (rand7() - 1) * 7 + rand7();\n        }\n        // 返回结果，+1是为了解决 40%10为0的情况\n        return 1 + num % 10;\n    }\n}\n```\n\n","slug":"LeetCode/470用Rand7()实现Rand10()","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:05.122Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgt008ffhjih85gbol0","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/\">https://leetcode-cn.com/problems/implement-rand10-using-rand7/</a></p>\n<p>(rand(7)-1)*7 + rand(7) 可以等概率生成[1,49]的数</p>\n<pre><code class=\"java\">class Solution extends SolBase &#123;\n    public int rand10() &#123;\n        int num = (rand7() - 1) * 7 + rand7();\n        // 只要它还大于40，就不断生成\n        while (num &gt; 40) &#123;\n            num = (rand7() - 1) * 7 + rand7();\n        &#125;\n        // 返回结果，+1是为了解决 40%10为0的情况\n        return 1 + num % 10;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/implement-rand10-using-rand7/\">https://leetcode-cn.com/problems/implement-rand10-using-rand7/</a></p>\n<p>(rand(7)-1)*7 + rand(7) 可以等概率生成[1,49]的数</p>\n<pre><code class=\"java\">class Solution extends SolBase &#123;\n    public int rand10() &#123;\n        int num = (rand7() - 1) * 7 + rand7();\n        // 只要它还大于40，就不断生成\n        while (num &gt; 40) &#123;\n            num = (rand7() - 1) * 7 + rand7();\n        &#125;\n        // 返回结果，+1是为了解决 40%10为0的情况\n        return 1 + num % 10;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"509斐波那契数","_content":"\n题目地址：https://leetcode-cn.com/problems/fibonacci-number/\n\n# 递归\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n```\n\n## 优化\n\n斐波那契数列递归的时候会造成大量的重复计算，比如就计算fib(6)为例来看下\n\n<img src=\"https://img-blog.csdnimg.cn/df38f5d613ea43d2aa85191db304cf3d.png\" style=\"zoom:25%;\" />\n\n我们看到上面相同颜色的都是重复计算，当n越大，重复的越多，所以我们可以使用一个map把计算过的值存起来，每次计算的时候先看map中有没有，如果有就表示计算过，直接从map中取，如果没有就先计算，计算完之后再把结果存到map中\n\n```java\nclass Solution {\n    public int fib(int n) {\n        return fib(n, new HashMap());\n    }\n\n    private int fib(int n, Map<Integer, Integer> map) {\n        if (n < 2) {\n            return n;\n        }\n        if (map.containsKey(n)) {\n            return map.get(n);\n        }\n        int first = fib(n - 1, map);\n        int second = fib(n - 2, map);\n        int res = (first + second);\n        map.put(n, res);\n        return res;\n    }\n}\n```\n\n# 非递归\n\n```java\nclass Solution {\n    public int fib(int n) {\n        int first = 0;\n        int second = 1;\n        while (n-- > 0) {\n            int temp = first + second;\n            first = second;\n            second = temp;\n        }\n        return first;\n    }\n}\n```\n\n","source":"_posts/LeetCode/509斐波那契数.md","raw":"---\ntitle: 509斐波那契数\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/fibonacci-number/\n\n# 递归\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if (n < 2) {\n            return n;\n        }\n        return fib(n - 1) + fib(n - 2);\n    }\n}\n```\n\n## 优化\n\n斐波那契数列递归的时候会造成大量的重复计算，比如就计算fib(6)为例来看下\n\n<img src=\"https://img-blog.csdnimg.cn/df38f5d613ea43d2aa85191db304cf3d.png\" style=\"zoom:25%;\" />\n\n我们看到上面相同颜色的都是重复计算，当n越大，重复的越多，所以我们可以使用一个map把计算过的值存起来，每次计算的时候先看map中有没有，如果有就表示计算过，直接从map中取，如果没有就先计算，计算完之后再把结果存到map中\n\n```java\nclass Solution {\n    public int fib(int n) {\n        return fib(n, new HashMap());\n    }\n\n    private int fib(int n, Map<Integer, Integer> map) {\n        if (n < 2) {\n            return n;\n        }\n        if (map.containsKey(n)) {\n            return map.get(n);\n        }\n        int first = fib(n - 1, map);\n        int second = fib(n - 2, map);\n        int res = (first + second);\n        map.put(n, res);\n        return res;\n    }\n}\n```\n\n# 非递归\n\n```java\nclass Solution {\n    public int fib(int n) {\n        int first = 0;\n        int second = 1;\n        while (n-- > 0) {\n            int temp = first + second;\n            first = second;\n            second = temp;\n        }\n        return first;\n    }\n}\n```\n\n","slug":"LeetCode/509斐波那契数","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:10.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgu008ifhjiea9eh8v0","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/fibonacci-number/\">https://leetcode-cn.com/problems/fibonacci-number/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public int fib(int n) &#123;\n        if (n &lt; 2) &#123;\n            return n;\n        &#125;\n        return fib(n - 1) + fib(n - 2);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>斐波那契数列递归的时候会造成大量的重复计算，比如就计算fib(6)为例来看下</p>\n<img src=\"https://img-blog.csdnimg.cn/df38f5d613ea43d2aa85191db304cf3d.png\" style=\"zoom:25%;\" />\n\n<p>我们看到上面相同颜色的都是重复计算，当n越大，重复的越多，所以我们可以使用一个map把计算过的值存起来，每次计算的时候先看map中有没有，如果有就表示计算过，直接从map中取，如果没有就先计算，计算完之后再把结果存到map中</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int fib(int n) &#123;\n        return fib(n, new HashMap());\n    &#125;\n\n    private int fib(int n, Map&lt;Integer, Integer&gt; map) &#123;\n        if (n &lt; 2) &#123;\n            return n;\n        &#125;\n        if (map.containsKey(n)) &#123;\n            return map.get(n);\n        &#125;\n        int first = fib(n - 1, map);\n        int second = fib(n - 2, map);\n        int res = (first + second);\n        map.put(n, res);\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h1><pre><code class=\"java\">class Solution &#123;\n    public int fib(int n) &#123;\n        int first = 0;\n        int second = 1;\n        while (n-- &gt; 0) &#123;\n            int temp = first + second;\n            first = second;\n            second = temp;\n        &#125;\n        return first;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/fibonacci-number/\">https://leetcode-cn.com/problems/fibonacci-number/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public int fib(int n) &#123;\n        if (n &lt; 2) &#123;\n            return n;\n        &#125;\n        return fib(n - 1) + fib(n - 2);\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h2><p>斐波那契数列递归的时候会造成大量的重复计算，比如就计算fib(6)为例来看下</p>\n<img src=\"https://img-blog.csdnimg.cn/df38f5d613ea43d2aa85191db304cf3d.png\" style=\"zoom:25%;\" />\n\n<p>我们看到上面相同颜色的都是重复计算，当n越大，重复的越多，所以我们可以使用一个map把计算过的值存起来，每次计算的时候先看map中有没有，如果有就表示计算过，直接从map中取，如果没有就先计算，计算完之后再把结果存到map中</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int fib(int n) &#123;\n        return fib(n, new HashMap());\n    &#125;\n\n    private int fib(int n, Map&lt;Integer, Integer&gt; map) &#123;\n        if (n &lt; 2) &#123;\n            return n;\n        &#125;\n        if (map.containsKey(n)) &#123;\n            return map.get(n);\n        &#125;\n        int first = fib(n - 1, map);\n        int second = fib(n - 2, map);\n        int res = (first + second);\n        map.put(n, res);\n        return res;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"非递归\"><a href=\"#非递归\" class=\"headerlink\" title=\"非递归\"></a>非递归</h1><pre><code class=\"java\">class Solution &#123;\n    public int fib(int n) &#123;\n        int first = 0;\n        int second = 1;\n        while (n-- &gt; 0) &#123;\n            int temp = first + second;\n            first = second;\n            second = temp;\n        &#125;\n        return first;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"50第一个只出现一次的字符","_content":"\n题目地址：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\n\n```java\nclass Solution {\n    public char firstUniqChar(String s) {\n        HashMap<Character, Boolean> map = new HashMap<>();\n        char[] chars = s.toCharArray();\n        for(char c : chars) {\n            map.put(c, !map.containsKey(c));\n        }\n        for(char c : chars) {\n            if(map.get(c)) {\n            \treturn c;\n            }\n        }\n        return ' ';\n    }\n}\n```\n\n","source":"_posts/LeetCode/50第一个只出现一次的字符.md","raw":"---\ntitle: 50第一个只出现一次的字符\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\n\n```java\nclass Solution {\n    public char firstUniqChar(String s) {\n        HashMap<Character, Boolean> map = new HashMap<>();\n        char[] chars = s.toCharArray();\n        for(char c : chars) {\n            map.put(c, !map.containsKey(c));\n        }\n        for(char c : chars) {\n            if(map.get(c)) {\n            \treturn c;\n            }\n        }\n        return ' ';\n    }\n}\n```\n\n","slug":"LeetCode/50第一个只出现一次的字符","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:15.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgv008kfhjifpal1vtx","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public char firstUniqChar(String s) &#123;\n        HashMap&lt;Character, Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for(char c : chars) &#123;\n            map.put(c, !map.containsKey(c));\n        &#125;\n        for(char c : chars) &#123;\n            if(map.get(c)) &#123;\n                return c;\n            &#125;\n        &#125;\n        return &#39; &#39;;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/\">https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public char firstUniqChar(String s) &#123;\n        HashMap&lt;Character, Boolean&gt; map = new HashMap&lt;&gt;();\n        char[] chars = s.toCharArray();\n        for(char c : chars) &#123;\n            map.put(c, !map.containsKey(c));\n        &#125;\n        for(char c : chars) &#123;\n            if(map.get(c)) &#123;\n                return c;\n            &#125;\n        &#125;\n        return &#39; &#39;;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"53最大子序和","_content":"\n题目地址：https://leetcode-cn.com/problems/maximum-subarray/\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int temp = nums[0], result = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            temp = Math.max(temp + nums[i], nums[i]);\n            result = Math.max(result, temp);\n        }\n        return result;\n    }\n}\n```","source":"_posts/LeetCode/53最大子序和.md","raw":"---\ntitle: 53最大子序和\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/maximum-subarray/\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int temp = nums[0], result = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            temp = Math.max(temp + nums[i], nums[i]);\n            result = Math.max(result, temp);\n        }\n        return result;\n    }\n}\n```","slug":"LeetCode/53最大子序和","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:19.063Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgv008nfhjibcmm30sy","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/maximum-subarray/\">https://leetcode-cn.com/problems/maximum-subarray/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxSubArray(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int temp = nums[0], result = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) &#123;\n            temp = Math.max(temp + nums[i], nums[i]);\n            result = Math.max(result, temp);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/maximum-subarray/\">https://leetcode-cn.com/problems/maximum-subarray/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxSubArray(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int temp = nums[0], result = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) &#123;\n            temp = Math.max(temp + nums[i], nums[i]);\n            result = Math.max(result, temp);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"543二叉树的直径","_content":"\n题目地址：https://leetcode-cn.com/problems/diameter-of-binary-tree/\n\n设置一个全局变量result；\n\n对root进行求最大深度，调用下`maxDeepth`方法；\n\n* 越过叶子节点，返回0；\n\n* 计算左子树最大深度left；\n\n* 计算右子树最大深度right；\n\n* 在这个位置：计算直径 =` left + right `, 然后再维护最大值result\n\n* 返回左右子树较大者 + 1；\n\n````java\nclass Solution {\n    int result = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        depth(root);\n        return result;\n    }\n    public int depth(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int L = depth(node.left);\n        int R = depth(node.right);\n        result = Math.max(result, L+R);\n        return Math.max(L, R) + 1;\n    }\n}\n````\n\n","source":"_posts/LeetCode/543二叉树的直径.md","raw":"---\ntitle: 543二叉树的直径\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/diameter-of-binary-tree/\n\n设置一个全局变量result；\n\n对root进行求最大深度，调用下`maxDeepth`方法；\n\n* 越过叶子节点，返回0；\n\n* 计算左子树最大深度left；\n\n* 计算右子树最大深度right；\n\n* 在这个位置：计算直径 =` left + right `, 然后再维护最大值result\n\n* 返回左右子树较大者 + 1；\n\n````java\nclass Solution {\n    int result = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        depth(root);\n        return result;\n    }\n    public int depth(TreeNode node) {\n        if (node == null) {\n            return 0;\n        }\n        int L = depth(node.left);\n        int R = depth(node.right);\n        result = Math.max(result, L+R);\n        return Math.max(L, R) + 1;\n    }\n}\n````\n\n","slug":"LeetCode/543二叉树的直径","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:22.502Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgw008pfhji8x9c39n7","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/diameter-of-binary-tree/\">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>\n<p>设置一个全局变量result；</p>\n<p>对root进行求最大深度，调用下<code>maxDeepth</code>方法；</p>\n<ul>\n<li><p>越过叶子节点，返回0；</p>\n</li>\n<li><p>计算左子树最大深度left；</p>\n</li>\n<li><p>计算右子树最大深度right；</p>\n</li>\n<li><p>在这个位置：计算直径 &#x3D;<code>left + right</code>, 然后再维护最大值result</p>\n</li>\n<li><p>返回左右子树较大者 + 1；</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    int result = 0;\n    public int diameterOfBinaryTree(TreeNode root) &#123;\n        depth(root);\n        return result;\n    &#125;\n    public int depth(TreeNode node) &#123;\n        if (node == null) &#123;\n            return 0;\n        &#125;\n        int L = depth(node.left);\n        int R = depth(node.right);\n        result = Math.max(result, L+R);\n        return Math.max(L, R) + 1;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/diameter-of-binary-tree/\">https://leetcode-cn.com/problems/diameter-of-binary-tree/</a></p>\n<p>设置一个全局变量result；</p>\n<p>对root进行求最大深度，调用下<code>maxDeepth</code>方法；</p>\n<ul>\n<li><p>越过叶子节点，返回0；</p>\n</li>\n<li><p>计算左子树最大深度left；</p>\n</li>\n<li><p>计算右子树最大深度right；</p>\n</li>\n<li><p>在这个位置：计算直径 &#x3D;<code>left + right</code>, 然后再维护最大值result</p>\n</li>\n<li><p>返回左右子树较大者 + 1；</p>\n</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    int result = 0;\n    public int diameterOfBinaryTree(TreeNode root) &#123;\n        depth(root);\n        return result;\n    &#125;\n    public int depth(TreeNode node) &#123;\n        if (node == null) &#123;\n            return 0;\n        &#125;\n        int L = depth(node.left);\n        int R = depth(node.right);\n        result = Math.max(result, L+R);\n        return Math.max(L, R) + 1;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"54螺旋矩阵","_content":"\n题目地址：https://leetcode-cn.com/problems/spiral-matrix/\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int col = 0, cols = matrix[0].length - 1, row = 0, rows = matrix.length - 1;\n        List<Integer> list = new ArrayList<>();\n        int total = matrix.length * matrix[0].length;\n        int num = 1;\n        while (num <= total) {\n            for (int i = col; i <= cols && num <= total ; i++) { //从左到右\n                list.add(matrix[row][i]);\n                num++;\n            }\n            row++;\n            for (int i = row; i <= rows && num <= total ; i++) { //从上到下\n                list.add(matrix[i][cols]);\n                num++;\n            }\n            cols--;\n            for (int i = cols; i >= col && num <= total ; i--) { //从右到左\n                list.add(matrix[rows][i]);\n                num++;\n            }\n            rows--;\n            for (int i = rows; i >= row && num <= total ; i--) { //从下到上\n                list.add(matrix[i][col]);\n                num++;\n            }\n            col++;\n        }\n        return list;\n    }\n}\n```\n\n","source":"_posts/LeetCode/54螺旋矩阵.md","raw":"---\ntitle: 54螺旋矩阵\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/spiral-matrix/\n\n```java\nclass Solution {\n    public List<Integer> spiralOrder(int[][] matrix) {\n        int col = 0, cols = matrix[0].length - 1, row = 0, rows = matrix.length - 1;\n        List<Integer> list = new ArrayList<>();\n        int total = matrix.length * matrix[0].length;\n        int num = 1;\n        while (num <= total) {\n            for (int i = col; i <= cols && num <= total ; i++) { //从左到右\n                list.add(matrix[row][i]);\n                num++;\n            }\n            row++;\n            for (int i = row; i <= rows && num <= total ; i++) { //从上到下\n                list.add(matrix[i][cols]);\n                num++;\n            }\n            cols--;\n            for (int i = cols; i >= col && num <= total ; i--) { //从右到左\n                list.add(matrix[rows][i]);\n                num++;\n            }\n            rows--;\n            for (int i = rows; i >= row && num <= total ; i--) { //从下到上\n                list.add(matrix[i][col]);\n                num++;\n            }\n            col++;\n        }\n        return list;\n    }\n}\n```\n\n","slug":"LeetCode/54螺旋矩阵","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:26.042Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgx008sfhjihi4x4zc2","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/spiral-matrix/\">https://leetcode-cn.com/problems/spiral-matrix/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;\n        int col = 0, cols = matrix[0].length - 1, row = 0, rows = matrix.length - 1;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        int total = matrix.length * matrix[0].length;\n        int num = 1;\n        while (num &lt;= total) &#123;\n            for (int i = col; i &lt;= cols &amp;&amp; num &lt;= total ; i++) &#123; //从左到右\n                list.add(matrix[row][i]);\n                num++;\n            &#125;\n            row++;\n            for (int i = row; i &lt;= rows &amp;&amp; num &lt;= total ; i++) &#123; //从上到下\n                list.add(matrix[i][cols]);\n                num++;\n            &#125;\n            cols--;\n            for (int i = cols; i &gt;= col &amp;&amp; num &lt;= total ; i--) &#123; //从右到左\n                list.add(matrix[rows][i]);\n                num++;\n            &#125;\n            rows--;\n            for (int i = rows; i &gt;= row &amp;&amp; num &lt;= total ; i--) &#123; //从下到上\n                list.add(matrix[i][col]);\n                num++;\n            &#125;\n            col++;\n        &#125;\n        return list;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/spiral-matrix/\">https://leetcode-cn.com/problems/spiral-matrix/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; spiralOrder(int[][] matrix) &#123;\n        int col = 0, cols = matrix[0].length - 1, row = 0, rows = matrix.length - 1;\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        int total = matrix.length * matrix[0].length;\n        int num = 1;\n        while (num &lt;= total) &#123;\n            for (int i = col; i &lt;= cols &amp;&amp; num &lt;= total ; i++) &#123; //从左到右\n                list.add(matrix[row][i]);\n                num++;\n            &#125;\n            row++;\n            for (int i = row; i &lt;= rows &amp;&amp; num &lt;= total ; i++) &#123; //从上到下\n                list.add(matrix[i][cols]);\n                num++;\n            &#125;\n            cols--;\n            for (int i = cols; i &gt;= col &amp;&amp; num &lt;= total ; i--) &#123; //从右到左\n                list.add(matrix[rows][i]);\n                num++;\n            &#125;\n            rows--;\n            for (int i = rows; i &gt;= row &amp;&amp; num &lt;= total ; i--) &#123; //从下到上\n                list.add(matrix[i][col]);\n                num++;\n            &#125;\n            col++;\n        &#125;\n        return list;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"55跳跃游戏","_content":"\n题目地址：https://leetcode-cn.com/problems/jump-game/\n\n我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。\n\n对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 `x+nums[x]` 更新 最远可以到达的位置。\n\n在遍历的过程中，如果最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。\n\n反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。\n\n```java\npublic class Solution {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int rightMost = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i <= rightMost) {\n                rightMost = Math.max(rightMost, i + nums[i]);\n                if (rightMost >= n - 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：O(n)，其中 n 为数组的大小。只需要访问 nums 数组一遍，共 n 个位置。\n\n* 空间复杂度：O(1)，不需要额外的空间开销。","source":"_posts/LeetCode/55跳跃游戏.md","raw":"---\ntitle: 55跳跃游戏\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/jump-game/\n\n我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。\n\n对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 `x+nums[x]` 更新 最远可以到达的位置。\n\n在遍历的过程中，如果最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。\n\n反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。\n\n```java\npublic class Solution {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        int rightMost = 0;\n        for (int i = 0; i < n; ++i) {\n            if (i <= rightMost) {\n                rightMost = Math.max(rightMost, i + nums[i]);\n                if (rightMost >= n - 1) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：O(n)，其中 n 为数组的大小。只需要访问 nums 数组一遍，共 n 个位置。\n\n* 空间复杂度：O(1)，不需要额外的空间开销。","slug":"LeetCode/55跳跃游戏","published":1,"date":"2021-11-24T14:36:32.054Z","updated":"2022-01-28T16:21:30.059Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgx008ufhjihdq3gi2n","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/jump-game/\">https://leetcode-cn.com/problems/jump-game/</a></p>\n<p>我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。</p>\n<p>对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 <code>x+nums[x]</code> 更新 最远可以到达的位置。</p>\n<p>在遍历的过程中，如果最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。</p>\n<p>反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p>\n<pre><code class=\"java\">public class Solution &#123;\n    public boolean canJump(int[] nums) &#123;\n        int n = nums.length;\n        int rightMost = 0;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (i &lt;= rightMost) &#123;\n                rightMost = Math.max(rightMost, i + nums[i]);\n                if (rightMost &gt;= n - 1) &#123;\n                    return true;\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(n)，其中 n 为数组的大小。只需要访问 nums 数组一遍，共 n 个位置。</p>\n</li>\n<li><p>空间复杂度：O(1)，不需要额外的空间开销。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/jump-game/\">https://leetcode-cn.com/problems/jump-game/</a></p>\n<p>我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。</p>\n<p>对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 <code>x+nums[x]</code> 更新 最远可以到达的位置。</p>\n<p>在遍历的过程中，如果最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。</p>\n<p>反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p>\n<pre><code class=\"java\">public class Solution &#123;\n    public boolean canJump(int[] nums) &#123;\n        int n = nums.length;\n        int rightMost = 0;\n        for (int i = 0; i &lt; n; ++i) &#123;\n            if (i &lt;= rightMost) &#123;\n                rightMost = Math.max(rightMost, i + nums[i]);\n                if (rightMost &gt;= n - 1) &#123;\n                    return true;\n                &#125;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(n)，其中 n 为数组的大小。只需要访问 nums 数组一遍，共 n 个位置。</p>\n</li>\n<li><p>空间复杂度：O(1)，不需要额外的空间开销。</p>\n</li>\n</ul>\n"},{"title":"5最长回文子串","_content":"\n题目地址：https://leetcode-cn.com/problems/longest-palindromic-substring/\n\n# 中心扩展法\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        if(s == null || s.length() == 0) {\n            return null;\n        }\n        int maxStart = 0, maxEnd = 0, maxLen = 0;\n        for(int i = 0; i < s.length()-1; i++){\n            //以i和i+1为中心扩散的回文子串，哪个大取哪个\n            int len = centerSpread(s,i,i) > centerSpread(s,i,i+1)? centerSpread(s,i,i):centerSpread(s,i,i+1);\n            if (maxLen < len) {\n                maxStart = i - (len - 1) / 2;\n                maxEnd = i + len / 2;\n                maxLen = len;\n            }\n        }\n        return s.substring(maxStart, maxEnd + 1);\n    }\n    private int centerSpread(String s, int left, int right){\n        int len = s.length();\n        int l = left;\n        int r = right;\n        while(l >= 0 && r <= len-1){\n            //若相等则继续扩散\n            if(s.charAt(l) == s.charAt(r)){\n                l--;\n                r++;\n            }else{\n                break;\n            }\n        }\n        //为什么还要减2 因为上面while循环终止了，此时s.charAt(l) != s.charAt(r)\n        //所以此时的回文子串的左右边界其实是l-1,r-1\n        return r-l+1-2;\n    }\n}\n```\n\n时间复杂度：`O(n^2)`，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n-1 个，每个回文中心最多会向外扩展 O(n) 次\n\n空间复杂度：O(1)。","source":"_posts/LeetCode/5最长回文子串.md","raw":"---\ntitle: 5最长回文子串\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/longest-palindromic-substring/\n\n# 中心扩展法\n\n```java\nclass Solution {\n    public String longestPalindrome(String s) {\n        if(s == null || s.length() == 0) {\n            return null;\n        }\n        int maxStart = 0, maxEnd = 0, maxLen = 0;\n        for(int i = 0; i < s.length()-1; i++){\n            //以i和i+1为中心扩散的回文子串，哪个大取哪个\n            int len = centerSpread(s,i,i) > centerSpread(s,i,i+1)? centerSpread(s,i,i):centerSpread(s,i,i+1);\n            if (maxLen < len) {\n                maxStart = i - (len - 1) / 2;\n                maxEnd = i + len / 2;\n                maxLen = len;\n            }\n        }\n        return s.substring(maxStart, maxEnd + 1);\n    }\n    private int centerSpread(String s, int left, int right){\n        int len = s.length();\n        int l = left;\n        int r = right;\n        while(l >= 0 && r <= len-1){\n            //若相等则继续扩散\n            if(s.charAt(l) == s.charAt(r)){\n                l--;\n                r++;\n            }else{\n                break;\n            }\n        }\n        //为什么还要减2 因为上面while循环终止了，此时s.charAt(l) != s.charAt(r)\n        //所以此时的回文子串的左右边界其实是l-1,r-1\n        return r-l+1-2;\n    }\n}\n```\n\n时间复杂度：`O(n^2)`，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n-1 个，每个回文中心最多会向外扩展 O(n) 次\n\n空间复杂度：O(1)。","slug":"LeetCode/5最长回文子串","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2021-12-27T05:09:50.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgy008xfhji0tic60ra","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>\n<h1 id=\"中心扩展法\"><a href=\"#中心扩展法\" class=\"headerlink\" title=\"中心扩展法\"></a>中心扩展法</h1><pre><code class=\"java\">class Solution &#123;\n    public String longestPalindrome(String s) &#123;\n        if(s == null || s.length() == 0) &#123;\n            return null;\n        &#125;\n        int maxStart = 0, maxEnd = 0, maxLen = 0;\n        for(int i = 0; i &lt; s.length()-1; i++)&#123;\n            //以i和i+1为中心扩散的回文子串，哪个大取哪个\n            int len = centerSpread(s,i,i) &gt; centerSpread(s,i,i+1)? centerSpread(s,i,i):centerSpread(s,i,i+1);\n            if (maxLen &lt; len) &#123;\n                maxStart = i - (len - 1) / 2;\n                maxEnd = i + len / 2;\n                maxLen = len;\n            &#125;\n        &#125;\n        return s.substring(maxStart, maxEnd + 1);\n    &#125;\n    private int centerSpread(String s, int left, int right)&#123;\n        int len = s.length();\n        int l = left;\n        int r = right;\n        while(l &gt;= 0 &amp;&amp; r &lt;= len-1)&#123;\n            //若相等则继续扩散\n            if(s.charAt(l) == s.charAt(r))&#123;\n                l--;\n                r++;\n            &#125;else&#123;\n                break;\n            &#125;\n        &#125;\n        //为什么还要减2 因为上面while循环终止了，此时s.charAt(l) != s.charAt(r)\n        //所以此时的回文子串的左右边界其实是l-1,r-1\n        return r-l+1-2;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(n^2)</code>，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n-1 个，每个回文中心最多会向外扩展 O(n) 次</p>\n<p>空间复杂度：O(1)。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-palindromic-substring/\">https://leetcode-cn.com/problems/longest-palindromic-substring/</a></p>\n<h1 id=\"中心扩展法\"><a href=\"#中心扩展法\" class=\"headerlink\" title=\"中心扩展法\"></a>中心扩展法</h1><pre><code class=\"java\">class Solution &#123;\n    public String longestPalindrome(String s) &#123;\n        if(s == null || s.length() == 0) &#123;\n            return null;\n        &#125;\n        int maxStart = 0, maxEnd = 0, maxLen = 0;\n        for(int i = 0; i &lt; s.length()-1; i++)&#123;\n            //以i和i+1为中心扩散的回文子串，哪个大取哪个\n            int len = centerSpread(s,i,i) &gt; centerSpread(s,i,i+1)? centerSpread(s,i,i):centerSpread(s,i,i+1);\n            if (maxLen &lt; len) &#123;\n                maxStart = i - (len - 1) / 2;\n                maxEnd = i + len / 2;\n                maxLen = len;\n            &#125;\n        &#125;\n        return s.substring(maxStart, maxEnd + 1);\n    &#125;\n    private int centerSpread(String s, int left, int right)&#123;\n        int len = s.length();\n        int l = left;\n        int r = right;\n        while(l &gt;= 0 &amp;&amp; r &lt;= len-1)&#123;\n            //若相等则继续扩散\n            if(s.charAt(l) == s.charAt(r))&#123;\n                l--;\n                r++;\n            &#125;else&#123;\n                break;\n            &#125;\n        &#125;\n        //为什么还要减2 因为上面while循环终止了，此时s.charAt(l) != s.charAt(r)\n        //所以此时的回文子串的左右边界其实是l-1,r-1\n        return r-l+1-2;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：<code>O(n^2)</code>，其中 n 是字符串的长度。长度为 1 和 2 的回文中心分别有 n 和 n-1 个，每个回文中心最多会向外扩展 O(n) 次</p>\n<p>空间复杂度：O(1)。</p>\n"},{"title":"617合并二叉树","_content":"\n题目地址：https://leetcode-cn.com/problems/merge-two-binary-trees/\n\n```java\nclass Solution {\n\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null || t2 == null) {\n            return (t1 == null ? t2 : t1);\n        }\n        return dfs(t1, t2);\n    }\n\n    TreeNode dfs(TreeNode r1, TreeNode r2) {\n        if (r1 == null || r2 == null) {\n            return r1 == null ? r2 : r1;\n        }\n        //让r1的值等于r1和r2的值累加，再递归的计算两颗树的左节点、右节点\n        r1.val += r2.val;\n        r1.left = dfs(r1.left, r2.left);\n        r1.right = dfs(r1.right, r2.right);\n        return r1;\n    }\n}\n```\n\n","source":"_posts/LeetCode/617合并二叉树.md","raw":"---\ntitle: 617合并二叉树\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/merge-two-binary-trees/\n\n```java\nclass Solution {\n\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n        if (t1 == null || t2 == null) {\n            return (t1 == null ? t2 : t1);\n        }\n        return dfs(t1, t2);\n    }\n\n    TreeNode dfs(TreeNode r1, TreeNode r2) {\n        if (r1 == null || r2 == null) {\n            return r1 == null ? r2 : r1;\n        }\n        //让r1的值等于r1和r2的值累加，再递归的计算两颗树的左节点、右节点\n        r1.val += r2.val;\n        r1.left = dfs(r1.left, r2.left);\n        r1.right = dfs(r1.right, r2.right);\n        return r1;\n    }\n}\n```\n\n","slug":"LeetCode/617合并二叉树","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:35.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwgz008zfhji98qh4gdx","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/\">https://leetcode-cn.com/problems/merge-two-binary-trees/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;\n        if (t1 == null || t2 == null) &#123;\n            return (t1 == null ? t2 : t1);\n        &#125;\n        return dfs(t1, t2);\n    &#125;\n\n    TreeNode dfs(TreeNode r1, TreeNode r2) &#123;\n        if (r1 == null || r2 == null) &#123;\n            return r1 == null ? r2 : r1;\n        &#125;\n        //让r1的值等于r1和r2的值累加，再递归的计算两颗树的左节点、右节点\n        r1.val += r2.val;\n        r1.left = dfs(r1.left, r2.left);\n        r1.right = dfs(r1.right, r2.right);\n        return r1;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/merge-two-binary-trees/\">https://leetcode-cn.com/problems/merge-two-binary-trees/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n\n    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) &#123;\n        if (t1 == null || t2 == null) &#123;\n            return (t1 == null ? t2 : t1);\n        &#125;\n        return dfs(t1, t2);\n    &#125;\n\n    TreeNode dfs(TreeNode r1, TreeNode r2) &#123;\n        if (r1 == null || r2 == null) &#123;\n            return r1 == null ? r2 : r1;\n        &#125;\n        //让r1的值等于r1和r2的值累加，再递归的计算两颗树的左节点、右节点\n        r1.val += r2.val;\n        r1.left = dfs(r1.left, r2.left);\n        r1.right = dfs(r1.right, r2.right);\n        return r1;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"637二叉树的层平均值","_content":"\n题目地址：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> averages = new ArrayList<Double>();\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            double sum = 0;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            averages.add(sum / size);\n        }\n        return averages;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 是二叉树中的节点个数\n\n空间复杂度：O(n)","source":"_posts/LeetCode/637二叉树的层平均值.md","raw":"---\ntitle: 637二叉树的层平均值\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\n\n```java\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> averages = new ArrayList<Double>();\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            double sum = 0;\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if (node.left != null) {\n                    queue.offer(node.left);\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            averages.add(sum / size);\n        }\n        return averages;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 是二叉树中的节点个数\n\n空间复杂度：O(n)","slug":"LeetCode/637二叉树的层平均值","published":1,"date":"2021-09-01T05:22:18.211Z","updated":"2022-01-28T16:21:39.484Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh00092fhjifi4xeyj6","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val = val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;\n        List&lt;Double&gt; averages = new ArrayList&lt;Double&gt;();\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n        queue.offer(root);\n        while (!queue.isEmpty()) &#123;\n            double sum = 0;\n            int size = queue.size();\n            for (int i = 0; i &lt; size; i++) &#123;\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if (node.left != null) &#123;\n                    queue.offer(node.left);\n                &#125;\n                if (node.right != null) &#123;\n                    queue.offer(node.right);\n                &#125;\n            &#125;\n            averages.add(sum / size);\n        &#125;\n        return averages;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数</p>\n<p>空间复杂度：O(n)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/\">https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/</a></p>\n<pre><code class=\"java\">/**\n * Definition for a binary tree node.\n * public class TreeNode &#123;\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() &#123;&#125;\n *     TreeNode(int val) &#123; this.val = val; &#125;\n *     TreeNode(int val, TreeNode left, TreeNode right) &#123;\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public List&lt;Double&gt; averageOfLevels(TreeNode root) &#123;\n        List&lt;Double&gt; averages = new ArrayList&lt;Double&gt;();\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n        queue.offer(root);\n        while (!queue.isEmpty()) &#123;\n            double sum = 0;\n            int size = queue.size();\n            for (int i = 0; i &lt; size; i++) &#123;\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if (node.left != null) &#123;\n                    queue.offer(node.left);\n                &#125;\n                if (node.right != null) &#123;\n                    queue.offer(node.right);\n                &#125;\n            &#125;\n            averages.add(sum / size);\n        &#125;\n        return averages;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 是二叉树中的节点个数</p>\n<p>空间复杂度：O(n)</p>\n"},{"title":"64最小路径和","_content":"\n**题目地址：**https://leetcode-cn.com/problems/minimum-path-sum/\n\n**状态定义：**\n\n设 dp 为大小m×n 矩阵，其中 `dp[i][j]` 的值代表直到走到 (i,j) 的最小路径和。\n\n**返回值：**\n\n- 返回 dp矩阵右下角值，即走到终点的最小路径和。\n\n其实我们完全不需要建立 dp 矩阵浪费额外空间，直接遍历 `grid[i][j]`修改即可。\n\n这是因为：`grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] `；原 grid 矩阵元素中被覆盖为 dp 元素后（都处于当前遍历点的左上方），不会再被使用到。\n\n时间复杂度 `O(M×N)` ： 遍历整个 grid 矩阵元素。\n\n空间复杂度 O(1) ： 直接修改原矩阵，不使用额外空间。\n\n```java\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                } else if (i == 0) {//当只有左边是矩阵边界时，只能从上面来\n                    grid[i][j] = grid[i][j-1] + grid[i][j];\n                } else if (j == 0) {//当只有上边是矩阵边界时，只能从左面来\n                    grid[i][j] = grid[i-1][j] + grid[i][j];\n                } else {\n                    grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n                }\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```\n\n","source":"_posts/LeetCode/64最小路径和.md","raw":"---\ntitle: 64最小路径和\ncategories: \n- LeetCode\n---\n\n**题目地址：**https://leetcode-cn.com/problems/minimum-path-sum/\n\n**状态定义：**\n\n设 dp 为大小m×n 矩阵，其中 `dp[i][j]` 的值代表直到走到 (i,j) 的最小路径和。\n\n**返回值：**\n\n- 返回 dp矩阵右下角值，即走到终点的最小路径和。\n\n其实我们完全不需要建立 dp 矩阵浪费额外空间，直接遍历 `grid[i][j]`修改即可。\n\n这是因为：`grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] `；原 grid 矩阵元素中被覆盖为 dp 元素后（都处于当前遍历点的左上方），不会再被使用到。\n\n时间复杂度 `O(M×N)` ： 遍历整个 grid 矩阵元素。\n\n空间复杂度 O(1) ： 直接修改原矩阵，不使用额外空间。\n\n```java\nclass Solution {\n    public int minPathSum(int[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (i == 0 && j == 0) {\n                    continue;\n                } else if (i == 0) {//当只有左边是矩阵边界时，只能从上面来\n                    grid[i][j] = grid[i][j-1] + grid[i][j];\n                } else if (j == 0) {//当只有上边是矩阵边界时，只能从左面来\n                    grid[i][j] = grid[i-1][j] + grid[i][j];\n                } else {\n                    grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n                }\n            }\n        }\n        return grid[grid.length-1][grid[0].length-1];\n    }\n}\n```\n\n","slug":"LeetCode/64最小路径和","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:21:45.438Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh00094fhji9uwm7m6d","content":"<p><strong>题目地址：</strong><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>\n<p><strong>状态定义：</strong></p>\n<p>设 dp 为大小m×n 矩阵，其中 <code>dp[i][j]</code> 的值代表直到走到 (i,j) 的最小路径和。</p>\n<p><strong>返回值：</strong></p>\n<ul>\n<li>返回 dp矩阵右下角值，即走到终点的最小路径和。</li>\n</ul>\n<p>其实我们完全不需要建立 dp 矩阵浪费额外空间，直接遍历 <code>grid[i][j]</code>修改即可。</p>\n<p>这是因为：<code>grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] </code>；原 grid 矩阵元素中被覆盖为 dp 元素后（都处于当前遍历点的左上方），不会再被使用到。</p>\n<p>时间复杂度 <code>O(M×N)</code> ： 遍历整个 grid 矩阵元素。</p>\n<p>空间复杂度 O(1) ： 直接修改原矩阵，不使用额外空间。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int minPathSum(int[][] grid) &#123;\n        if (grid == null || grid.length == 0) &#123;\n            return 0;\n        &#125;\n        for (int i = 0; i &lt; grid.length; i++) &#123;\n            for (int j = 0; j &lt; grid[0].length; j++) &#123;\n                if (i == 0 &amp;&amp; j == 0) &#123;\n                    continue;\n                &#125; else if (i == 0) &#123;//当只有左边是矩阵边界时，只能从上面来\n                    grid[i][j] = grid[i][j-1] + grid[i][j];\n                &#125; else if (j == 0) &#123;//当只有上边是矩阵边界时，只能从左面来\n                    grid[i][j] = grid[i-1][j] + grid[i][j];\n                &#125; else &#123;\n                    grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n                &#125;\n            &#125;\n        &#125;\n        return grid[grid.length-1][grid[0].length-1];\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>题目地址：</strong><a href=\"https://leetcode-cn.com/problems/minimum-path-sum/\">https://leetcode-cn.com/problems/minimum-path-sum/</a></p>\n<p><strong>状态定义：</strong></p>\n<p>设 dp 为大小m×n 矩阵，其中 <code>dp[i][j]</code> 的值代表直到走到 (i,j) 的最小路径和。</p>\n<p><strong>返回值：</strong></p>\n<ul>\n<li>返回 dp矩阵右下角值，即走到终点的最小路径和。</li>\n</ul>\n<p>其实我们完全不需要建立 dp 矩阵浪费额外空间，直接遍历 <code>grid[i][j]</code>修改即可。</p>\n<p>这是因为：<code>grid[i][j] = min(grid[i - 1][j], grid[i][j - 1]) + grid[i][j] </code>；原 grid 矩阵元素中被覆盖为 dp 元素后（都处于当前遍历点的左上方），不会再被使用到。</p>\n<p>时间复杂度 <code>O(M×N)</code> ： 遍历整个 grid 矩阵元素。</p>\n<p>空间复杂度 O(1) ： 直接修改原矩阵，不使用额外空间。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int minPathSum(int[][] grid) &#123;\n        if (grid == null || grid.length == 0) &#123;\n            return 0;\n        &#125;\n        for (int i = 0; i &lt; grid.length; i++) &#123;\n            for (int j = 0; j &lt; grid[0].length; j++) &#123;\n                if (i == 0 &amp;&amp; j == 0) &#123;\n                    continue;\n                &#125; else if (i == 0) &#123;//当只有左边是矩阵边界时，只能从上面来\n                    grid[i][j] = grid[i][j-1] + grid[i][j];\n                &#125; else if (j == 0) &#123;//当只有上边是矩阵边界时，只能从左面来\n                    grid[i][j] = grid[i-1][j] + grid[i][j];\n                &#125; else &#123;\n                    grid[i][j] = Math.min(grid[i-1][j], grid[i][j-1]) + grid[i][j];\n                &#125;\n            &#125;\n        &#125;\n        return grid[grid.length-1][grid[0].length-1];\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"674最长连续递增序列","_content":"\n题目地址：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/\n\n```java\nclass Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int count = 1, result = 1;\n        for (int i =0;i<nums.length - 1;i++){\n            if (nums[i] < nums[i+1]){\n                count++;\n            }else {\n                count = 1;\n            }\n            result = Math.max(result , count);\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(N)","source":"_posts/LeetCode/674最长连续递增序列.md","raw":"---\ntitle: 674最长连续递增序列\ncategories:\n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/\n\n```java\nclass Solution {\n    public int findLengthOfLCIS(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int count = 1, result = 1;\n        for (int i =0;i<nums.length - 1;i++){\n            if (nums[i] < nums[i+1]){\n                count++;\n            }else {\n                count = 1;\n            }\n            result = Math.max(result , count);\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(N)","slug":"LeetCode/674最长连续递增序列","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:21:49.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh10097fhjibcps41f2","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/\">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int findLengthOfLCIS(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int count = 1, result = 1;\n        for (int i =0;i&lt;nums.length - 1;i++)&#123;\n            if (nums[i] &lt; nums[i+1])&#123;\n                count++;\n            &#125;else &#123;\n                count = 1;\n            &#125;\n            result = Math.max(result , count);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/\">https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int findLengthOfLCIS(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int count = 1, result = 1;\n        for (int i =0;i&lt;nums.length - 1;i++)&#123;\n            if (nums[i] &lt; nums[i+1])&#123;\n                count++;\n            &#125;else &#123;\n                count = 1;\n            &#125;\n            result = Math.max(result , count);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(N)</p>\n"},{"title":"69X的平方根","_content":"\n题目地址：https://leetcode-cn.com/problems/sqrtx/\n\n# 二分查找\n\n我们知道x的平方根的整数部分是满足**k的平方小于等于x的k**的最大值\n\n设置二分查找的下界为 0，上界为 x\n\n在二分查找的每一步中，我们只需要比较中间元素 `mid` 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x, result = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid <= x) {\n                result = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return result;\n    }\n}\n```\n\n","source":"_posts/LeetCode/69X的平方根.md","raw":"---\ntitle: 69X的平方根\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/sqrtx/\n\n# 二分查找\n\n我们知道x的平方根的整数部分是满足**k的平方小于等于x的k**的最大值\n\n设置二分查找的下界为 0，上界为 x\n\n在二分查找的每一步中，我们只需要比较中间元素 `mid` 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围\n\n```java\nclass Solution {\n    public int mySqrt(int x) {\n        int l = 0, r = x, result = -1;\n        while (l <= r) {\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid <= x) {\n                result = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return result;\n    }\n}\n```\n\n","slug":"LeetCode/69X的平方根","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:21:53.734Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh10099fhji6b5z8q3y","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sqrtx/\">https://leetcode-cn.com/problems/sqrtx/</a></p>\n<h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><p>我们知道x的平方根的整数部分是满足<strong>k的平方小于等于x的k</strong>的最大值</p>\n<p>设置二分查找的下界为 0，上界为 x</p>\n<p>在二分查找的每一步中，我们只需要比较中间元素 <code>mid</code> 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int mySqrt(int x) &#123;\n        int l = 0, r = x, result = -1;\n        while (l &lt;= r) &#123;\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid &lt;= x) &#123;\n                result = mid;\n                l = mid + 1;\n            &#125; else &#123;\n                r = mid - 1;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sqrtx/\">https://leetcode-cn.com/problems/sqrtx/</a></p>\n<h1 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h1><p>我们知道x的平方根的整数部分是满足<strong>k的平方小于等于x的k</strong>的最大值</p>\n<p>设置二分查找的下界为 0，上界为 x</p>\n<p>在二分查找的每一步中，我们只需要比较中间元素 <code>mid</code> 的平方与 x 的大小关系，并通过比较的结果调整上下界的范围</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int mySqrt(int x) &#123;\n        int l = 0, r = x, result = -1;\n        while (l &lt;= r) &#123;\n            int mid = l + (r - l) / 2;\n            if ((long) mid * mid &lt;= x) &#123;\n                result = mid;\n                l = mid + 1;\n            &#125; else &#123;\n                r = mid - 1;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"704二分查找","_content":"\n题目地址：https://leetcode-cn.com/problems/binary-search/\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if (nums==null || nums.length == 0) {\n            return -1;\n        }\n        int left = 0, right = nums.length - 1;\n        while(left<=right){\n            int middle = left + (right - left) / 2;\n            if (nums[middle]==target) {\n                return middle;\n            } else if (nums[middle] > target) {\n                right = middle - 1;\n            } else {\n                left = middle + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n","source":"_posts/LeetCode/704二分查找.md","raw":"---\ntitle: 704二分查找\ncategories:\n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/binary-search/\n\n```java\nclass Solution {\n    public int search(int[] nums, int target) {\n        if (nums==null || nums.length == 0) {\n            return -1;\n        }\n        int left = 0, right = nums.length - 1;\n        while(left<=right){\n            int middle = left + (right - left) / 2;\n            if (nums[middle]==target) {\n                return middle;\n            } else if (nums[middle] > target) {\n                right = middle - 1;\n            } else {\n                left = middle + 1;\n            }\n        }\n        return -1;\n    }\n}\n```\n\n","slug":"LeetCode/704二分查找","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:21:59.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh2009cfhji9zes15na","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-search/\">https://leetcode-cn.com/problems/binary-search/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        if (nums==null || nums.length == 0) &#123;\n            return -1;\n        &#125;\n        int left = 0, right = nums.length - 1;\n        while(left&lt;=right)&#123;\n            int middle = left + (right - left) / 2;\n            if (nums[middle]==target) &#123;\n                return middle;\n            &#125; else if (nums[middle] &gt; target) &#123;\n                right = middle - 1;\n            &#125; else &#123;\n                left = middle + 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-search/\">https://leetcode-cn.com/problems/binary-search/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int search(int[] nums, int target) &#123;\n        if (nums==null || nums.length == 0) &#123;\n            return -1;\n        &#125;\n        int left = 0, right = nums.length - 1;\n        while(left&lt;=right)&#123;\n            int middle = left + (right - left) / 2;\n            if (nums[middle]==target) &#123;\n                return middle;\n            &#125; else if (nums[middle] &gt; target) &#123;\n                right = middle - 1;\n            &#125; else &#123;\n                left = middle + 1;\n            &#125;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"70爬楼梯","_content":"\n题目地址：https://leetcode-cn.com/problems/climbing-stairs/\n\n**动态规划**\n\n爬第n阶楼梯的方法数量，等于 2 部分之和\n\n* 爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶\n\n* 爬上 n-2 阶楼梯的方法数量，因为再爬2阶就能到第n阶\n\n所以我们得到公式 `dp[n] = dp[n-1] + dp[n-2]`\n\n同时需要初始化` dp[0]=1` 和 `dp[1]=1`\n\n时间复杂度：O(n)\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n\nclass Solution {\n    public int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。\n\n* 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。","source":"_posts/LeetCode/70爬楼梯.md","raw":"---\ntitle: 70爬楼梯\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/climbing-stairs/\n\n**动态规划**\n\n爬第n阶楼梯的方法数量，等于 2 部分之和\n\n* 爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶\n\n* 爬上 n-2 阶楼梯的方法数量，因为再爬2阶就能到第n阶\n\n所以我们得到公式 `dp[n] = dp[n-1] + dp[n-2]`\n\n同时需要初始化` dp[0]=1` 和 `dp[1]=1`\n\n时间复杂度：O(n)\n\n```java\nclass Solution {\n    public int climbStairs(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        return dp[n];\n    }\n}\n\nclass Solution {\n    public int climbStairs(int n) {\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i <= n; ++i) {\n            p = q; \n            q = r; \n            r = p + q;\n        }\n        return r;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。\n\n* 空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。","slug":"LeetCode/70爬楼梯","published":1,"date":"2021-11-22T01:49:19.844Z","updated":"2022-01-28T16:22:03.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh3009efhji9en6g4bh","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">https://leetcode-cn.com/problems/climbing-stairs/</a></p>\n<p><strong>动态规划</strong></p>\n<p>爬第n阶楼梯的方法数量，等于 2 部分之和</p>\n<ul>\n<li><p>爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶</p>\n</li>\n<li><p>爬上 n-2 阶楼梯的方法数量，因为再爬2阶就能到第n阶</p>\n</li>\n</ul>\n<p>所以我们得到公式 <code>dp[n] = dp[n-1] + dp[n-2]</code></p>\n<p>同时需要初始化<code> dp[0]=1</code> 和 <code>dp[1]=1</code></p>\n<p>时间复杂度：O(n)</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int climbStairs(int n) &#123;\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i &lt;= n; i++) &#123;\n            dp[i] = dp[i - 1] + dp[i - 2];\n        &#125;\n        return dp[n];\n    &#125;\n&#125;\n\nclass Solution &#123;\n    public int climbStairs(int n) &#123;\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            p = q; \n            q = r; \n            r = p + q;\n        &#125;\n        return r;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。</p>\n</li>\n<li><p>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/climbing-stairs/\">https://leetcode-cn.com/problems/climbing-stairs/</a></p>\n<p><strong>动态规划</strong></p>\n<p>爬第n阶楼梯的方法数量，等于 2 部分之和</p>\n<ul>\n<li><p>爬上 n-1 阶楼梯的方法数量。因为再爬1阶就能到第n阶</p>\n</li>\n<li><p>爬上 n-2 阶楼梯的方法数量，因为再爬2阶就能到第n阶</p>\n</li>\n</ul>\n<p>所以我们得到公式 <code>dp[n] = dp[n-1] + dp[n-2]</code></p>\n<p>同时需要初始化<code> dp[0]=1</code> 和 <code>dp[1]=1</code></p>\n<p>时间复杂度：O(n)</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int climbStairs(int n) &#123;\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for(int i = 2; i &lt;= n; i++) &#123;\n            dp[i] = dp[i - 1] + dp[i - 2];\n        &#125;\n        return dp[n];\n    &#125;\n&#125;\n\nclass Solution &#123;\n    public int climbStairs(int n) &#123;\n        int p = 0, q = 0, r = 1;\n        for (int i = 1; i &lt;= n; ++i) &#123;\n            p = q; \n            q = r; \n            r = p + q;\n        &#125;\n        return r;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：循环执行 n 次，每次花费常数的时间代价，故渐进时间复杂度为 O(n)。</p>\n</li>\n<li><p>空间复杂度：这里只用了常数个变量作为辅助空间，故渐进空间复杂度为 O(1)。</p>\n</li>\n</ul>\n"},{"title":"746使用最小花费爬楼梯","_content":"\n题目地址：https://leetcode-cn.com/problems/min-cost-climbing-stairs/\n\n**动态规划**\n\n这道题是爬楼梯那道题的变种，这里的每一级楼梯都是有价格的，想要跨过它，就要交保护费，而我们每次可以从前一个楼梯或者前两个楼梯爬上来，所以，不难写出动态规划方程：\n\n状态定义：`dp[i]` 表示到达第 i 级楼梯所需要的最小代价（注意：是到达，还没有跨过）。\n\n转移方程：`dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1])`，要想到达 i，要么交 i-2 的保护费走两步上来，要么交 i-1 的保护费走一步上来。\n\n初始值：`dp[0] = dp[1] = 0`，可以直接从 0 或 1 号楼梯开始，所以到达它们不需要花费代价。\n\n返回值：`dp[n]`，表示到达第 n 级楼梯的最小代价，也就是跨过第 n-1 的最小代价。\n\n优化：可以看到转移方程中只与前两项有关，所以，可以声明两个变量轮动减小空间。\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int prev = 0, curr = 0;\n        for (int i = 2; i <= n; i++) {\n            int next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);\n            prev = curr;\n            curr = next;\n        }\n        return curr;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：O(n)\n\n* 空间复杂度：O(1)。使用滚动数组的思想，只需要使用有限的额外空间。","source":"_posts/LeetCode/746使用最小花费爬楼梯.md","raw":"---\ntitle: 746使用最小花费爬楼梯\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/min-cost-climbing-stairs/\n\n**动态规划**\n\n这道题是爬楼梯那道题的变种，这里的每一级楼梯都是有价格的，想要跨过它，就要交保护费，而我们每次可以从前一个楼梯或者前两个楼梯爬上来，所以，不难写出动态规划方程：\n\n状态定义：`dp[i]` 表示到达第 i 级楼梯所需要的最小代价（注意：是到达，还没有跨过）。\n\n转移方程：`dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1])`，要想到达 i，要么交 i-2 的保护费走两步上来，要么交 i-1 的保护费走一步上来。\n\n初始值：`dp[0] = dp[1] = 0`，可以直接从 0 或 1 号楼梯开始，所以到达它们不需要花费代价。\n\n返回值：`dp[n]`，表示到达第 n 级楼梯的最小代价，也就是跨过第 n-1 的最小代价。\n\n优化：可以看到转移方程中只与前两项有关，所以，可以声明两个变量轮动减小空间。\n\n```java\nclass Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int prev = 0, curr = 0;\n        for (int i = 2; i <= n; i++) {\n            int next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);\n            prev = curr;\n            curr = next;\n        }\n        return curr;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：O(n)\n\n* 空间复杂度：O(1)。使用滚动数组的思想，只需要使用有限的额外空间。","slug":"LeetCode/746使用最小花费爬楼梯","published":1,"date":"2021-11-22T02:05:59.693Z","updated":"2022-01-28T16:22:09.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh3009hfhjicz74arnq","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p>\n<p><strong>动态规划</strong></p>\n<p>这道题是爬楼梯那道题的变种，这里的每一级楼梯都是有价格的，想要跨过它，就要交保护费，而我们每次可以从前一个楼梯或者前两个楼梯爬上来，所以，不难写出动态规划方程：</p>\n<p>状态定义：<code>dp[i]</code> 表示到达第 i 级楼梯所需要的最小代价（注意：是到达，还没有跨过）。</p>\n<p>转移方程：<code>dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1])</code>，要想到达 i，要么交 i-2 的保护费走两步上来，要么交 i-1 的保护费走一步上来。</p>\n<p>初始值：<code>dp[0] = dp[1] = 0</code>，可以直接从 0 或 1 号楼梯开始，所以到达它们不需要花费代价。</p>\n<p>返回值：<code>dp[n]</code>，表示到达第 n 级楼梯的最小代价，也就是跨过第 n-1 的最小代价。</p>\n<p>优化：可以看到转移方程中只与前两项有关，所以，可以声明两个变量轮动减小空间。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int minCostClimbingStairs(int[] cost) &#123;\n        int n = cost.length;\n        int prev = 0, curr = 0;\n        for (int i = 2; i &lt;= n; i++) &#123;\n            int next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);\n            prev = curr;\n            curr = next;\n        &#125;\n        return curr;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(n)</p>\n</li>\n<li><p>空间复杂度：O(1)。使用滚动数组的思想，只需要使用有限的额外空间。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/min-cost-climbing-stairs/\">https://leetcode-cn.com/problems/min-cost-climbing-stairs/</a></p>\n<p><strong>动态规划</strong></p>\n<p>这道题是爬楼梯那道题的变种，这里的每一级楼梯都是有价格的，想要跨过它，就要交保护费，而我们每次可以从前一个楼梯或者前两个楼梯爬上来，所以，不难写出动态规划方程：</p>\n<p>状态定义：<code>dp[i]</code> 表示到达第 i 级楼梯所需要的最小代价（注意：是到达，还没有跨过）。</p>\n<p>转移方程：<code>dp[i] = min(dp[i-2]+cost[i-2], dp[i-1]+cost[i-1])</code>，要想到达 i，要么交 i-2 的保护费走两步上来，要么交 i-1 的保护费走一步上来。</p>\n<p>初始值：<code>dp[0] = dp[1] = 0</code>，可以直接从 0 或 1 号楼梯开始，所以到达它们不需要花费代价。</p>\n<p>返回值：<code>dp[n]</code>，表示到达第 n 级楼梯的最小代价，也就是跨过第 n-1 的最小代价。</p>\n<p>优化：可以看到转移方程中只与前两项有关，所以，可以声明两个变量轮动减小空间。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int minCostClimbingStairs(int[] cost) &#123;\n        int n = cost.length;\n        int prev = 0, curr = 0;\n        for (int i = 2; i &lt;= n; i++) &#123;\n            int next = Math.min(curr + cost[i - 1], prev + cost[i - 2]);\n            prev = curr;\n            curr = next;\n        &#125;\n        return curr;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(n)</p>\n</li>\n<li><p>空间复杂度：O(1)。使用滚动数组的思想，只需要使用有限的额外空间。</p>\n</li>\n</ul>\n"},{"title":"75颜色分类","_content":"\n题目地址：https://leetcode-cn.com/problems/sort-colors/\n\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return;\n        }\n        int p0 = 0, p2 = nums.length - 1;\n        for (int i = 0; i<= p2;i++) {\n            //当我们将nums[i]与nums[p2]进行交换之后，新的nums[i]可能仍然是2\n            while (i <= p2 && nums[i] == 2) {\n                swap(nums, i, p2);\n                p2--;\n            }\n            if (nums[i] == 0) {\n                swap(nums, i, p0);\n                p0++;\n            }\n        }\n    }\n    private void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}\n```\n\n","source":"_posts/LeetCode/75颜色分类.md","raw":"---\ntitle: 75颜色分类\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/sort-colors/\n\n```java\nclass Solution {\n    public void sortColors(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return;\n        }\n        int p0 = 0, p2 = nums.length - 1;\n        for (int i = 0; i<= p2;i++) {\n            //当我们将nums[i]与nums[p2]进行交换之后，新的nums[i]可能仍然是2\n            while (i <= p2 && nums[i] == 2) {\n                swap(nums, i, p2);\n                p2--;\n            }\n            if (nums[i] == 0) {\n                swap(nums, i, p0);\n                p0++;\n            }\n        }\n    }\n    private void swap(int[] nums, int a, int b) {\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}\n```\n\n","slug":"LeetCode/75颜色分类","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:22:15.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh4009jfhjiho9b4j88","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sort-colors/\">https://leetcode-cn.com/problems/sort-colors/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public void sortColors(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return;\n        &#125;\n        int p0 = 0, p2 = nums.length - 1;\n        for (int i = 0; i&lt;= p2;i++) &#123;\n            //当我们将nums[i]与nums[p2]进行交换之后，新的nums[i]可能仍然是2\n            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;\n                swap(nums, i, p2);\n                p2--;\n            &#125;\n            if (nums[i] == 0) &#123;\n                swap(nums, i, p0);\n                p0++;\n            &#125;\n        &#125;\n    &#125;\n    private void swap(int[] nums, int a, int b) &#123;\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/sort-colors/\">https://leetcode-cn.com/problems/sort-colors/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public void sortColors(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return;\n        &#125;\n        int p0 = 0, p2 = nums.length - 1;\n        for (int i = 0; i&lt;= p2;i++) &#123;\n            //当我们将nums[i]与nums[p2]进行交换之后，新的nums[i]可能仍然是2\n            while (i &lt;= p2 &amp;&amp; nums[i] == 2) &#123;\n                swap(nums, i, p2);\n                p2--;\n            &#125;\n            if (nums[i] == 0) &#123;\n                swap(nums, i, p0);\n                p0++;\n            &#125;\n        &#125;\n    &#125;\n    private void swap(int[] nums, int a, int b) &#123;\n        int temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"78子集","_content":"\n题目地址：https://leetcode-cn.com/problems/subsets/\n\n先加入一个空集让他成为新的子集，然后每遍历一个元素就在原来的子集的后面追加这个值\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201210140112.png\" style=\"zoom:50%;\" />\n\n```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        //先添加一个空的集合\n        result.add(new ArrayList<>());\n        for (int num : nums) {\n            //每遍历一个元素就在之前子集中的每个集合追加这个元素，让他变成新的子集\n            for (int i = 0, j = result.size(); i < j; i++) {\n                //遍历之前的子集，重新封装成一个新的子集\n                List<Integer> list = new ArrayList<>(result.get(i));\n                //然后在新的子集后面追加这个元素\n                list.add(num);\n                //把这个新的子集添加到集合中\n                result.add(list);\n            }\n        }\n        return result;\n    }\n}\n```\n\n","source":"_posts/LeetCode/78子集.md","raw":"---\ntitle: 78子集\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/subsets/\n\n先加入一个空集让他成为新的子集，然后每遍历一个元素就在原来的子集的后面追加这个值\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201210140112.png\" style=\"zoom:50%;\" />\n\n```java\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        //先添加一个空的集合\n        result.add(new ArrayList<>());\n        for (int num : nums) {\n            //每遍历一个元素就在之前子集中的每个集合追加这个元素，让他变成新的子集\n            for (int i = 0, j = result.size(); i < j; i++) {\n                //遍历之前的子集，重新封装成一个新的子集\n                List<Integer> list = new ArrayList<>(result.get(i));\n                //然后在新的子集后面追加这个元素\n                list.add(num);\n                //把这个新的子集添加到集合中\n                result.add(list);\n            }\n        }\n        return result;\n    }\n}\n```\n\n","slug":"LeetCode/78子集","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:22:20.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh5009mfhji24r9fa7u","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/subsets/\">https://leetcode-cn.com/problems/subsets/</a></p>\n<p>先加入一个空集让他成为新的子集，然后每遍历一个元素就在原来的子集的后面追加这个值</p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201210140112.png\" style=\"zoom:50%;\" />\n\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        //先添加一个空的集合\n        result.add(new ArrayList&lt;&gt;());\n        for (int num : nums) &#123;\n            //每遍历一个元素就在之前子集中的每个集合追加这个元素，让他变成新的子集\n            for (int i = 0, j = result.size(); i &lt; j; i++) &#123;\n                //遍历之前的子集，重新封装成一个新的子集\n                List&lt;Integer&gt; list = new ArrayList&lt;&gt;(result.get(i));\n                //然后在新的子集后面追加这个元素\n                list.add(num);\n                //把这个新的子集添加到集合中\n                result.add(list);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/subsets/\">https://leetcode-cn.com/problems/subsets/</a></p>\n<p>先加入一个空集让他成为新的子集，然后每遍历一个元素就在原来的子集的后面追加这个值</p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20201210140112.png\" style=\"zoom:50%;\" />\n\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        //先添加一个空的集合\n        result.add(new ArrayList&lt;&gt;());\n        for (int num : nums) &#123;\n            //每遍历一个元素就在之前子集中的每个集合追加这个元素，让他变成新的子集\n            for (int i = 0, j = result.size(); i &lt; j; i++) &#123;\n                //遍历之前的子集，重新封装成一个新的子集\n                List&lt;Integer&gt; list = new ArrayList&lt;&gt;(result.get(i));\n                //然后在新的子集后面追加这个元素\n                list.add(num);\n                //把这个新的子集添加到集合中\n                result.add(list);\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"7整数反转","_content":"\n题目地址：https://leetcode-cn.com/problems/reverse-integer/\n\n最大的值与最小的值为：`[−2^31, 2^31 − 1]`， 即：`[-2147483648, 2147483647]`\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int sum = 0;\n        while(x != 0) {\n            int last = x % 10;\n            if (sum > Integer.MAX_VALUE / 10 || (sum == Integer.MAX_VALUE / 10 && last > 7)) {\n                return 0;\n            }\n            if (sum < Integer.MIN_VALUE / 10 || (sum == Integer.MIN_VALUE / 10 && last < -8)) {\n                return 0;\n            }\n            sum = sum * 10 + last;\n            x = x / 10;\n        }\n        return sum;\n    }\n}\n```\n\n","source":"_posts/LeetCode/7整数反转.md","raw":"---\ntitle: 7整数反转\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/reverse-integer/\n\n最大的值与最小的值为：`[−2^31, 2^31 − 1]`， 即：`[-2147483648, 2147483647]`\n\n```java\nclass Solution {\n    public int reverse(int x) {\n        int sum = 0;\n        while(x != 0) {\n            int last = x % 10;\n            if (sum > Integer.MAX_VALUE / 10 || (sum == Integer.MAX_VALUE / 10 && last > 7)) {\n                return 0;\n            }\n            if (sum < Integer.MIN_VALUE / 10 || (sum == Integer.MIN_VALUE / 10 && last < -8)) {\n                return 0;\n            }\n            sum = sum * 10 + last;\n            x = x / 10;\n        }\n        return sum;\n    }\n}\n```\n\n","slug":"LeetCode/7整数反转","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2021-12-27T05:12:21.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh5009ofhji33qhhd6s","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-integer/\">https://leetcode-cn.com/problems/reverse-integer/</a></p>\n<p>最大的值与最小的值为：<code>[−2^31, 2^31 − 1]</code>， 即：<code>[-2147483648, 2147483647]</code></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int reverse(int x) &#123;\n        int sum = 0;\n        while(x != 0) &#123;\n            int last = x % 10;\n            if (sum &gt; Integer.MAX_VALUE / 10 || (sum == Integer.MAX_VALUE / 10 &amp;&amp; last &gt; 7)) &#123;\n                return 0;\n            &#125;\n            if (sum &lt; Integer.MIN_VALUE / 10 || (sum == Integer.MIN_VALUE / 10 &amp;&amp; last &lt; -8)) &#123;\n                return 0;\n            &#125;\n            sum = sum * 10 + last;\n            x = x / 10;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-integer/\">https://leetcode-cn.com/problems/reverse-integer/</a></p>\n<p>最大的值与最小的值为：<code>[−2^31, 2^31 − 1]</code>， 即：<code>[-2147483648, 2147483647]</code></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int reverse(int x) &#123;\n        int sum = 0;\n        while(x != 0) &#123;\n            int last = x % 10;\n            if (sum &gt; Integer.MAX_VALUE / 10 || (sum == Integer.MAX_VALUE / 10 &amp;&amp; last &gt; 7)) &#123;\n                return 0;\n            &#125;\n            if (sum &lt; Integer.MIN_VALUE / 10 || (sum == Integer.MIN_VALUE / 10 &amp;&amp; last &lt; -8)) &#123;\n                return 0;\n            &#125;\n            sum = sum * 10 + last;\n            x = x / 10;\n        &#125;\n        return sum;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"83删除排序链表中的重复元素","_content":"\n题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\n\n指定 cur 指针指向头部 head\n\n当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了\n\n当 `cur.val` 和 `cur.next.val` 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果\n\n如果不相等则 cur 移动到下一个位置继续循环\n\n时间复杂度：O(n)\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            if (cur.val == cur.next.val) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n","source":"_posts/LeetCode/83删除排序链表中的重复元素.md","raw":"---\ntitle: 83删除排序链表中的重复元素\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\n\n指定 cur 指针指向头部 head\n\n当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了\n\n当 `cur.val` 和 `cur.next.val` 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果\n\n如果不相等则 cur 移动到下一个位置继续循环\n\n时间复杂度：O(n)\n\n```java\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        ListNode cur = head;\n        while (cur != null && cur.next != null) {\n            if (cur.val == cur.next.val) {\n                cur.next = cur.next.next;\n            } else {\n                cur = cur.next;\n            }\n        }\n        return head;\n    }\n}\n```\n\n","slug":"LeetCode/83删除排序链表中的重复元素","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:22:25.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh6009rfhjicpt39frc","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p>\n<p>指定 cur 指针指向头部 head</p>\n<p>当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了</p>\n<p>当 <code>cur.val</code> 和 <code>cur.next.val</code> 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果</p>\n<p>如果不相等则 cur 移动到下一个位置继续循环</p>\n<p>时间复杂度：O(n)</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode deleteDuplicates(ListNode head) &#123;\n        ListNode cur = head;\n        while (cur != null &amp;&amp; cur.next != null) &#123;\n            if (cur.val == cur.next.val) &#123;\n                cur.next = cur.next.next;\n            &#125; else &#123;\n                cur = cur.next;\n            &#125;\n        &#125;\n        return head;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/\">https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/</a></p>\n<p>指定 cur 指针指向头部 head</p>\n<p>当 cur 和 cur.next 的存在为循环结束条件，当二者有一个不存在时说明链表没有去重复的必要了</p>\n<p>当 <code>cur.val</code> 和 <code>cur.next.val</code> 相等时说明需要去重，则将 cur 的下一个指针指向下一个的下一个，这样就能达到去重复的效果</p>\n<p>如果不相等则 cur 移动到下一个位置继续循环</p>\n<p>时间复杂度：O(n)</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode deleteDuplicates(ListNode head) &#123;\n        ListNode cur = head;\n        while (cur != null &amp;&amp; cur.next != null) &#123;\n            if (cur.val == cur.next.val) &#123;\n                cur.next = cur.next.next;\n            &#125; else &#123;\n                cur = cur.next;\n            &#125;\n        &#125;\n        return head;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"88合并两个有序数组","_content":"\n题目地址:https://leetcode-cn.com/problems/merge-sorted-array/\n\n因为 nums1 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去\n\n设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充\n\n当 len1<0 时遍历结束，此时 nums2 中还有数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组\n\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n - 1;\n        int p = n + m - 1;\n        while (p1 >= 0 && p2 >= 0) {\n            nums1[p--] = (nums1[p1] < nums2[p2] ? nums2[p2--] : nums1[p1--]);\n        }\n        while (p2 >= 0) {\n            nums1[p--] = nums2[p2--];\n        }\n    }\n}\n```\n\n","source":"_posts/LeetCode/88合并两个有序数组.md","raw":"---\ntitle: 88合并两个有序数组\ncategories: \n- LeetCode\n---\n\n题目地址:https://leetcode-cn.com/problems/merge-sorted-array/\n\n因为 nums1 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去\n\n设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充\n\n当 len1<0 时遍历结束，此时 nums2 中还有数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组\n\n```java\nclass Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n - 1;\n        int p = n + m - 1;\n        while (p1 >= 0 && p2 >= 0) {\n            nums1[p--] = (nums1[p1] < nums2[p2] ? nums2[p2--] : nums1[p1--]);\n        }\n        while (p2 >= 0) {\n            nums1[p--] = nums2[p2--];\n        }\n    }\n}\n```\n\n","slug":"LeetCode/88合并两个有序数组","published":1,"date":"2021-09-01T05:22:18.212Z","updated":"2022-01-28T16:22:30.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh7009tfhji0f2p9hld","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\">https://leetcode-cn.com/problems/merge-sorted-array/</a></p>\n<p>因为 nums1 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去</p>\n<p>设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充</p>\n<p>当 len1&lt;0 时遍历结束，此时 nums2 中还有数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组</p>\n<pre><code class=\"java\">class Solution &#123;\n    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;\n        int p1 = m - 1;\n        int p2 = n - 1;\n        int p = n + m - 1;\n        while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123;\n            nums1[p--] = (nums1[p1] &lt; nums2[p2] ? nums2[p2--] : nums1[p1--]);\n        &#125;\n        while (p2 &gt;= 0) &#123;\n            nums1[p--] = nums2[p2--];\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/merge-sorted-array/\">https://leetcode-cn.com/problems/merge-sorted-array/</a></p>\n<p>因为 nums1 的空间都集中在后面，所以从后向前处理排序的数据会更好，节省空间，一边遍历一边将值填充进去</p>\n<p>设置指针 len1 和 len2 分别指向 nums1 和 nums2 的有数字尾部，从尾部值开始比较遍历，同时设置指针 len 指向 nums1 的最末尾，每次遍历比较值大小之后，则进行填充</p>\n<p>当 len1&lt;0 时遍历结束，此时 nums2 中还有数据未拷贝完全，将其直接拷贝到 nums1 的前面，最后得到结果数组</p>\n<pre><code class=\"java\">class Solution &#123;\n    public void merge(int[] nums1, int m, int[] nums2, int n) &#123;\n        int p1 = m - 1;\n        int p2 = n - 1;\n        int p = n + m - 1;\n        while (p1 &gt;= 0 &amp;&amp; p2 &gt;= 0) &#123;\n            nums1[p--] = (nums1[p1] &lt; nums2[p2] ? nums2[p2--] : nums1[p1--]);\n        &#125;\n        while (p2 &gt;= 0) &#123;\n            nums1[p--] = nums2[p2--];\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"90子集II","_content":"\n题目地址：https://leetcode-cn.com/problems/subsets-ii/submissions/\n\n我们只需要判断当前数字和上一个数字是否相同，相同的话跳过即可。当然，要把数字首先进行排序\n\n```java\nclass Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    getResult(nums, 0, new ArrayList<>(), result);\n    return result;\n}\n\n    private void getResult(int[] nums, int start, ArrayList<Integer> temp, List<List<Integer>> result) {\n        result.add(new ArrayList<>(temp));\n        for (int i = start; i < nums.length; i++) {\n            //和上个数字相等就跳过\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            temp.add(nums[i]);\n            getResult(nums, i + 1, temp, result);\n            temp.remove(temp.size() - 1);\n        }\n    }\n}\n```\n\n","source":"_posts/LeetCode/90子集II.md","raw":"---\ntitle: 90子集II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/subsets-ii/submissions/\n\n我们只需要判断当前数字和上一个数字是否相同，相同的话跳过即可。当然，要把数字首先进行排序\n\n```java\nclass Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n    List<List<Integer>> result = new ArrayList<>();\n    Arrays.sort(nums);\n    getResult(nums, 0, new ArrayList<>(), result);\n    return result;\n}\n\n    private void getResult(int[] nums, int start, ArrayList<Integer> temp, List<List<Integer>> result) {\n        result.add(new ArrayList<>(temp));\n        for (int i = start; i < nums.length; i++) {\n            //和上个数字相等就跳过\n            if (i > start && nums[i] == nums[i - 1]) {\n                continue;\n            }\n            temp.add(nums[i]);\n            getResult(nums, i + 1, temp, result);\n            temp.remove(temp.size() - 1);\n        }\n    }\n}\n```\n\n","slug":"LeetCode/90子集II","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T16:22:34.197Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh8009wfhji5tujb5ul","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/subsets-ii/submissions/\">https://leetcode-cn.com/problems/subsets-ii/submissions/</a></p>\n<p>我们只需要判断当前数字和上一个数字是否相同，相同的话跳过即可。当然，要把数字首先进行排序</p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n    Arrays.sort(nums);\n    getResult(nums, 0, new ArrayList&lt;&gt;(), result);\n    return result;\n&#125;\n\n    private void getResult(int[] nums, int start, ArrayList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; result) &#123;\n        result.add(new ArrayList&lt;&gt;(temp));\n        for (int i = start; i &lt; nums.length; i++) &#123;\n            //和上个数字相等就跳过\n            if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            temp.add(nums[i]);\n            getResult(nums, i + 1, temp, result);\n            temp.remove(temp.size() - 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/subsets-ii/submissions/\">https://leetcode-cn.com/problems/subsets-ii/submissions/</a></p>\n<p>我们只需要判断当前数字和上一个数字是否相同，相同的话跳过即可。当然，要把数字首先进行排序</p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; subsetsWithDup(int[] nums) &#123;\n    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n    Arrays.sort(nums);\n    getResult(nums, 0, new ArrayList&lt;&gt;(), result);\n    return result;\n&#125;\n\n    private void getResult(int[] nums, int start, ArrayList&lt;Integer&gt; temp, List&lt;List&lt;Integer&gt;&gt; result) &#123;\n        result.add(new ArrayList&lt;&gt;(temp));\n        for (int i = start; i &lt; nums.length; i++) &#123;\n            //和上个数字相等就跳过\n            if (i &gt; start &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            temp.add(nums[i]);\n            getResult(nums, i + 1, temp, result);\n            temp.remove(temp.size() - 1);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"92反转链表II","_content":"\n题目地址：https://leetcode-cn.com/problems/reverse-linked-list-ii/\n\n第一步：找到待反转节点的前一个节点。\n\n第二步：反转m到n这部分。\n\n第三步：将反转的起点的next指向反转的后面一部分。\n\n第四步：将第一步找到的节点指向反转以后的头节点。\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210103192432.png\" style=\"zoom:50%;\" />\n\n```java\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        ListNode res = new ListNode(0);\n        res.next = head;\n        ListNode node = res;\n        //找到需要反转的那一段的上一个节点\n        for (int i = 1; i < m; i++) {\n            node = node.next;\n        }\n        //node.next就是需要反转的这段的起点\n        ListNode nextHead = node.next;\n        ListNode next = null;\n        ListNode pre = null;\n        //反转m到n这一段\n        for (int i = m; i <= n; i++) {\n            next = nextHead.next;\n            nextHead.next = pre;\n            pre = nextHead;\n            nextHead = next;\n        }\n        //将反转的起点的next指向next\n        node.next.next = next;\n        //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点\n        node.next = pre;\n        return res.next;\n    }\n}\n```\n\n","source":"_posts/LeetCode/92反转链表II.md","raw":"---\ntitle: 92反转链表II\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/reverse-linked-list-ii/\n\n第一步：找到待反转节点的前一个节点。\n\n第二步：反转m到n这部分。\n\n第三步：将反转的起点的next指向反转的后面一部分。\n\n第四步：将第一步找到的节点指向反转以后的头节点。\n\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210103192432.png\" style=\"zoom:50%;\" />\n\n```java\nclass Solution {\n    public ListNode reverseBetween(ListNode head, int m, int n) {\n        ListNode res = new ListNode(0);\n        res.next = head;\n        ListNode node = res;\n        //找到需要反转的那一段的上一个节点\n        for (int i = 1; i < m; i++) {\n            node = node.next;\n        }\n        //node.next就是需要反转的这段的起点\n        ListNode nextHead = node.next;\n        ListNode next = null;\n        ListNode pre = null;\n        //反转m到n这一段\n        for (int i = m; i <= n; i++) {\n            next = nextHead.next;\n            nextHead.next = pre;\n            pre = nextHead;\n            nextHead = next;\n        }\n        //将反转的起点的next指向next\n        node.next.next = next;\n        //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点\n        node.next = pre;\n        return res.next;\n    }\n}\n```\n\n","slug":"LeetCode/92反转链表II","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T16:22:38.004Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh8009yfhji3zgi7kon","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/\">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a></p>\n<p>第一步：找到待反转节点的前一个节点。</p>\n<p>第二步：反转m到n这部分。</p>\n<p>第三步：将反转的起点的next指向反转的后面一部分。</p>\n<p>第四步：将第一步找到的节点指向反转以后的头节点。</p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210103192432.png\" style=\"zoom:50%;\" />\n\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseBetween(ListNode head, int m, int n) &#123;\n        ListNode res = new ListNode(0);\n        res.next = head;\n        ListNode node = res;\n        //找到需要反转的那一段的上一个节点\n        for (int i = 1; i &lt; m; i++) &#123;\n            node = node.next;\n        &#125;\n        //node.next就是需要反转的这段的起点\n        ListNode nextHead = node.next;\n        ListNode next = null;\n        ListNode pre = null;\n        //反转m到n这一段\n        for (int i = m; i &lt;= n; i++) &#123;\n            next = nextHead.next;\n            nextHead.next = pre;\n            pre = nextHead;\n            nextHead = next;\n        &#125;\n        //将反转的起点的next指向next\n        node.next.next = next;\n        //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点\n        node.next = pre;\n        return res.next;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/reverse-linked-list-ii/\">https://leetcode-cn.com/problems/reverse-linked-list-ii/</a></p>\n<p>第一步：找到待反转节点的前一个节点。</p>\n<p>第二步：反转m到n这部分。</p>\n<p>第三步：将反转的起点的next指向反转的后面一部分。</p>\n<p>第四步：将第一步找到的节点指向反转以后的头节点。</p>\n<img src=\"https://xiaoflyfish.oss-cn-beijing.aliyuncs.com/image/20210103192432.png\" style=\"zoom:50%;\" />\n\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseBetween(ListNode head, int m, int n) &#123;\n        ListNode res = new ListNode(0);\n        res.next = head;\n        ListNode node = res;\n        //找到需要反转的那一段的上一个节点\n        for (int i = 1; i &lt; m; i++) &#123;\n            node = node.next;\n        &#125;\n        //node.next就是需要反转的这段的起点\n        ListNode nextHead = node.next;\n        ListNode next = null;\n        ListNode pre = null;\n        //反转m到n这一段\n        for (int i = m; i &lt;= n; i++) &#123;\n            next = nextHead.next;\n            nextHead.next = pre;\n            pre = nextHead;\n            nextHead = next;\n        &#125;\n        //将反转的起点的next指向next\n        node.next.next = next;\n        //需要反转的那一段的上一个节点的next节点指向反转后链表的头结点\n        node.next = pre;\n        return res.next;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"94二叉树的中序遍历","_content":"\n题目地址：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\n\n# 递归\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        inorder(root, result);\n        return result;\n    }\n    private void inorder(TreeNode root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left, result);\n        result.add(root.val);\n        inorder(root.right, result);\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n\n空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。\n\n# 栈\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        while(root != null || !stack.isEmpty()) {\n            while(root!=null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            result.add(root.val);\n            root = root.right;\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n\n空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。","source":"_posts/LeetCode/94二叉树的中序遍历.md","raw":"---\ntitle: 94二叉树的中序遍历\ncategories:\n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\n\n# 递归\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        inorder(root, result);\n        return result;\n    }\n    private void inorder(TreeNode root, List<Integer> result) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left, result);\n        result.add(root.val);\n        inorder(root.right, result);\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n\n空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。\n\n# 栈\n\n```java\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        Stack<TreeNode> stack = new Stack<>();\n        while(root != null || !stack.isEmpty()) {\n            while(root!=null) {\n                stack.push(root);\n                root = root.left;\n            }\n            root = stack.pop();\n            result.add(root.val);\n            root = root.right;\n        }\n        return result;\n    }\n}\n```\n\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。\n\n空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。","slug":"LeetCode/94二叉树的中序遍历","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T16:22:42.266Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwh900a1fhji2env415r","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        inorder(root, result);\n        return result;\n    &#125;\n    private void inorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        inorder(root.left, result);\n        result.add(root.val);\n        inorder(root.right, result);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>\n<p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        while(root != null || !stack.isEmpty()) &#123;\n            while(root!=null) &#123;\n                stack.push(root);\n                root = root.left;\n            &#125;\n            root = stack.pop();\n            result.add(root.val);\n            root = root.right;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>\n<p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/binary-tree-inorder-traversal/\">https://leetcode-cn.com/problems/binary-tree-inorder-traversal/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        inorder(root, result);\n        return result;\n    &#125;\n    private void inorder(TreeNode root, List&lt;Integer&gt; result) &#123;\n        if (root == null) &#123;\n            return;\n        &#125;\n        inorder(root.left, result);\n        result.add(root.val);\n        inorder(root.right, result);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>\n<p>空间复杂度：O(n)。空间复杂度取决于递归的栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>\n<h1 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h1><pre><code class=\"java\">class Solution &#123;\n    public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;\n        List&lt;Integer&gt; result = new ArrayList&lt;&gt;();\n        Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n        while(root != null || !stack.isEmpty()) &#123;\n            while(root!=null) &#123;\n                stack.push(root);\n                root = root.left;\n            &#125;\n            root = stack.pop();\n            result.add(root.val);\n            root = root.right;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度：O(n)，其中 n 为二叉树节点的个数。二叉树的遍历中每个节点会被访问一次且只会被访问一次。</p>\n<p>空间复杂度：O(n)。空间复杂度取决于栈深度，而栈深度在二叉树为一条链的情况下会达到 O(n) 的级别。</p>\n"},{"title":"98验证二叉搜索树","_content":"\n题目地址：https://leetcode-cn.com/problems/validate-binary-search-tree/\n\n中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false\n\n```java\nclass Solution {\n    long pre = Long.MIN_VALUE;\n    public boolean isValidBST(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        // 访问左子树\n        if (!isValidBST(root.left)) {\n            return false;\n        }\n        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回false，否则继续遍历\n        if (root.val <= pre) {\n            return false;\n        }\n        pre = root.val;\n        // 访问右子树\n        return isValidBST(root.right);\n    }\n}\n```\n\n","source":"_posts/LeetCode/98验证二叉搜索树.md","raw":"---\ntitle: 98验证二叉搜索树\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/validate-binary-search-tree/\n\n中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false\n\n```java\nclass Solution {\n    long pre = Long.MIN_VALUE;\n    public boolean isValidBST(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        // 访问左子树\n        if (!isValidBST(root.left)) {\n            return false;\n        }\n        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回false，否则继续遍历\n        if (root.val <= pre) {\n            return false;\n        }\n        pre = root.val;\n        // 访问右子树\n        return isValidBST(root.right);\n    }\n}\n```\n\n","slug":"LeetCode/98验证二叉搜索树","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T16:22:46.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwha00a3fhji3wzl3vf6","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p>\n<p>中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false</p>\n<pre><code class=\"java\">class Solution &#123;\n    long pre = Long.MIN_VALUE;\n    public boolean isValidBST(TreeNode root) &#123;\n        if (root == null) &#123;\n            return true;\n        &#125;\n        // 访问左子树\n        if (!isValidBST(root.left)) &#123;\n            return false;\n        &#125;\n        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回false，否则继续遍历\n        if (root.val &lt;= pre) &#123;\n            return false;\n        &#125;\n        pre = root.val;\n        // 访问右子树\n        return isValidBST(root.right);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/validate-binary-search-tree/\">https://leetcode-cn.com/problems/validate-binary-search-tree/</a></p>\n<p>中序遍历时，判断当前节点是否大于中序遍历的前一个节点，如果大于，说明满足 BST，继续遍历；否则直接返回 false</p>\n<pre><code class=\"java\">class Solution &#123;\n    long pre = Long.MIN_VALUE;\n    public boolean isValidBST(TreeNode root) &#123;\n        if (root == null) &#123;\n            return true;\n        &#125;\n        // 访问左子树\n        if (!isValidBST(root.left)) &#123;\n            return false;\n        &#125;\n        // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回false，否则继续遍历\n        if (root.val &lt;= pre) &#123;\n            return false;\n        &#125;\n        pre = root.val;\n        // 访问右子树\n        return isValidBST(root.right);\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"9回文数","_content":"\n题目地址：https://leetcode-cn.com/problems/palindrome-number/\n\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        // 特殊情况：\n        // 当 x < 0 时，x 不是回文数\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 如果是偶数的话，revertNum 和 x 相等；\n        // 如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。\n\n* 空间复杂度：O(1)。我们只需要常数空间存放若干变量。","source":"_posts/LeetCode/9回文数.md","raw":"---\ntitle: 9回文数\ncategories: \n- LeetCode\n---\n\n题目地址：https://leetcode-cn.com/problems/palindrome-number/\n\n```java\nclass Solution {\n    public boolean isPalindrome(int x) {\n        // 特殊情况：\n        // 当 x < 0 时，x 不是回文数\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int revertedNumber = 0;\n        while (x > revertedNumber) {\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        }\n\n        // 如果是偶数的话，revertNum 和 x 相等；\n        // 如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n        return x == revertedNumber || x == revertedNumber / 10;\n    }\n}\n```\n\n**复杂度分析**\n\n* 时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。\n\n* 空间复杂度：O(1)。我们只需要常数空间存放若干变量。","slug":"LeetCode/9回文数","published":1,"date":"2021-11-28T04:32:03.654Z","updated":"2021-12-28T01:09:53.478Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwha00a6fhji89z2bndf","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/palindrome-number/\">https://leetcode-cn.com/problems/palindrome-number/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isPalindrome(int x) &#123;\n        // 特殊情况：\n        // 当 x &lt; 0 时，x 不是回文数\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;\n            return false;\n        &#125;\n\n        int revertedNumber = 0;\n        while (x &gt; revertedNumber) &#123;\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        &#125;\n\n        // 如果是偶数的话，revertNum 和 x 相等；\n        // 如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n        return x == revertedNumber || x == revertedNumber / 10;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。</p>\n</li>\n<li><p>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/palindrome-number/\">https://leetcode-cn.com/problems/palindrome-number/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isPalindrome(int x) &#123;\n        // 特殊情况：\n        // 当 x &lt; 0 时，x 不是回文数\n        // 同样地，如果数字的最后一位是 0，为了使该数字为回文\n        // 则其第一位数字也应该是 0\n        // 只有 0 满足这一属性\n        if (x &lt; 0 || (x % 10 == 0 &amp;&amp; x != 0)) &#123;\n            return false;\n        &#125;\n\n        int revertedNumber = 0;\n        while (x &gt; revertedNumber) &#123;\n            revertedNumber = revertedNumber * 10 + x % 10;\n            x /= 10;\n        &#125;\n\n        // 如果是偶数的话，revertNum 和 x 相等；\n        // 如果是奇数的话，最中间的数字就在revertNum 的最低位上，将它除以 10 以后应该和 x 相等。\n        return x == revertedNumber || x == revertedNumber / 10;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>复杂度分析</strong></p>\n<ul>\n<li><p>时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)。</p>\n</li>\n<li><p>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p>\n</li>\n</ul>\n"},{"title":"变量","_content":"\n**变量命名规范**\n\n在Bash中，变量的默认类型都是字符串型，定义 `name = 'kk'`\n\n**变量分类**\n\n- 用户自定义变量。变量自定义的。\n- 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的。\n- 位置参数变量：这种变量主要是用来向脚本当中传递参数或者数据的，变量名不能自定义，变量作用是固定的。\n- 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。\n\n**变量调用**\n\n```bash\necho $变量名\n例如：\n echo $x\n echo $name\n```\n\n**变量叠加**\n\n```ini\nx = 123\nx = \"$x\"456\nx = ${x}789\n```\n\n**变量查看**\n\n```bash\nset \n```\n\n**删除变量**\n\n使用 **unset** 命令可以删除变量。\n\n```bash\nunset variable_name\n```\n\n**设置环境变量**\n\n```bash\nexport 变量名 = 变量值\n\n或：\n变量名 = 变量名\nexport 变量名\n```\n\n**常用环境变量**\n\n```makefile\nbash-4.1$ env\nHOSTNAME=iZ2zebwk59ftsrtzd05mpzZ 主机名\nSHELL=/bin/bash  当前的shell\nTERM=xterm  终端环境\nHISTSIZE=1000   历史命令条数\nSSH_CLIENT=114.247.188.89 14320 60022  当前操作环境使用ssh连接的，这里记录客户端ip\nOLDPWD=/home/chenjinxin  \nSSH_TTY=/dev/pts/0  ssh连接的终端是pts/1\nUSER=program  当前登录的用户\n```\n\n**PATH环境变量**\n\n```bash\nPATH变量：系统查找命令的路径\n\nbash-4.1$ echo $PATH\n/usr/local/server/node/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/chenjinxin/bin\n\necho $PATH  \n#查看PATH环境变量\nPATH = \"$PATH\":/root/sh\n#临时添加PATH变量的值\n```\n\n**位置参数变量**\n\n| 位置参数变量 | 作用                                                         |\n| ------------ | ------------------------------------------------------------ |\n| $n           | n为数字，`$0`代表命令本身，`$1-$9`代表第一到第九个参数，十以上的参数需要用大括号包含，如`${10}` |\n| $*           | 代表命令行中所有的参数，`$*`把所有的参数看成一个整体         |\n| $@           | 代表命令行中所有的参数，不过`$@`把每个参数区分对待           |\n| $#           | 代表命令行中所有参数的个数                                   |\n\n例子1：\n\n```bash\n#!/bin/bash\nnum1 = $1\nnum2 = $2\nsum = $(($num1+$num2))\necho $sum\n```\n\n**预定义变量**\n\n| 预定义变量 | 作用                                                         |\n| ---------- | ------------------------------------------------------------ |\n| $?         | 最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0，则证明上一个命令执行不正确 |\n| $$         | 当前进程的进程号（PID）                                      |\n| $!         | 后台运行的最后一个进程的进程号（PID）                        |\n\n**接受键盘输入**\n\n`read [选项][变量名]`\n\n- -p \"提示信息\"： 在等待read输入时，输出提示信息\n- -t 秒数： read命令会一直等待用户输入，使用此选项可以指定等待时间\n- -n 字符数： read命令只接受指定的字符数，就会执行\n- -s 隐藏输入的数据，适用于机密信息的输入\n\n```bash\n#!/bin/bash  \nread -p \"Enter your name : \" name  \necho \"Hi, $name. Let us be friends!\" \n```","source":"_posts/Shell脚本编程大全/变量.md","raw":"---\ntitle: 变量\ncategories: \n- Shell脚本编程大全\n---\n\n**变量命名规范**\n\n在Bash中，变量的默认类型都是字符串型，定义 `name = 'kk'`\n\n**变量分类**\n\n- 用户自定义变量。变量自定义的。\n- 环境变量：这种变量中主要保存的是和系统操作环境相关的数据。变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的。\n- 位置参数变量：这种变量主要是用来向脚本当中传递参数或者数据的，变量名不能自定义，变量作用是固定的。\n- 预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。\n\n**变量调用**\n\n```bash\necho $变量名\n例如：\n echo $x\n echo $name\n```\n\n**变量叠加**\n\n```ini\nx = 123\nx = \"$x\"456\nx = ${x}789\n```\n\n**变量查看**\n\n```bash\nset \n```\n\n**删除变量**\n\n使用 **unset** 命令可以删除变量。\n\n```bash\nunset variable_name\n```\n\n**设置环境变量**\n\n```bash\nexport 变量名 = 变量值\n\n或：\n变量名 = 变量名\nexport 变量名\n```\n\n**常用环境变量**\n\n```makefile\nbash-4.1$ env\nHOSTNAME=iZ2zebwk59ftsrtzd05mpzZ 主机名\nSHELL=/bin/bash  当前的shell\nTERM=xterm  终端环境\nHISTSIZE=1000   历史命令条数\nSSH_CLIENT=114.247.188.89 14320 60022  当前操作环境使用ssh连接的，这里记录客户端ip\nOLDPWD=/home/chenjinxin  \nSSH_TTY=/dev/pts/0  ssh连接的终端是pts/1\nUSER=program  当前登录的用户\n```\n\n**PATH环境变量**\n\n```bash\nPATH变量：系统查找命令的路径\n\nbash-4.1$ echo $PATH\n/usr/local/server/node/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/chenjinxin/bin\n\necho $PATH  \n#查看PATH环境变量\nPATH = \"$PATH\":/root/sh\n#临时添加PATH变量的值\n```\n\n**位置参数变量**\n\n| 位置参数变量 | 作用                                                         |\n| ------------ | ------------------------------------------------------------ |\n| $n           | n为数字，`$0`代表命令本身，`$1-$9`代表第一到第九个参数，十以上的参数需要用大括号包含，如`${10}` |\n| $*           | 代表命令行中所有的参数，`$*`把所有的参数看成一个整体         |\n| $@           | 代表命令行中所有的参数，不过`$@`把每个参数区分对待           |\n| $#           | 代表命令行中所有参数的个数                                   |\n\n例子1：\n\n```bash\n#!/bin/bash\nnum1 = $1\nnum2 = $2\nsum = $(($num1+$num2))\necho $sum\n```\n\n**预定义变量**\n\n| 预定义变量 | 作用                                                         |\n| ---------- | ------------------------------------------------------------ |\n| $?         | 最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0，则证明上一个命令执行不正确 |\n| $$         | 当前进程的进程号（PID）                                      |\n| $!         | 后台运行的最后一个进程的进程号（PID）                        |\n\n**接受键盘输入**\n\n`read [选项][变量名]`\n\n- -p \"提示信息\"： 在等待read输入时，输出提示信息\n- -t 秒数： read命令会一直等待用户输入，使用此选项可以指定等待时间\n- -n 字符数： read命令只接受指定的字符数，就会执行\n- -s 隐藏输入的数据，适用于机密信息的输入\n\n```bash\n#!/bin/bash  \nread -p \"Enter your name : \" name  \necho \"Hi, $name. Let us be friends!\" \n```","slug":"Shell脚本编程大全/变量","published":1,"date":"2022-02-20T01:43:43.902Z","updated":"2022-02-20T01:48:29.661Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwi100cefhji6gmaecer","content":"<p><strong>变量命名规范</strong></p>\n<p>在Bash中，变量的默认类型都是字符串型，定义 <code>name = &#39;kk&#39;</code></p>\n<p><strong>变量分类</strong></p>\n<ul>\n<li>用户自定义变量。变量自定义的。</li>\n<li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的。</li>\n<li>位置参数变量：这种变量主要是用来向脚本当中传递参数或者数据的，变量名不能自定义，变量作用是固定的。</li>\n<li>预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li>\n</ul>\n<p><strong>变量调用</strong></p>\n<pre><code class=\"bash\">echo $变量名\n例如：\n echo $x\n echo $name\n</code></pre>\n<p><strong>变量叠加</strong></p>\n<pre><code class=\"ini\">x = 123\nx = &quot;$x&quot;456\nx = $&#123;x&#125;789\n</code></pre>\n<p><strong>变量查看</strong></p>\n<pre><code class=\"bash\">set \n</code></pre>\n<p><strong>删除变量</strong></p>\n<p>使用 <strong>unset</strong> 命令可以删除变量。</p>\n<pre><code class=\"bash\">unset variable_name\n</code></pre>\n<p><strong>设置环境变量</strong></p>\n<pre><code class=\"bash\">export 变量名 = 变量值\n\n或：\n变量名 = 变量名\nexport 变量名\n</code></pre>\n<p><strong>常用环境变量</strong></p>\n<pre><code class=\"makefile\">bash-4.1$ env\nHOSTNAME=iZ2zebwk59ftsrtzd05mpzZ 主机名\nSHELL=/bin/bash  当前的shell\nTERM=xterm  终端环境\nHISTSIZE=1000   历史命令条数\nSSH_CLIENT=114.247.188.89 14320 60022  当前操作环境使用ssh连接的，这里记录客户端ip\nOLDPWD=/home/chenjinxin  \nSSH_TTY=/dev/pts/0  ssh连接的终端是pts/1\nUSER=program  当前登录的用户\n</code></pre>\n<p><strong>PATH环境变量</strong></p>\n<pre><code class=\"bash\">PATH变量：系统查找命令的路径\n\nbash-4.1$ echo $PATH\n/usr/local/server/node/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/chenjinxin/bin\n\necho $PATH  \n#查看PATH环境变量\nPATH = &quot;$PATH&quot;:/root/sh\n#临时添加PATH变量的值\n</code></pre>\n<p><strong>位置参数变量</strong></p>\n<table>\n<thead>\n<tr>\n<th>位置参数变量</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$n</td>\n<td>n为数字，<code>$0</code>代表命令本身，<code>$1-$9</code>代表第一到第九个参数，十以上的参数需要用大括号包含，如<code>$&#123;10&#125;</code></td>\n</tr>\n<tr>\n<td>$*</td>\n<td>代表命令行中所有的参数，<code>$*</code>把所有的参数看成一个整体</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>代表命令行中所有的参数，不过<code>$@</code>把每个参数区分对待</td>\n</tr>\n<tr>\n<td>$#</td>\n<td>代表命令行中所有参数的个数</td>\n</tr>\n</tbody></table>\n<p>例子1：</p>\n<pre><code class=\"bash\">#!/bin/bash\nnum1 = $1\nnum2 = $2\nsum = $(($num1+$num2))\necho $sum\n</code></pre>\n<p><strong>预定义变量</strong></p>\n<table>\n<thead>\n<tr>\n<th>预定义变量</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$?</td>\n<td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0，则证明上一个命令执行不正确</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前进程的进程号（PID）</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>后台运行的最后一个进程的进程号（PID）</td>\n</tr>\n</tbody></table>\n<p><strong>接受键盘输入</strong></p>\n<p><code>read [选项][变量名]</code></p>\n<ul>\n<li>-p “提示信息”： 在等待read输入时，输出提示信息</li>\n<li>-t 秒数： read命令会一直等待用户输入，使用此选项可以指定等待时间</li>\n<li>-n 字符数： read命令只接受指定的字符数，就会执行</li>\n<li>-s 隐藏输入的数据，适用于机密信息的输入</li>\n</ul>\n<pre><code class=\"bash\">#!/bin/bash  \nread -p &quot;Enter your name : &quot; name  \necho &quot;Hi, $name. Let us be friends!&quot; \n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>变量命名规范</strong></p>\n<p>在Bash中，变量的默认类型都是字符串型，定义 <code>name = &#39;kk&#39;</code></p>\n<p><strong>变量分类</strong></p>\n<ul>\n<li>用户自定义变量。变量自定义的。</li>\n<li>环境变量：这种变量中主要保存的是和系统操作环境相关的数据。变量可以自定义，但是对系统生效的环境变量名和变量作用是固定的。</li>\n<li>位置参数变量：这种变量主要是用来向脚本当中传递参数或者数据的，变量名不能自定义，变量作用是固定的。</li>\n<li>预定义变量：是Bash中已经定义好的变量，变量名不能自定义，变量作用也是固定的。</li>\n</ul>\n<p><strong>变量调用</strong></p>\n<pre><code class=\"bash\">echo $变量名\n例如：\n echo $x\n echo $name\n</code></pre>\n<p><strong>变量叠加</strong></p>\n<pre><code class=\"ini\">x = 123\nx = &quot;$x&quot;456\nx = $&#123;x&#125;789\n</code></pre>\n<p><strong>变量查看</strong></p>\n<pre><code class=\"bash\">set \n</code></pre>\n<p><strong>删除变量</strong></p>\n<p>使用 <strong>unset</strong> 命令可以删除变量。</p>\n<pre><code class=\"bash\">unset variable_name\n</code></pre>\n<p><strong>设置环境变量</strong></p>\n<pre><code class=\"bash\">export 变量名 = 变量值\n\n或：\n变量名 = 变量名\nexport 变量名\n</code></pre>\n<p><strong>常用环境变量</strong></p>\n<pre><code class=\"makefile\">bash-4.1$ env\nHOSTNAME=iZ2zebwk59ftsrtzd05mpzZ 主机名\nSHELL=/bin/bash  当前的shell\nTERM=xterm  终端环境\nHISTSIZE=1000   历史命令条数\nSSH_CLIENT=114.247.188.89 14320 60022  当前操作环境使用ssh连接的，这里记录客户端ip\nOLDPWD=/home/chenjinxin  \nSSH_TTY=/dev/pts/0  ssh连接的终端是pts/1\nUSER=program  当前登录的用户\n</code></pre>\n<p><strong>PATH环境变量</strong></p>\n<pre><code class=\"bash\">PATH变量：系统查找命令的路径\n\nbash-4.1$ echo $PATH\n/usr/local/server/node/bin:/usr/local/bin:/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/sbin:/home/chenjinxin/bin\n\necho $PATH  \n#查看PATH环境变量\nPATH = &quot;$PATH&quot;:/root/sh\n#临时添加PATH变量的值\n</code></pre>\n<p><strong>位置参数变量</strong></p>\n<table>\n<thead>\n<tr>\n<th>位置参数变量</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$n</td>\n<td>n为数字，<code>$0</code>代表命令本身，<code>$1-$9</code>代表第一到第九个参数，十以上的参数需要用大括号包含，如<code>$&#123;10&#125;</code></td>\n</tr>\n<tr>\n<td>$*</td>\n<td>代表命令行中所有的参数，<code>$*</code>把所有的参数看成一个整体</td>\n</tr>\n<tr>\n<td>$@</td>\n<td>代表命令行中所有的参数，不过<code>$@</code>把每个参数区分对待</td>\n</tr>\n<tr>\n<td>$#</td>\n<td>代表命令行中所有参数的个数</td>\n</tr>\n</tbody></table>\n<p>例子1：</p>\n<pre><code class=\"bash\">#!/bin/bash\nnum1 = $1\nnum2 = $2\nsum = $(($num1+$num2))\necho $sum\n</code></pre>\n<p><strong>预定义变量</strong></p>\n<table>\n<thead>\n<tr>\n<th>预定义变量</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>$?</td>\n<td>最后一次执行的命令的返回状态。如果这个变量的值为0，证明上一个命令正确执行；如果这个变量的值为非0，则证明上一个命令执行不正确</td>\n</tr>\n<tr>\n<td>$$</td>\n<td>当前进程的进程号（PID）</td>\n</tr>\n<tr>\n<td>$!</td>\n<td>后台运行的最后一个进程的进程号（PID）</td>\n</tr>\n</tbody></table>\n<p><strong>接受键盘输入</strong></p>\n<p><code>read [选项][变量名]</code></p>\n<ul>\n<li>-p “提示信息”： 在等待read输入时，输出提示信息</li>\n<li>-t 秒数： read命令会一直等待用户输入，使用此选项可以指定等待时间</li>\n<li>-n 字符数： read命令只接受指定的字符数，就会执行</li>\n<li>-s 隐藏输入的数据，适用于机密信息的输入</li>\n</ul>\n<pre><code class=\"bash\">#!/bin/bash  \nread -p &quot;Enter your name : &quot; name  \necho &quot;Hi, $name. Let us be friends!&quot; \n</code></pre>\n"},{"title":"基础知识","_content":"\nShell是一个命令行解释器，为用户提供了一个向Linux内核发送请求，以便程序运行的界面系统级程序，用户可以用Shell来启动，挂起，停止程序，甚至编写一些程序。\n\nShell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。\n\n* Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。\n\n**Echo输出命令：**\n\nShell 的 echo 指令 用于字符串的输出。\n\n命令格式：\n\n```css\necho [选项][输出内容]\n选项：\n-e ： 支持反斜线控制的字符串转换\n```\n显示普通字符串：\n\n```\necho \"It is a test\"\n```\n\n显示换行：\n\n```\necho -e \"OK!\\n\" # -e 开启转义\necho \"It it a test\"\n```\n\n| 控制字符 | 作用                                                      |\n| -------- | --------------------------------------------------------- |\n| \\a       | 输出警告音                                                |\n| \\b       | 退格键，也就是像左删除健                                  |\n| \\n       | 换行符                                                    |\n| \\r       | 回车健                                                    |\n| \\t       | 制表符，也就是tab                                         |\n| \\v       | 垂直制表符                                                |\n| \\0nnn    | 按照八进制acsii表输出字符，其中0未数字零，nnn是三位八进制 |\n| \\xhh     | 安卓十六进制输出输出字符                                  |\n\n**第一个脚本：**\n\n```bash\n#!/bin/bash\necho \"hello shell!\" # 打印字符串“hello shell!”\n```\n\n在shell脚本中，#开始的行代表注释！\n\n**脚本执行：**\n\n赋予执行权限，直接运行\n\n```\nchmod 755 hello.sh\n./hello.sh\n```\n\n通过bash调用执行脚本\n\n```\nbash hello.sh\n```","source":"_posts/Shell脚本编程大全/基础知识.md","raw":"---\ntitle: 基础知识\ncategories: \n- Shell脚本编程大全\n---\n\nShell是一个命令行解释器，为用户提供了一个向Linux内核发送请求，以便程序运行的界面系统级程序，用户可以用Shell来启动，挂起，停止程序，甚至编写一些程序。\n\nShell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。\n\n* Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。\n\n**Echo输出命令：**\n\nShell 的 echo 指令 用于字符串的输出。\n\n命令格式：\n\n```css\necho [选项][输出内容]\n选项：\n-e ： 支持反斜线控制的字符串转换\n```\n显示普通字符串：\n\n```\necho \"It is a test\"\n```\n\n显示换行：\n\n```\necho -e \"OK!\\n\" # -e 开启转义\necho \"It it a test\"\n```\n\n| 控制字符 | 作用                                                      |\n| -------- | --------------------------------------------------------- |\n| \\a       | 输出警告音                                                |\n| \\b       | 退格键，也就是像左删除健                                  |\n| \\n       | 换行符                                                    |\n| \\r       | 回车健                                                    |\n| \\t       | 制表符，也就是tab                                         |\n| \\v       | 垂直制表符                                                |\n| \\0nnn    | 按照八进制acsii表输出字符，其中0未数字零，nnn是三位八进制 |\n| \\xhh     | 安卓十六进制输出输出字符                                  |\n\n**第一个脚本：**\n\n```bash\n#!/bin/bash\necho \"hello shell!\" # 打印字符串“hello shell!”\n```\n\n在shell脚本中，#开始的行代表注释！\n\n**脚本执行：**\n\n赋予执行权限，直接运行\n\n```\nchmod 755 hello.sh\n./hello.sh\n```\n\n通过bash调用执行脚本\n\n```\nbash hello.sh\n```","slug":"Shell脚本编程大全/基础知识","published":1,"date":"2022-02-19T06:51:54.948Z","updated":"2022-02-19T08:54:10.733Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwi200cgfhji858s9ujf","content":"<p>Shell是一个命令行解释器，为用户提供了一个向Linux内核发送请求，以便程序运行的界面系统级程序，用户可以用Shell来启动，挂起，停止程序，甚至编写一些程序。</p>\n<p>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。</p>\n<ul>\n<li>Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。</li>\n</ul>\n<p><strong>Echo输出命令：</strong></p>\n<p>Shell 的 echo 指令 用于字符串的输出。</p>\n<p>命令格式：</p>\n<pre><code class=\"css\">echo [选项][输出内容]\n选项：\n-e ： 支持反斜线控制的字符串转换\n</code></pre>\n<p>显示普通字符串：</p>\n<pre><code>echo &quot;It is a test&quot;\n</code></pre>\n<p>显示换行：</p>\n<pre><code>echo -e &quot;OK!\\n&quot; # -e 开启转义\necho &quot;It it a test&quot;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>控制字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\a</td>\n<td>输出警告音</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格键，也就是像左删除健</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车健</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符，也就是tab</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>垂直制表符</td>\n</tr>\n<tr>\n<td>\\0nnn</td>\n<td>按照八进制acsii表输出字符，其中0未数字零，nnn是三位八进制</td>\n</tr>\n<tr>\n<td>\\xhh</td>\n<td>安卓十六进制输出输出字符</td>\n</tr>\n</tbody></table>\n<p><strong>第一个脚本：</strong></p>\n<pre><code class=\"bash\">#!/bin/bash\necho &quot;hello shell!&quot; # 打印字符串“hello shell!”\n</code></pre>\n<p>在shell脚本中，#开始的行代表注释！</p>\n<p><strong>脚本执行：</strong></p>\n<p>赋予执行权限，直接运行</p>\n<pre><code>chmod 755 hello.sh\n./hello.sh\n</code></pre>\n<p>通过bash调用执行脚本</p>\n<pre><code>bash hello.sh\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>Shell是一个命令行解释器，为用户提供了一个向Linux内核发送请求，以便程序运行的界面系统级程序，用户可以用Shell来启动，挂起，停止程序，甚至编写一些程序。</p>\n<p>Shell还是一个功能相当强大的编程语言，易编写，易调试，灵活性较强。</p>\n<ul>\n<li>Shell是解释执行的脚本语言，在Shell中可以直接调用Linux系统命令。</li>\n</ul>\n<p><strong>Echo输出命令：</strong></p>\n<p>Shell 的 echo 指令 用于字符串的输出。</p>\n<p>命令格式：</p>\n<pre><code class=\"css\">echo [选项][输出内容]\n选项：\n-e ： 支持反斜线控制的字符串转换\n</code></pre>\n<p>显示普通字符串：</p>\n<pre><code>echo &quot;It is a test&quot;\n</code></pre>\n<p>显示换行：</p>\n<pre><code>echo -e &quot;OK!\\n&quot; # -e 开启转义\necho &quot;It it a test&quot;\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>控制字符</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>\\a</td>\n<td>输出警告音</td>\n</tr>\n<tr>\n<td>\\b</td>\n<td>退格键，也就是像左删除健</td>\n</tr>\n<tr>\n<td>\\n</td>\n<td>换行符</td>\n</tr>\n<tr>\n<td>\\r</td>\n<td>回车健</td>\n</tr>\n<tr>\n<td>\\t</td>\n<td>制表符，也就是tab</td>\n</tr>\n<tr>\n<td>\\v</td>\n<td>垂直制表符</td>\n</tr>\n<tr>\n<td>\\0nnn</td>\n<td>按照八进制acsii表输出字符，其中0未数字零，nnn是三位八进制</td>\n</tr>\n<tr>\n<td>\\xhh</td>\n<td>安卓十六进制输出输出字符</td>\n</tr>\n</tbody></table>\n<p><strong>第一个脚本：</strong></p>\n<pre><code class=\"bash\">#!/bin/bash\necho &quot;hello shell!&quot; # 打印字符串“hello shell!”\n</code></pre>\n<p>在shell脚本中，#开始的行代表注释！</p>\n<p><strong>脚本执行：</strong></p>\n<p>赋予执行权限，直接运行</p>\n<pre><code>chmod 755 hello.sh\n./hello.sh\n</code></pre>\n<p>通过bash调用执行脚本</p>\n<pre><code>bash hello.sh\n</code></pre>\n"},{"title":"Executor组件","_content":"\n为了提高处理能力和并发度，Web容器一般会把处理请求的工作放到线程池里来执行，Tomcat扩展了原生的Java线程池，来满足Web容器高并发的需求。\n\n**通常我们可以将执行的任务分为两类：**\n\n- cpu 密集型任务\n- io 密集型任务\n\ncpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程，过多的线程将会频繁引起上文切换，降低任务处理处理速度\n\nio 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取/写入数据，增加线程数量可以提高并发度，尽可能多处理任务\n\n* JDK线程池这种策略显然比较适合处理 cpu 密集型任务，但是对于 io 密集型任务，如数据库查询，rpc 请求调用等，就不是很友好了\n\n由于 Tomcat/Jetty 需要处理大量客户端请求任务，如果采用原生线程池，一旦接受请求数量大于线程池核心线程数，这些请求就会被放入到队列中，等待核心线程处理，这样做显然降低这些请求总体处理速度，所以两者都没采用 JDK 原生线程池。\n\n* 跟FixedThreadPool/CachedThreadPool一样，Tomcat的线程池也是一个定制版的ThreadPoolExecutor。\n\n**定制版的ThreadPoolExecutor**\n\n通过比较FixedThreadPool和CachedThreadPool，我们发现它们传给ThreadPoolExecutor的参数有两个关键点：\n\n- 是否限制线程个数。\n- 是否限制队列长度。\n\n对于Tomcat来说，这两个资源都需要限制，也就是说要对高并发进行控制，否则CPU和内存有资源耗尽的风险。\n\n因此Tomcat传入的参数是这样的：\n\n```java\n//定制版的任务队列\ntaskqueue = new TaskQueue(maxQueueSize);\n\n//定制版的线程工厂\nTaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());\n\n//定制版的线程池\nexecutor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);\n```\n\n你可以看到其中的两个关键点：\n\n- Tomcat有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是maxQueueSize。\n- Tomcat对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。\n\n除了资源限制以外，Tomcat线程池还定制自己的任务处理流程。\n\nTomcat线程池扩展了原生的ThreadPoolExecutor，通过重写execute方法实现了自己的任务处理逻辑：\n\n1. 前corePoolSize个任务时，来一个任务就创建一个新线程。\n2. 再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。\n3. 如果总线程数达到maximumPoolSize，**则继续尝试把任务添加到任务队列中去。**\n4. **如果缓冲队列也满了，插入失败，执行拒绝策略。**\n\n观察Tomcat线程池和Java原生线程池的区别，其实就是在第3步，Tomcat在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。\n\n**定制版的任务队列**\n\n只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。\n\n这就是为什么Tomcat需要维护已提交任务数这个变量，它的目的就是在任务队列的长度无限制的情况下，让线程池有机会创建新的线程。\n\n* 默认情况下Tomcat的任务队列是没有限制的，你可以通过设置maxQueueSize参数来限制任务队列的长度。\n\n**总结**\n\n池化的目的是为了避免频繁地创建和销毁对象，减少对系统资源的消耗。\n\n* Java提供了默认的线程池实现，我们也可以扩展Java原生的线程池来实现定制自己的线程池，Tomcat就是这么做的。\n* Tomcat扩展了Java线程池的核心类ThreadPoolExecutor，并重写了它的execute方法，定制了自己的任务处理流程。\n* 同时Tomcat还实现了定制版的任务队列，重写了offer方法，使得在任务队列长度无限制的情况下，线程池仍然有机会创建新的线程。","source":"_posts/Tomcat架构解析/Executor组件.md","raw":"---\ntitle: Executor组件\ncategories: \n- Tomcat架构解析\n---\n\n为了提高处理能力和并发度，Web容器一般会把处理请求的工作放到线程池里来执行，Tomcat扩展了原生的Java线程池，来满足Web容器高并发的需求。\n\n**通常我们可以将执行的任务分为两类：**\n\n- cpu 密集型任务\n- io 密集型任务\n\ncpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程，过多的线程将会频繁引起上文切换，降低任务处理处理速度\n\nio 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取/写入数据，增加线程数量可以提高并发度，尽可能多处理任务\n\n* JDK线程池这种策略显然比较适合处理 cpu 密集型任务，但是对于 io 密集型任务，如数据库查询，rpc 请求调用等，就不是很友好了\n\n由于 Tomcat/Jetty 需要处理大量客户端请求任务，如果采用原生线程池，一旦接受请求数量大于线程池核心线程数，这些请求就会被放入到队列中，等待核心线程处理，这样做显然降低这些请求总体处理速度，所以两者都没采用 JDK 原生线程池。\n\n* 跟FixedThreadPool/CachedThreadPool一样，Tomcat的线程池也是一个定制版的ThreadPoolExecutor。\n\n**定制版的ThreadPoolExecutor**\n\n通过比较FixedThreadPool和CachedThreadPool，我们发现它们传给ThreadPoolExecutor的参数有两个关键点：\n\n- 是否限制线程个数。\n- 是否限制队列长度。\n\n对于Tomcat来说，这两个资源都需要限制，也就是说要对高并发进行控制，否则CPU和内存有资源耗尽的风险。\n\n因此Tomcat传入的参数是这样的：\n\n```java\n//定制版的任务队列\ntaskqueue = new TaskQueue(maxQueueSize);\n\n//定制版的线程工厂\nTaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());\n\n//定制版的线程池\nexecutor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);\n```\n\n你可以看到其中的两个关键点：\n\n- Tomcat有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是maxQueueSize。\n- Tomcat对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。\n\n除了资源限制以外，Tomcat线程池还定制自己的任务处理流程。\n\nTomcat线程池扩展了原生的ThreadPoolExecutor，通过重写execute方法实现了自己的任务处理逻辑：\n\n1. 前corePoolSize个任务时，来一个任务就创建一个新线程。\n2. 再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。\n3. 如果总线程数达到maximumPoolSize，**则继续尝试把任务添加到任务队列中去。**\n4. **如果缓冲队列也满了，插入失败，执行拒绝策略。**\n\n观察Tomcat线程池和Java原生线程池的区别，其实就是在第3步，Tomcat在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。\n\n**定制版的任务队列**\n\n只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。\n\n这就是为什么Tomcat需要维护已提交任务数这个变量，它的目的就是在任务队列的长度无限制的情况下，让线程池有机会创建新的线程。\n\n* 默认情况下Tomcat的任务队列是没有限制的，你可以通过设置maxQueueSize参数来限制任务队列的长度。\n\n**总结**\n\n池化的目的是为了避免频繁地创建和销毁对象，减少对系统资源的消耗。\n\n* Java提供了默认的线程池实现，我们也可以扩展Java原生的线程池来实现定制自己的线程池，Tomcat就是这么做的。\n* Tomcat扩展了Java线程池的核心类ThreadPoolExecutor，并重写了它的execute方法，定制了自己的任务处理流程。\n* 同时Tomcat还实现了定制版的任务队列，重写了offer方法，使得在任务队列长度无限制的情况下，线程池仍然有机会创建新的线程。","slug":"Tomcat架构解析/Executor组件","published":1,"date":"2022-02-04T05:16:53.004Z","updated":"2022-02-04T05:25:55.556Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwil00e1fhjicmb4cvl8","content":"<p>为了提高处理能力和并发度，Web容器一般会把处理请求的工作放到线程池里来执行，Tomcat扩展了原生的Java线程池，来满足Web容器高并发的需求。</p>\n<p><strong>通常我们可以将执行的任务分为两类：</strong></p>\n<ul>\n<li>cpu 密集型任务</li>\n<li>io 密集型任务</li>\n</ul>\n<p>cpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程，过多的线程将会频繁引起上文切换，降低任务处理处理速度</p>\n<p>io 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取&#x2F;写入数据，增加线程数量可以提高并发度，尽可能多处理任务</p>\n<ul>\n<li>JDK线程池这种策略显然比较适合处理 cpu 密集型任务，但是对于 io 密集型任务，如数据库查询，rpc 请求调用等，就不是很友好了</li>\n</ul>\n<p>由于 Tomcat&#x2F;Jetty 需要处理大量客户端请求任务，如果采用原生线程池，一旦接受请求数量大于线程池核心线程数，这些请求就会被放入到队列中，等待核心线程处理，这样做显然降低这些请求总体处理速度，所以两者都没采用 JDK 原生线程池。</p>\n<ul>\n<li>跟FixedThreadPool&#x2F;CachedThreadPool一样，Tomcat的线程池也是一个定制版的ThreadPoolExecutor。</li>\n</ul>\n<p><strong>定制版的ThreadPoolExecutor</strong></p>\n<p>通过比较FixedThreadPool和CachedThreadPool，我们发现它们传给ThreadPoolExecutor的参数有两个关键点：</p>\n<ul>\n<li>是否限制线程个数。</li>\n<li>是否限制队列长度。</li>\n</ul>\n<p>对于Tomcat来说，这两个资源都需要限制，也就是说要对高并发进行控制，否则CPU和内存有资源耗尽的风险。</p>\n<p>因此Tomcat传入的参数是这样的：</p>\n<pre><code class=\"java\">//定制版的任务队列\ntaskqueue = new TaskQueue(maxQueueSize);\n\n//定制版的线程工厂\nTaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());\n\n//定制版的线程池\nexecutor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);\n</code></pre>\n<p>你可以看到其中的两个关键点：</p>\n<ul>\n<li>Tomcat有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是maxQueueSize。</li>\n<li>Tomcat对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。</li>\n</ul>\n<p>除了资源限制以外，Tomcat线程池还定制自己的任务处理流程。</p>\n<p>Tomcat线程池扩展了原生的ThreadPoolExecutor，通过重写execute方法实现了自己的任务处理逻辑：</p>\n<ol>\n<li>前corePoolSize个任务时，来一个任务就创建一个新线程。</li>\n<li>再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。</li>\n<li>如果总线程数达到maximumPoolSize，<strong>则继续尝试把任务添加到任务队列中去。</strong></li>\n<li><strong>如果缓冲队列也满了，插入失败，执行拒绝策略。</strong></li>\n</ol>\n<p>观察Tomcat线程池和Java原生线程池的区别，其实就是在第3步，Tomcat在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。</p>\n<p><strong>定制版的任务队列</strong></p>\n<p>只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。</p>\n<p>这就是为什么Tomcat需要维护已提交任务数这个变量，它的目的就是在任务队列的长度无限制的情况下，让线程池有机会创建新的线程。</p>\n<ul>\n<li>默认情况下Tomcat的任务队列是没有限制的，你可以通过设置maxQueueSize参数来限制任务队列的长度。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>池化的目的是为了避免频繁地创建和销毁对象，减少对系统资源的消耗。</p>\n<ul>\n<li>Java提供了默认的线程池实现，我们也可以扩展Java原生的线程池来实现定制自己的线程池，Tomcat就是这么做的。</li>\n<li>Tomcat扩展了Java线程池的核心类ThreadPoolExecutor，并重写了它的execute方法，定制了自己的任务处理流程。</li>\n<li>同时Tomcat还实现了定制版的任务队列，重写了offer方法，使得在任务队列长度无限制的情况下，线程池仍然有机会创建新的线程。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>为了提高处理能力和并发度，Web容器一般会把处理请求的工作放到线程池里来执行，Tomcat扩展了原生的Java线程池，来满足Web容器高并发的需求。</p>\n<p><strong>通常我们可以将执行的任务分为两类：</strong></p>\n<ul>\n<li>cpu 密集型任务</li>\n<li>io 密集型任务</li>\n</ul>\n<p>cpu 密集型任务，需要线程长时间进行的复杂的运算，这种类型的任务需要少创建线程，过多的线程将会频繁引起上文切换，降低任务处理处理速度</p>\n<p>io 密集型任务，由于线程并不是一直在运行，可能大部分时间在等待 IO 读取&#x2F;写入数据，增加线程数量可以提高并发度，尽可能多处理任务</p>\n<ul>\n<li>JDK线程池这种策略显然比较适合处理 cpu 密集型任务，但是对于 io 密集型任务，如数据库查询，rpc 请求调用等，就不是很友好了</li>\n</ul>\n<p>由于 Tomcat&#x2F;Jetty 需要处理大量客户端请求任务，如果采用原生线程池，一旦接受请求数量大于线程池核心线程数，这些请求就会被放入到队列中，等待核心线程处理，这样做显然降低这些请求总体处理速度，所以两者都没采用 JDK 原生线程池。</p>\n<ul>\n<li>跟FixedThreadPool&#x2F;CachedThreadPool一样，Tomcat的线程池也是一个定制版的ThreadPoolExecutor。</li>\n</ul>\n<p><strong>定制版的ThreadPoolExecutor</strong></p>\n<p>通过比较FixedThreadPool和CachedThreadPool，我们发现它们传给ThreadPoolExecutor的参数有两个关键点：</p>\n<ul>\n<li>是否限制线程个数。</li>\n<li>是否限制队列长度。</li>\n</ul>\n<p>对于Tomcat来说，这两个资源都需要限制，也就是说要对高并发进行控制，否则CPU和内存有资源耗尽的风险。</p>\n<p>因此Tomcat传入的参数是这样的：</p>\n<pre><code class=\"java\">//定制版的任务队列\ntaskqueue = new TaskQueue(maxQueueSize);\n\n//定制版的线程工厂\nTaskThreadFactory tf = new TaskThreadFactory(namePrefix,daemon,getThreadPriority());\n\n//定制版的线程池\nexecutor = new ThreadPoolExecutor(getMinSpareThreads(), getMaxThreads(), maxIdleTime, TimeUnit.MILLISECONDS,taskqueue, tf);\n</code></pre>\n<p>你可以看到其中的两个关键点：</p>\n<ul>\n<li>Tomcat有自己的定制版任务队列和线程工厂，并且可以限制任务队列的长度，它的最大长度是maxQueueSize。</li>\n<li>Tomcat对线程数也有限制，设置了核心线程数（minSpareThreads）和最大线程池数（maxThreads）。</li>\n</ul>\n<p>除了资源限制以外，Tomcat线程池还定制自己的任务处理流程。</p>\n<p>Tomcat线程池扩展了原生的ThreadPoolExecutor，通过重写execute方法实现了自己的任务处理逻辑：</p>\n<ol>\n<li>前corePoolSize个任务时，来一个任务就创建一个新线程。</li>\n<li>再来任务的话，就把任务添加到任务队列里让所有的线程去抢，如果队列满了就创建临时线程。</li>\n<li>如果总线程数达到maximumPoolSize，<strong>则继续尝试把任务添加到任务队列中去。</strong></li>\n<li><strong>如果缓冲队列也满了，插入失败，执行拒绝策略。</strong></li>\n</ol>\n<p>观察Tomcat线程池和Java原生线程池的区别，其实就是在第3步，Tomcat在线程总数达到最大数时，不是立即执行拒绝策略，而是再尝试向任务队列添加任务，添加失败后再执行拒绝策略。</p>\n<p><strong>定制版的任务队列</strong></p>\n<p>只有当前线程数大于核心线程数、小于最大线程数，并且已提交的任务个数大于当前线程数时，也就是说线程不够用了，但是线程数又没达到极限，才会去创建新的线程。</p>\n<p>这就是为什么Tomcat需要维护已提交任务数这个变量，它的目的就是在任务队列的长度无限制的情况下，让线程池有机会创建新的线程。</p>\n<ul>\n<li>默认情况下Tomcat的任务队列是没有限制的，你可以通过设置maxQueueSize参数来限制任务队列的长度。</li>\n</ul>\n<p><strong>总结</strong></p>\n<p>池化的目的是为了避免频繁地创建和销毁对象，减少对系统资源的消耗。</p>\n<ul>\n<li>Java提供了默认的线程池实现，我们也可以扩展Java原生的线程池来实现定制自己的线程池，Tomcat就是这么做的。</li>\n<li>Tomcat扩展了Java线程池的核心类ThreadPoolExecutor，并重写了它的execute方法，定制了自己的任务处理流程。</li>\n<li>同时Tomcat还实现了定制版的任务队列，重写了offer方法，使得在任务队列长度无限制的情况下，线程池仍然有机会创建新的线程。</li>\n</ul>\n"},{"title":"Servlet","_content":"\nServlet容器用来加载和管理业务类。HTTP服务器不直接跟业务类打交道，而是把请求交给Servlet容器去处理，Servlet容器会将请求转发到具体的Servlet，如果这个Servlet还没创建，就加载并实例化这个Servlet，然后调用这个Servlet的接口方法。\n\n* 因此Servlet接口其实是**Servlet容器跟具体业务类之间的接口**。\n\n<img src=\"https://img-blog.csdnimg.cn/84cfa19d741949b9af0debc7beedcf23.png\" style=\"zoom:25%;\" />\n\n**Servlet规范**\n\nServlet接口和Servlet容器这一整套规范叫作Servlet规范。\n\n* Tomcat和Jetty都按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。\n\n作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了。\n\n**Servlet容器**\n\n* 当客户请求某个资源时，HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来，然后调用Servlet容器的service方法\n\n* Servlet容器拿到请求后，根据请求的URL和Servlet的映射关系，找到相应的Servlet\n\n* 如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来完成初始化，接着调用Servlet的service方法来处理请求，把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端。\n\n<img src=\"https://img-blog.csdnimg.cn/560dfb37233d4f65bc569746b672a232.png\" style=\"zoom:25%;\" />\n\n**扩展机制**\n\n**Filter**\n\n* 过滤器，这个接口允许你对请求和响应做一些统一的定制化处理，比如你可以根据请求的频率来限制访问，或者根据国家地区的不同来修改响应内容。\n\n过滤器的工作原理：Web应用部署完成后，Servlet容器需要实例化Filter并把Filter链接成一个FilterChain。当请求进来时，获取第一个Filter并调用doFilter方法，doFilter方法负责调用这个FilterChain中的下一个Filter。\n\n**Listener**\n\n* 监听器，当Web应用在Servlet容器中运行时，Servlet容器内部会不断的发生各种事件，如Web应用的启动和停止、用户请求到达等。 \n\nServlet容器提供了一些默认的监听器来监听这些事件，当事件发生时，Servlet容器会负责调用监听器的方法。","source":"_posts/Tomcat架构解析/Servlet.md","raw":"---\ntitle: Servlet\ncategories: \n- Tomcat架构解析\n---\n\nServlet容器用来加载和管理业务类。HTTP服务器不直接跟业务类打交道，而是把请求交给Servlet容器去处理，Servlet容器会将请求转发到具体的Servlet，如果这个Servlet还没创建，就加载并实例化这个Servlet，然后调用这个Servlet的接口方法。\n\n* 因此Servlet接口其实是**Servlet容器跟具体业务类之间的接口**。\n\n<img src=\"https://img-blog.csdnimg.cn/84cfa19d741949b9af0debc7beedcf23.png\" style=\"zoom:25%;\" />\n\n**Servlet规范**\n\nServlet接口和Servlet容器这一整套规范叫作Servlet规范。\n\n* Tomcat和Jetty都按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。\n\n作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了。\n\n**Servlet容器**\n\n* 当客户请求某个资源时，HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来，然后调用Servlet容器的service方法\n\n* Servlet容器拿到请求后，根据请求的URL和Servlet的映射关系，找到相应的Servlet\n\n* 如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来完成初始化，接着调用Servlet的service方法来处理请求，把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端。\n\n<img src=\"https://img-blog.csdnimg.cn/560dfb37233d4f65bc569746b672a232.png\" style=\"zoom:25%;\" />\n\n**扩展机制**\n\n**Filter**\n\n* 过滤器，这个接口允许你对请求和响应做一些统一的定制化处理，比如你可以根据请求的频率来限制访问，或者根据国家地区的不同来修改响应内容。\n\n过滤器的工作原理：Web应用部署完成后，Servlet容器需要实例化Filter并把Filter链接成一个FilterChain。当请求进来时，获取第一个Filter并调用doFilter方法，doFilter方法负责调用这个FilterChain中的下一个Filter。\n\n**Listener**\n\n* 监听器，当Web应用在Servlet容器中运行时，Servlet容器内部会不断的发生各种事件，如Web应用的启动和停止、用户请求到达等。 \n\nServlet容器提供了一些默认的监听器来监听这些事件，当事件发生时，Servlet容器会负责调用监听器的方法。","slug":"Tomcat架构解析/Servlet","published":1,"date":"2022-02-02T15:04:23.865Z","updated":"2022-02-02T15:14:38.542Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwim00e4fhjigvy69vqg","content":"<p>Servlet容器用来加载和管理业务类。HTTP服务器不直接跟业务类打交道，而是把请求交给Servlet容器去处理，Servlet容器会将请求转发到具体的Servlet，如果这个Servlet还没创建，就加载并实例化这个Servlet，然后调用这个Servlet的接口方法。</p>\n<ul>\n<li>因此Servlet接口其实是<strong>Servlet容器跟具体业务类之间的接口</strong>。</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/84cfa19d741949b9af0debc7beedcf23.png\" style=\"zoom:25%;\" />\n\n<p><strong>Servlet规范</strong></p>\n<p>Servlet接口和Servlet容器这一整套规范叫作Servlet规范。</p>\n<ul>\n<li>Tomcat和Jetty都按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。</li>\n</ul>\n<p>作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了。</p>\n<p><strong>Servlet容器</strong></p>\n<ul>\n<li><p>当客户请求某个资源时，HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来，然后调用Servlet容器的service方法</p>\n</li>\n<li><p>Servlet容器拿到请求后，根据请求的URL和Servlet的映射关系，找到相应的Servlet</p>\n</li>\n<li><p>如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来完成初始化，接着调用Servlet的service方法来处理请求，把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/560dfb37233d4f65bc569746b672a232.png\" style=\"zoom:25%;\" />\n\n<p><strong>扩展机制</strong></p>\n<p><strong>Filter</strong></p>\n<ul>\n<li>过滤器，这个接口允许你对请求和响应做一些统一的定制化处理，比如你可以根据请求的频率来限制访问，或者根据国家地区的不同来修改响应内容。</li>\n</ul>\n<p>过滤器的工作原理：Web应用部署完成后，Servlet容器需要实例化Filter并把Filter链接成一个FilterChain。当请求进来时，获取第一个Filter并调用doFilter方法，doFilter方法负责调用这个FilterChain中的下一个Filter。</p>\n<p><strong>Listener</strong></p>\n<ul>\n<li>监听器，当Web应用在Servlet容器中运行时，Servlet容器内部会不断的发生各种事件，如Web应用的启动和停止、用户请求到达等。</li>\n</ul>\n<p>Servlet容器提供了一些默认的监听器来监听这些事件，当事件发生时，Servlet容器会负责调用监听器的方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Servlet容器用来加载和管理业务类。HTTP服务器不直接跟业务类打交道，而是把请求交给Servlet容器去处理，Servlet容器会将请求转发到具体的Servlet，如果这个Servlet还没创建，就加载并实例化这个Servlet，然后调用这个Servlet的接口方法。</p>\n<ul>\n<li>因此Servlet接口其实是<strong>Servlet容器跟具体业务类之间的接口</strong>。</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/84cfa19d741949b9af0debc7beedcf23.png\" style=\"zoom:25%;\" />\n\n<p><strong>Servlet规范</strong></p>\n<p>Servlet接口和Servlet容器这一整套规范叫作Servlet规范。</p>\n<ul>\n<li>Tomcat和Jetty都按照Servlet规范的要求实现了Servlet容器，同时它们也具有HTTP服务器的功能。</li>\n</ul>\n<p>作为Java程序员，如果我们要实现新的业务功能，只需要实现一个Servlet，并把它注册到Tomcat（Servlet容器）中，剩下的事情就由Tomcat帮我们处理了。</p>\n<p><strong>Servlet容器</strong></p>\n<ul>\n<li><p>当客户请求某个资源时，HTTP服务器会用一个ServletRequest对象把客户的请求信息封装起来，然后调用Servlet容器的service方法</p>\n</li>\n<li><p>Servlet容器拿到请求后，根据请求的URL和Servlet的映射关系，找到相应的Servlet</p>\n</li>\n<li><p>如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来完成初始化，接着调用Servlet的service方法来处理请求，把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/560dfb37233d4f65bc569746b672a232.png\" style=\"zoom:25%;\" />\n\n<p><strong>扩展机制</strong></p>\n<p><strong>Filter</strong></p>\n<ul>\n<li>过滤器，这个接口允许你对请求和响应做一些统一的定制化处理，比如你可以根据请求的频率来限制访问，或者根据国家地区的不同来修改响应内容。</li>\n</ul>\n<p>过滤器的工作原理：Web应用部署完成后，Servlet容器需要实例化Filter并把Filter链接成一个FilterChain。当请求进来时，获取第一个Filter并调用doFilter方法，doFilter方法负责调用这个FilterChain中的下一个Filter。</p>\n<p><strong>Listener</strong></p>\n<ul>\n<li>监听器，当Web应用在Servlet容器中运行时，Servlet容器内部会不断的发生各种事件，如Web应用的启动和停止、用户请求到达等。</li>\n</ul>\n<p>Servlet容器提供了一些默认的监听器来监听这些事件，当事件发生时，Servlet容器会负责调用监听器的方法。</p>\n"},{"title":"双亲委托机制","_content":"\nTomcat的自定义类加载器WebAppClassLoader打破了双亲委托机制\n\n它**首先自己尝试去加载某个类，如果找不到再代理给父类加载器**，其目的是优先加载Web应用自己定义的类。\n\n* 具体实现就是重写ClassLoader的两个方法：findClass和loadClass。\n\n要打破双亲委托机制，需要继承ClassLoader抽象类，并且需要重写它的loadClass方法，因为ClassLoader的默认实现就是双亲委托。\n\n**findClass方法**\n\n在findClass方法里，主要有三个步骤：\n\n1. 先在Web应用本地目录下查找要加载的类。\n2. 如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器AppClassLoader。\n3. 如何父加载器也没找到这个类，抛出ClassNotFound异常。\n\n**loadClass方法**\n\nloadClass方法主要有六个步骤：\n\n1. 先在本地Cache查找该类是否已经加载过，也就是说Tomcat的类加载器是否已经加载过这个类。\n2. 如果Tomcat类加载器没有加载过这个类，再看看系统类加载器是否加载过。\n3. 如果都没有，就让**ExtClassLoader**去加载，目的**防止Web应用自己的类覆盖JRE的核心类**。因为Tomcat需要打破双亲委托机制，假如Web应用里自定义了一个叫Object的类，如果先加载这个Object类，就会覆盖JRE里面的那个Object类，因为ExtClassLoader会委托给BootstrapClassLoader去加载，BootstrapClassLoader发现自己已经加载了Object类，直接返回给Tomcat的类加载器，这样Tomcat的类加载器就不会去加载Web应用下的Object类了，也就避免了覆盖JRE核心类的问题。\n4. 如果ExtClassLoader加载器加载失败，也就是说JRE核心类中没有这类，那么就在本地Web应用目录下查找并加载。\n5. 如果本地目录下没有这个类，说明不是Web应用自己定义的类，那么由系统类加载器去加载。注意，Web应用是通过`Class.forName`调用交给系统类加载器的，因为`Class.forName`的默认加载器就是系统类加载器。\n6. 如果上述加载过程全部失败，抛出ClassNotFound异常。\n\nTomcat的类加载器打破了双亲委托机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖JRE的核心类，先尝试用JVM扩展类加载器ExtClassLoader去加载。\n\n为什么不先用系统类加载器AppClassLoader去加载？\n\n> 很显然，如果是这样的话，那就变成双亲委托机制了，这就是Tomcat类加载器的巧妙之处。","source":"_posts/Tomcat架构解析/双亲委托机制.md","raw":"---\ntitle: 双亲委托机制\ncategories: \n- Tomcat架构解析\n---\n\nTomcat的自定义类加载器WebAppClassLoader打破了双亲委托机制\n\n它**首先自己尝试去加载某个类，如果找不到再代理给父类加载器**，其目的是优先加载Web应用自己定义的类。\n\n* 具体实现就是重写ClassLoader的两个方法：findClass和loadClass。\n\n要打破双亲委托机制，需要继承ClassLoader抽象类，并且需要重写它的loadClass方法，因为ClassLoader的默认实现就是双亲委托。\n\n**findClass方法**\n\n在findClass方法里，主要有三个步骤：\n\n1. 先在Web应用本地目录下查找要加载的类。\n2. 如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器AppClassLoader。\n3. 如何父加载器也没找到这个类，抛出ClassNotFound异常。\n\n**loadClass方法**\n\nloadClass方法主要有六个步骤：\n\n1. 先在本地Cache查找该类是否已经加载过，也就是说Tomcat的类加载器是否已经加载过这个类。\n2. 如果Tomcat类加载器没有加载过这个类，再看看系统类加载器是否加载过。\n3. 如果都没有，就让**ExtClassLoader**去加载，目的**防止Web应用自己的类覆盖JRE的核心类**。因为Tomcat需要打破双亲委托机制，假如Web应用里自定义了一个叫Object的类，如果先加载这个Object类，就会覆盖JRE里面的那个Object类，因为ExtClassLoader会委托给BootstrapClassLoader去加载，BootstrapClassLoader发现自己已经加载了Object类，直接返回给Tomcat的类加载器，这样Tomcat的类加载器就不会去加载Web应用下的Object类了，也就避免了覆盖JRE核心类的问题。\n4. 如果ExtClassLoader加载器加载失败，也就是说JRE核心类中没有这类，那么就在本地Web应用目录下查找并加载。\n5. 如果本地目录下没有这个类，说明不是Web应用自己定义的类，那么由系统类加载器去加载。注意，Web应用是通过`Class.forName`调用交给系统类加载器的，因为`Class.forName`的默认加载器就是系统类加载器。\n6. 如果上述加载过程全部失败，抛出ClassNotFound异常。\n\nTomcat的类加载器打破了双亲委托机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖JRE的核心类，先尝试用JVM扩展类加载器ExtClassLoader去加载。\n\n为什么不先用系统类加载器AppClassLoader去加载？\n\n> 很显然，如果是这样的话，那就变成双亲委托机制了，这就是Tomcat类加载器的巧妙之处。","slug":"Tomcat架构解析/双亲委托机制","published":1,"date":"2022-02-05T03:27:51.386Z","updated":"2022-02-05T03:35:34.347Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwim00e5fhjia2pnbdwi","content":"<p>Tomcat的自定义类加载器WebAppClassLoader打破了双亲委托机制</p>\n<p>它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载Web应用自己定义的类。</p>\n<ul>\n<li>具体实现就是重写ClassLoader的两个方法：findClass和loadClass。</li>\n</ul>\n<p>要打破双亲委托机制，需要继承ClassLoader抽象类，并且需要重写它的loadClass方法，因为ClassLoader的默认实现就是双亲委托。</p>\n<p><strong>findClass方法</strong></p>\n<p>在findClass方法里，主要有三个步骤：</p>\n<ol>\n<li>先在Web应用本地目录下查找要加载的类。</li>\n<li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器AppClassLoader。</li>\n<li>如何父加载器也没找到这个类，抛出ClassNotFound异常。</li>\n</ol>\n<p><strong>loadClass方法</strong></p>\n<p>loadClass方法主要有六个步骤：</p>\n<ol>\n<li>先在本地Cache查找该类是否已经加载过，也就是说Tomcat的类加载器是否已经加载过这个类。</li>\n<li>如果Tomcat类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li>\n<li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，目的<strong>防止Web应用自己的类覆盖JRE的核心类</strong>。因为Tomcat需要打破双亲委托机制，假如Web应用里自定义了一个叫Object的类，如果先加载这个Object类，就会覆盖JRE里面的那个Object类，因为ExtClassLoader会委托给BootstrapClassLoader去加载，BootstrapClassLoader发现自己已经加载了Object类，直接返回给Tomcat的类加载器，这样Tomcat的类加载器就不会去加载Web应用下的Object类了，也就避免了覆盖JRE核心类的问题。</li>\n<li>如果ExtClassLoader加载器加载失败，也就是说JRE核心类中没有这类，那么就在本地Web应用目录下查找并加载。</li>\n<li>如果本地目录下没有这个类，说明不是Web应用自己定义的类，那么由系统类加载器去加载。注意，Web应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li>\n<li>如果上述加载过程全部失败，抛出ClassNotFound异常。</li>\n</ol>\n<p>Tomcat的类加载器打破了双亲委托机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖JRE的核心类，先尝试用JVM扩展类加载器ExtClassLoader去加载。</p>\n<p>为什么不先用系统类加载器AppClassLoader去加载？</p>\n<blockquote>\n<p>很显然，如果是这样的话，那就变成双亲委托机制了，这就是Tomcat类加载器的巧妙之处。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>Tomcat的自定义类加载器WebAppClassLoader打破了双亲委托机制</p>\n<p>它<strong>首先自己尝试去加载某个类，如果找不到再代理给父类加载器</strong>，其目的是优先加载Web应用自己定义的类。</p>\n<ul>\n<li>具体实现就是重写ClassLoader的两个方法：findClass和loadClass。</li>\n</ul>\n<p>要打破双亲委托机制，需要继承ClassLoader抽象类，并且需要重写它的loadClass方法，因为ClassLoader的默认实现就是双亲委托。</p>\n<p><strong>findClass方法</strong></p>\n<p>在findClass方法里，主要有三个步骤：</p>\n<ol>\n<li>先在Web应用本地目录下查找要加载的类。</li>\n<li>如果没有找到，交给父加载器去查找，它的父加载器就是上面提到的系统类加载器AppClassLoader。</li>\n<li>如何父加载器也没找到这个类，抛出ClassNotFound异常。</li>\n</ol>\n<p><strong>loadClass方法</strong></p>\n<p>loadClass方法主要有六个步骤：</p>\n<ol>\n<li>先在本地Cache查找该类是否已经加载过，也就是说Tomcat的类加载器是否已经加载过这个类。</li>\n<li>如果Tomcat类加载器没有加载过这个类，再看看系统类加载器是否加载过。</li>\n<li>如果都没有，就让<strong>ExtClassLoader</strong>去加载，目的<strong>防止Web应用自己的类覆盖JRE的核心类</strong>。因为Tomcat需要打破双亲委托机制，假如Web应用里自定义了一个叫Object的类，如果先加载这个Object类，就会覆盖JRE里面的那个Object类，因为ExtClassLoader会委托给BootstrapClassLoader去加载，BootstrapClassLoader发现自己已经加载了Object类，直接返回给Tomcat的类加载器，这样Tomcat的类加载器就不会去加载Web应用下的Object类了，也就避免了覆盖JRE核心类的问题。</li>\n<li>如果ExtClassLoader加载器加载失败，也就是说JRE核心类中没有这类，那么就在本地Web应用目录下查找并加载。</li>\n<li>如果本地目录下没有这个类，说明不是Web应用自己定义的类，那么由系统类加载器去加载。注意，Web应用是通过<code>Class.forName</code>调用交给系统类加载器的，因为<code>Class.forName</code>的默认加载器就是系统类加载器。</li>\n<li>如果上述加载过程全部失败，抛出ClassNotFound异常。</li>\n</ol>\n<p>Tomcat的类加载器打破了双亲委托机制，没有一上来就直接委托给父加载器，而是先在本地目录下加载，为了避免本地目录下的类覆盖JRE的核心类，先尝试用JVM扩展类加载器ExtClassLoader去加载。</p>\n<p>为什么不先用系统类加载器AppClassLoader去加载？</p>\n<blockquote>\n<p>很显然，如果是这样的话，那就变成双亲委托机制了，这就是Tomcat类加载器的巧妙之处。</p>\n</blockquote>\n"},{"title":"多层容器","_content":"\nTomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。\n\n这4种容器不是平行关系，而是父子关系。\n\n<img src=\"https://img-blog.csdnimg.cn/60f43086537c4373be031b5d2de1938e.png\" style=\"zoom:25%;\" />\n\n* Context表示一个Web应用程序；Wrapper表示一个Servlet，一个Web应用程序中可能会有多个Servlet；\n\n* Host代表的是一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序；\n\n* Engine表示引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine。\n\nTomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。\n\n参考Tomcat的`server.xml`配置文件：\n\n<img src=\"https://img-blog.csdnimg.cn/ae4a2d36d5d7406abea18d1e59d92c27.png\" style=\"zoom:25%;\" />\n\n> Tomcat就是用组合模式来管理这些容器。\n\n所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。\n\n这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine。\n\n**请求定位Servlet的过程**\n\nTomcat是怎么确定请求是由哪个Wrapper容器里的Servlet来处理的呢？\n\n> Tomcat是用Mapper组件来完成这个任务的。\n\nMapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是：\n\n> Mapper组件里保存了Web应用的配置信息，其实就是**容器组件与访问路径的映射关系**，比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。\n\n当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet。\n\n> 注意，一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet。\n\n<img src=\"https://img-blog.csdnimg.cn/8728e1dc868d4f79b058f68ab22933e9.png\" style=\"zoom:25%;\" />\n\n**Pipeline-Valve**\n\nPipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。\n\n<img src=\"https://img-blog.csdnimg.cn/15a19b65e9444bfab2cc9bbd2c75e4e6.png\" style=\"zoom:25%;\" />\n\n请求的链式调用是基于Pipeline-Valve责任链来完成的，这样的设计使得系统具有良好的可扩展性，如果需要扩展容器本身的功能，只需要增加相应的Valve即可。","source":"_posts/Tomcat架构解析/多层容器.md","raw":"---\ntitle: 多层容器\ncategories: \n- Tomcat架构解析\n---\n\nTomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。\n\n这4种容器不是平行关系，而是父子关系。\n\n<img src=\"https://img-blog.csdnimg.cn/60f43086537c4373be031b5d2de1938e.png\" style=\"zoom:25%;\" />\n\n* Context表示一个Web应用程序；Wrapper表示一个Servlet，一个Web应用程序中可能会有多个Servlet；\n\n* Host代表的是一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序；\n\n* Engine表示引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine。\n\nTomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。\n\n参考Tomcat的`server.xml`配置文件：\n\n<img src=\"https://img-blog.csdnimg.cn/ae4a2d36d5d7406abea18d1e59d92c27.png\" style=\"zoom:25%;\" />\n\n> Tomcat就是用组合模式来管理这些容器。\n\n所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。\n\n这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine。\n\n**请求定位Servlet的过程**\n\nTomcat是怎么确定请求是由哪个Wrapper容器里的Servlet来处理的呢？\n\n> Tomcat是用Mapper组件来完成这个任务的。\n\nMapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是：\n\n> Mapper组件里保存了Web应用的配置信息，其实就是**容器组件与访问路径的映射关系**，比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。\n\n当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet。\n\n> 注意，一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet。\n\n<img src=\"https://img-blog.csdnimg.cn/8728e1dc868d4f79b058f68ab22933e9.png\" style=\"zoom:25%;\" />\n\n**Pipeline-Valve**\n\nPipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。\n\n<img src=\"https://img-blog.csdnimg.cn/15a19b65e9444bfab2cc9bbd2c75e4e6.png\" style=\"zoom:25%;\" />\n\n请求的链式调用是基于Pipeline-Valve责任链来完成的，这样的设计使得系统具有良好的可扩展性，如果需要扩展容器本身的功能，只需要增加相应的Valve即可。","slug":"Tomcat架构解析/多层容器","published":1,"date":"2022-02-03T04:11:56.224Z","updated":"2022-02-03T04:16:59.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwin00e8fhji305n7p1f","content":"<p>Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。</p>\n<p>这4种容器不是平行关系，而是父子关系。</p>\n<img src=\"https://img-blog.csdnimg.cn/60f43086537c4373be031b5d2de1938e.png\" style=\"zoom:25%;\" />\n\n<ul>\n<li><p>Context表示一个Web应用程序；Wrapper表示一个Servlet，一个Web应用程序中可能会有多个Servlet；</p>\n</li>\n<li><p>Host代表的是一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序；</p>\n</li>\n<li><p>Engine表示引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine。</p>\n</li>\n</ul>\n<p>Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。</p>\n<p>参考Tomcat的<code>server.xml</code>配置文件：</p>\n<img src=\"https://img-blog.csdnimg.cn/ae4a2d36d5d7406abea18d1e59d92c27.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>Tomcat就是用组合模式来管理这些容器。</p>\n</blockquote>\n<p>所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。</p>\n<p>这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine。</p>\n<p><strong>请求定位Servlet的过程</strong></p>\n<p>Tomcat是怎么确定请求是由哪个Wrapper容器里的Servlet来处理的呢？</p>\n<blockquote>\n<p>Tomcat是用Mapper组件来完成这个任务的。</p>\n</blockquote>\n<p>Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是：</p>\n<blockquote>\n<p>Mapper组件里保存了Web应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。</p>\n</blockquote>\n<p>当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet。</p>\n<blockquote>\n<p>注意，一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet。</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/8728e1dc868d4f79b058f68ab22933e9.png\" style=\"zoom:25%;\" />\n\n<p><strong>Pipeline-Valve</strong></p>\n<p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。</p>\n<img src=\"https://img-blog.csdnimg.cn/15a19b65e9444bfab2cc9bbd2c75e4e6.png\" style=\"zoom:25%;\" />\n\n<p>请求的链式调用是基于Pipeline-Valve责任链来完成的，这样的设计使得系统具有良好的可扩展性，如果需要扩展容器本身的功能，只需要增加相应的Valve即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Tomcat设计了4种容器，分别是Engine、Host、Context和Wrapper。</p>\n<p>这4种容器不是平行关系，而是父子关系。</p>\n<img src=\"https://img-blog.csdnimg.cn/60f43086537c4373be031b5d2de1938e.png\" style=\"zoom:25%;\" />\n\n<ul>\n<li><p>Context表示一个Web应用程序；Wrapper表示一个Servlet，一个Web应用程序中可能会有多个Servlet；</p>\n</li>\n<li><p>Host代表的是一个虚拟主机，或者说一个站点，可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序；</p>\n</li>\n<li><p>Engine表示引擎，用来管理多个虚拟站点，一个Service最多只能有一个Engine。</p>\n</li>\n</ul>\n<p>Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的格式要求配置在这个顶层容器中。</p>\n<p>参考Tomcat的<code>server.xml</code>配置文件：</p>\n<img src=\"https://img-blog.csdnimg.cn/ae4a2d36d5d7406abea18d1e59d92c27.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>Tomcat就是用组合模式来管理这些容器。</p>\n</blockquote>\n<p>所有容器组件都实现了Container接口，因此组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性。</p>\n<p>这里单容器对象指的是最底层的Wrapper，组合容器对象指的是上面的Context、Host或者Engine。</p>\n<p><strong>请求定位Servlet的过程</strong></p>\n<p>Tomcat是怎么确定请求是由哪个Wrapper容器里的Servlet来处理的呢？</p>\n<blockquote>\n<p>Tomcat是用Mapper组件来完成这个任务的。</p>\n</blockquote>\n<p>Mapper组件的功能就是将用户请求的URL定位到一个Servlet，它的工作原理是：</p>\n<blockquote>\n<p>Mapper组件里保存了Web应用的配置信息，其实就是<strong>容器组件与访问路径的映射关系</strong>，比如Host容器里配置的域名、Context容器里的Web应用路径，以及Wrapper容器里Servlet映射的路径，你可以想象这些配置信息就是一个多层次的Map。</p>\n</blockquote>\n<p>当一个请求到来时，Mapper组件通过解析请求URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet。</p>\n<blockquote>\n<p>注意，一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet。</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/8728e1dc868d4f79b058f68ab22933e9.png\" style=\"zoom:25%;\" />\n\n<p><strong>Pipeline-Valve</strong></p>\n<p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理。</p>\n<img src=\"https://img-blog.csdnimg.cn/15a19b65e9444bfab2cc9bbd2c75e4e6.png\" style=\"zoom:25%;\" />\n\n<p>请求的链式调用是基于Pipeline-Valve责任链来完成的，这样的设计使得系统具有良好的可扩展性，如果需要扩展容器本身的功能，只需要增加相应的Valve即可。</p>\n"},{"title":"核心组件","_content":"\n我们可以通过Tomcat的`/bin`目录下的脚本`startup.sh`来启动Tomcat，那我们执行了这个脚本后发生了什么呢？\n\n<img src=\"https://img-blog.csdnimg.cn/e6f976a917c64eb79c15776ee7172b26.png\" style=\"zoom:25%;\" />\n\n**Catalina**\n\nCatalina的主要任务就是创建Server，它不是直接new一个Server实例就完事了，而是需要解析`server.xml`，把在`server.xml`里配置的各种组件一一创建出来，接着调用Server组件的init方法和start方法，这样整个Tomcat就启动起来了。\n\n**Server组件**\n\nServer继承了LifecycleBase，它的生命周期被统一管理，并且它的子组件是Service，因此它还需要管理Service的生命周期，也就是说在启动时调用Service组件的启动方法，在停止时调用它们的停止方法。\n\n* Server在内部维护了若干Service组件，它是以数组来保存的。","source":"_posts/Tomcat架构解析/核心组件.md","raw":"---\ntitle: 核心组件\ncategories: \n- Tomcat架构解析\n---\n\n我们可以通过Tomcat的`/bin`目录下的脚本`startup.sh`来启动Tomcat，那我们执行了这个脚本后发生了什么呢？\n\n<img src=\"https://img-blog.csdnimg.cn/e6f976a917c64eb79c15776ee7172b26.png\" style=\"zoom:25%;\" />\n\n**Catalina**\n\nCatalina的主要任务就是创建Server，它不是直接new一个Server实例就完事了，而是需要解析`server.xml`，把在`server.xml`里配置的各种组件一一创建出来，接着调用Server组件的init方法和start方法，这样整个Tomcat就启动起来了。\n\n**Server组件**\n\nServer继承了LifecycleBase，它的生命周期被统一管理，并且它的子组件是Service，因此它还需要管理Service的生命周期，也就是说在启动时调用Service组件的启动方法，在停止时调用它们的停止方法。\n\n* Server在内部维护了若干Service组件，它是以数组来保存的。","slug":"Tomcat架构解析/核心组件","published":1,"date":"2022-02-04T04:54:16.461Z","updated":"2022-02-04T04:54:47.147Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwin00e9fhji63e57tq4","content":"<p>我们可以通过Tomcat的<code>/bin</code>目录下的脚本<code>startup.sh</code>来启动Tomcat，那我们执行了这个脚本后发生了什么呢？</p>\n<img src=\"https://img-blog.csdnimg.cn/e6f976a917c64eb79c15776ee7172b26.png\" style=\"zoom:25%;\" />\n\n<p><strong>Catalina</strong></p>\n<p>Catalina的主要任务就是创建Server，它不是直接new一个Server实例就完事了，而是需要解析<code>server.xml</code>，把在<code>server.xml</code>里配置的各种组件一一创建出来，接着调用Server组件的init方法和start方法，这样整个Tomcat就启动起来了。</p>\n<p><strong>Server组件</strong></p>\n<p>Server继承了LifecycleBase，它的生命周期被统一管理，并且它的子组件是Service，因此它还需要管理Service的生命周期，也就是说在启动时调用Service组件的启动方法，在停止时调用它们的停止方法。</p>\n<ul>\n<li>Server在内部维护了若干Service组件，它是以数组来保存的。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>我们可以通过Tomcat的<code>/bin</code>目录下的脚本<code>startup.sh</code>来启动Tomcat，那我们执行了这个脚本后发生了什么呢？</p>\n<img src=\"https://img-blog.csdnimg.cn/e6f976a917c64eb79c15776ee7172b26.png\" style=\"zoom:25%;\" />\n\n<p><strong>Catalina</strong></p>\n<p>Catalina的主要任务就是创建Server，它不是直接new一个Server实例就完事了，而是需要解析<code>server.xml</code>，把在<code>server.xml</code>里配置的各种组件一一创建出来，接着调用Server组件的init方法和start方法，这样整个Tomcat就启动起来了。</p>\n<p><strong>Server组件</strong></p>\n<p>Server继承了LifecycleBase，它的生命周期被统一管理，并且它的子组件是Service，因此它还需要管理Service的生命周期，也就是说在启动时调用Service组件的启动方法，在停止时调用它们的停止方法。</p>\n<ul>\n<li>Server在内部维护了若干Service组件，它是以数组来保存的。</li>\n</ul>\n"},{"title":"热部署和热加载","_content":"\n要在运行的过程中升级Web应用，如果你不想重启系统，实现的方式有两种：热加载和热部署。\n\n那如何实现热部署和热加载呢？它们跟类加载机制有关，具体来说就是：\n\n- 热加载的实现方式是Web容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空Session ，一般用在开发环境。\n- 热部署原理类似，也是由后台线程定时检测Web应用的变化，但它会重新加载整个Web应用。这种方式会清空Session，比热加载更加干净、彻底，一般用在生产环境。\n\nTomcat通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。\n\n**Tomcat的后台线程**\n\n要说开启后台线程做周期性的任务，马上会想到线程池中的ScheduledThreadPoolExecutor，它除了具有线程池的功能，还能够执行周期性的任务。\n\n> Tomcat就是通过它来开启后台线程的。\n\n我们只需要在顶层容器，也就是Engine容器中启动一个后台线程，那么这个线程**不但会执行Engine容器的周期性任务，它还会执行所有子容器的周期性任务**。\n\n**热加载**\n\n* 我们可以在Context上配置reloadable属性为true，这样就表示该应用开启了热加载功能，默认是false\n\n热加载触发的条件是：**WEB-INF/classes目录下的文件发生了变化，WEB-INF/lib目录下的jar包添加、删除、修改都会触发热加载**\n\n> 注意：虽然我们在热加载的过程发现它是先停止再启动，做法看似粗暴，但是这样是性价比比较高的，并且这种方式至少比重启Tomcat效率要高很多\n\n> 注意：热加载不能用于war包\n","source":"_posts/Tomcat架构解析/热部署和热加载.md","raw":"---\ntitle: 热部署和热加载\ncategories: \n- Tomcat架构解析\n---\n\n要在运行的过程中升级Web应用，如果你不想重启系统，实现的方式有两种：热加载和热部署。\n\n那如何实现热部署和热加载呢？它们跟类加载机制有关，具体来说就是：\n\n- 热加载的实现方式是Web容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空Session ，一般用在开发环境。\n- 热部署原理类似，也是由后台线程定时检测Web应用的变化，但它会重新加载整个Web应用。这种方式会清空Session，比热加载更加干净、彻底，一般用在生产环境。\n\nTomcat通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。\n\n**Tomcat的后台线程**\n\n要说开启后台线程做周期性的任务，马上会想到线程池中的ScheduledThreadPoolExecutor，它除了具有线程池的功能，还能够执行周期性的任务。\n\n> Tomcat就是通过它来开启后台线程的。\n\n我们只需要在顶层容器，也就是Engine容器中启动一个后台线程，那么这个线程**不但会执行Engine容器的周期性任务，它还会执行所有子容器的周期性任务**。\n\n**热加载**\n\n* 我们可以在Context上配置reloadable属性为true，这样就表示该应用开启了热加载功能，默认是false\n\n热加载触发的条件是：**WEB-INF/classes目录下的文件发生了变化，WEB-INF/lib目录下的jar包添加、删除、修改都会触发热加载**\n\n> 注意：虽然我们在热加载的过程发现它是先停止再启动，做法看似粗暴，但是这样是性价比比较高的，并且这种方式至少比重启Tomcat效率要高很多\n\n> 注意：热加载不能用于war包\n","slug":"Tomcat架构解析/热部署和热加载","published":1,"date":"2022-02-04T05:53:44.194Z","updated":"2022-02-04T05:56:19.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwio00ecfhjigi2s31jc","content":"<p>要在运行的过程中升级Web应用，如果你不想重启系统，实现的方式有两种：热加载和热部署。</p>\n<p>那如何实现热部署和热加载呢？它们跟类加载机制有关，具体来说就是：</p>\n<ul>\n<li>热加载的实现方式是Web容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空Session ，一般用在开发环境。</li>\n<li>热部署原理类似，也是由后台线程定时检测Web应用的变化，但它会重新加载整个Web应用。这种方式会清空Session，比热加载更加干净、彻底，一般用在生产环境。</li>\n</ul>\n<p>Tomcat通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。</p>\n<p><strong>Tomcat的后台线程</strong></p>\n<p>要说开启后台线程做周期性的任务，马上会想到线程池中的ScheduledThreadPoolExecutor，它除了具有线程池的功能，还能够执行周期性的任务。</p>\n<blockquote>\n<p>Tomcat就是通过它来开启后台线程的。</p>\n</blockquote>\n<p>我们只需要在顶层容器，也就是Engine容器中启动一个后台线程，那么这个线程<strong>不但会执行Engine容器的周期性任务，它还会执行所有子容器的周期性任务</strong>。</p>\n<p><strong>热加载</strong></p>\n<ul>\n<li>我们可以在Context上配置reloadable属性为true，这样就表示该应用开启了热加载功能，默认是false</li>\n</ul>\n<p>热加载触发的条件是：<strong>WEB-INF&#x2F;classes目录下的文件发生了变化，WEB-INF&#x2F;lib目录下的jar包添加、删除、修改都会触发热加载</strong></p>\n<blockquote>\n<p>注意：虽然我们在热加载的过程发现它是先停止再启动，做法看似粗暴，但是这样是性价比比较高的，并且这种方式至少比重启Tomcat效率要高很多</p>\n</blockquote>\n<blockquote>\n<p>注意：热加载不能用于war包</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>要在运行的过程中升级Web应用，如果你不想重启系统，实现的方式有两种：热加载和热部署。</p>\n<p>那如何实现热部署和热加载呢？它们跟类加载机制有关，具体来说就是：</p>\n<ul>\n<li>热加载的实现方式是Web容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空Session ，一般用在开发环境。</li>\n<li>热部署原理类似，也是由后台线程定时检测Web应用的变化，但它会重新加载整个Web应用。这种方式会清空Session，比热加载更加干净、彻底，一般用在生产环境。</li>\n</ul>\n<p>Tomcat通过开启后台线程，使得各个层次的容器组件都有机会完成一些周期性任务。</p>\n<p><strong>Tomcat的后台线程</strong></p>\n<p>要说开启后台线程做周期性的任务，马上会想到线程池中的ScheduledThreadPoolExecutor，它除了具有线程池的功能，还能够执行周期性的任务。</p>\n<blockquote>\n<p>Tomcat就是通过它来开启后台线程的。</p>\n</blockquote>\n<p>我们只需要在顶层容器，也就是Engine容器中启动一个后台线程，那么这个线程<strong>不但会执行Engine容器的周期性任务，它还会执行所有子容器的周期性任务</strong>。</p>\n<p><strong>热加载</strong></p>\n<ul>\n<li>我们可以在Context上配置reloadable属性为true，这样就表示该应用开启了热加载功能，默认是false</li>\n</ul>\n<p>热加载触发的条件是：<strong>WEB-INF&#x2F;classes目录下的文件发生了变化，WEB-INF&#x2F;lib目录下的jar包添加、删除、修改都会触发热加载</strong></p>\n<blockquote>\n<p>注意：虽然我们在热加载的过程发现它是先停止再启动，做法看似粗暴，但是这样是性价比比较高的，并且这种方式至少比重启Tomcat效率要高很多</p>\n</blockquote>\n<blockquote>\n<p>注意：热加载不能用于war包</p>\n</blockquote>\n"},{"title":"生命周期管理","_content":"\n<img src=\"https://img-blog.csdnimg.cn/e785b731c60149e3904f86f8c0fb4448.png\" style=\"zoom:25%;\" />\n\n上面这张图描述了组件之间的静态关系，如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；\n\n在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。\n\n> 也就是说，Tomcat需要动态地管理这些组件的生命周期。\n\n**Lifecycle接口**\n\n> 这个接口跟生命周期有关。\n\nLifecycle接口里应该定义这么几个方法：init、start、stop和destroy，每个具体的组件去实现这些方法。\n\n理所当然，在父组件的init方法里需要创建子组件并调用子组件的init方法。\n\n同样，在父组件的start方法里也需要调用子组件的start方法，因此调用者可以无差别的调用各组件的init方法和start方法，这就是**组合模式**的使用，并且只要调用最顶层组件，也就是Server组件的init和start方法，整个Tomcat就被启动起来了。\n\n**Lifecycle事件**\n\n我们注意到，组件的init和start调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。\n\n> 而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除，这就是典型的**观察者模式**。\n\n具体来说就是在Lifecycle接口里加入两个方法：添加监听器和删除监听器。\n\n除此之外，我们还需要定义一个Enum来表示组件有哪些状态，以及处在什么状态会触发什么样的事件。\n\n","source":"_posts/Tomcat架构解析/生命周期管理.md","raw":"---\ntitle: 生命周期管理\ncategories: \n- Tomcat架构解析\n---\n\n<img src=\"https://img-blog.csdnimg.cn/e785b731c60149e3904f86f8c0fb4448.png\" style=\"zoom:25%;\" />\n\n上面这张图描述了组件之间的静态关系，如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；\n\n在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。\n\n> 也就是说，Tomcat需要动态地管理这些组件的生命周期。\n\n**Lifecycle接口**\n\n> 这个接口跟生命周期有关。\n\nLifecycle接口里应该定义这么几个方法：init、start、stop和destroy，每个具体的组件去实现这些方法。\n\n理所当然，在父组件的init方法里需要创建子组件并调用子组件的init方法。\n\n同样，在父组件的start方法里也需要调用子组件的start方法，因此调用者可以无差别的调用各组件的init方法和start方法，这就是**组合模式**的使用，并且只要调用最顶层组件，也就是Server组件的init和start方法，整个Tomcat就被启动起来了。\n\n**Lifecycle事件**\n\n我们注意到，组件的init和start调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。\n\n> 而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除，这就是典型的**观察者模式**。\n\n具体来说就是在Lifecycle接口里加入两个方法：添加监听器和删除监听器。\n\n除此之外，我们还需要定义一个Enum来表示组件有哪些状态，以及处在什么状态会触发什么样的事件。\n\n","slug":"Tomcat架构解析/生命周期管理","published":1,"date":"2022-02-03T04:17:40.972Z","updated":"2022-02-03T04:24:24.587Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwip00edfhjignx41ako","content":"<img src=\"https://img-blog.csdnimg.cn/e785b731c60149e3904f86f8c0fb4448.png\" style=\"zoom:25%;\" />\n\n<p>上面这张图描述了组件之间的静态关系，如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；</p>\n<p>在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。</p>\n<blockquote>\n<p>也就是说，Tomcat需要动态地管理这些组件的生命周期。</p>\n</blockquote>\n<p><strong>Lifecycle接口</strong></p>\n<blockquote>\n<p>这个接口跟生命周期有关。</p>\n</blockquote>\n<p>Lifecycle接口里应该定义这么几个方法：init、start、stop和destroy，每个具体的组件去实现这些方法。</p>\n<p>理所当然，在父组件的init方法里需要创建子组件并调用子组件的init方法。</p>\n<p>同样，在父组件的start方法里也需要调用子组件的start方法，因此调用者可以无差别的调用各组件的init方法和start方法，这就是<strong>组合模式</strong>的使用，并且只要调用最顶层组件，也就是Server组件的init和start方法，整个Tomcat就被启动起来了。</p>\n<p><strong>Lifecycle事件</strong></p>\n<p>我们注意到，组件的init和start调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。</p>\n<blockquote>\n<p>而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除，这就是典型的<strong>观察者模式</strong>。</p>\n</blockquote>\n<p>具体来说就是在Lifecycle接口里加入两个方法：添加监听器和删除监听器。</p>\n<p>除此之外，我们还需要定义一个Enum来表示组件有哪些状态，以及处在什么状态会触发什么样的事件。</p>\n","site":{"data":{}},"excerpt":"","more":"<img src=\"https://img-blog.csdnimg.cn/e785b731c60149e3904f86f8c0fb4448.png\" style=\"zoom:25%;\" />\n\n<p>上面这张图描述了组件之间的静态关系，如果想让一个系统能够对外提供服务，我们需要创建、组装并启动这些组件；</p>\n<p>在服务停止的时候，我们还需要释放资源，销毁这些组件，因此这是一个动态的过程。</p>\n<blockquote>\n<p>也就是说，Tomcat需要动态地管理这些组件的生命周期。</p>\n</blockquote>\n<p><strong>Lifecycle接口</strong></p>\n<blockquote>\n<p>这个接口跟生命周期有关。</p>\n</blockquote>\n<p>Lifecycle接口里应该定义这么几个方法：init、start、stop和destroy，每个具体的组件去实现这些方法。</p>\n<p>理所当然，在父组件的init方法里需要创建子组件并调用子组件的init方法。</p>\n<p>同样，在父组件的start方法里也需要调用子组件的start方法，因此调用者可以无差别的调用各组件的init方法和start方法，这就是<strong>组合模式</strong>的使用，并且只要调用最顶层组件，也就是Server组件的init和start方法，整个Tomcat就被启动起来了。</p>\n<p><strong>Lifecycle事件</strong></p>\n<p>我们注意到，组件的init和start调用是由它的父组件的状态变化触发的，上层组件的初始化会触发子组件的初始化，上层组件的启动会触发子组件的启动，因此我们把组件的生命周期定义成一个个状态，把状态的转变看作是一个事件。</p>\n<blockquote>\n<p>而事件是有监听器的，在监听器里可以实现一些逻辑，并且监听器也可以方便的添加和删除，这就是典型的<strong>观察者模式</strong>。</p>\n</blockquote>\n<p>具体来说就是在Lifecycle接口里加入两个方法：添加监听器和删除监听器。</p>\n<p>除此之外，我们还需要定义一个Enum来表示组件有哪些状态，以及处在什么状态会触发什么样的事件。</p>\n"},{"title":"类加载器","_content":"\nTomcat作为Servlet容器，它负责加载我们的Servlet类，此外它还负责加载Servlet所依赖的JAR包。\n\n并且Tomcat本身也是一个Java程序，因此它需要加载自己的类和依赖的JAR包。\n\n**Tomcat类加载器的层次结构**\n\n<img src=\"https://img-blog.csdnimg.cn/6e65887a605646888368f3a0203bf668.png\" style=\"zoom:25%;\" />\n\n假如我们使用JVM默认AppClassLoader来加载Web应用，AppClassLoader只能加载一个Servlet类，在加载第二个同名Servlet类时，AppClassLoader会返回第一个Servlet类的Class实例，这是因为在AppClassLoader看来，同名的Servlet类只被加载一次。\n\n> 因此Tomcat的解决方案是自定义一个类加载器WebAppClassLoader， 并且给每个Web应用创建一个类加载器实例。\n\nContext容器组件对应一个Web应用，因此，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。\n\n**不同的加载器实例加载的类被认为是不同的类**，即使它们的类名相同。这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间，每一个Web应用都有自己的类空间，Web应用之间通过各自的类加载器互相隔离。\n\n**SharedClassLoader**\n\n在双亲委托机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享JRE的核心类。\n\n因此Tomcat的设计者又加了一个类加载器SharedClassLoader，作为WebAppClassLoader的父加载器，专门来加载Web应用之间共享的类。如果WebAppClassLoader自己没有加载到某个类，就会委托父加载器SharedClassLoader去加载这个类，SharedClassLoader会在指定目录下加载共享类，之后返回给WebAppClassLoader，这样共享的问题就解决了。\n\n**CatalinaClassLoader**\n\n> 如何隔离Tomcat本身的类和Web应用的类？\n\n我们知道，要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。\n\n基于此Tomcat又设计一个类加载器CatalinaClassLoader，专门来加载Tomcat自身的类。\n\n**CommonClassLoader**\n\n> Tomcat和各Web应用之间需要共享一些类时该怎么办呢？\n\n* 增加CommonClassLoader，作为CatalinaClassLoader和SharedClassLoader的父加载器。\n\nCommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader 使用，而CatalinaClassLoader和SharedClassLoader能加载的类则与对方相互隔离。\n\nWebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。","source":"_posts/Tomcat架构解析/类加载器.md","raw":"---\ntitle: 类加载器\ncategories: \n- Tomcat架构解析\n---\n\nTomcat作为Servlet容器，它负责加载我们的Servlet类，此外它还负责加载Servlet所依赖的JAR包。\n\n并且Tomcat本身也是一个Java程序，因此它需要加载自己的类和依赖的JAR包。\n\n**Tomcat类加载器的层次结构**\n\n<img src=\"https://img-blog.csdnimg.cn/6e65887a605646888368f3a0203bf668.png\" style=\"zoom:25%;\" />\n\n假如我们使用JVM默认AppClassLoader来加载Web应用，AppClassLoader只能加载一个Servlet类，在加载第二个同名Servlet类时，AppClassLoader会返回第一个Servlet类的Class实例，这是因为在AppClassLoader看来，同名的Servlet类只被加载一次。\n\n> 因此Tomcat的解决方案是自定义一个类加载器WebAppClassLoader， 并且给每个Web应用创建一个类加载器实例。\n\nContext容器组件对应一个Web应用，因此，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。\n\n**不同的加载器实例加载的类被认为是不同的类**，即使它们的类名相同。这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间，每一个Web应用都有自己的类空间，Web应用之间通过各自的类加载器互相隔离。\n\n**SharedClassLoader**\n\n在双亲委托机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享JRE的核心类。\n\n因此Tomcat的设计者又加了一个类加载器SharedClassLoader，作为WebAppClassLoader的父加载器，专门来加载Web应用之间共享的类。如果WebAppClassLoader自己没有加载到某个类，就会委托父加载器SharedClassLoader去加载这个类，SharedClassLoader会在指定目录下加载共享类，之后返回给WebAppClassLoader，这样共享的问题就解决了。\n\n**CatalinaClassLoader**\n\n> 如何隔离Tomcat本身的类和Web应用的类？\n\n我们知道，要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。\n\n基于此Tomcat又设计一个类加载器CatalinaClassLoader，专门来加载Tomcat自身的类。\n\n**CommonClassLoader**\n\n> Tomcat和各Web应用之间需要共享一些类时该怎么办呢？\n\n* 增加CommonClassLoader，作为CatalinaClassLoader和SharedClassLoader的父加载器。\n\nCommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader 使用，而CatalinaClassLoader和SharedClassLoader能加载的类则与对方相互隔离。\n\nWebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。","slug":"Tomcat架构解析/类加载器","published":1,"date":"2022-02-05T03:41:55.851Z","updated":"2022-02-05T03:53:18.764Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiq00egfhji2wphgssg","content":"<p>Tomcat作为Servlet容器，它负责加载我们的Servlet类，此外它还负责加载Servlet所依赖的JAR包。</p>\n<p>并且Tomcat本身也是一个Java程序，因此它需要加载自己的类和依赖的JAR包。</p>\n<p><strong>Tomcat类加载器的层次结构</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/6e65887a605646888368f3a0203bf668.png\" style=\"zoom:25%;\" />\n\n<p>假如我们使用JVM默认AppClassLoader来加载Web应用，AppClassLoader只能加载一个Servlet类，在加载第二个同名Servlet类时，AppClassLoader会返回第一个Servlet类的Class实例，这是因为在AppClassLoader看来，同名的Servlet类只被加载一次。</p>\n<blockquote>\n<p>因此Tomcat的解决方案是自定义一个类加载器WebAppClassLoader， 并且给每个Web应用创建一个类加载器实例。</p>\n</blockquote>\n<p>Context容器组件对应一个Web应用，因此，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。</p>\n<p><strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间，每一个Web应用都有自己的类空间，Web应用之间通过各自的类加载器互相隔离。</p>\n<p><strong>SharedClassLoader</strong></p>\n<p>在双亲委托机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享JRE的核心类。</p>\n<p>因此Tomcat的设计者又加了一个类加载器SharedClassLoader，作为WebAppClassLoader的父加载器，专门来加载Web应用之间共享的类。如果WebAppClassLoader自己没有加载到某个类，就会委托父加载器SharedClassLoader去加载这个类，SharedClassLoader会在指定目录下加载共享类，之后返回给WebAppClassLoader，这样共享的问题就解决了。</p>\n<p><strong>CatalinaClassLoader</strong></p>\n<blockquote>\n<p>如何隔离Tomcat本身的类和Web应用的类？</p>\n</blockquote>\n<p>我们知道，要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。</p>\n<p>基于此Tomcat又设计一个类加载器CatalinaClassLoader，专门来加载Tomcat自身的类。</p>\n<p><strong>CommonClassLoader</strong></p>\n<blockquote>\n<p>Tomcat和各Web应用之间需要共享一些类时该怎么办呢？</p>\n</blockquote>\n<ul>\n<li>增加CommonClassLoader，作为CatalinaClassLoader和SharedClassLoader的父加载器。</li>\n</ul>\n<p>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader 使用，而CatalinaClassLoader和SharedClassLoader能加载的类则与对方相互隔离。</p>\n<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Tomcat作为Servlet容器，它负责加载我们的Servlet类，此外它还负责加载Servlet所依赖的JAR包。</p>\n<p>并且Tomcat本身也是一个Java程序，因此它需要加载自己的类和依赖的JAR包。</p>\n<p><strong>Tomcat类加载器的层次结构</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/6e65887a605646888368f3a0203bf668.png\" style=\"zoom:25%;\" />\n\n<p>假如我们使用JVM默认AppClassLoader来加载Web应用，AppClassLoader只能加载一个Servlet类，在加载第二个同名Servlet类时，AppClassLoader会返回第一个Servlet类的Class实例，这是因为在AppClassLoader看来，同名的Servlet类只被加载一次。</p>\n<blockquote>\n<p>因此Tomcat的解决方案是自定义一个类加载器WebAppClassLoader， 并且给每个Web应用创建一个类加载器实例。</p>\n</blockquote>\n<p>Context容器组件对应一个Web应用，因此，每个Context容器负责创建和维护一个WebAppClassLoader加载器实例。</p>\n<p><strong>不同的加载器实例加载的类被认为是不同的类</strong>，即使它们的类名相同。这就相当于在Java虚拟机内部创建了一个个相互隔离的Java类空间，每一个Web应用都有自己的类空间，Web应用之间通过各自的类加载器互相隔离。</p>\n<p><strong>SharedClassLoader</strong></p>\n<p>在双亲委托机制里，各个子加载器都可以通过父加载器去加载类，那么把需要共享的类放到父加载器的加载路径下不就行了吗，应用程序也正是通过这种方式共享JRE的核心类。</p>\n<p>因此Tomcat的设计者又加了一个类加载器SharedClassLoader，作为WebAppClassLoader的父加载器，专门来加载Web应用之间共享的类。如果WebAppClassLoader自己没有加载到某个类，就会委托父加载器SharedClassLoader去加载这个类，SharedClassLoader会在指定目录下加载共享类，之后返回给WebAppClassLoader，这样共享的问题就解决了。</p>\n<p><strong>CatalinaClassLoader</strong></p>\n<blockquote>\n<p>如何隔离Tomcat本身的类和Web应用的类？</p>\n</blockquote>\n<p>我们知道，要共享可以通过父子关系，要隔离那就需要兄弟关系了。兄弟关系就是指两个类加载器是平行的，它们可能拥有同一个父加载器，但是两个兄弟类加载器加载的类是隔离的。</p>\n<p>基于此Tomcat又设计一个类加载器CatalinaClassLoader，专门来加载Tomcat自身的类。</p>\n<p><strong>CommonClassLoader</strong></p>\n<blockquote>\n<p>Tomcat和各Web应用之间需要共享一些类时该怎么办呢？</p>\n</blockquote>\n<ul>\n<li>增加CommonClassLoader，作为CatalinaClassLoader和SharedClassLoader的父加载器。</li>\n</ul>\n<p>CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader 使用，而CatalinaClassLoader和SharedClassLoader能加载的类则与对方相互隔离。</p>\n<p>WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。</p>\n"},{"title":"连接器","_content":"\nTomcat要实现2个核心功能：\n\n- 处理Socket连接，负责网络字节流与Request和Response对象的转化。\n- 加载和管理Servlet，以及具体处理Request请求。\n\n**因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。**\n\n**连接器负责对外交流，容器负责内部处理。**\n\nTomcat支持的I/O模型：\n\n- NIO：非阻塞I/O，采用Java NIO类库实现。\n- NIO.2：异步I/O，采用JDK 7最新的NIO.2类库实现。\n- APR：采用Apache可移植运行库实现，是C/C++编写的本地库。\n\nTomcat支持的应用层协议有：\n\n- HTTP/1.1：这是大部分Web应用采用的访问协议。\n- AJP：用于和Web服务器集成（如Apache）。\n- HTTP/2：HTTP 2.0大幅度的提升了Web性能。\n\nTomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。\n\n* 但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作Service组件。\n\n> Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。\n\nTomcat内可能有多个Service，这样的设计也是出于灵活性的考虑。\n\n通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。\n\n<img src=\"https://img-blog.csdnimg.cn/1990e7c358494088a783e5d6235b398e.png\" style=\"zoom:25%;\" />\n\n* 最顶层是Server，这里的Server指的就是一个Tomcat实例。\n\n* 一个Server中有一个或者多个Service，一个Service中有多个连接器和一个容器。\n\n* 连接器与容器之间通过标准的ServletRequest和ServletResponse通信。\n\n**连接器**\n\n连接器对Servlet容器屏蔽了协议及I/O模型等的区别，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象。\n\n连接器需要完成3个**高内聚**的功能：\n\n- 网络通信。\n- 应用层协议解析。\n- Tomcat Request/Response与ServletRequest/ServletResponse的转化。\n\n因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是Endpoint、Processor和Adapter。\n\n**Tomcat3个组件**\n\n<img src=\"https://img-blog.csdnimg.cn/76ed2f29729f4904ae895395b3253a07.png\" style=\"zoom:25%;\" />\n\n**ProtocolHandler组件**\n\n* 连接器用ProtocolHandler来处理网络连接和应用层协议。\n\n**Endpoint**\n\n* Endpoint是通信端点，即通信监听的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此Endpoint是用来实现TCP/IP协议的。\n\n**Processor**\n\n* 如果说Endpoint是用来实现TCP/IP协议的，那么Processor用来实现HTTP协议，Processor接收来自Endpoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象。\n\n<img src=\"https://img-blog.csdnimg.cn/ea1a310823b740c28148c0a7f6fe2cf6.png\" style=\"zoom:25%;\" />\n\n**Adapter组件**\n\n由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类来存放这些请求信息。\n\nProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。\n\n> 连接器通过适配器Adapter调用容器。\n\n**总结：**\n\nTomcat的整体架构包含了两个核心组件连接器和容器。\n\n> 连接器负责对外交流，容器负责内部处理。\n\n连接器用ProtocolHandler接口来封装通信协议和I/O模型的差异，ProtocolHandler内部又分为Endpoint和Processor模块，Endpoint负责底层Socket通信，Processor负责应用层协议解析。连接器通过适配器Adapter调用容器。","source":"_posts/Tomcat架构解析/连接器.md","raw":"---\ntitle: 连接器\ncategories: \n- Tomcat架构解析\n---\n\nTomcat要实现2个核心功能：\n\n- 处理Socket连接，负责网络字节流与Request和Response对象的转化。\n- 加载和管理Servlet，以及具体处理Request请求。\n\n**因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。**\n\n**连接器负责对外交流，容器负责内部处理。**\n\nTomcat支持的I/O模型：\n\n- NIO：非阻塞I/O，采用Java NIO类库实现。\n- NIO.2：异步I/O，采用JDK 7最新的NIO.2类库实现。\n- APR：采用Apache可移植运行库实现，是C/C++编写的本地库。\n\nTomcat支持的应用层协议有：\n\n- HTTP/1.1：这是大部分Web应用采用的访问协议。\n- AJP：用于和Web服务器集成（如Apache）。\n- HTTP/2：HTTP 2.0大幅度的提升了Web性能。\n\nTomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。\n\n* 但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作Service组件。\n\n> Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。\n\nTomcat内可能有多个Service，这样的设计也是出于灵活性的考虑。\n\n通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。\n\n<img src=\"https://img-blog.csdnimg.cn/1990e7c358494088a783e5d6235b398e.png\" style=\"zoom:25%;\" />\n\n* 最顶层是Server，这里的Server指的就是一个Tomcat实例。\n\n* 一个Server中有一个或者多个Service，一个Service中有多个连接器和一个容器。\n\n* 连接器与容器之间通过标准的ServletRequest和ServletResponse通信。\n\n**连接器**\n\n连接器对Servlet容器屏蔽了协议及I/O模型等的区别，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象。\n\n连接器需要完成3个**高内聚**的功能：\n\n- 网络通信。\n- 应用层协议解析。\n- Tomcat Request/Response与ServletRequest/ServletResponse的转化。\n\n因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是Endpoint、Processor和Adapter。\n\n**Tomcat3个组件**\n\n<img src=\"https://img-blog.csdnimg.cn/76ed2f29729f4904ae895395b3253a07.png\" style=\"zoom:25%;\" />\n\n**ProtocolHandler组件**\n\n* 连接器用ProtocolHandler来处理网络连接和应用层协议。\n\n**Endpoint**\n\n* Endpoint是通信端点，即通信监听的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此Endpoint是用来实现TCP/IP协议的。\n\n**Processor**\n\n* 如果说Endpoint是用来实现TCP/IP协议的，那么Processor用来实现HTTP协议，Processor接收来自Endpoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象。\n\n<img src=\"https://img-blog.csdnimg.cn/ea1a310823b740c28148c0a7f6fe2cf6.png\" style=\"zoom:25%;\" />\n\n**Adapter组件**\n\n由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类来存放这些请求信息。\n\nProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。\n\n> 连接器通过适配器Adapter调用容器。\n\n**总结：**\n\nTomcat的整体架构包含了两个核心组件连接器和容器。\n\n> 连接器负责对外交流，容器负责内部处理。\n\n连接器用ProtocolHandler接口来封装通信协议和I/O模型的差异，ProtocolHandler内部又分为Endpoint和Processor模块，Endpoint负责底层Socket通信，Processor负责应用层协议解析。连接器通过适配器Adapter调用容器。","slug":"Tomcat架构解析/连接器","published":1,"date":"2022-02-03T03:35:56.097Z","updated":"2022-02-03T04:06:00.726Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiq00ehfhji1sr63dcg","content":"<p>Tomcat要实现2个核心功能：</p>\n<ul>\n<li>处理Socket连接，负责网络字节流与Request和Response对象的转化。</li>\n<li>加载和管理Servlet，以及具体处理Request请求。</li>\n</ul>\n<p><strong>因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。</strong></p>\n<p><strong>连接器负责对外交流，容器负责内部处理。</strong></p>\n<p>Tomcat支持的I&#x2F;O模型：</p>\n<ul>\n<li>NIO：非阻塞I&#x2F;O，采用Java NIO类库实现。</li>\n<li>NIO.2：异步I&#x2F;O，采用JDK 7最新的NIO.2类库实现。</li>\n<li>APR：采用Apache可移植运行库实现，是C&#x2F;C++编写的本地库。</li>\n</ul>\n<p>Tomcat支持的应用层协议有：</p>\n<ul>\n<li>HTTP&#x2F;1.1：这是大部分Web应用采用的访问协议。</li>\n<li>AJP：用于和Web服务器集成（如Apache）。</li>\n<li>HTTP&#x2F;2：HTTP 2.0大幅度的提升了Web性能。</li>\n</ul>\n<p>Tomcat为了实现支持多种I&#x2F;O模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。</p>\n<ul>\n<li>但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作Service组件。</li>\n</ul>\n<blockquote>\n<p>Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。</p>\n</blockquote>\n<p>Tomcat内可能有多个Service，这样的设计也是出于灵活性的考虑。</p>\n<p>通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>\n<img src=\"https://img-blog.csdnimg.cn/1990e7c358494088a783e5d6235b398e.png\" style=\"zoom:25%;\" />\n\n<ul>\n<li><p>最顶层是Server，这里的Server指的就是一个Tomcat实例。</p>\n</li>\n<li><p>一个Server中有一个或者多个Service，一个Service中有多个连接器和一个容器。</p>\n</li>\n<li><p>连接器与容器之间通过标准的ServletRequest和ServletResponse通信。</p>\n</li>\n</ul>\n<p><strong>连接器</strong></p>\n<p>连接器对Servlet容器屏蔽了协议及I&#x2F;O模型等的区别，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象。</p>\n<p>连接器需要完成3个<strong>高内聚</strong>的功能：</p>\n<ul>\n<li>网络通信。</li>\n<li>应用层协议解析。</li>\n<li>Tomcat Request&#x2F;Response与ServletRequest&#x2F;ServletResponse的转化。</li>\n</ul>\n<p>因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是Endpoint、Processor和Adapter。</p>\n<p><strong>Tomcat3个组件</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/76ed2f29729f4904ae895395b3253a07.png\" style=\"zoom:25%;\" />\n\n<p><strong>ProtocolHandler组件</strong></p>\n<ul>\n<li>连接器用ProtocolHandler来处理网络连接和应用层协议。</li>\n</ul>\n<p><strong>Endpoint</strong></p>\n<ul>\n<li>Endpoint是通信端点，即通信监听的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此Endpoint是用来实现TCP&#x2F;IP协议的。</li>\n</ul>\n<p><strong>Processor</strong></p>\n<ul>\n<li>如果说Endpoint是用来实现TCP&#x2F;IP协议的，那么Processor用来实现HTTP协议，Processor接收来自Endpoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象。</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/ea1a310823b740c28148c0a7f6fe2cf6.png\" style=\"zoom:25%;\" />\n\n<p><strong>Adapter组件</strong></p>\n<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类来存放这些请求信息。</p>\n<p>ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。</p>\n<blockquote>\n<p>连接器通过适配器Adapter调用容器。</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<p>Tomcat的整体架构包含了两个核心组件连接器和容器。</p>\n<blockquote>\n<p>连接器负责对外交流，容器负责内部处理。</p>\n</blockquote>\n<p>连接器用ProtocolHandler接口来封装通信协议和I&#x2F;O模型的差异，ProtocolHandler内部又分为Endpoint和Processor模块，Endpoint负责底层Socket通信，Processor负责应用层协议解析。连接器通过适配器Adapter调用容器。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Tomcat要实现2个核心功能：</p>\n<ul>\n<li>处理Socket连接，负责网络字节流与Request和Response对象的转化。</li>\n<li>加载和管理Servlet，以及具体处理Request请求。</li>\n</ul>\n<p><strong>因此Tomcat设计了两个核心组件连接器（Connector）和容器（Container）来分别做这两件事情。</strong></p>\n<p><strong>连接器负责对外交流，容器负责内部处理。</strong></p>\n<p>Tomcat支持的I&#x2F;O模型：</p>\n<ul>\n<li>NIO：非阻塞I&#x2F;O，采用Java NIO类库实现。</li>\n<li>NIO.2：异步I&#x2F;O，采用JDK 7最新的NIO.2类库实现。</li>\n<li>APR：采用Apache可移植运行库实现，是C&#x2F;C++编写的本地库。</li>\n</ul>\n<p>Tomcat支持的应用层协议有：</p>\n<ul>\n<li>HTTP&#x2F;1.1：这是大部分Web应用采用的访问协议。</li>\n<li>AJP：用于和Web服务器集成（如Apache）。</li>\n<li>HTTP&#x2F;2：HTTP 2.0大幅度的提升了Web性能。</li>\n</ul>\n<p>Tomcat为了实现支持多种I&#x2F;O模型和应用层协议，一个容器可能对接多个连接器，就好比一个房间有多个门。</p>\n<ul>\n<li>但是单独的连接器或者容器都不能对外提供服务，需要把它们组装起来才能工作，组装后这个整体叫作Service组件。</li>\n</ul>\n<blockquote>\n<p>Service本身没有做什么重要的事情，只是在连接器和容器外面多包了一层，把它们组装在一起。</p>\n</blockquote>\n<p>Tomcat内可能有多个Service，这样的设计也是出于灵活性的考虑。</p>\n<p>通过在Tomcat中配置多个Service，可以实现通过不同的端口号来访问同一台机器上部署的不同应用。</p>\n<img src=\"https://img-blog.csdnimg.cn/1990e7c358494088a783e5d6235b398e.png\" style=\"zoom:25%;\" />\n\n<ul>\n<li><p>最顶层是Server，这里的Server指的就是一个Tomcat实例。</p>\n</li>\n<li><p>一个Server中有一个或者多个Service，一个Service中有多个连接器和一个容器。</p>\n</li>\n<li><p>连接器与容器之间通过标准的ServletRequest和ServletResponse通信。</p>\n</li>\n</ul>\n<p><strong>连接器</strong></p>\n<p>连接器对Servlet容器屏蔽了协议及I&#x2F;O模型等的区别，无论是HTTP还是AJP，在容器中获取到的都是一个标准的ServletRequest对象。</p>\n<p>连接器需要完成3个<strong>高内聚</strong>的功能：</p>\n<ul>\n<li>网络通信。</li>\n<li>应用层协议解析。</li>\n<li>Tomcat Request&#x2F;Response与ServletRequest&#x2F;ServletResponse的转化。</li>\n</ul>\n<p>因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是Endpoint、Processor和Adapter。</p>\n<p><strong>Tomcat3个组件</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/76ed2f29729f4904ae895395b3253a07.png\" style=\"zoom:25%;\" />\n\n<p><strong>ProtocolHandler组件</strong></p>\n<ul>\n<li>连接器用ProtocolHandler来处理网络连接和应用层协议。</li>\n</ul>\n<p><strong>Endpoint</strong></p>\n<ul>\n<li>Endpoint是通信端点，即通信监听的接口，是具体的Socket接收和发送处理器，是对传输层的抽象，因此Endpoint是用来实现TCP&#x2F;IP协议的。</li>\n</ul>\n<p><strong>Processor</strong></p>\n<ul>\n<li>如果说Endpoint是用来实现TCP&#x2F;IP协议的，那么Processor用来实现HTTP协议，Processor接收来自Endpoint的Socket，读取字节流解析成Tomcat Request和Response对象，并通过Adapter将其提交到容器处理，Processor是对应用层协议的抽象。</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/ea1a310823b740c28148c0a7f6fe2cf6.png\" style=\"zoom:25%;\" />\n\n<p><strong>Adapter组件</strong></p>\n<p>由于协议不同，客户端发过来的请求信息也不尽相同，Tomcat定义了自己的Request类来存放这些请求信息。</p>\n<p>ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器。</p>\n<blockquote>\n<p>连接器通过适配器Adapter调用容器。</p>\n</blockquote>\n<p><strong>总结：</strong></p>\n<p>Tomcat的整体架构包含了两个核心组件连接器和容器。</p>\n<blockquote>\n<p>连接器负责对外交流，容器负责内部处理。</p>\n</blockquote>\n<p>连接器用ProtocolHandler接口来封装通信协议和I&#x2F;O模型的差异，ProtocolHandler内部又分为Endpoint和Processor模块，Endpoint负责底层Socket通信，Processor负责应用层协议解析。连接器通过适配器Adapter调用容器。</p>\n"},{"title":"ArrayList和LinkedList","_content":"\n# 前言\n\n在面试的时候，经常会被问到几个问题：\n\nArrayList和LinkedList的区别，相信大部分朋友都能回答上：\n\n> ArrayList是基于数组实现，LinkedList是基于链表实现\n>\n> 当随机访问List时，ArrayList比LinkedList的效率更高，等等\n\n当被问到ArrayList和LinkedList的使用场景是什么时，大部分朋友的答案可能是：\n\n> ArrayList和LinkedList在新增、删除元素时，LinkedList的效率要高于 ArrayList，而在遍历的时候，ArrayList的效率要高于LinkedList\n\n那这个回答是否准确呢？今天我们就来研究研究！\n\n配合这篇文章食用会更香，[从源码角度解析ArrayList.subList的几个坑](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484795&idx=1&sn=7da407a6d061f079c5dadcbc2a0fbb7d&scene=21#wechat_redirect)\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n喜欢的话，之后会分享更多系列文章！\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n公众号后台回复666，可以获得免费电子书籍\n\n我们先来简单介绍下ArrayList和LinkedList的原理实现！\n\n# 源码分析\n\n## ArrayList\n\n**实现类**\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n```\n\nArrayList实现了List接口，继承了AbstractList抽象类，底层是数组实现的，并且实现了自增扩容数组大小。\n\nArrayList还实现了Cloneable接口和Serializable接口，所以他可以实现克隆和序列化。\n\nArrayList还实现了RandomAccess接口，这个接口是一个标志接口，他标志着“只要实现该接口的List类，都能实现快速随机访问”。\n\n**基本属性**\n\nArrayList属性主要由数组长度size、对象数组elementData、初始化容量`default_capacity`等组成， 其中初始化容量默认大小为10。\n\n```java\n//默认初始化容量\nprivate static final int DEFAULT_CAPACITY = 10;\n//对象数组\ntransient Object[] elementData; \n//数组长度\nprivate int size;\n```\n\n从ArrayList属性来看，elementData被关键字transient修饰了，transient关键字修饰该字段则表示该属性不会被序列化。\n\n> 但ArrayList其实是实现了序列化接口，这是为什么呢？\n\n由于ArrayList的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。\n\n如果采用外部序列化法实现数组的序列化，会序列化整个数组，ArrayList为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法writeObject以及readObject来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。\n\n因此使用transient修饰数组，是防止对象数组被其他外部方法序列化。\n\nArrayList自定义序列化方法如下：\n\n![](https://img-blog.csdnimg.cn/989715e145c44f4f992094d7668a4fb0.png)\n\n**初始化**\n\n有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：\n\n![](https://img-blog.csdnimg.cn/d18f17fd65654a8fa1fdff6b67ffc57a.png)\n\n当ArrayList新增元素时，如果所存储的元素已经超过其已有大小，它会计算元素大小后再进行动态扩容，数组的扩容会导致整个数组进行一次内存复制。\n\n因此，我们在初始化ArrayList时，可以通过第一个构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。\n\n> 注意点：\n\nArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。\n\n**新增元素**\n\nArrayList新增元素的方法有两种，一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。\n\n```java\n public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n两个方法的相同之处是在添加元素之前，都会先确认容量大小，如果容量够大，就不用进行扩容；如果容量不够大，就会按照原来数组的1.5倍大小进行扩容，在扩容之后需要将数组复制到新分配的内存地址。\n\n下面是具体的源码：\n\n![](https://img-blog.csdnimg.cn/58ccf22a4be540898a8685ad8efd4a6f.png)\n\n这两个方法也有不同之处，添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列，而将元素添加到数组的末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。\n\n> 所以ArrayList在大量新增元素的场景下效率不一定就很慢的\n\n如果我们在初始化时就比较清楚存储数据的大小，就可以在ArrayList初始化时指定数组容量大小，并且在添加元素时，只在数组末尾添加元素，那么ArrayList在大量新增元素的场景下，性能并不会变差，反而比其他List集合的性能要好。\n\n**删除元素**\n\nArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多。\n\nArrayList在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。\n\n我们选取根据值删除方式来进行源码说明：\n\n![](https://img-blog.csdnimg.cn/bbfb216dd9564aa0b3bd893ccd8d15c0.png)\n\n**遍历元素**\n\n由于ArrayList是基于数组实现的，所以在获取元素的时候是非常快捷的。\n\n```java\npublic E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n```\n\n## LinkedList\n\nLinkedList是基于双向链表数据结构实现的。\n\n这个双向链表结构，链表中的每个节点都可以向前或者向后追溯，有几个概念如下：\n\n- 链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；\n- first 是双向链表的头节点，它的前一个节点是 null。\n- last 是双向链表的尾节点，它的后一个节点是 null；\n- 当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；\n- 因为是个双向链表，只要机器内存足够强大，是没有大小限制的。\n\nNode结构中包含了3个部分：元素内容item、前指针prev以及后指针next，代码如下。\n\n```java\nprivate static class Node<E> {\n    E item;// 节点值\n    Node<E> next; // 指向的下一个节点\n    Node<E> prev; // 指向的前一个节点\n\n    // 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\nLinkedList就是由Node结构对象连接而成的一个双向链表。\n\n**实现类**\n\nLinkedList类实现了List接口、Deque接口，同时继承了AbstractSequentialList抽象类，LinkedList既实现了List类型又有Queue类型的特点；LinkedList也实现了Cloneable和Serializable接口，同ArrayList一样，可以实现克隆和序列化。\n\n由于LinkedList存储数据的内存地址是不连续的，而是通过指针来定位不连续地址，因此，LinkedList不支持随机快速访问，LinkedList也就不能实现RandomAccess接口。\n\n```java\npublic class LinkedList\n    extends AbstractSequentialList\n    implements List, Deque, Cloneable, java.io.Serializable\n```\n\n**基本属性**\n\n```java\ntransient int size = 0;\ntransient Node first;\ntransient Node last;\n```\n\n我们可以看到这三个属性都被transient修饰了，原因很简单，我们在序列化的时候不会只对头尾进行序列化，所以LinkedList也是自行实现readObject和writeObject进行序列化与反序列化。\n\n下面是LinkedList自定义序列化的方法。\n\n![](https://img-blog.csdnimg.cn/f48f295a5cb64d19aa6c509c0854827a.png)\n\n**节点查询**\n\n链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：\n\n![](https://img-blog.csdnimg.cn/e414794f959a4ef598db449f0bf1bbcb.png)\n\nLinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。\n\n如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。\n\n**新增元素**\n\nLinkedList添加元素的实现很简洁，但添加的方式却有很多种。\n\n默认的add (Ee)方法是将添加的元素加到队尾，首先是将last元素置换到临时变量中，生成一个新的Node节点对象，然后将last引用指向新节点对象，之前的last对象的前指针指向新节点对象。\n\n![](https://img-blog.csdnimg.cn/9d8d455e45e5402f9c42ad9902ae6317.png)\n\nLinkedList也有添加元素到任意位置的方法，如果我们是将元素添加到任意两个元素的中间位置，添加元素操作只会改变前后元素的前后指针，指针将会指向添加的新元素，所以相比ArrayList的添加操作来说，LinkedList的性能优势明显。\n\n![](https://img-blog.csdnimg.cn/2cf9f878f205486f92245cea4a44b277.png)\n\n**删除元素**\n\n在LinkedList删除元素的操作中，我们首先要通过循环找到要删除的元素，如果要删除的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找。\n\n这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果List拥有大量元素，移除的元素又在List的中间段，那效率相对来说会很低。\n\n**遍历元素**\n\nLinkedList的获取元素操作实现跟LinkedList的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素，但是通过这种方式来查询元素是非常低效的，特别是在for循环遍历的情况下，每一次循环都会去遍历半个List。\n\n所以在LinkedList循环遍历时，我们可以使用iterator方式迭代循环，直接拿到我们的元素，而不需要通过循环查找List。\n\n# 分析测试\n\n**新增元素操作性能测试**\n\n测试用例源代码：\n\n- ArrayList：https://paste.ubuntu.com/p/gktBvjgMGk/\n- LinkedList：https://paste.ubuntu.com/p/3jQrY2XMPr/\n\n![](https://img-blog.csdnimg.cn/071fcc7c4b3d4ded81ae309cef73f7ad.png)\n\n测试结果：\n\n| 操作                                     | 花费时间 |\n| :--------------------------------------- | :------- |\n| 从集合头部位置添加元素（ArrayList）      | 550      |\n| 从集合头部位置添加元素（LinkedList）     | 34       |\n| 从集合中间位置位置添加元素（ArrayList）  | 32       |\n| 从集合中间位置位置添加元素（LinkedList） | 58746    |\n| 从集合尾部位置添加元素（ArrayList）      | 29       |\n| 从集合尾部位置添加元素（LinkedList）     | 31       |\n\n通过这组测试，我们可以知道LinkedList添加元素的效率未必要高于ArrayList。\n\n> 从集合头部位置添加元素\n\n由于ArrayList是数组实现的，在添加元素到数组头部的时候，需要对头部以后的数据进行复制重排，所以效率很低；\n\nLinkedList是基于链表实现，在添加元素的时候，首先会通过循环查找到添加元素的位置，如果要添加的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找，因此LinkedList添加元素到头部是非常高效的。\n\n> 从集合中间位置位置添加元素\n\nArrayList在添加元素到数组中间时，同样有部分数据需要复制重排，效率也不是很高；\n\nLinkedList将元素添加到中间位置，是添加元素最低效率的，因为靠近中间位置，在添加元素之前的循环查找是遍历元素最多的操作。\n\n> 从集合尾部位置添加元素\n\n而在添加元素到尾部的操作中，在没有扩容的情况下，ArrayList的效率要高于LinkedList。\n\n这是因为ArrayList在添加元素到尾部的时候，不需要复制重排数据，效率非常高。\n\nLinkedList虽然也不用循环查找元素，但LinkedList中多了new对象以及变换指针指向对象的过程，所以效率要低于ArrayList。\n\n> 注意：这是排除动态扩容数组容量的情况下进行的测试，如果有动态扩容的情况，ArrayList的效率也会降低。\n\n**删除元素操作性能测试**\n\nArrayList和LinkedList删除元素操作测试的结果和添加元素操作测试的结果很接近！\n\n**结论：**如果需要在List的头部进行大量的插入、删除操作，那么直接选择LinkedList。否则，ArrayList即可。\n\n**遍历元素操作性能测试**\n\n测试用例源代码：\n\n- ArrayList：https://paste.ubuntu.com/p/ZNWc9H2pYm/\n- LinkedList：https://paste.ubuntu.com/p/xSk4nHDHvN/\n\n![](https://img-blog.csdnimg.cn/47e530a6579f48a484fcf3146650787e.png)\n\n测试结果：\n\n| 操作                     | 花费时间 |\n| :----------------------- | :------- |\n| for循环（ArrayList）     | 3        |\n| for循环（LinkedList）    | 17557    |\n| 迭代器循环（ArrayList）  | 4        |\n| 迭代器循环（LinkedList） | 4        |\n\n我们可以看到，LinkedList的for循环性能是最差的，而ArrayList的for循环性能是最好的。\n\n这是因为LinkedList基于链表实现的，在使用for循环的时候，每一次for循环都会去遍历半个List，所以严重影响了遍历的效率；ArrayList则是基于数组实现的，并且实现了RandomAccess接口标志，意味着ArrayList可以实现快速随机访问，所以for循环效率非常高。\n\nLinkedList的迭代循环遍历和ArrayList的迭代循环遍历性能相当，也不会太差，所以在遍历LinkedList时，我们要切忌使用for循环遍历。\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n公众号后台回复666，可以获得免费电子书籍","source":"_posts/公众号文章/ArrayList和LinkedList.md","raw":"---\ntitle: ArrayList和LinkedList\ncategories: \n- 公众号文章\n---\n\n# 前言\n\n在面试的时候，经常会被问到几个问题：\n\nArrayList和LinkedList的区别，相信大部分朋友都能回答上：\n\n> ArrayList是基于数组实现，LinkedList是基于链表实现\n>\n> 当随机访问List时，ArrayList比LinkedList的效率更高，等等\n\n当被问到ArrayList和LinkedList的使用场景是什么时，大部分朋友的答案可能是：\n\n> ArrayList和LinkedList在新增、删除元素时，LinkedList的效率要高于 ArrayList，而在遍历的时候，ArrayList的效率要高于LinkedList\n\n那这个回答是否准确呢？今天我们就来研究研究！\n\n配合这篇文章食用会更香，[从源码角度解析ArrayList.subList的几个坑](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484795&idx=1&sn=7da407a6d061f079c5dadcbc2a0fbb7d&scene=21#wechat_redirect)\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n喜欢的话，之后会分享更多系列文章！\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n公众号后台回复666，可以获得免费电子书籍\n\n我们先来简单介绍下ArrayList和LinkedList的原理实现！\n\n# 源码分析\n\n## ArrayList\n\n**实现类**\n\n```java\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable\n```\n\nArrayList实现了List接口，继承了AbstractList抽象类，底层是数组实现的，并且实现了自增扩容数组大小。\n\nArrayList还实现了Cloneable接口和Serializable接口，所以他可以实现克隆和序列化。\n\nArrayList还实现了RandomAccess接口，这个接口是一个标志接口，他标志着“只要实现该接口的List类，都能实现快速随机访问”。\n\n**基本属性**\n\nArrayList属性主要由数组长度size、对象数组elementData、初始化容量`default_capacity`等组成， 其中初始化容量默认大小为10。\n\n```java\n//默认初始化容量\nprivate static final int DEFAULT_CAPACITY = 10;\n//对象数组\ntransient Object[] elementData; \n//数组长度\nprivate int size;\n```\n\n从ArrayList属性来看，elementData被关键字transient修饰了，transient关键字修饰该字段则表示该属性不会被序列化。\n\n> 但ArrayList其实是实现了序列化接口，这是为什么呢？\n\n由于ArrayList的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。\n\n如果采用外部序列化法实现数组的序列化，会序列化整个数组，ArrayList为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法writeObject以及readObject来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。\n\n因此使用transient修饰数组，是防止对象数组被其他外部方法序列化。\n\nArrayList自定义序列化方法如下：\n\n![](https://img-blog.csdnimg.cn/989715e145c44f4f992094d7668a4fb0.png)\n\n**初始化**\n\n有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：\n\n![](https://img-blog.csdnimg.cn/d18f17fd65654a8fa1fdff6b67ffc57a.png)\n\n当ArrayList新增元素时，如果所存储的元素已经超过其已有大小，它会计算元素大小后再进行动态扩容，数组的扩容会导致整个数组进行一次内存复制。\n\n因此，我们在初始化ArrayList时，可以通过第一个构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。\n\n> 注意点：\n\nArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。\n\n**新增元素**\n\nArrayList新增元素的方法有两种，一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。\n\n```java\n public boolean add(E e) {\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    }\n\n    public void add(int index, E element) {\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    }\n```\n\n两个方法的相同之处是在添加元素之前，都会先确认容量大小，如果容量够大，就不用进行扩容；如果容量不够大，就会按照原来数组的1.5倍大小进行扩容，在扩容之后需要将数组复制到新分配的内存地址。\n\n下面是具体的源码：\n\n![](https://img-blog.csdnimg.cn/58ccf22a4be540898a8685ad8efd4a6f.png)\n\n这两个方法也有不同之处，添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列，而将元素添加到数组的末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。\n\n> 所以ArrayList在大量新增元素的场景下效率不一定就很慢的\n\n如果我们在初始化时就比较清楚存储数据的大小，就可以在ArrayList初始化时指定数组容量大小，并且在添加元素时，只在数组末尾添加元素，那么ArrayList在大量新增元素的场景下，性能并不会变差，反而比其他List集合的性能要好。\n\n**删除元素**\n\nArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多。\n\nArrayList在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。\n\n我们选取根据值删除方式来进行源码说明：\n\n![](https://img-blog.csdnimg.cn/bbfb216dd9564aa0b3bd893ccd8d15c0.png)\n\n**遍历元素**\n\n由于ArrayList是基于数组实现的，所以在获取元素的时候是非常快捷的。\n\n```java\npublic E get(int index) {\n        rangeCheck(index);\n\n        return elementData(index);\n    }\n\n    E elementData(int index) {\n        return (E) elementData[index];\n    }\n```\n\n## LinkedList\n\nLinkedList是基于双向链表数据结构实现的。\n\n这个双向链表结构，链表中的每个节点都可以向前或者向后追溯，有几个概念如下：\n\n- 链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；\n- first 是双向链表的头节点，它的前一个节点是 null。\n- last 是双向链表的尾节点，它的后一个节点是 null；\n- 当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；\n- 因为是个双向链表，只要机器内存足够强大，是没有大小限制的。\n\nNode结构中包含了3个部分：元素内容item、前指针prev以及后指针next，代码如下。\n\n```java\nprivate static class Node<E> {\n    E item;// 节点值\n    Node<E> next; // 指向的下一个节点\n    Node<E> prev; // 指向的前一个节点\n\n    // 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点\n    Node(Node<E> prev, E element, Node<E> next) {\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    }\n}\n```\n\nLinkedList就是由Node结构对象连接而成的一个双向链表。\n\n**实现类**\n\nLinkedList类实现了List接口、Deque接口，同时继承了AbstractSequentialList抽象类，LinkedList既实现了List类型又有Queue类型的特点；LinkedList也实现了Cloneable和Serializable接口，同ArrayList一样，可以实现克隆和序列化。\n\n由于LinkedList存储数据的内存地址是不连续的，而是通过指针来定位不连续地址，因此，LinkedList不支持随机快速访问，LinkedList也就不能实现RandomAccess接口。\n\n```java\npublic class LinkedList\n    extends AbstractSequentialList\n    implements List, Deque, Cloneable, java.io.Serializable\n```\n\n**基本属性**\n\n```java\ntransient int size = 0;\ntransient Node first;\ntransient Node last;\n```\n\n我们可以看到这三个属性都被transient修饰了，原因很简单，我们在序列化的时候不会只对头尾进行序列化，所以LinkedList也是自行实现readObject和writeObject进行序列化与反序列化。\n\n下面是LinkedList自定义序列化的方法。\n\n![](https://img-blog.csdnimg.cn/f48f295a5cb64d19aa6c509c0854827a.png)\n\n**节点查询**\n\n链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：\n\n![](https://img-blog.csdnimg.cn/e414794f959a4ef598db449f0bf1bbcb.png)\n\nLinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。\n\n如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。\n\n**新增元素**\n\nLinkedList添加元素的实现很简洁，但添加的方式却有很多种。\n\n默认的add (Ee)方法是将添加的元素加到队尾，首先是将last元素置换到临时变量中，生成一个新的Node节点对象，然后将last引用指向新节点对象，之前的last对象的前指针指向新节点对象。\n\n![](https://img-blog.csdnimg.cn/9d8d455e45e5402f9c42ad9902ae6317.png)\n\nLinkedList也有添加元素到任意位置的方法，如果我们是将元素添加到任意两个元素的中间位置，添加元素操作只会改变前后元素的前后指针，指针将会指向添加的新元素，所以相比ArrayList的添加操作来说，LinkedList的性能优势明显。\n\n![](https://img-blog.csdnimg.cn/2cf9f878f205486f92245cea4a44b277.png)\n\n**删除元素**\n\n在LinkedList删除元素的操作中，我们首先要通过循环找到要删除的元素，如果要删除的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找。\n\n这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果List拥有大量元素，移除的元素又在List的中间段，那效率相对来说会很低。\n\n**遍历元素**\n\nLinkedList的获取元素操作实现跟LinkedList的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素，但是通过这种方式来查询元素是非常低效的，特别是在for循环遍历的情况下，每一次循环都会去遍历半个List。\n\n所以在LinkedList循环遍历时，我们可以使用iterator方式迭代循环，直接拿到我们的元素，而不需要通过循环查找List。\n\n# 分析测试\n\n**新增元素操作性能测试**\n\n测试用例源代码：\n\n- ArrayList：https://paste.ubuntu.com/p/gktBvjgMGk/\n- LinkedList：https://paste.ubuntu.com/p/3jQrY2XMPr/\n\n![](https://img-blog.csdnimg.cn/071fcc7c4b3d4ded81ae309cef73f7ad.png)\n\n测试结果：\n\n| 操作                                     | 花费时间 |\n| :--------------------------------------- | :------- |\n| 从集合头部位置添加元素（ArrayList）      | 550      |\n| 从集合头部位置添加元素（LinkedList）     | 34       |\n| 从集合中间位置位置添加元素（ArrayList）  | 32       |\n| 从集合中间位置位置添加元素（LinkedList） | 58746    |\n| 从集合尾部位置添加元素（ArrayList）      | 29       |\n| 从集合尾部位置添加元素（LinkedList）     | 31       |\n\n通过这组测试，我们可以知道LinkedList添加元素的效率未必要高于ArrayList。\n\n> 从集合头部位置添加元素\n\n由于ArrayList是数组实现的，在添加元素到数组头部的时候，需要对头部以后的数据进行复制重排，所以效率很低；\n\nLinkedList是基于链表实现，在添加元素的时候，首先会通过循环查找到添加元素的位置，如果要添加的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找，因此LinkedList添加元素到头部是非常高效的。\n\n> 从集合中间位置位置添加元素\n\nArrayList在添加元素到数组中间时，同样有部分数据需要复制重排，效率也不是很高；\n\nLinkedList将元素添加到中间位置，是添加元素最低效率的，因为靠近中间位置，在添加元素之前的循环查找是遍历元素最多的操作。\n\n> 从集合尾部位置添加元素\n\n而在添加元素到尾部的操作中，在没有扩容的情况下，ArrayList的效率要高于LinkedList。\n\n这是因为ArrayList在添加元素到尾部的时候，不需要复制重排数据，效率非常高。\n\nLinkedList虽然也不用循环查找元素，但LinkedList中多了new对象以及变换指针指向对象的过程，所以效率要低于ArrayList。\n\n> 注意：这是排除动态扩容数组容量的情况下进行的测试，如果有动态扩容的情况，ArrayList的效率也会降低。\n\n**删除元素操作性能测试**\n\nArrayList和LinkedList删除元素操作测试的结果和添加元素操作测试的结果很接近！\n\n**结论：**如果需要在List的头部进行大量的插入、删除操作，那么直接选择LinkedList。否则，ArrayList即可。\n\n**遍历元素操作性能测试**\n\n测试用例源代码：\n\n- ArrayList：https://paste.ubuntu.com/p/ZNWc9H2pYm/\n- LinkedList：https://paste.ubuntu.com/p/xSk4nHDHvN/\n\n![](https://img-blog.csdnimg.cn/47e530a6579f48a484fcf3146650787e.png)\n\n测试结果：\n\n| 操作                     | 花费时间 |\n| :----------------------- | :------- |\n| for循环（ArrayList）     | 3        |\n| for循环（LinkedList）    | 17557    |\n| 迭代器循环（ArrayList）  | 4        |\n| 迭代器循环（LinkedList） | 4        |\n\n我们可以看到，LinkedList的for循环性能是最差的，而ArrayList的for循环性能是最好的。\n\n这是因为LinkedList基于链表实现的，在使用for循环的时候，每一次for循环都会去遍历半个List，所以严重影响了遍历的效率；ArrayList则是基于数组实现的，并且实现了RandomAccess接口标志，意味着ArrayList可以实现快速随机访问，所以for循环效率非常高。\n\nLinkedList的迭代循环遍历和ArrayList的迭代循环遍历性能相当，也不会太差，所以在遍历LinkedList时，我们要切忌使用for循环遍历。\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n公众号后台回复666，可以获得免费电子书籍","slug":"公众号文章/ArrayList和LinkedList","published":1,"date":"2022-02-09T16:53:54.165Z","updated":"2022-02-09T16:56:09.922Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwis00epfhji1w7f64uy","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在面试的时候，经常会被问到几个问题：</p>\n<p>ArrayList和LinkedList的区别，相信大部分朋友都能回答上：</p>\n<blockquote>\n<p>ArrayList是基于数组实现，LinkedList是基于链表实现</p>\n<p>当随机访问List时，ArrayList比LinkedList的效率更高，等等</p>\n</blockquote>\n<p>当被问到ArrayList和LinkedList的使用场景是什么时，大部分朋友的答案可能是：</p>\n<blockquote>\n<p>ArrayList和LinkedList在新增、删除元素时，LinkedList的效率要高于 ArrayList，而在遍历的时候，ArrayList的效率要高于LinkedList</p>\n</blockquote>\n<p>那这个回答是否准确呢？今天我们就来研究研究！</p>\n<p>配合这篇文章食用会更香，<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484795&idx=1&sn=7da407a6d061f079c5dadcbc2a0fbb7d&scene=21#wechat_redirect\">从源码角度解析ArrayList.subList的几个坑</a></p>\n<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>喜欢的话，之后会分享更多系列文章！</p>\n<p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n<p>我们先来简单介绍下ArrayList和LinkedList的原理实现！</p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><p><strong>实现类</strong></p>\n<pre><code class=\"java\">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\n</code></pre>\n<p>ArrayList实现了List接口，继承了AbstractList抽象类，底层是数组实现的，并且实现了自增扩容数组大小。</p>\n<p>ArrayList还实现了Cloneable接口和Serializable接口，所以他可以实现克隆和序列化。</p>\n<p>ArrayList还实现了RandomAccess接口，这个接口是一个标志接口，他标志着“只要实现该接口的List类，都能实现快速随机访问”。</p>\n<p><strong>基本属性</strong></p>\n<p>ArrayList属性主要由数组长度size、对象数组elementData、初始化容量<code>default_capacity</code>等组成， 其中初始化容量默认大小为10。</p>\n<pre><code class=\"java\">//默认初始化容量\nprivate static final int DEFAULT_CAPACITY = 10;\n//对象数组\ntransient Object[] elementData; \n//数组长度\nprivate int size;\n</code></pre>\n<p>从ArrayList属性来看，elementData被关键字transient修饰了，transient关键字修饰该字段则表示该属性不会被序列化。</p>\n<blockquote>\n<p>但ArrayList其实是实现了序列化接口，这是为什么呢？</p>\n</blockquote>\n<p>由于ArrayList的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。</p>\n<p>如果采用外部序列化法实现数组的序列化，会序列化整个数组，ArrayList为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法writeObject以及readObject来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。</p>\n<p>因此使用transient修饰数组，是防止对象数组被其他外部方法序列化。</p>\n<p>ArrayList自定义序列化方法如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/989715e145c44f4f992094d7668a4fb0.png\"></p>\n<p><strong>初始化</strong></p>\n<p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d18f17fd65654a8fa1fdff6b67ffc57a.png\"></p>\n<p>当ArrayList新增元素时，如果所存储的元素已经超过其已有大小，它会计算元素大小后再进行动态扩容，数组的扩容会导致整个数组进行一次内存复制。</p>\n<p>因此，我们在初始化ArrayList时，可以通过第一个构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。</p>\n<blockquote>\n<p>注意点：</p>\n</blockquote>\n<p>ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。</p>\n<p><strong>新增元素</strong></p>\n<p>ArrayList新增元素的方法有两种，一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。</p>\n<pre><code class=\"java\"> public boolean add(E e) &#123;\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    &#125;\n\n    public void add(int index, E element) &#123;\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    &#125;\n</code></pre>\n<p>两个方法的相同之处是在添加元素之前，都会先确认容量大小，如果容量够大，就不用进行扩容；如果容量不够大，就会按照原来数组的1.5倍大小进行扩容，在扩容之后需要将数组复制到新分配的内存地址。</p>\n<p>下面是具体的源码：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/58ccf22a4be540898a8685ad8efd4a6f.png\"></p>\n<p>这两个方法也有不同之处，添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列，而将元素添加到数组的末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。</p>\n<blockquote>\n<p>所以ArrayList在大量新增元素的场景下效率不一定就很慢的</p>\n</blockquote>\n<p>如果我们在初始化时就比较清楚存储数据的大小，就可以在ArrayList初始化时指定数组容量大小，并且在添加元素时，只在数组末尾添加元素，那么ArrayList在大量新增元素的场景下，性能并不会变差，反而比其他List集合的性能要好。</p>\n<p><strong>删除元素</strong></p>\n<p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多。</p>\n<p>ArrayList在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。</p>\n<p>我们选取根据值删除方式来进行源码说明：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bbfb216dd9564aa0b3bd893ccd8d15c0.png\"></p>\n<p><strong>遍历元素</strong></p>\n<p>由于ArrayList是基于数组实现的，所以在获取元素的时候是非常快捷的。</p>\n<pre><code class=\"java\">public E get(int index) &#123;\n        rangeCheck(index);\n\n        return elementData(index);\n    &#125;\n\n    E elementData(int index) &#123;\n        return (E) elementData[index];\n    &#125;\n</code></pre>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><p>LinkedList是基于双向链表数据结构实现的。</p>\n<p>这个双向链表结构，链表中的每个节点都可以向前或者向后追溯，有几个概念如下：</p>\n<ul>\n<li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；</li>\n<li>first 是双向链表的头节点，它的前一个节点是 null。</li>\n<li>last 是双向链表的尾节点，它的后一个节点是 null；</li>\n<li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li>\n<li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li>\n</ul>\n<p>Node结构中包含了3个部分：元素内容item、前指针prev以及后指针next，代码如下。</p>\n<pre><code class=\"java\">private static class Node&lt;E&gt; &#123;\n    E item;// 节点值\n    Node&lt;E&gt; next; // 指向的下一个节点\n    Node&lt;E&gt; prev; // 指向的前一个节点\n\n    // 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点\n    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    &#125;\n&#125;\n</code></pre>\n<p>LinkedList就是由Node结构对象连接而成的一个双向链表。</p>\n<p><strong>实现类</strong></p>\n<p>LinkedList类实现了List接口、Deque接口，同时继承了AbstractSequentialList抽象类，LinkedList既实现了List类型又有Queue类型的特点；LinkedList也实现了Cloneable和Serializable接口，同ArrayList一样，可以实现克隆和序列化。</p>\n<p>由于LinkedList存储数据的内存地址是不连续的，而是通过指针来定位不连续地址，因此，LinkedList不支持随机快速访问，LinkedList也就不能实现RandomAccess接口。</p>\n<pre><code class=\"java\">public class LinkedList\n    extends AbstractSequentialList\n    implements List, Deque, Cloneable, java.io.Serializable\n</code></pre>\n<p><strong>基本属性</strong></p>\n<pre><code class=\"java\">transient int size = 0;\ntransient Node first;\ntransient Node last;\n</code></pre>\n<p>我们可以看到这三个属性都被transient修饰了，原因很简单，我们在序列化的时候不会只对头尾进行序列化，所以LinkedList也是自行实现readObject和writeObject进行序列化与反序列化。</p>\n<p>下面是LinkedList自定义序列化的方法。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f48f295a5cb64d19aa6c509c0854827a.png\"></p>\n<p><strong>节点查询</strong></p>\n<p>链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e414794f959a4ef598db449f0bf1bbcb.png\"></p>\n<p>LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。</p>\n<p>如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。</p>\n<p><strong>新增元素</strong></p>\n<p>LinkedList添加元素的实现很简洁，但添加的方式却有很多种。</p>\n<p>默认的add (Ee)方法是将添加的元素加到队尾，首先是将last元素置换到临时变量中，生成一个新的Node节点对象，然后将last引用指向新节点对象，之前的last对象的前指针指向新节点对象。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9d8d455e45e5402f9c42ad9902ae6317.png\"></p>\n<p>LinkedList也有添加元素到任意位置的方法，如果我们是将元素添加到任意两个元素的中间位置，添加元素操作只会改变前后元素的前后指针，指针将会指向添加的新元素，所以相比ArrayList的添加操作来说，LinkedList的性能优势明显。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2cf9f878f205486f92245cea4a44b277.png\"></p>\n<p><strong>删除元素</strong></p>\n<p>在LinkedList删除元素的操作中，我们首先要通过循环找到要删除的元素，如果要删除的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找。</p>\n<p>这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果List拥有大量元素，移除的元素又在List的中间段，那效率相对来说会很低。</p>\n<p><strong>遍历元素</strong></p>\n<p>LinkedList的获取元素操作实现跟LinkedList的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素，但是通过这种方式来查询元素是非常低效的，特别是在for循环遍历的情况下，每一次循环都会去遍历半个List。</p>\n<p>所以在LinkedList循环遍历时，我们可以使用iterator方式迭代循环，直接拿到我们的元素，而不需要通过循环查找List。</p>\n<h1 id=\"分析测试\"><a href=\"#分析测试\" class=\"headerlink\" title=\"分析测试\"></a>分析测试</h1><p><strong>新增元素操作性能测试</strong></p>\n<p>测试用例源代码：</p>\n<ul>\n<li>ArrayList：<a href=\"https://paste.ubuntu.com/p/gktBvjgMGk/\">https://paste.ubuntu.com/p/gktBvjgMGk/</a></li>\n<li>LinkedList：<a href=\"https://paste.ubuntu.com/p/3jQrY2XMPr/\">https://paste.ubuntu.com/p/3jQrY2XMPr/</a></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/071fcc7c4b3d4ded81ae309cef73f7ad.png\"></p>\n<p>测试结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">花费时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">从集合头部位置添加元素（ArrayList）</td>\n<td align=\"left\">550</td>\n</tr>\n<tr>\n<td align=\"left\">从集合头部位置添加元素（LinkedList）</td>\n<td align=\"left\">34</td>\n</tr>\n<tr>\n<td align=\"left\">从集合中间位置位置添加元素（ArrayList）</td>\n<td align=\"left\">32</td>\n</tr>\n<tr>\n<td align=\"left\">从集合中间位置位置添加元素（LinkedList）</td>\n<td align=\"left\">58746</td>\n</tr>\n<tr>\n<td align=\"left\">从集合尾部位置添加元素（ArrayList）</td>\n<td align=\"left\">29</td>\n</tr>\n<tr>\n<td align=\"left\">从集合尾部位置添加元素（LinkedList）</td>\n<td align=\"left\">31</td>\n</tr>\n</tbody></table>\n<p>通过这组测试，我们可以知道LinkedList添加元素的效率未必要高于ArrayList。</p>\n<blockquote>\n<p>从集合头部位置添加元素</p>\n</blockquote>\n<p>由于ArrayList是数组实现的，在添加元素到数组头部的时候，需要对头部以后的数据进行复制重排，所以效率很低；</p>\n<p>LinkedList是基于链表实现，在添加元素的时候，首先会通过循环查找到添加元素的位置，如果要添加的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找，因此LinkedList添加元素到头部是非常高效的。</p>\n<blockquote>\n<p>从集合中间位置位置添加元素</p>\n</blockquote>\n<p>ArrayList在添加元素到数组中间时，同样有部分数据需要复制重排，效率也不是很高；</p>\n<p>LinkedList将元素添加到中间位置，是添加元素最低效率的，因为靠近中间位置，在添加元素之前的循环查找是遍历元素最多的操作。</p>\n<blockquote>\n<p>从集合尾部位置添加元素</p>\n</blockquote>\n<p>而在添加元素到尾部的操作中，在没有扩容的情况下，ArrayList的效率要高于LinkedList。</p>\n<p>这是因为ArrayList在添加元素到尾部的时候，不需要复制重排数据，效率非常高。</p>\n<p>LinkedList虽然也不用循环查找元素，但LinkedList中多了new对象以及变换指针指向对象的过程，所以效率要低于ArrayList。</p>\n<blockquote>\n<p>注意：这是排除动态扩容数组容量的情况下进行的测试，如果有动态扩容的情况，ArrayList的效率也会降低。</p>\n</blockquote>\n<p><strong>删除元素操作性能测试</strong></p>\n<p>ArrayList和LinkedList删除元素操作测试的结果和添加元素操作测试的结果很接近！</p>\n<p><strong>结论：</strong>如果需要在List的头部进行大量的插入、删除操作，那么直接选择LinkedList。否则，ArrayList即可。</p>\n<p><strong>遍历元素操作性能测试</strong></p>\n<p>测试用例源代码：</p>\n<ul>\n<li>ArrayList：<a href=\"https://paste.ubuntu.com/p/ZNWc9H2pYm/\">https://paste.ubuntu.com/p/ZNWc9H2pYm/</a></li>\n<li>LinkedList：<a href=\"https://paste.ubuntu.com/p/xSk4nHDHvN/\">https://paste.ubuntu.com/p/xSk4nHDHvN/</a></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/47e530a6579f48a484fcf3146650787e.png\"></p>\n<p>测试结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">花费时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">for循环（ArrayList）</td>\n<td align=\"left\">3</td>\n</tr>\n<tr>\n<td align=\"left\">for循环（LinkedList）</td>\n<td align=\"left\">17557</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器循环（ArrayList）</td>\n<td align=\"left\">4</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器循环（LinkedList）</td>\n<td align=\"left\">4</td>\n</tr>\n</tbody></table>\n<p>我们可以看到，LinkedList的for循环性能是最差的，而ArrayList的for循环性能是最好的。</p>\n<p>这是因为LinkedList基于链表实现的，在使用for循环的时候，每一次for循环都会去遍历半个List，所以严重影响了遍历的效率；ArrayList则是基于数组实现的，并且实现了RandomAccess接口标志，意味着ArrayList可以实现快速随机访问，所以for循环效率非常高。</p>\n<p>LinkedList的迭代循环遍历和ArrayList的迭代循环遍历性能相当，也不会太差，所以在遍历LinkedList时，我们要切忌使用for循环遍历。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>在面试的时候，经常会被问到几个问题：</p>\n<p>ArrayList和LinkedList的区别，相信大部分朋友都能回答上：</p>\n<blockquote>\n<p>ArrayList是基于数组实现，LinkedList是基于链表实现</p>\n<p>当随机访问List时，ArrayList比LinkedList的效率更高，等等</p>\n</blockquote>\n<p>当被问到ArrayList和LinkedList的使用场景是什么时，大部分朋友的答案可能是：</p>\n<blockquote>\n<p>ArrayList和LinkedList在新增、删除元素时，LinkedList的效率要高于 ArrayList，而在遍历的时候，ArrayList的效率要高于LinkedList</p>\n</blockquote>\n<p>那这个回答是否准确呢？今天我们就来研究研究！</p>\n<p>配合这篇文章食用会更香，<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484795&idx=1&sn=7da407a6d061f079c5dadcbc2a0fbb7d&scene=21#wechat_redirect\">从源码角度解析ArrayList.subList的几个坑</a></p>\n<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>喜欢的话，之后会分享更多系列文章！</p>\n<p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n<p>我们先来简单介绍下ArrayList和LinkedList的原理实现！</p>\n<h1 id=\"源码分析\"><a href=\"#源码分析\" class=\"headerlink\" title=\"源码分析\"></a>源码分析</h1><h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><p><strong>实现类</strong></p>\n<pre><code class=\"java\">public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt;\n        implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable\n</code></pre>\n<p>ArrayList实现了List接口，继承了AbstractList抽象类，底层是数组实现的，并且实现了自增扩容数组大小。</p>\n<p>ArrayList还实现了Cloneable接口和Serializable接口，所以他可以实现克隆和序列化。</p>\n<p>ArrayList还实现了RandomAccess接口，这个接口是一个标志接口，他标志着“只要实现该接口的List类，都能实现快速随机访问”。</p>\n<p><strong>基本属性</strong></p>\n<p>ArrayList属性主要由数组长度size、对象数组elementData、初始化容量<code>default_capacity</code>等组成， 其中初始化容量默认大小为10。</p>\n<pre><code class=\"java\">//默认初始化容量\nprivate static final int DEFAULT_CAPACITY = 10;\n//对象数组\ntransient Object[] elementData; \n//数组长度\nprivate int size;\n</code></pre>\n<p>从ArrayList属性来看，elementData被关键字transient修饰了，transient关键字修饰该字段则表示该属性不会被序列化。</p>\n<blockquote>\n<p>但ArrayList其实是实现了序列化接口，这是为什么呢？</p>\n</blockquote>\n<p>由于ArrayList的数组是基于动态扩增的，所以并不是所有被分配的内存空间都存储了数据。</p>\n<p>如果采用外部序列化法实现数组的序列化，会序列化整个数组，ArrayList为了避免这些没有存储数据的内存空间被序列化，内部提供了两个私有方法writeObject以及readObject来自我完成序列化与反序列化，从而在序列化与反序列化数组时节省了空间和时间。</p>\n<p>因此使用transient修饰数组，是防止对象数组被其他外部方法序列化。</p>\n<p>ArrayList自定义序列化方法如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/989715e145c44f4f992094d7668a4fb0.png\"></p>\n<p><strong>初始化</strong></p>\n<p>有三种初始化办法：无参数直接初始化、指定大小初始化、指定初始数据初始化，源码如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d18f17fd65654a8fa1fdff6b67ffc57a.png\"></p>\n<p>当ArrayList新增元素时，如果所存储的元素已经超过其已有大小，它会计算元素大小后再进行动态扩容，数组的扩容会导致整个数组进行一次内存复制。</p>\n<p>因此，我们在初始化ArrayList时，可以通过第一个构造函数合理指定数组初始大小，这样有助于减少数组的扩容次数，从而提高系统性能。</p>\n<blockquote>\n<p>注意点：</p>\n</blockquote>\n<p>ArrayList 无参构造器初始化时，默认大小是空数组，并不是大家常说的 10，10 是在第一次 add 的时候扩容的数组值。</p>\n<p><strong>新增元素</strong></p>\n<p>ArrayList新增元素的方法有两种，一种是直接将元素加到数组的末尾，另外一种是添加元素到任意位置。</p>\n<pre><code class=\"java\"> public boolean add(E e) &#123;\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        elementData[size++] = e;\n        return true;\n    &#125;\n\n    public void add(int index, E element) &#123;\n        rangeCheckForAdd(index);\n\n        ensureCapacityInternal(size + 1);  // Increments modCount!!\n        System.arraycopy(elementData, index, elementData, index + 1,\n                         size - index);\n        elementData[index] = element;\n        size++;\n    &#125;\n</code></pre>\n<p>两个方法的相同之处是在添加元素之前，都会先确认容量大小，如果容量够大，就不用进行扩容；如果容量不够大，就会按照原来数组的1.5倍大小进行扩容，在扩容之后需要将数组复制到新分配的内存地址。</p>\n<p>下面是具体的源码：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/58ccf22a4be540898a8685ad8efd4a6f.png\"></p>\n<p>这两个方法也有不同之处，添加元素到任意位置，会导致在该位置后的所有元素都需要重新排列，而将元素添加到数组的末尾，在没有发生扩容的前提下，是不会有元素复制排序过程的。</p>\n<blockquote>\n<p>所以ArrayList在大量新增元素的场景下效率不一定就很慢的</p>\n</blockquote>\n<p>如果我们在初始化时就比较清楚存储数据的大小，就可以在ArrayList初始化时指定数组容量大小，并且在添加元素时，只在数组末尾添加元素，那么ArrayList在大量新增元素的场景下，性能并不会变差，反而比其他List集合的性能要好。</p>\n<p><strong>删除元素</strong></p>\n<p>ArrayList 删除元素有很多种方式，比如根据数组索引删除、根据值删除或批量删除等等，原理和思路都差不多。</p>\n<p>ArrayList在每一次有效的删除元素操作之后，都要进行数组的重组，并且删除的元素位置越靠前，数组重组的开销就越大。</p>\n<p>我们选取根据值删除方式来进行源码说明：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/bbfb216dd9564aa0b3bd893ccd8d15c0.png\"></p>\n<p><strong>遍历元素</strong></p>\n<p>由于ArrayList是基于数组实现的，所以在获取元素的时候是非常快捷的。</p>\n<pre><code class=\"java\">public E get(int index) &#123;\n        rangeCheck(index);\n\n        return elementData(index);\n    &#125;\n\n    E elementData(int index) &#123;\n        return (E) elementData[index];\n    &#125;\n</code></pre>\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><p>LinkedList是基于双向链表数据结构实现的。</p>\n<p>这个双向链表结构，链表中的每个节点都可以向前或者向后追溯，有几个概念如下：</p>\n<ul>\n<li>链表每个节点我们叫做 Node，Node 有 prev 属性，代表前一个节点的位置，next 属性，代表后一个节点的位置；</li>\n<li>first 是双向链表的头节点，它的前一个节点是 null。</li>\n<li>last 是双向链表的尾节点，它的后一个节点是 null；</li>\n<li>当链表中没有数据时，first 和 last 是同一个节点，前后指向都是 null；</li>\n<li>因为是个双向链表，只要机器内存足够强大，是没有大小限制的。</li>\n</ul>\n<p>Node结构中包含了3个部分：元素内容item、前指针prev以及后指针next，代码如下。</p>\n<pre><code class=\"java\">private static class Node&lt;E&gt; &#123;\n    E item;// 节点值\n    Node&lt;E&gt; next; // 指向的下一个节点\n    Node&lt;E&gt; prev; // 指向的前一个节点\n\n    // 初始化参数顺序分别是：前一个节点、本身节点值、后一个节点\n    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n        this.item = element;\n        this.next = next;\n        this.prev = prev;\n    &#125;\n&#125;\n</code></pre>\n<p>LinkedList就是由Node结构对象连接而成的一个双向链表。</p>\n<p><strong>实现类</strong></p>\n<p>LinkedList类实现了List接口、Deque接口，同时继承了AbstractSequentialList抽象类，LinkedList既实现了List类型又有Queue类型的特点；LinkedList也实现了Cloneable和Serializable接口，同ArrayList一样，可以实现克隆和序列化。</p>\n<p>由于LinkedList存储数据的内存地址是不连续的，而是通过指针来定位不连续地址，因此，LinkedList不支持随机快速访问，LinkedList也就不能实现RandomAccess接口。</p>\n<pre><code class=\"java\">public class LinkedList\n    extends AbstractSequentialList\n    implements List, Deque, Cloneable, java.io.Serializable\n</code></pre>\n<p><strong>基本属性</strong></p>\n<pre><code class=\"java\">transient int size = 0;\ntransient Node first;\ntransient Node last;\n</code></pre>\n<p>我们可以看到这三个属性都被transient修饰了，原因很简单，我们在序列化的时候不会只对头尾进行序列化，所以LinkedList也是自行实现readObject和writeObject进行序列化与反序列化。</p>\n<p>下面是LinkedList自定义序列化的方法。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/f48f295a5cb64d19aa6c509c0854827a.png\"></p>\n<p><strong>节点查询</strong></p>\n<p>链表查询某一个节点是比较慢的，需要挨个循环查找才行，我们看看 LinkedList 的源码是如何寻找节点的：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e414794f959a4ef598db449f0bf1bbcb.png\"></p>\n<p>LinkedList 并没有采用从头循环到尾的做法，而是采取了简单二分法，首先看看 index 是在链表的前半部分，还是后半部分。</p>\n<p>如果是前半部分，就从头开始寻找，反之亦然。通过这种方式，使循环的次数至少降低了一半，提高了查找的性能。</p>\n<p><strong>新增元素</strong></p>\n<p>LinkedList添加元素的实现很简洁，但添加的方式却有很多种。</p>\n<p>默认的add (Ee)方法是将添加的元素加到队尾，首先是将last元素置换到临时变量中，生成一个新的Node节点对象，然后将last引用指向新节点对象，之前的last对象的前指针指向新节点对象。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9d8d455e45e5402f9c42ad9902ae6317.png\"></p>\n<p>LinkedList也有添加元素到任意位置的方法，如果我们是将元素添加到任意两个元素的中间位置，添加元素操作只会改变前后元素的前后指针，指针将会指向添加的新元素，所以相比ArrayList的添加操作来说，LinkedList的性能优势明显。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/2cf9f878f205486f92245cea4a44b277.png\"></p>\n<p><strong>删除元素</strong></p>\n<p>在LinkedList删除元素的操作中，我们首先要通过循环找到要删除的元素，如果要删除的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找。</p>\n<p>这样做的话，无论要删除较为靠前或较为靠后的元素都是非常高效的，但如果List拥有大量元素，移除的元素又在List的中间段，那效率相对来说会很低。</p>\n<p><strong>遍历元素</strong></p>\n<p>LinkedList的获取元素操作实现跟LinkedList的删除元素操作基本类似，通过分前后半段来循环查找到对应的元素，但是通过这种方式来查询元素是非常低效的，特别是在for循环遍历的情况下，每一次循环都会去遍历半个List。</p>\n<p>所以在LinkedList循环遍历时，我们可以使用iterator方式迭代循环，直接拿到我们的元素，而不需要通过循环查找List。</p>\n<h1 id=\"分析测试\"><a href=\"#分析测试\" class=\"headerlink\" title=\"分析测试\"></a>分析测试</h1><p><strong>新增元素操作性能测试</strong></p>\n<p>测试用例源代码：</p>\n<ul>\n<li>ArrayList：<a href=\"https://paste.ubuntu.com/p/gktBvjgMGk/\">https://paste.ubuntu.com/p/gktBvjgMGk/</a></li>\n<li>LinkedList：<a href=\"https://paste.ubuntu.com/p/3jQrY2XMPr/\">https://paste.ubuntu.com/p/3jQrY2XMPr/</a></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/071fcc7c4b3d4ded81ae309cef73f7ad.png\"></p>\n<p>测试结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">花费时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">从集合头部位置添加元素（ArrayList）</td>\n<td align=\"left\">550</td>\n</tr>\n<tr>\n<td align=\"left\">从集合头部位置添加元素（LinkedList）</td>\n<td align=\"left\">34</td>\n</tr>\n<tr>\n<td align=\"left\">从集合中间位置位置添加元素（ArrayList）</td>\n<td align=\"left\">32</td>\n</tr>\n<tr>\n<td align=\"left\">从集合中间位置位置添加元素（LinkedList）</td>\n<td align=\"left\">58746</td>\n</tr>\n<tr>\n<td align=\"left\">从集合尾部位置添加元素（ArrayList）</td>\n<td align=\"left\">29</td>\n</tr>\n<tr>\n<td align=\"left\">从集合尾部位置添加元素（LinkedList）</td>\n<td align=\"left\">31</td>\n</tr>\n</tbody></table>\n<p>通过这组测试，我们可以知道LinkedList添加元素的效率未必要高于ArrayList。</p>\n<blockquote>\n<p>从集合头部位置添加元素</p>\n</blockquote>\n<p>由于ArrayList是数组实现的，在添加元素到数组头部的时候，需要对头部以后的数据进行复制重排，所以效率很低；</p>\n<p>LinkedList是基于链表实现，在添加元素的时候，首先会通过循环查找到添加元素的位置，如果要添加的位置处于List的前半段，就从前往后找；若其位置处于后半段，就从后往前找，因此LinkedList添加元素到头部是非常高效的。</p>\n<blockquote>\n<p>从集合中间位置位置添加元素</p>\n</blockquote>\n<p>ArrayList在添加元素到数组中间时，同样有部分数据需要复制重排，效率也不是很高；</p>\n<p>LinkedList将元素添加到中间位置，是添加元素最低效率的，因为靠近中间位置，在添加元素之前的循环查找是遍历元素最多的操作。</p>\n<blockquote>\n<p>从集合尾部位置添加元素</p>\n</blockquote>\n<p>而在添加元素到尾部的操作中，在没有扩容的情况下，ArrayList的效率要高于LinkedList。</p>\n<p>这是因为ArrayList在添加元素到尾部的时候，不需要复制重排数据，效率非常高。</p>\n<p>LinkedList虽然也不用循环查找元素，但LinkedList中多了new对象以及变换指针指向对象的过程，所以效率要低于ArrayList。</p>\n<blockquote>\n<p>注意：这是排除动态扩容数组容量的情况下进行的测试，如果有动态扩容的情况，ArrayList的效率也会降低。</p>\n</blockquote>\n<p><strong>删除元素操作性能测试</strong></p>\n<p>ArrayList和LinkedList删除元素操作测试的结果和添加元素操作测试的结果很接近！</p>\n<p><strong>结论：</strong>如果需要在List的头部进行大量的插入、删除操作，那么直接选择LinkedList。否则，ArrayList即可。</p>\n<p><strong>遍历元素操作性能测试</strong></p>\n<p>测试用例源代码：</p>\n<ul>\n<li>ArrayList：<a href=\"https://paste.ubuntu.com/p/ZNWc9H2pYm/\">https://paste.ubuntu.com/p/ZNWc9H2pYm/</a></li>\n<li>LinkedList：<a href=\"https://paste.ubuntu.com/p/xSk4nHDHvN/\">https://paste.ubuntu.com/p/xSk4nHDHvN/</a></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/47e530a6579f48a484fcf3146650787e.png\"></p>\n<p>测试结果：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">操作</th>\n<th align=\"left\">花费时间</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">for循环（ArrayList）</td>\n<td align=\"left\">3</td>\n</tr>\n<tr>\n<td align=\"left\">for循环（LinkedList）</td>\n<td align=\"left\">17557</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器循环（ArrayList）</td>\n<td align=\"left\">4</td>\n</tr>\n<tr>\n<td align=\"left\">迭代器循环（LinkedList）</td>\n<td align=\"left\">4</td>\n</tr>\n</tbody></table>\n<p>我们可以看到，LinkedList的for循环性能是最差的，而ArrayList的for循环性能是最好的。</p>\n<p>这是因为LinkedList基于链表实现的，在使用for循环的时候，每一次for循环都会去遍历半个List，所以严重影响了遍历的效率；ArrayList则是基于数组实现的，并且实现了RandomAccess接口标志，意味着ArrayList可以实现快速随机访问，所以for循环效率非常高。</p>\n<p>LinkedList的迭代循环遍历和ArrayList的迭代循环遍历性能相当，也不会太差，所以在遍历LinkedList时，我们要切忌使用for循环遍历。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n"},{"title":"Disruptor框架","_content":"\n# 前言\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\nDisruptor是一个开源框架，研发的初衷是为了解决高并发下队列锁的问题，最早由LMAX提出并使用，能够在无锁的情况下实现队列的并发操作，并号称能够在一个线程里每秒处理6百万笔订单\n\n官网：http://lmax-exchange.github.io/disruptor/\n\n目前，包括Apache Storm、Camel、Log4j2在内的很多知名项目都应用了Disruptor以获取高性能\n\n# 为什么会产生Disruptor框架\n\n**「目前Java内置队列保证线程安全的方式：」**\n\nArrayBlockingQueue：基于数组形式的队列，通过加锁的方式，来保证多线程情况下数据的安全；\n\nLinkedBlockingQueue：基于链表形式的队列，也通过加锁的方式，来保证多线程情况下数据的安全；\n\nConcurrentLinkedQueue：基于链表形式的队列，通过CAS的方式\n\n我们知道，在编程过程中，加锁通常会严重地影响性能，所以尽量用无锁方式，就产生了Disruptor这种无锁高并发框架\n\n# 基本概念\n\n参考地址：https://github.com/LMAX-Exchange/disruptor/wiki/Introduction#core-concepts\n\nRingBuffer——Disruptor底层数据结构实现，核心类，是线程间交换数据的中转地；\n\nSequencer——序号管理器，生产同步的实现者，负责消费者/生产者各自序号、序号栅栏的管理和协调,Sequencer有单生产者,多生产者两种不同的模式,里面实现了各种同步的算法；\n\nSequence——序号，声明一个序号，用于跟踪ringbuffer中任务的变化和消费者的消费情况，disruptor里面大部分的并发代码都是通过对Sequence的值同步修改实现的,而非锁,这是disruptor高性能的一个主要原因；\n\nSequenceBarrier——序号栅栏，管理和协调生产者的游标序号和各个消费者的序号，确保生产者不会覆盖消费者未来得及处理的消息，确保存在依赖的消费者之间能够按照正确的顺序处理\n\nEventProcessor——事件处理器，监听RingBuffer的事件，并消费可用事件，从RingBuffer读取的事件会交由实际的生产者实现类来消费；它会一直侦听下一个可用的序号，直到该序号对应的事件已经准备好。\n\nEventHandler——业务处理器，是实际消费者的接口，完成具体的业务逻辑实现，第三方实现该接口；代表着消费者。\n\nProducer——生产者接口，第三方线程充当该角色，producer向RingBuffer写入事件。\n\nWait Strategy：Wait Strategy决定了一个消费者怎么等待生产者将事件（Event）放入Disruptor中。\n\n![](https://img-blog.csdnimg.cn/b3421fa31c3d4c58a127e493bedfe999.png)\n\n# 等待策略\n\n源码地址：https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java\n\n**「BlockingWaitStrategy」**\n\nDisruptor的默认策略是BlockingWaitStrategy。在BlockingWaitStrategy内部是使用锁和condition来控制线程的唤醒。BlockingWaitStrategy是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。\n\n**「SleepingWaitStrategy」**\n\nSleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，通过使用`LockSupport.parkNanos(1)`来实现循环等待。\n\n**「YieldingWaitStrategy」**\n\nYieldingWaitStrategy是可以使用在低延迟系统的策略之一。YieldingWaitStrategy将自旋以等待序列增加到适当的值。在循环体内，将调用`Thread.yield()`以允许其他排队的线程运行。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。\n\n**「BusySpinWaitStrategy」**\n\n性能最好，适合用于低延迟的系统。在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。\n\n**「PhasedBackoffWaitStrategy」**\n\n自旋 + yield + 自定义策略，CPU资源紧缺，吞吐量和延迟并不重要的场景。\n\n# 使用举例\n\n参考地址：https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started\n\n```xml\n<dependency>\n      <groupId>com.lmax</groupId>\n      <artifactId>disruptor</artifactId>\n      <version>3.3.4</version>\n   </dependency>\n```\n\n```java\n//定义事件event  通过Disruptor 进行交换的数据类型。\npublic class LongEvent {\n\n    private Long value;\n\n    public Long getValue() {\n        return value;\n    }\n\n    public void setValue(Long value) {\n        this.value = value;\n    }\n\n}\n```\n\n```java\npublic class LongEventFactory implements EventFactory<LongEvent> {\n    public LongEvent newInstance() {\n        return new LongEvent();\n    }\n}\n```\n\n```java\n//定义事件消费者\npublic class LongEventHandler implements EventHandler<LongEvent>  {\n    public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception {\n         System.out.println(\"消费者:\"+event.getValue());\n    }\n}\n```\n\n```java\n//定义生产者\npublic class LongEventProducer {\n    public final RingBuffer<LongEvent> ringBuffer;\n    public LongEventProducer(RingBuffer<LongEvent> ringBuffer) {\n        this.ringBuffer = ringBuffer;\n    }\n    public void onData(ByteBuffer byteBuffer) {\n        // 1.ringBuffer 事件队列 下一个槽\n        long sequence = ringBuffer.next();\n        Long data = null;\n        try {\n            //2.取出空的事件队列\n            LongEvent longEvent = ringBuffer.get(sequence);\n            data = byteBuffer.getLong(0);\n            //3.获取事件队列传递的数据\n            longEvent.setValue(data);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        } finally {\n            System.out.println(\"生产这准备发送数据\");\n            //4.发布事件\n            ringBuffer.publish(sequence);\n        }\n    }\n}\n```\n\n```java\npublic class DisruptorMain {\n    public static void main(String[] args) {\n        // 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理\n        ExecutorService executor = Executors.newCachedThreadPool();\n        // 2.创建工厂\n        EventFactory<LongEvent> eventFactory = new LongEventFactory();\n        // 3.创建ringBuffer 大小\n        int ringBufferSize = 1024 * 1024; // ringBufferSize大小一定要是2的N次方\n        // 4.创建Disruptor\n        Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>(eventFactory, ringBufferSize, executor,\n                ProducerType.SINGLE, new YieldingWaitStrategy());\n        // 5.连接消费端方法\n        disruptor.handleEventsWith(new LongEventHandler());\n        // 6.启动\n        disruptor.start();\n        // 7.创建RingBuffer容器\n        RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();\n        // 8.创建生产者\n        LongEventProducer producer = new LongEventProducer(ringBuffer);\n        // 9.指定缓冲区大小\n        ByteBuffer byteBuffer = ByteBuffer.allocate(8);\n        for (int i = 1; i <= 100; i++) {\n            byteBuffer.putLong(0, i);\n            producer.onData(byteBuffer);\n        }\n        //10.关闭disruptor和executor\n        disruptor.shutdown();\n        executor.shutdown();\n    }\n}\n```\n\n# 核心设计原理\n\nDisruptor通过以下设计来解决队列速度慢的问题：\n\n**「环形数组结构：」**\n\n为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好\n\n> ❝\n>\n> 原因：CPU缓存是由很多个缓存行组成的。每个缓存行通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个缓存行。在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。\n>\n> ❞\n\n**「元素位置定位：」**\n\n数组长度`2^n`，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。\n\n**「无锁设计：」**\n\n每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据，整个过程通过原子变量CAS，保证操作的线程安全\n\n# 数据结构\n\n框架使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。\n\n除数组外还有一个序列号(sequence)，用以指向下一个可用的元素，供生产者与消费者使用。\n\n原理图如下所示：\n\n![](https://img-blog.csdnimg.cn/d41d9a80af764e60831a2582f7424291.png)\n\n## Sequence\n\nmark：Disruptor通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据(事件)的处理过程总是沿着序号逐个递增处理。\n\n**「数组+序列号设计的优势是什么呢？」**\n\n回顾一下HashMap，在知道索引(index)下标的情况下，存与取数组上的元素时间复杂度只有O(1)，而这个index我们可以通过序列号与数组的长度取模来计算得出，`index=sequence % table.length`。当然也可以用位运算来计算效率更高，此时table.length必须是2的幂次方。\n\n# 写数据流程\n\n单线程写数据的流程：\n\n1. 申请写入m个元素；\n2. 若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；\n3. 若是返回的正确，则生产者开始写入元素。\n\n![](https://img-blog.csdnimg.cn/a7b10a9a10a3472c9eb7dadfebd4e4ed.png)\n\n# 使用场景\n\n经过测试，Disruptor的的延时和吞吐量都比ArrayBlockingQueue优秀很多，所以，当你在使用ArrayBlockingQueue出现性能瓶颈的时候，你就可以考虑采用Disruptor的代替。\n\n参考：https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results\n\n![](https://img-blog.csdnimg.cn/ae694a420f9a4c50b310468c9f4ba8ef.png)\n\n![](https://img-blog.csdnimg.cn/6fac3d5d5083457eada5f8eb0622667a.png)\n\n当然，Disruptor性能高并不是必然的，所以，是否使用还得经过测试。\n\nDisruptor的最常用的场景就是“生产者-消费者”场景，对场景的就是“一个生产者、多个消费者”的场景，并且要求顺序处理。\n\n举个例子，我们从MySQL的BigLog文件中顺序读取数据，然后写入到ElasticSearch（搜索引擎）中。在这种场景下，BigLog要求一个文件一个生产者，那个是一个生产者。而写入到ElasticSearch，则严格要求顺序，否则会出现问题，所以通常意义上的多消费者线程无法解决该问题，如果通过加锁，则性能大打折扣\n\n**参考：**\n\nhttps://tech.meituan.com/2016/11/18/disruptor.html\n\nhttps://github.com/LMAX-Exchange/disruptor/wiki","source":"_posts/公众号文章/Disruptor框架.md","raw":"---\ntitle: Disruptor框架\ncategories: \n- 公众号文章\n---\n\n# 前言\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\nDisruptor是一个开源框架，研发的初衷是为了解决高并发下队列锁的问题，最早由LMAX提出并使用，能够在无锁的情况下实现队列的并发操作，并号称能够在一个线程里每秒处理6百万笔订单\n\n官网：http://lmax-exchange.github.io/disruptor/\n\n目前，包括Apache Storm、Camel、Log4j2在内的很多知名项目都应用了Disruptor以获取高性能\n\n# 为什么会产生Disruptor框架\n\n**「目前Java内置队列保证线程安全的方式：」**\n\nArrayBlockingQueue：基于数组形式的队列，通过加锁的方式，来保证多线程情况下数据的安全；\n\nLinkedBlockingQueue：基于链表形式的队列，也通过加锁的方式，来保证多线程情况下数据的安全；\n\nConcurrentLinkedQueue：基于链表形式的队列，通过CAS的方式\n\n我们知道，在编程过程中，加锁通常会严重地影响性能，所以尽量用无锁方式，就产生了Disruptor这种无锁高并发框架\n\n# 基本概念\n\n参考地址：https://github.com/LMAX-Exchange/disruptor/wiki/Introduction#core-concepts\n\nRingBuffer——Disruptor底层数据结构实现，核心类，是线程间交换数据的中转地；\n\nSequencer——序号管理器，生产同步的实现者，负责消费者/生产者各自序号、序号栅栏的管理和协调,Sequencer有单生产者,多生产者两种不同的模式,里面实现了各种同步的算法；\n\nSequence——序号，声明一个序号，用于跟踪ringbuffer中任务的变化和消费者的消费情况，disruptor里面大部分的并发代码都是通过对Sequence的值同步修改实现的,而非锁,这是disruptor高性能的一个主要原因；\n\nSequenceBarrier——序号栅栏，管理和协调生产者的游标序号和各个消费者的序号，确保生产者不会覆盖消费者未来得及处理的消息，确保存在依赖的消费者之间能够按照正确的顺序处理\n\nEventProcessor——事件处理器，监听RingBuffer的事件，并消费可用事件，从RingBuffer读取的事件会交由实际的生产者实现类来消费；它会一直侦听下一个可用的序号，直到该序号对应的事件已经准备好。\n\nEventHandler——业务处理器，是实际消费者的接口，完成具体的业务逻辑实现，第三方实现该接口；代表着消费者。\n\nProducer——生产者接口，第三方线程充当该角色，producer向RingBuffer写入事件。\n\nWait Strategy：Wait Strategy决定了一个消费者怎么等待生产者将事件（Event）放入Disruptor中。\n\n![](https://img-blog.csdnimg.cn/b3421fa31c3d4c58a127e493bedfe999.png)\n\n# 等待策略\n\n源码地址：https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java\n\n**「BlockingWaitStrategy」**\n\nDisruptor的默认策略是BlockingWaitStrategy。在BlockingWaitStrategy内部是使用锁和condition来控制线程的唤醒。BlockingWaitStrategy是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。\n\n**「SleepingWaitStrategy」**\n\nSleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，通过使用`LockSupport.parkNanos(1)`来实现循环等待。\n\n**「YieldingWaitStrategy」**\n\nYieldingWaitStrategy是可以使用在低延迟系统的策略之一。YieldingWaitStrategy将自旋以等待序列增加到适当的值。在循环体内，将调用`Thread.yield()`以允许其他排队的线程运行。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。\n\n**「BusySpinWaitStrategy」**\n\n性能最好，适合用于低延迟的系统。在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。\n\n**「PhasedBackoffWaitStrategy」**\n\n自旋 + yield + 自定义策略，CPU资源紧缺，吞吐量和延迟并不重要的场景。\n\n# 使用举例\n\n参考地址：https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started\n\n```xml\n<dependency>\n      <groupId>com.lmax</groupId>\n      <artifactId>disruptor</artifactId>\n      <version>3.3.4</version>\n   </dependency>\n```\n\n```java\n//定义事件event  通过Disruptor 进行交换的数据类型。\npublic class LongEvent {\n\n    private Long value;\n\n    public Long getValue() {\n        return value;\n    }\n\n    public void setValue(Long value) {\n        this.value = value;\n    }\n\n}\n```\n\n```java\npublic class LongEventFactory implements EventFactory<LongEvent> {\n    public LongEvent newInstance() {\n        return new LongEvent();\n    }\n}\n```\n\n```java\n//定义事件消费者\npublic class LongEventHandler implements EventHandler<LongEvent>  {\n    public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception {\n         System.out.println(\"消费者:\"+event.getValue());\n    }\n}\n```\n\n```java\n//定义生产者\npublic class LongEventProducer {\n    public final RingBuffer<LongEvent> ringBuffer;\n    public LongEventProducer(RingBuffer<LongEvent> ringBuffer) {\n        this.ringBuffer = ringBuffer;\n    }\n    public void onData(ByteBuffer byteBuffer) {\n        // 1.ringBuffer 事件队列 下一个槽\n        long sequence = ringBuffer.next();\n        Long data = null;\n        try {\n            //2.取出空的事件队列\n            LongEvent longEvent = ringBuffer.get(sequence);\n            data = byteBuffer.getLong(0);\n            //3.获取事件队列传递的数据\n            longEvent.setValue(data);\n            try {\n                Thread.sleep(10);\n            } catch (InterruptedException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        } finally {\n            System.out.println(\"生产这准备发送数据\");\n            //4.发布事件\n            ringBuffer.publish(sequence);\n        }\n    }\n}\n```\n\n```java\npublic class DisruptorMain {\n    public static void main(String[] args) {\n        // 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理\n        ExecutorService executor = Executors.newCachedThreadPool();\n        // 2.创建工厂\n        EventFactory<LongEvent> eventFactory = new LongEventFactory();\n        // 3.创建ringBuffer 大小\n        int ringBufferSize = 1024 * 1024; // ringBufferSize大小一定要是2的N次方\n        // 4.创建Disruptor\n        Disruptor<LongEvent> disruptor = new Disruptor<LongEvent>(eventFactory, ringBufferSize, executor,\n                ProducerType.SINGLE, new YieldingWaitStrategy());\n        // 5.连接消费端方法\n        disruptor.handleEventsWith(new LongEventHandler());\n        // 6.启动\n        disruptor.start();\n        // 7.创建RingBuffer容器\n        RingBuffer<LongEvent> ringBuffer = disruptor.getRingBuffer();\n        // 8.创建生产者\n        LongEventProducer producer = new LongEventProducer(ringBuffer);\n        // 9.指定缓冲区大小\n        ByteBuffer byteBuffer = ByteBuffer.allocate(8);\n        for (int i = 1; i <= 100; i++) {\n            byteBuffer.putLong(0, i);\n            producer.onData(byteBuffer);\n        }\n        //10.关闭disruptor和executor\n        disruptor.shutdown();\n        executor.shutdown();\n    }\n}\n```\n\n# 核心设计原理\n\nDisruptor通过以下设计来解决队列速度慢的问题：\n\n**「环形数组结构：」**\n\n为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好\n\n> ❝\n>\n> 原因：CPU缓存是由很多个缓存行组成的。每个缓存行通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个缓存行。在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。\n>\n> ❞\n\n**「元素位置定位：」**\n\n数组长度`2^n`，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。\n\n**「无锁设计：」**\n\n每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据，整个过程通过原子变量CAS，保证操作的线程安全\n\n# 数据结构\n\n框架使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。\n\n除数组外还有一个序列号(sequence)，用以指向下一个可用的元素，供生产者与消费者使用。\n\n原理图如下所示：\n\n![](https://img-blog.csdnimg.cn/d41d9a80af764e60831a2582f7424291.png)\n\n## Sequence\n\nmark：Disruptor通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据(事件)的处理过程总是沿着序号逐个递增处理。\n\n**「数组+序列号设计的优势是什么呢？」**\n\n回顾一下HashMap，在知道索引(index)下标的情况下，存与取数组上的元素时间复杂度只有O(1)，而这个index我们可以通过序列号与数组的长度取模来计算得出，`index=sequence % table.length`。当然也可以用位运算来计算效率更高，此时table.length必须是2的幂次方。\n\n# 写数据流程\n\n单线程写数据的流程：\n\n1. 申请写入m个元素；\n2. 若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；\n3. 若是返回的正确，则生产者开始写入元素。\n\n![](https://img-blog.csdnimg.cn/a7b10a9a10a3472c9eb7dadfebd4e4ed.png)\n\n# 使用场景\n\n经过测试，Disruptor的的延时和吞吐量都比ArrayBlockingQueue优秀很多，所以，当你在使用ArrayBlockingQueue出现性能瓶颈的时候，你就可以考虑采用Disruptor的代替。\n\n参考：https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results\n\n![](https://img-blog.csdnimg.cn/ae694a420f9a4c50b310468c9f4ba8ef.png)\n\n![](https://img-blog.csdnimg.cn/6fac3d5d5083457eada5f8eb0622667a.png)\n\n当然，Disruptor性能高并不是必然的，所以，是否使用还得经过测试。\n\nDisruptor的最常用的场景就是“生产者-消费者”场景，对场景的就是“一个生产者、多个消费者”的场景，并且要求顺序处理。\n\n举个例子，我们从MySQL的BigLog文件中顺序读取数据，然后写入到ElasticSearch（搜索引擎）中。在这种场景下，BigLog要求一个文件一个生产者，那个是一个生产者。而写入到ElasticSearch，则严格要求顺序，否则会出现问题，所以通常意义上的多消费者线程无法解决该问题，如果通过加锁，则性能大打折扣\n\n**参考：**\n\nhttps://tech.meituan.com/2016/11/18/disruptor.html\n\nhttps://github.com/LMAX-Exchange/disruptor/wiki","slug":"公众号文章/Disruptor框架","published":1,"date":"2022-03-05T16:35:06.318Z","updated":"2022-03-05T16:43:33.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwit00esfhjic99lf0e5","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>Disruptor是一个开源框架，研发的初衷是为了解决高并发下队列锁的问题，最早由LMAX提出并使用，能够在无锁的情况下实现队列的并发操作，并号称能够在一个线程里每秒处理6百万笔订单</p>\n<p>官网：<a href=\"http://lmax-exchange.github.io/disruptor/\">http://lmax-exchange.github.io/disruptor/</a></p>\n<p>目前，包括Apache Storm、Camel、Log4j2在内的很多知名项目都应用了Disruptor以获取高性能</p>\n<h1 id=\"为什么会产生Disruptor框架\"><a href=\"#为什么会产生Disruptor框架\" class=\"headerlink\" title=\"为什么会产生Disruptor框架\"></a>为什么会产生Disruptor框架</h1><p><strong>「目前Java内置队列保证线程安全的方式：」</strong></p>\n<p>ArrayBlockingQueue：基于数组形式的队列，通过加锁的方式，来保证多线程情况下数据的安全；</p>\n<p>LinkedBlockingQueue：基于链表形式的队列，也通过加锁的方式，来保证多线程情况下数据的安全；</p>\n<p>ConcurrentLinkedQueue：基于链表形式的队列，通过CAS的方式</p>\n<p>我们知道，在编程过程中，加锁通常会严重地影响性能，所以尽量用无锁方式，就产生了Disruptor这种无锁高并发框架</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>参考地址：<a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Introduction#core-concepts\">https://github.com/LMAX-Exchange/disruptor/wiki/Introduction#core-concepts</a></p>\n<p>RingBuffer——Disruptor底层数据结构实现，核心类，是线程间交换数据的中转地；</p>\n<p>Sequencer——序号管理器，生产同步的实现者，负责消费者&#x2F;生产者各自序号、序号栅栏的管理和协调,Sequencer有单生产者,多生产者两种不同的模式,里面实现了各种同步的算法；</p>\n<p>Sequence——序号，声明一个序号，用于跟踪ringbuffer中任务的变化和消费者的消费情况，disruptor里面大部分的并发代码都是通过对Sequence的值同步修改实现的,而非锁,这是disruptor高性能的一个主要原因；</p>\n<p>SequenceBarrier——序号栅栏，管理和协调生产者的游标序号和各个消费者的序号，确保生产者不会覆盖消费者未来得及处理的消息，确保存在依赖的消费者之间能够按照正确的顺序处理</p>\n<p>EventProcessor——事件处理器，监听RingBuffer的事件，并消费可用事件，从RingBuffer读取的事件会交由实际的生产者实现类来消费；它会一直侦听下一个可用的序号，直到该序号对应的事件已经准备好。</p>\n<p>EventHandler——业务处理器，是实际消费者的接口，完成具体的业务逻辑实现，第三方实现该接口；代表着消费者。</p>\n<p>Producer——生产者接口，第三方线程充当该角色，producer向RingBuffer写入事件。</p>\n<p>Wait Strategy：Wait Strategy决定了一个消费者怎么等待生产者将事件（Event）放入Disruptor中。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b3421fa31c3d4c58a127e493bedfe999.png\"></p>\n<h1 id=\"等待策略\"><a href=\"#等待策略\" class=\"headerlink\" title=\"等待策略\"></a>等待策略</h1><p>源码地址：<a href=\"https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java\">https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java</a></p>\n<p><strong>「BlockingWaitStrategy」</strong></p>\n<p>Disruptor的默认策略是BlockingWaitStrategy。在BlockingWaitStrategy内部是使用锁和condition来控制线程的唤醒。BlockingWaitStrategy是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。</p>\n<p><strong>「SleepingWaitStrategy」</strong></p>\n<p>SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，通过使用<code>LockSupport.parkNanos(1)</code>来实现循环等待。</p>\n<p><strong>「YieldingWaitStrategy」</strong></p>\n<p>YieldingWaitStrategy是可以使用在低延迟系统的策略之一。YieldingWaitStrategy将自旋以等待序列增加到适当的值。在循环体内，将调用<code>Thread.yield()</code>以允许其他排队的线程运行。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p>\n<p><strong>「BusySpinWaitStrategy」</strong></p>\n<p>性能最好，适合用于低延迟的系统。在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p>\n<p><strong>「PhasedBackoffWaitStrategy」</strong></p>\n<p>自旋 + yield + 自定义策略，CPU资源紧缺，吞吐量和延迟并不重要的场景。</p>\n<h1 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h1><p>参考地址：<a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started\">https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started</a></p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n      &lt;groupId&gt;com.lmax&lt;/groupId&gt;\n      &lt;artifactId&gt;disruptor&lt;/artifactId&gt;\n      &lt;version&gt;3.3.4&lt;/version&gt;\n   &lt;/dependency&gt;\n</code></pre>\n<pre><code class=\"java\">//定义事件event  通过Disruptor 进行交换的数据类型。\npublic class LongEvent &#123;\n\n    private Long value;\n\n    public Long getValue() &#123;\n        return value;\n    &#125;\n\n    public void setValue(Long value) &#123;\n        this.value = value;\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class LongEventFactory implements EventFactory&lt;LongEvent&gt; &#123;\n    public LongEvent newInstance() &#123;\n        return new LongEvent();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//定义事件消费者\npublic class LongEventHandler implements EventHandler&lt;LongEvent&gt;  &#123;\n    public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception &#123;\n         System.out.println(&quot;消费者:&quot;+event.getValue());\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//定义生产者\npublic class LongEventProducer &#123;\n    public final RingBuffer&lt;LongEvent&gt; ringBuffer;\n    public LongEventProducer(RingBuffer&lt;LongEvent&gt; ringBuffer) &#123;\n        this.ringBuffer = ringBuffer;\n    &#125;\n    public void onData(ByteBuffer byteBuffer) &#123;\n        // 1.ringBuffer 事件队列 下一个槽\n        long sequence = ringBuffer.next();\n        Long data = null;\n        try &#123;\n            //2.取出空的事件队列\n            LongEvent longEvent = ringBuffer.get(sequence);\n            data = byteBuffer.getLong(0);\n            //3.获取事件队列传递的数据\n            longEvent.setValue(data);\n            try &#123;\n                Thread.sleep(10);\n            &#125; catch (InterruptedException e) &#123;\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            &#125;\n        &#125; finally &#123;\n            System.out.println(&quot;生产这准备发送数据&quot;);\n            //4.发布事件\n            ringBuffer.publish(sequence);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class DisruptorMain &#123;\n    public static void main(String[] args) &#123;\n        // 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理\n        ExecutorService executor = Executors.newCachedThreadPool();\n        // 2.创建工厂\n        EventFactory&lt;LongEvent&gt; eventFactory = new LongEventFactory();\n        // 3.创建ringBuffer 大小\n        int ringBufferSize = 1024 * 1024; // ringBufferSize大小一定要是2的N次方\n        // 4.创建Disruptor\n        Disruptor&lt;LongEvent&gt; disruptor = new Disruptor&lt;LongEvent&gt;(eventFactory, ringBufferSize, executor,\n                ProducerType.SINGLE, new YieldingWaitStrategy());\n        // 5.连接消费端方法\n        disruptor.handleEventsWith(new LongEventHandler());\n        // 6.启动\n        disruptor.start();\n        // 7.创建RingBuffer容器\n        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();\n        // 8.创建生产者\n        LongEventProducer producer = new LongEventProducer(ringBuffer);\n        // 9.指定缓冲区大小\n        ByteBuffer byteBuffer = ByteBuffer.allocate(8);\n        for (int i = 1; i &lt;= 100; i++) &#123;\n            byteBuffer.putLong(0, i);\n            producer.onData(byteBuffer);\n        &#125;\n        //10.关闭disruptor和executor\n        disruptor.shutdown();\n        executor.shutdown();\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"核心设计原理\"><a href=\"#核心设计原理\" class=\"headerlink\" title=\"核心设计原理\"></a>核心设计原理</h1><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>\n<p><strong>「环形数组结构：」</strong></p>\n<p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好</p>\n<blockquote>\n<p>❝</p>\n<p>原因：CPU缓存是由很多个缓存行组成的。每个缓存行通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个缓存行。在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。</p>\n<p>❞</p>\n</blockquote>\n<p><strong>「元素位置定位：」</strong></p>\n<p>数组长度<code>2^n</code>，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>\n<p><strong>「无锁设计：」</strong></p>\n<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据，整个过程通过原子变量CAS，保证操作的线程安全</p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p>框架使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。</p>\n<p>除数组外还有一个序列号(sequence)，用以指向下一个可用的元素，供生产者与消费者使用。</p>\n<p>原理图如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d41d9a80af764e60831a2582f7424291.png\"></p>\n<h2 id=\"Sequence\"><a href=\"#Sequence\" class=\"headerlink\" title=\"Sequence\"></a>Sequence</h2><p>mark：Disruptor通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据(事件)的处理过程总是沿着序号逐个递增处理。</p>\n<p><strong>「数组+序列号设计的优势是什么呢？」</strong></p>\n<p>回顾一下HashMap，在知道索引(index)下标的情况下，存与取数组上的元素时间复杂度只有O(1)，而这个index我们可以通过序列号与数组的长度取模来计算得出，<code>index=sequence % table.length</code>。当然也可以用位运算来计算效率更高，此时table.length必须是2的幂次方。</p>\n<h1 id=\"写数据流程\"><a href=\"#写数据流程\" class=\"headerlink\" title=\"写数据流程\"></a>写数据流程</h1><p>单线程写数据的流程：</p>\n<ol>\n<li>申请写入m个元素；</li>\n<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li>\n<li>若是返回的正确，则生产者开始写入元素。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/a7b10a9a10a3472c9eb7dadfebd4e4ed.png\"></p>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><p>经过测试，Disruptor的的延时和吞吐量都比ArrayBlockingQueue优秀很多，所以，当你在使用ArrayBlockingQueue出现性能瓶颈的时候，你就可以考虑采用Disruptor的代替。</p>\n<p>参考：<a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results\">https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ae694a420f9a4c50b310468c9f4ba8ef.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6fac3d5d5083457eada5f8eb0622667a.png\"></p>\n<p>当然，Disruptor性能高并不是必然的，所以，是否使用还得经过测试。</p>\n<p>Disruptor的最常用的场景就是“生产者-消费者”场景，对场景的就是“一个生产者、多个消费者”的场景，并且要求顺序处理。</p>\n<p>举个例子，我们从MySQL的BigLog文件中顺序读取数据，然后写入到ElasticSearch（搜索引擎）中。在这种场景下，BigLog要求一个文件一个生产者，那个是一个生产者。而写入到ElasticSearch，则严格要求顺序，否则会出现问题，所以通常意义上的多消费者线程无法解决该问题，如果通过加锁，则性能大打折扣</p>\n<p><strong>参考：</strong></p>\n<p><a href=\"https://tech.meituan.com/2016/11/18/disruptor.html\">https://tech.meituan.com/2016/11/18/disruptor.html</a></p>\n<p><a href=\"https://github.com/LMAX-Exchange/disruptor/wiki\">https://github.com/LMAX-Exchange/disruptor/wiki</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>Disruptor是一个开源框架，研发的初衷是为了解决高并发下队列锁的问题，最早由LMAX提出并使用，能够在无锁的情况下实现队列的并发操作，并号称能够在一个线程里每秒处理6百万笔订单</p>\n<p>官网：<a href=\"http://lmax-exchange.github.io/disruptor/\">http://lmax-exchange.github.io/disruptor/</a></p>\n<p>目前，包括Apache Storm、Camel、Log4j2在内的很多知名项目都应用了Disruptor以获取高性能</p>\n<h1 id=\"为什么会产生Disruptor框架\"><a href=\"#为什么会产生Disruptor框架\" class=\"headerlink\" title=\"为什么会产生Disruptor框架\"></a>为什么会产生Disruptor框架</h1><p><strong>「目前Java内置队列保证线程安全的方式：」</strong></p>\n<p>ArrayBlockingQueue：基于数组形式的队列，通过加锁的方式，来保证多线程情况下数据的安全；</p>\n<p>LinkedBlockingQueue：基于链表形式的队列，也通过加锁的方式，来保证多线程情况下数据的安全；</p>\n<p>ConcurrentLinkedQueue：基于链表形式的队列，通过CAS的方式</p>\n<p>我们知道，在编程过程中，加锁通常会严重地影响性能，所以尽量用无锁方式，就产生了Disruptor这种无锁高并发框架</p>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>参考地址：<a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Introduction#core-concepts\">https://github.com/LMAX-Exchange/disruptor/wiki/Introduction#core-concepts</a></p>\n<p>RingBuffer——Disruptor底层数据结构实现，核心类，是线程间交换数据的中转地；</p>\n<p>Sequencer——序号管理器，生产同步的实现者，负责消费者&#x2F;生产者各自序号、序号栅栏的管理和协调,Sequencer有单生产者,多生产者两种不同的模式,里面实现了各种同步的算法；</p>\n<p>Sequence——序号，声明一个序号，用于跟踪ringbuffer中任务的变化和消费者的消费情况，disruptor里面大部分的并发代码都是通过对Sequence的值同步修改实现的,而非锁,这是disruptor高性能的一个主要原因；</p>\n<p>SequenceBarrier——序号栅栏，管理和协调生产者的游标序号和各个消费者的序号，确保生产者不会覆盖消费者未来得及处理的消息，确保存在依赖的消费者之间能够按照正确的顺序处理</p>\n<p>EventProcessor——事件处理器，监听RingBuffer的事件，并消费可用事件，从RingBuffer读取的事件会交由实际的生产者实现类来消费；它会一直侦听下一个可用的序号，直到该序号对应的事件已经准备好。</p>\n<p>EventHandler——业务处理器，是实际消费者的接口，完成具体的业务逻辑实现，第三方实现该接口；代表着消费者。</p>\n<p>Producer——生产者接口，第三方线程充当该角色，producer向RingBuffer写入事件。</p>\n<p>Wait Strategy：Wait Strategy决定了一个消费者怎么等待生产者将事件（Event）放入Disruptor中。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b3421fa31c3d4c58a127e493bedfe999.png\"></p>\n<h1 id=\"等待策略\"><a href=\"#等待策略\" class=\"headerlink\" title=\"等待策略\"></a>等待策略</h1><p>源码地址：<a href=\"https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java\">https://github.com/LMAX-Exchange/disruptor/blob/master/src/main/java/com/lmax/disruptor/WaitStrategy.java</a></p>\n<p><strong>「BlockingWaitStrategy」</strong></p>\n<p>Disruptor的默认策略是BlockingWaitStrategy。在BlockingWaitStrategy内部是使用锁和condition来控制线程的唤醒。BlockingWaitStrategy是最低效的策略，但其对CPU的消耗最小并且在各种不同部署环境中能提供更加一致的性能表现。</p>\n<p><strong>「SleepingWaitStrategy」</strong></p>\n<p>SleepingWaitStrategy 的性能表现跟 BlockingWaitStrategy 差不多，对 CPU 的消耗也类似，但其对生产者线程的影响最小，通过使用<code>LockSupport.parkNanos(1)</code>来实现循环等待。</p>\n<p><strong>「YieldingWaitStrategy」</strong></p>\n<p>YieldingWaitStrategy是可以使用在低延迟系统的策略之一。YieldingWaitStrategy将自旋以等待序列增加到适当的值。在循环体内，将调用<code>Thread.yield()</code>以允许其他排队的线程运行。在要求极高性能且事件处理线数小于 CPU 逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p>\n<p><strong>「BusySpinWaitStrategy」</strong></p>\n<p>性能最好，适合用于低延迟的系统。在要求极高性能且事件处理线程数小于CPU逻辑核心数的场景中，推荐使用此策略；例如，CPU开启超线程的特性。</p>\n<p><strong>「PhasedBackoffWaitStrategy」</strong></p>\n<p>自旋 + yield + 自定义策略，CPU资源紧缺，吞吐量和延迟并不重要的场景。</p>\n<h1 id=\"使用举例\"><a href=\"#使用举例\" class=\"headerlink\" title=\"使用举例\"></a>使用举例</h1><p>参考地址：<a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started\">https://github.com/LMAX-Exchange/disruptor/wiki/Getting-Started</a></p>\n<pre><code class=\"xml\">&lt;dependency&gt;\n      &lt;groupId&gt;com.lmax&lt;/groupId&gt;\n      &lt;artifactId&gt;disruptor&lt;/artifactId&gt;\n      &lt;version&gt;3.3.4&lt;/version&gt;\n   &lt;/dependency&gt;\n</code></pre>\n<pre><code class=\"java\">//定义事件event  通过Disruptor 进行交换的数据类型。\npublic class LongEvent &#123;\n\n    private Long value;\n\n    public Long getValue() &#123;\n        return value;\n    &#125;\n\n    public void setValue(Long value) &#123;\n        this.value = value;\n    &#125;\n\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class LongEventFactory implements EventFactory&lt;LongEvent&gt; &#123;\n    public LongEvent newInstance() &#123;\n        return new LongEvent();\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//定义事件消费者\npublic class LongEventHandler implements EventHandler&lt;LongEvent&gt;  &#123;\n    public void onEvent(LongEvent event, long sequence, boolean endOfBatch) throws Exception &#123;\n         System.out.println(&quot;消费者:&quot;+event.getValue());\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">//定义生产者\npublic class LongEventProducer &#123;\n    public final RingBuffer&lt;LongEvent&gt; ringBuffer;\n    public LongEventProducer(RingBuffer&lt;LongEvent&gt; ringBuffer) &#123;\n        this.ringBuffer = ringBuffer;\n    &#125;\n    public void onData(ByteBuffer byteBuffer) &#123;\n        // 1.ringBuffer 事件队列 下一个槽\n        long sequence = ringBuffer.next();\n        Long data = null;\n        try &#123;\n            //2.取出空的事件队列\n            LongEvent longEvent = ringBuffer.get(sequence);\n            data = byteBuffer.getLong(0);\n            //3.获取事件队列传递的数据\n            longEvent.setValue(data);\n            try &#123;\n                Thread.sleep(10);\n            &#125; catch (InterruptedException e) &#123;\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            &#125;\n        &#125; finally &#123;\n            System.out.println(&quot;生产这准备发送数据&quot;);\n            //4.发布事件\n            ringBuffer.publish(sequence);\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<pre><code class=\"java\">public class DisruptorMain &#123;\n    public static void main(String[] args) &#123;\n        // 1.创建一个可缓存的线程 提供线程来出发Consumer 的事件处理\n        ExecutorService executor = Executors.newCachedThreadPool();\n        // 2.创建工厂\n        EventFactory&lt;LongEvent&gt; eventFactory = new LongEventFactory();\n        // 3.创建ringBuffer 大小\n        int ringBufferSize = 1024 * 1024; // ringBufferSize大小一定要是2的N次方\n        // 4.创建Disruptor\n        Disruptor&lt;LongEvent&gt; disruptor = new Disruptor&lt;LongEvent&gt;(eventFactory, ringBufferSize, executor,\n                ProducerType.SINGLE, new YieldingWaitStrategy());\n        // 5.连接消费端方法\n        disruptor.handleEventsWith(new LongEventHandler());\n        // 6.启动\n        disruptor.start();\n        // 7.创建RingBuffer容器\n        RingBuffer&lt;LongEvent&gt; ringBuffer = disruptor.getRingBuffer();\n        // 8.创建生产者\n        LongEventProducer producer = new LongEventProducer(ringBuffer);\n        // 9.指定缓冲区大小\n        ByteBuffer byteBuffer = ByteBuffer.allocate(8);\n        for (int i = 1; i &lt;= 100; i++) &#123;\n            byteBuffer.putLong(0, i);\n            producer.onData(byteBuffer);\n        &#125;\n        //10.关闭disruptor和executor\n        disruptor.shutdown();\n        executor.shutdown();\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"核心设计原理\"><a href=\"#核心设计原理\" class=\"headerlink\" title=\"核心设计原理\"></a>核心设计原理</h1><p>Disruptor通过以下设计来解决队列速度慢的问题：</p>\n<p><strong>「环形数组结构：」</strong></p>\n<p>为了避免垃圾回收，采用数组而非链表。同时，数组对处理器的缓存机制更加友好</p>\n<blockquote>\n<p>❝</p>\n<p>原因：CPU缓存是由很多个缓存行组成的。每个缓存行通常是64字节，并且它有效地引用主内存中的一块儿地址。一个Java的long类型变量是8字节，因此在一个缓存行中可以存8个long类型的变量。CPU每次从主存中拉取数据时，会把相邻的数据也存入同一个缓存行。在访问一个long数组的时候，如果数组中的一个值被加载到缓存中，它会自动加载另外7个。因此你能非常快的遍历这个数组。</p>\n<p>❞</p>\n</blockquote>\n<p><strong>「元素位置定位：」</strong></p>\n<p>数组长度<code>2^n</code>，通过位运算，加快定位的速度。下标采取递增的形式。不用担心index溢出的问题。index是long类型，即使100万QPS的处理速度，也需要30万年才能用完。</p>\n<p><strong>「无锁设计：」</strong></p>\n<p>每个生产者或者消费者线程，会先申请可以操作的元素在数组中的位置，申请到之后，直接在该位置写入或者读取数据，整个过程通过原子变量CAS，保证操作的线程安全</p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><p>框架使用RingBuffer来作为队列的数据结构，RingBuffer就是一个可自定义大小的环形数组。</p>\n<p>除数组外还有一个序列号(sequence)，用以指向下一个可用的元素，供生产者与消费者使用。</p>\n<p>原理图如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d41d9a80af764e60831a2582f7424291.png\"></p>\n<h2 id=\"Sequence\"><a href=\"#Sequence\" class=\"headerlink\" title=\"Sequence\"></a>Sequence</h2><p>mark：Disruptor通过顺序递增的序号来编号管理通过其进行交换的数据（事件），对数据(事件)的处理过程总是沿着序号逐个递增处理。</p>\n<p><strong>「数组+序列号设计的优势是什么呢？」</strong></p>\n<p>回顾一下HashMap，在知道索引(index)下标的情况下，存与取数组上的元素时间复杂度只有O(1)，而这个index我们可以通过序列号与数组的长度取模来计算得出，<code>index=sequence % table.length</code>。当然也可以用位运算来计算效率更高，此时table.length必须是2的幂次方。</p>\n<h1 id=\"写数据流程\"><a href=\"#写数据流程\" class=\"headerlink\" title=\"写数据流程\"></a>写数据流程</h1><p>单线程写数据的流程：</p>\n<ol>\n<li>申请写入m个元素；</li>\n<li>若是有m个元素可以入，则返回最大的序列号。这儿主要判断是否会覆盖未读的元素；</li>\n<li>若是返回的正确，则生产者开始写入元素。</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/a7b10a9a10a3472c9eb7dadfebd4e4ed.png\"></p>\n<h1 id=\"使用场景\"><a href=\"#使用场景\" class=\"headerlink\" title=\"使用场景\"></a>使用场景</h1><p>经过测试，Disruptor的的延时和吞吐量都比ArrayBlockingQueue优秀很多，所以，当你在使用ArrayBlockingQueue出现性能瓶颈的时候，你就可以考虑采用Disruptor的代替。</p>\n<p>参考：<a href=\"https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results\">https://github.com/LMAX-Exchange/disruptor/wiki/Performance-Results</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ae694a420f9a4c50b310468c9f4ba8ef.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/6fac3d5d5083457eada5f8eb0622667a.png\"></p>\n<p>当然，Disruptor性能高并不是必然的，所以，是否使用还得经过测试。</p>\n<p>Disruptor的最常用的场景就是“生产者-消费者”场景，对场景的就是“一个生产者、多个消费者”的场景，并且要求顺序处理。</p>\n<p>举个例子，我们从MySQL的BigLog文件中顺序读取数据，然后写入到ElasticSearch（搜索引擎）中。在这种场景下，BigLog要求一个文件一个生产者，那个是一个生产者。而写入到ElasticSearch，则严格要求顺序，否则会出现问题，所以通常意义上的多消费者线程无法解决该问题，如果通过加锁，则性能大打折扣</p>\n<p><strong>参考：</strong></p>\n<p><a href=\"https://tech.meituan.com/2016/11/18/disruptor.html\">https://tech.meituan.com/2016/11/18/disruptor.html</a></p>\n<p><a href=\"https://github.com/LMAX-Exchange/disruptor/wiki\">https://github.com/LMAX-Exchange/disruptor/wiki</a></p>\n"},{"title":"Explain","_content":"\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png)\n\n在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）\n\n```sql\nCREATE TABLE `film` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `actor` (\n  `id` int(11) NOT NULL,\n  `name` varchar(45) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `film_actor` (\n  `id` int(11) NOT NULL,\n  `film_id` int(11) NOT NULL,\n  `actor_id` int(11) NOT NULL,\n  `remark` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_film_actor_id` (`film_id`,`actor_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```\n\n# 两个变种\n\n## explain extended\n\n会在 explain 的基础上额外提供一些查询优化的信息。\n\n紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。\n\n额外还有 filtered 列，是一个半分比的值，`rows * filtered/100` 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）\n\n```sql\nmysql> explain extended select * from film where id = 1;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/33b3446b9267cff1feb72506ccbec664.png)\n\n```sql\nmysql> show warnings;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/1408b011996e38f27d982a3e13cd9280.png)\n\n## explain partitions\n\n相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。\n\n# id列\n\nid列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 \n\nMySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。 \n\n复杂查询分为三类：\n\n* 简单子查询、派生表（from语句中的子查询）、union 查询。\n*  id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。\n\n# select_type列\n\nselect_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。\n\n1.simple简单查询。查询不包含子查询和union\n\n```sql\nmysql> explain select * from film where id = 2;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/c53259eba39d7c96393847a7d65607b1.png) 2）primary：复杂查询中最外层的 select\n\n3）subquery：包含在 select 中的子查询（不在 from 子句中）\n\n4）derived：包含在 from 子句中的子查询。\n\nMySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） 用这个例子来了解 primary、subquery 和 derived 类型\n\n```sql\nmysql> explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/e06fabb196445384e310f96e361e7758.png)  5）union：在 union 中的第二个和随后的 select\n\n6）union result：从 union 临时表检索结果的 select 用这个例子来了解 union 和 union result 类型：\n\n```sql\nmysql> explain select 1 union all select 1;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/b91fb8db9f7f027e38db92cd0e55abb7.png)\n\n# table列\n\n这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。 \n\n当有 union 时，UNION RESULT 的 table 列的值为`<union1,2>`，1和2表示参与 union 的 select 行id。\n\n# type列\n\n这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 \n\n依次从最优到最差分别为：system > const > eq_ref > ref > range > index > ALL 一般来说，得保证查询达到range级别，最好达到ref\n\n## NULL\n\nmysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。\n\n例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。\n\n```sql\nmysql> explain select min(id) from film;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/33a84bf3c56121be0186e1dce3c55b14.png)\n\n## const, system\n\nmysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。\n\n用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。\n\nsystem是const的特例，表里只有一条元组匹配时为system。\n\n```sql\nmysql> explain extended select * from (select * from film where id = 1) tmp;\n```\n\n## eq_ref\n\nprimary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。\n\n这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。\n\n```\nmysql> explain select * from film_actor left join film on film_actor.film_id = film.id;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/5825b45ab1b4a921af7355a0135cd3ce.png)\n\n## ref\n\n相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n\n1. 简单 select 查询，name是普通索引（非唯一索引）\n\n```sql\nmysql> explain select * from film where name = \"film1\";\n```\n\n2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。\n\n```sql\nmysql> explain select film_id from film left join film_actor on film.id = film_actor.film_id;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/1fdd576fa9dd2f5b5b3d434cca5ccb84.png)\n\n## range\n\n范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。\n\n```sql\nmysql> explain select * from actor where id > 1;\n```\n\n## index\n\n扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）\n\n```sql\nmysql> explain select * from film;\n```\n\n## ALL\n\n即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了\n\n```sql\nmysql> explain select * from actor;\n```\n\n# possible_keys列\n\n这一列显示查询可能使用哪些索引来查找。 \n\nexplain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。\n\n如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。\n\n# key列\n\n这一列显示mysql实际采用哪个索引来优化对该表的访问。 \n\n如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。\n\n# key_len列\n\n这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 \n\n举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。\n\n通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。\n\n```sql\nmysql> explain select * from film_actor where film_id = 2;\n```\n\n> “\n>\n> key_len计算规则如下： 字符串 char(n)：n字节长度 varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2 数值类型 tinyint：1字节 smallint：2字节 int：4字节 bigint：8字节　　 时间类型　 date：3字节 timestamp：4字节 datetime：8字节\n>\n> ”\n\n如果字段允许为 NULL，需要1字节记录是否为 NULL 索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。\n\n# ref列\n\n这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）\n\n# rows列\n\n这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。\n\n# Extra列\n\n这一列展示的是额外信息。常见的重要值如下：\n\n## Using index\n\n查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。\n\n一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高\n\n```sql\nmysql> explain select film_id from film_actor where film_id = 1;\n```\n\n## Using where\n\n查询的列未被索引覆盖，where筛选条件非索引的前导列\n\n```sql\nmysql> explain select * from actor where name = 'a';\n```\n\n## Using where Using index\n\n查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据\n\n```sql\nmysql> explain select film_id from film_actor where actor_id = 1;\n```\n\n## NULL\n\n查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引\n\n```\nmysql>explain select * from film_actor where film_id = 1;\n```\n\n## Using index condition\n\n与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；\n\n```\nmysql> explain select * from film_actor where film_id > 1;\n```\n\n## Using temporary\n\nmysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。\n\n1. actor.name没有索引，此时创建了张临时表来distinct\n\n```\nmysql> explain select distinct name from actor;\n```\n\n1. film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表\n\n```\nmysql> explain select distinct name from film;\n```\n\n## Using filesort\n\nmysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。\n\n此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。\n\n这种情况下一般也是要考虑使用索引来优化的。\n\n1. actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。\n\n```\nmysql> explain select * from actor order by name;\n```\n\n1. film.name建立了idx_name索引,此时查询时extra是using index\n\n```\nmysql> explain select * from film order by name;\n```\n","source":"_posts/公众号文章/Explain.md","raw":"---\ntitle: Explain\ncategories: \n- 公众号文章\n---\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png)\n\n在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）\n\n```sql\nCREATE TABLE `film` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `actor` (\n  `id` int(11) NOT NULL,\n  `name` varchar(45) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `film_actor` (\n  `id` int(11) NOT NULL,\n  `film_id` int(11) NOT NULL,\n  `actor_id` int(11) NOT NULL,\n  `remark` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_film_actor_id` (`film_id`,`actor_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n```\n\n# 两个变种\n\n## explain extended\n\n会在 explain 的基础上额外提供一些查询优化的信息。\n\n紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。\n\n额外还有 filtered 列，是一个半分比的值，`rows * filtered/100` 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）\n\n```sql\nmysql> explain extended select * from film where id = 1;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/33b3446b9267cff1feb72506ccbec664.png)\n\n```sql\nmysql> show warnings;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/1408b011996e38f27d982a3e13cd9280.png)\n\n## explain partitions\n\n相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。\n\n# id列\n\nid列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 \n\nMySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。 \n\n复杂查询分为三类：\n\n* 简单子查询、派生表（from语句中的子查询）、union 查询。\n*  id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。\n\n# select_type列\n\nselect_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。\n\n1.simple简单查询。查询不包含子查询和union\n\n```sql\nmysql> explain select * from film where id = 2;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/c53259eba39d7c96393847a7d65607b1.png) 2）primary：复杂查询中最外层的 select\n\n3）subquery：包含在 select 中的子查询（不在 from 子句中）\n\n4）derived：包含在 from 子句中的子查询。\n\nMySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） 用这个例子来了解 primary、subquery 和 derived 类型\n\n```sql\nmysql> explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/e06fabb196445384e310f96e361e7758.png)  5）union：在 union 中的第二个和随后的 select\n\n6）union result：从 union 临时表检索结果的 select 用这个例子来了解 union 和 union result 类型：\n\n```sql\nmysql> explain select 1 union all select 1;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/b91fb8db9f7f027e38db92cd0e55abb7.png)\n\n# table列\n\n这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。 \n\n当有 union 时，UNION RESULT 的 table 列的值为`<union1,2>`，1和2表示参与 union 的 select 行id。\n\n# type列\n\n这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 \n\n依次从最优到最差分别为：system > const > eq_ref > ref > range > index > ALL 一般来说，得保证查询达到range级别，最好达到ref\n\n## NULL\n\nmysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。\n\n例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。\n\n```sql\nmysql> explain select min(id) from film;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/33a84bf3c56121be0186e1dce3c55b14.png)\n\n## const, system\n\nmysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。\n\n用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。\n\nsystem是const的特例，表里只有一条元组匹配时为system。\n\n```sql\nmysql> explain extended select * from (select * from film where id = 1) tmp;\n```\n\n## eq_ref\n\nprimary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。\n\n这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。\n\n```\nmysql> explain select * from film_actor left join film on film_actor.film_id = film.id;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/5825b45ab1b4a921af7355a0135cd3ce.png)\n\n## ref\n\n相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。\n\n1. 简单 select 查询，name是普通索引（非唯一索引）\n\n```sql\nmysql> explain select * from film where name = \"film1\";\n```\n\n2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。\n\n```sql\nmysql> explain select film_id from film left join film_actor on film.id = film_actor.film_id;\n```\n\n![img](https://img-blog.csdnimg.cn/img_convert/1fdd576fa9dd2f5b5b3d434cca5ccb84.png)\n\n## range\n\n范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。\n\n```sql\nmysql> explain select * from actor where id > 1;\n```\n\n## index\n\n扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）\n\n```sql\nmysql> explain select * from film;\n```\n\n## ALL\n\n即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了\n\n```sql\nmysql> explain select * from actor;\n```\n\n# possible_keys列\n\n这一列显示查询可能使用哪些索引来查找。 \n\nexplain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。\n\n如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。\n\n# key列\n\n这一列显示mysql实际采用哪个索引来优化对该表的访问。 \n\n如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。\n\n# key_len列\n\n这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 \n\n举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。\n\n通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执行索引查找。\n\n```sql\nmysql> explain select * from film_actor where film_id = 2;\n```\n\n> “\n>\n> key_len计算规则如下： 字符串 char(n)：n字节长度 varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2 数值类型 tinyint：1字节 smallint：2字节 int：4字节 bigint：8字节　　 时间类型　 date：3字节 timestamp：4字节 datetime：8字节\n>\n> ”\n\n如果字段允许为 NULL，需要1字节记录是否为 NULL 索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。\n\n# ref列\n\n这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）\n\n# rows列\n\n这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。\n\n# Extra列\n\n这一列展示的是额外信息。常见的重要值如下：\n\n## Using index\n\n查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。\n\n一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高\n\n```sql\nmysql> explain select film_id from film_actor where film_id = 1;\n```\n\n## Using where\n\n查询的列未被索引覆盖，where筛选条件非索引的前导列\n\n```sql\nmysql> explain select * from actor where name = 'a';\n```\n\n## Using where Using index\n\n查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据\n\n```sql\nmysql> explain select film_id from film_actor where actor_id = 1;\n```\n\n## NULL\n\n查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引\n\n```\nmysql>explain select * from film_actor where film_id = 1;\n```\n\n## Using index condition\n\n与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；\n\n```\nmysql> explain select * from film_actor where film_id > 1;\n```\n\n## Using temporary\n\nmysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。\n\n1. actor.name没有索引，此时创建了张临时表来distinct\n\n```\nmysql> explain select distinct name from actor;\n```\n\n1. film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表\n\n```\nmysql> explain select distinct name from film;\n```\n\n## Using filesort\n\nmysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。\n\n此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。\n\n这种情况下一般也是要考虑使用索引来优化的。\n\n1. actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。\n\n```\nmysql> explain select * from actor order by name;\n```\n\n1. film.name建立了idx_name索引,此时查询时extra是using index\n\n```\nmysql> explain select * from film order by name;\n```\n","slug":"公众号文章/Explain","published":1,"date":"2022-03-12T02:07:08.117Z","updated":"2022-03-12T02:16:03.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiu00etfhji3ijwdqhp","content":"<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png\"></p>\n<p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）</p>\n<pre><code class=\"sql\">CREATE TABLE `film` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `actor` (\n  `id` int(11) NOT NULL,\n  `name` varchar(45) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `film_actor` (\n  `id` int(11) NOT NULL,\n  `film_id` int(11) NOT NULL,\n  `actor_id` int(11) NOT NULL,\n  `remark` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_film_actor_id` (`film_id`,`actor_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n</code></pre>\n<h1 id=\"两个变种\"><a href=\"#两个变种\" class=\"headerlink\" title=\"两个变种\"></a>两个变种</h1><h2 id=\"explain-extended\"><a href=\"#explain-extended\" class=\"headerlink\" title=\"explain extended\"></a>explain extended</h2><p>会在 explain 的基础上额外提供一些查询优化的信息。</p>\n<p>紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。</p>\n<p>额外还有 filtered 列，是一个半分比的值，<code>rows * filtered/100</code> 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）</p>\n<pre><code class=\"sql\">mysql&gt; explain extended select * from film where id = 1;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/33b3446b9267cff1feb72506ccbec664.png\" alt=\"img\"></p>\n<pre><code class=\"sql\">mysql&gt; show warnings;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/1408b011996e38f27d982a3e13cd9280.png\" alt=\"img\"></p>\n<h2 id=\"explain-partitions\"><a href=\"#explain-partitions\" class=\"headerlink\" title=\"explain partitions\"></a>explain partitions</h2><p>相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>\n<h1 id=\"id列\"><a href=\"#id列\" class=\"headerlink\" title=\"id列\"></a>id列</h1><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 </p>\n<p>MySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。 </p>\n<p>复杂查询分为三类：</p>\n<ul>\n<li>简单子查询、派生表（from语句中的子查询）、union 查询。</li>\n<li>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</li>\n</ul>\n<h1 id=\"select-type列\"><a href=\"#select-type列\" class=\"headerlink\" title=\"select_type列\"></a>select_type列</h1><p>select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p>\n<p>1.simple简单查询。查询不包含子查询和union</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from film where id = 2;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c53259eba39d7c96393847a7d65607b1.png\" alt=\"img\"> 2）primary：复杂查询中最外层的 select</p>\n<p>3）subquery：包含在 select 中的子查询（不在 from 子句中）</p>\n<p>4）derived：包含在 from 子句中的子查询。</p>\n<p>MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） 用这个例子来了解 primary、subquery 和 derived 类型</p>\n<pre><code class=\"sql\">mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e06fabb196445384e310f96e361e7758.png\" alt=\"img\">  5）union：在 union 中的第二个和随后的 select</p>\n<p>6）union result：从 union 临时表检索结果的 select 用这个例子来了解 union 和 union result 类型：</p>\n<pre><code class=\"sql\">mysql&gt; explain select 1 union all select 1;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b91fb8db9f7f027e38db92cd0e55abb7.png\" alt=\"img\"></p>\n<h1 id=\"table列\"><a href=\"#table列\" class=\"headerlink\" title=\"table列\"></a>table列</h1><p>这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。 </p>\n<p>当有 union 时，UNION RESULT 的 table 列的值为<code>&lt;union1,2&gt;</code>，1和2表示参与 union 的 select 行id。</p>\n<h1 id=\"type列\"><a href=\"#type列\" class=\"headerlink\" title=\"type列\"></a>type列</h1><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p>\n<p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说，得保证查询达到range级别，最好达到ref</p>\n<h2 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><p>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。</p>\n<p>例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。</p>\n<pre><code class=\"sql\">mysql&gt; explain select min(id) from film;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/33a84bf3c56121be0186e1dce3c55b14.png\" alt=\"img\"></p>\n<h2 id=\"const-system\"><a href=\"#const-system\" class=\"headerlink\" title=\"const, system\"></a>const, system</h2><p>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。</p>\n<p>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</p>\n<p>system是const的特例，表里只有一条元组匹配时为system。</p>\n<pre><code class=\"sql\">mysql&gt; explain extended select * from (select * from film where id = 1) tmp;\n</code></pre>\n<h2 id=\"eq-ref\"><a href=\"#eq-ref\" class=\"headerlink\" title=\"eq_ref\"></a>eq_ref</h2><p>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</p>\n<p>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>\n<pre><code>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5825b45ab1b4a921af7355a0135cd3ce.png\" alt=\"img\"></p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>\n<ol>\n<li>简单 select 查询，name是普通索引（非唯一索引）</li>\n</ol>\n<pre><code class=\"sql\">mysql&gt; explain select * from film where name = &quot;film1&quot;;\n</code></pre>\n<p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</p>\n<pre><code class=\"sql\">mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/1fdd576fa9dd2f5b5b3d434cca5ccb84.png\" alt=\"img\"></p>\n<h2 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range\"></a>range</h2><p>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from actor where id &gt; 1;\n</code></pre>\n<h2 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h2><p>扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from film;\n</code></pre>\n<h2 id=\"ALL\"><a href=\"#ALL\" class=\"headerlink\" title=\"ALL\"></a>ALL</h2><p>即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from actor;\n</code></pre>\n<h1 id=\"possible-keys列\"><a href=\"#possible-keys列\" class=\"headerlink\" title=\"possible_keys列\"></a>possible_keys列</h1><p>这一列显示查询可能使用哪些索引来查找。 </p>\n<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。</p>\n<p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>\n<h1 id=\"key列\"><a href=\"#key列\" class=\"headerlink\" title=\"key列\"></a>key列</h1><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </p>\n<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>\n<h1 id=\"key-len列\"><a href=\"#key-len列\" class=\"headerlink\" title=\"key_len列\"></a>key_len列</h1><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p>\n<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。</p>\n<p>通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from film_actor where film_id = 2;\n</code></pre>\n<blockquote>\n<p>“</p>\n<p>key_len计算规则如下： 字符串 char(n)：n字节长度 varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2 数值类型 tinyint：1字节 smallint：2字节 int：4字节 bigint：8字节　　 时间类型　 date：3字节 timestamp：4字节 datetime：8字节</p>\n<p>”</p>\n</blockquote>\n<p>如果字段允许为 NULL，需要1字节记录是否为 NULL 索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>\n<h1 id=\"ref列\"><a href=\"#ref列\" class=\"headerlink\" title=\"ref列\"></a>ref列</h1><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>\n<h1 id=\"rows列\"><a href=\"#rows列\" class=\"headerlink\" title=\"rows列\"></a>rows列</h1><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>\n<h1 id=\"Extra列\"><a href=\"#Extra列\" class=\"headerlink\" title=\"Extra列\"></a>Extra列</h1><p>这一列展示的是额外信息。常见的重要值如下：</p>\n<h2 id=\"Using-index\"><a href=\"#Using-index\" class=\"headerlink\" title=\"Using index\"></a>Using index</h2><p>查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。</p>\n<p>一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高</p>\n<pre><code class=\"sql\">mysql&gt; explain select film_id from film_actor where film_id = 1;\n</code></pre>\n<h2 id=\"Using-where\"><a href=\"#Using-where\" class=\"headerlink\" title=\"Using where\"></a>Using where</h2><p>查询的列未被索引覆盖，where筛选条件非索引的前导列</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from actor where name = &#39;a&#39;;\n</code></pre>\n<h2 id=\"Using-where-Using-index\"><a href=\"#Using-where-Using-index\" class=\"headerlink\" title=\"Using where Using index\"></a>Using where Using index</h2><p>查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据</p>\n<pre><code class=\"sql\">mysql&gt; explain select film_id from film_actor where actor_id = 1;\n</code></pre>\n<h2 id=\"NULL-1\"><a href=\"#NULL-1\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><p>查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引</p>\n<pre><code>mysql&gt;explain select * from film_actor where film_id = 1;\n</code></pre>\n<h2 id=\"Using-index-condition\"><a href=\"#Using-index-condition\" class=\"headerlink\" title=\"Using index condition\"></a>Using index condition</h2><p>与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p>\n<pre><code>mysql&gt; explain select * from film_actor where film_id &gt; 1;\n</code></pre>\n<h2 id=\"Using-temporary\"><a href=\"#Using-temporary\" class=\"headerlink\" title=\"Using temporary\"></a>Using temporary</h2><p>mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>\n<ol>\n<li>actor.name没有索引，此时创建了张临时表来distinct</li>\n</ol>\n<pre><code>mysql&gt; explain select distinct name from actor;\n</code></pre>\n<ol>\n<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</li>\n</ol>\n<pre><code>mysql&gt; explain select distinct name from film;\n</code></pre>\n<h2 id=\"Using-filesort\"><a href=\"#Using-filesort\" class=\"headerlink\" title=\"Using filesort\"></a>Using filesort</h2><p>mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。</p>\n<p>此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。</p>\n<p>这种情况下一般也是要考虑使用索引来优化的。</p>\n<ol>\n<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。</li>\n</ol>\n<pre><code>mysql&gt; explain select * from actor order by name;\n</code></pre>\n<ol>\n<li>film.name建立了idx_name索引,此时查询时extra是using index</li>\n</ol>\n<pre><code>mysql&gt; explain select * from film order by name;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png\"></p>\n<p>在 select 语句之前增加 explain 关键字，MySQL 会在查询上设置一个标记，执行查询时，会返回执行计划的信息，而不是执行这条SQL（如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中）</p>\n<pre><code class=\"sql\">CREATE TABLE `film` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `name` varchar(10) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_name` (`name`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `actor` (\n  `id` int(11) NOT NULL,\n  `name` varchar(45) DEFAULT NULL,\n  `update_time` datetime DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `film_actor` (\n  `id` int(11) NOT NULL,\n  `film_id` int(11) NOT NULL,\n  `actor_id` int(11) NOT NULL,\n  `remark` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `idx_film_actor_id` (`film_id`,`actor_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8\n</code></pre>\n<h1 id=\"两个变种\"><a href=\"#两个变种\" class=\"headerlink\" title=\"两个变种\"></a>两个变种</h1><h2 id=\"explain-extended\"><a href=\"#explain-extended\" class=\"headerlink\" title=\"explain extended\"></a>explain extended</h2><p>会在 explain 的基础上额外提供一些查询优化的信息。</p>\n<p>紧随其后通过 show warnings 命令可以 得到优化后的查询语句，从而看出优化器优化了什么。</p>\n<p>额外还有 filtered 列，是一个半分比的值，<code>rows * filtered/100</code> 可以估算出将要和 explain 中前一个表进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）</p>\n<pre><code class=\"sql\">mysql&gt; explain extended select * from film where id = 1;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/33b3446b9267cff1feb72506ccbec664.png\" alt=\"img\"></p>\n<pre><code class=\"sql\">mysql&gt; show warnings;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/1408b011996e38f27d982a3e13cd9280.png\" alt=\"img\"></p>\n<h2 id=\"explain-partitions\"><a href=\"#explain-partitions\" class=\"headerlink\" title=\"explain partitions\"></a>explain partitions</h2><p>相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>\n<h1 id=\"id列\"><a href=\"#id列\" class=\"headerlink\" title=\"id列\"></a>id列</h1><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。 </p>\n<p>MySQL将 select 查询分为简单查询(SIMPLE)和复杂查询(PRIMARY)。 </p>\n<p>复杂查询分为三类：</p>\n<ul>\n<li>简单子查询、派生表（from语句中的子查询）、union 查询。</li>\n<li>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</li>\n</ul>\n<h1 id=\"select-type列\"><a href=\"#select-type列\" class=\"headerlink\" title=\"select_type列\"></a>select_type列</h1><p>select_type 表示对应行是简单还是复杂的查询，如果是复杂的查询，又是上述三种复杂查询中的哪一种。</p>\n<p>1.simple简单查询。查询不包含子查询和union</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from film where id = 2;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/c53259eba39d7c96393847a7d65607b1.png\" alt=\"img\"> 2）primary：复杂查询中最外层的 select</p>\n<p>3）subquery：包含在 select 中的子查询（不在 from 子句中）</p>\n<p>4）derived：包含在 from 子句中的子查询。</p>\n<p>MySQL会将结果存放在一个临时表中，也称为派生表（derived的英文含义） 用这个例子来了解 primary、subquery 和 derived 类型</p>\n<pre><code class=\"sql\">mysql&gt; explain select (select 1 from actor where id = 1) from (select * from film where id = 1) der;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/e06fabb196445384e310f96e361e7758.png\" alt=\"img\">  5）union：在 union 中的第二个和随后的 select</p>\n<p>6）union result：从 union 临时表检索结果的 select 用这个例子来了解 union 和 union result 类型：</p>\n<pre><code class=\"sql\">mysql&gt; explain select 1 union all select 1;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/b91fb8db9f7f027e38db92cd0e55abb7.png\" alt=\"img\"></p>\n<h1 id=\"table列\"><a href=\"#table列\" class=\"headerlink\" title=\"table列\"></a>table列</h1><p>这一列表示 explain 的一行正在访问哪个表。 当 from 子句中有子查询时，table列是 格式，表示当前查询依赖 id&#x3D;N 的查询，于是先执行 id&#x3D;N 的查询。 </p>\n<p>当有 union 时，UNION RESULT 的 table 列的值为<code>&lt;union1,2&gt;</code>，1和2表示参与 union 的 select 行id。</p>\n<h1 id=\"type列\"><a href=\"#type列\" class=\"headerlink\" title=\"type列\"></a>type列</h1><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概范围。 </p>\n<p>依次从最优到最差分别为：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL 一般来说，得保证查询达到range级别，最好达到ref</p>\n<h2 id=\"NULL\"><a href=\"#NULL\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><p>mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。</p>\n<p>例如：在索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表。</p>\n<pre><code class=\"sql\">mysql&gt; explain select min(id) from film;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/33a84bf3c56121be0186e1dce3c55b14.png\" alt=\"img\"></p>\n<h2 id=\"const-system\"><a href=\"#const-system\" class=\"headerlink\" title=\"const, system\"></a>const, system</h2><p>mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。</p>\n<p>用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。</p>\n<p>system是const的特例，表里只有一条元组匹配时为system。</p>\n<pre><code class=\"sql\">mysql&gt; explain extended select * from (select * from film where id = 1) tmp;\n</code></pre>\n<h2 id=\"eq-ref\"><a href=\"#eq-ref\" class=\"headerlink\" title=\"eq_ref\"></a>eq_ref</h2><p>primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。</p>\n<p>这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种 type。</p>\n<pre><code>mysql&gt; explain select * from film_actor left join film on film_actor.film_id = film.id;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/5825b45ab1b4a921af7355a0135cd3ce.png\" alt=\"img\"></p>\n<h2 id=\"ref\"><a href=\"#ref\" class=\"headerlink\" title=\"ref\"></a>ref</h2><p>相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行。</p>\n<ol>\n<li>简单 select 查询，name是普通索引（非唯一索引）</li>\n</ol>\n<pre><code class=\"sql\">mysql&gt; explain select * from film where name = &quot;film1&quot;;\n</code></pre>\n<p>2.关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</p>\n<pre><code class=\"sql\">mysql&gt; explain select film_id from film left join film_actor on film.id = film_actor.film_id;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/img_convert/1fdd576fa9dd2f5b5b3d434cca5ccb84.png\" alt=\"img\"></p>\n<h2 id=\"range\"><a href=\"#range\" class=\"headerlink\" title=\"range\"></a>range</h2><p>范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;&#x3D; 等操作中。使用一个索引来检索给定范围的行。</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from actor where id &gt; 1;\n</code></pre>\n<h2 id=\"index\"><a href=\"#index\" class=\"headerlink\" title=\"index\"></a>index</h2><p>扫描全表索引，这通常比ALL快一些。（index是从索引中读取的，而all是从硬盘中读取）</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from film;\n</code></pre>\n<h2 id=\"ALL\"><a href=\"#ALL\" class=\"headerlink\" title=\"ALL\"></a>ALL</h2><p>即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from actor;\n</code></pre>\n<h1 id=\"possible-keys列\"><a href=\"#possible-keys列\" class=\"headerlink\" title=\"possible_keys列\"></a>possible_keys列</h1><p>这一列显示查询可能使用哪些索引来查找。 </p>\n<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。</p>\n<p>如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。</p>\n<h1 id=\"key列\"><a href=\"#key列\" class=\"headerlink\" title=\"key列\"></a>key列</h1><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </p>\n<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index。</p>\n<h1 id=\"key-len列\"><a href=\"#key-len列\" class=\"headerlink\" title=\"key_len列\"></a>key_len列</h1><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。 </p>\n<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成，并且每个int是4字节。</p>\n<p>通过结果中的key_len&#x3D;4可推断出查询使用了第一个列：film_id列来执行索引查找。</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from film_actor where film_id = 2;\n</code></pre>\n<blockquote>\n<p>“</p>\n<p>key_len计算规则如下： 字符串 char(n)：n字节长度 varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2 数值类型 tinyint：1字节 smallint：2字节 int：4字节 bigint：8字节　　 时间类型　 date：3字节 timestamp：4字节 datetime：8字节</p>\n<p>”</p>\n</blockquote>\n<p>如果字段允许为 NULL，需要1字节记录是否为 NULL 索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>\n<h1 id=\"ref列\"><a href=\"#ref列\" class=\"headerlink\" title=\"ref列\"></a>ref列</h1><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id）</p>\n<h1 id=\"rows列\"><a href=\"#rows列\" class=\"headerlink\" title=\"rows列\"></a>rows列</h1><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。</p>\n<h1 id=\"Extra列\"><a href=\"#Extra列\" class=\"headerlink\" title=\"Extra列\"></a>Extra列</h1><p>这一列展示的是额外信息。常见的重要值如下：</p>\n<h2 id=\"Using-index\"><a href=\"#Using-index\" class=\"headerlink\" title=\"Using index\"></a>Using index</h2><p>查询的列被索引覆盖，并且where筛选条件是索引的前导列，是性能高的表现。</p>\n<p>一般是使用了覆盖索引(索引包含了所有查询的字段)。对于innodb来说，如果是辅助索引性能会有不少提高</p>\n<pre><code class=\"sql\">mysql&gt; explain select film_id from film_actor where film_id = 1;\n</code></pre>\n<h2 id=\"Using-where\"><a href=\"#Using-where\" class=\"headerlink\" title=\"Using where\"></a>Using where</h2><p>查询的列未被索引覆盖，where筛选条件非索引的前导列</p>\n<pre><code class=\"sql\">mysql&gt; explain select * from actor where name = &#39;a&#39;;\n</code></pre>\n<h2 id=\"Using-where-Using-index\"><a href=\"#Using-where-Using-index\" class=\"headerlink\" title=\"Using where Using index\"></a>Using where Using index</h2><p>查询的列被索引覆盖，并且where筛选条件是索引列之一但是不是索引的前导列，意味着无法直接通过索引查找来查询到符合条件的数据</p>\n<pre><code class=\"sql\">mysql&gt; explain select film_id from film_actor where actor_id = 1;\n</code></pre>\n<h2 id=\"NULL-1\"><a href=\"#NULL-1\" class=\"headerlink\" title=\"NULL\"></a>NULL</h2><p>查询的列未被索引覆盖，并且where筛选条件是索引的前导列，意味着用到了索引，但是部分字段未被索引覆盖，必须通过“回表”来实现，不是纯粹地用到了索引，也不是完全没用到索引</p>\n<pre><code>mysql&gt;explain select * from film_actor where film_id = 1;\n</code></pre>\n<h2 id=\"Using-index-condition\"><a href=\"#Using-index-condition\" class=\"headerlink\" title=\"Using index condition\"></a>Using index condition</h2><p>与Using where类似，查询的列不完全被索引覆盖，where条件中是一个前导列的范围；</p>\n<pre><code>mysql&gt; explain select * from film_actor where film_id &gt; 1;\n</code></pre>\n<h2 id=\"Using-temporary\"><a href=\"#Using-temporary\" class=\"headerlink\" title=\"Using temporary\"></a>Using temporary</h2><p>mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行优化的，首先是想到用索引来优化。</p>\n<ol>\n<li>actor.name没有索引，此时创建了张临时表来distinct</li>\n</ol>\n<pre><code>mysql&gt; explain select distinct name from actor;\n</code></pre>\n<ol>\n<li>film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表</li>\n</ol>\n<pre><code>mysql&gt; explain select distinct name from film;\n</code></pre>\n<h2 id=\"Using-filesort\"><a href=\"#Using-filesort\" class=\"headerlink\" title=\"Using filesort\"></a>Using filesort</h2><p>mysql 会对结果使用一个外部索引排序，而不是按索引次序从表里读取行。</p>\n<p>此时mysql会根据联接类型浏览所有符合条件的记录，并保存排序关键字和行指针，然后排序关键字并按顺序检索行信息。</p>\n<p>这种情况下一般也是要考虑使用索引来优化的。</p>\n<ol>\n<li>actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录。</li>\n</ol>\n<pre><code>mysql&gt; explain select * from actor order by name;\n</code></pre>\n<ol>\n<li>film.name建立了idx_name索引,此时查询时extra是using index</li>\n</ol>\n<pre><code>mysql&gt; explain select * from film order by name;\n</code></pre>\n"},{"title":"MySQL优化","_content":"\n# 前言\n\n面试题来自：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect)\n\n**MySQL常见的优化手段分为下面几个方面：**\n\nSQL优化、设计优化，硬件优化等，其中每个大的方向中又包含多个小的优化点\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/hC3oNAJqSRyHzQFLFcTsrVbcYguC9bVrFxWgMe5HPnMqoXwEBbPFPl3o1aBakiahmoD4Q1lZqphbiamncOKK4ZUA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n下面我们具体来看看\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n- 公众号后台回复666，可以获得免费电子书籍\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n# SQL优化\n\n此优化方案指的是通过优化 SQL 语句以及索引来提高 MySQL 数据库的运行效率，具体内容如下：\n\n## 分页优化\n\n例如：\n\n```sql\nselect * from table where type = 2 and level = 9 order by id asc limit 190289,10;\n```\n\n优化方案：\n\n- 延迟关联\n\n  先通过where条件提取出主键，在将该表与原数据表关联，通过主键id提取数据行，而不是通过原来的二级索引提取数据行\n\n  例如：\n\n```sql\nselect a.* from table a, (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b where a.id = b.id\n```\n\n- 书签方式\n\n  书签方式说白了就是找到limit第一个参数对应的主键值，再根据这个主键值再去过滤并limit\n\n  例如：\n\n```sql\nselect * from table where id > (select * from table where type = 2 and level = 9 order by id asc limit 190289, 1) limit 10;\n```\n\n## 索引优化\n\n**正确使用索引**\n\n假如我们没有添加索引，那么在查询时就会触发全表扫描，因此查询的数据就会很多，并且查询效率会很低，为了提高查询的性能，我们就需要给最常使用的查询字段上，添加相应的索引，这样才能提高查询的性能\n\n> 建立覆盖索引\n\nInnoDB使用辅助索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引\n\n例如对于如下查询：\n\n```sql\nselect name from test where city='上海'\n```\n\n我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取\n\n```sql\nalter table test add index idx_city_name (city, name);\n```\n\n> 在 MySQL 5.0 之前的版本尽量避免使用or查询\n\n在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，在 MySQL 5.0 之后的版本中引入了索引合并\n\n索引合并简单来说就是把多条件查询，比如or或and查询对多个索引分别进行条件扫描，然后将它们各自的结果进行合并，因此就不会导致索引失效的问题了\n\n如果从Explain执行计划的type列的值是`index_merge`可以看出MySQL使用索引合并的方式来执行对表的查询\n\n关于Explain的使用可以参考我之前的文章：[最完整的Explain总结，SQL优化不再困难](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect)\n\n> 避免在 where 查询条件中使用 != 或者 <> 操作符\n\nSQL中，不等于操作符会导致查询引擎放弃索引索引，引起全表扫描，即使比较的字段上有索引\n\n解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描\n\n例如，把`column<>’aaa’，改成column>’aaa’ or column<’aaa’`，就可以使用索引了\n\n> 适当使用前缀索引\n\nMySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引\n\n我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率\n\n比如，邮箱的后缀都是固定的“`@xxx.com`”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引\n\n```\nalter table test add index index2(email(6));\n```\n\n使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本\n\n需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引\n\n> 查询具体的字段而非全部字段\n\n要尽量避免使用`select *`，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力\n\n> 优化子查询\n\n尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大\n\n关于Join语句使用，可以参考我之前的文章：[写出好的Join语句，前提你得懂这些](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect)\n\n> 小表驱动大表\n\n我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：\n\n```\nselect name from A where id in (select id from B);\n```\n\n> 不要在列上进行运算操作\n\n不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率\n\n```sql\nselect * from test where id + 1 = 50;\nselect * from test where month(updateTime) = 7;\n```\n\n一个很容易踩的坑：隐式类型转换：\n\n```sql\nselect * from test where skuId=123456\n```\n\nskuId这个字段上有索引，但是explain的结果却显示这条语句会全表扫描\n\n原因在于skuId的字符类型是varchar(32)，比较值却是整型，故需要做类型转换\n\n**适当增加冗余字段**\n\n增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略\n\n**正确使用联合索引**\n\n使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序\n\n例如，我们创建了一个联合索引是`idx(name,age,sex)`，那么当我们使用，姓名+年龄+性别、姓名+年龄、姓名等这种最左前缀查询条件时，就会触发联合索引进行查询；然而如果非最左匹配的查询条件，例如，性别+姓名这种查询条件就不会触发联合索引\n\n## Join优化\n\nMySQL的join语句连接表使用的是nested-loop join算法，这个过程类似于嵌套循环，简单来说，就是遍历驱动表（外层表），每读出一行数据，取出连接字段到被驱动表（内层表）里查找满足条件的行，组成结果行\n\n要提升join语句的性能，就要尽可能减少嵌套循环的循环次数\n\n一个显著优化方式是对被驱动表的join字段建立索引，利用索引能快速匹配到对应的行，避免与内层表每一行记录做比较，极大地减少总循环次数。另一个优化点，就是连接时用小结果集驱动大结果集，在索引优化的基础上能进一步减少嵌套循环的次数\n\n如果难以判断哪个是大表，哪个是小表，可以用inner join连接，MySQL会自动选择**小表去驱动大表**\n\n关于Join语句使用，可以参考我之前的文章：[写出好的Join语句，前提你得懂这些](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect)\n\n**避免使用JOIN关联太多的表**\n\n对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由`join_buffer_size`参数进行设置\n\n在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大\n\n如果程序中大量的使用了多表关联的操作，同时`join_buffer_size`设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性\n\n## 排序优化\n\n**利用索引扫描做排序**\n\nMySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的\n\n但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢\n\n因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行\n\n例如：\n\n```sql\n--建立索引（date,staff_id,customer_id）\nselect staff_id, customer_id from test where date = '2010-01-01' order by staff_id,customer_id;\n```\n\n只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序\n\n## UNION优化\n\nMySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引\n\n最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化\n\n此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高\n\n## 慢查询日志\n\n出现慢查询通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 Explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理\n\n慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过`long_query_time`值的 SQL 将会被记录在日志中\n\n我们可以通过设置`“slow_query_log=1”`来开启慢查询\n\n需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能\n\n# 设计优化\n\n**尽量避免使用NULL**\n\nNULL在MySQL中不好处理，存储需要额外空间，运算也需要特殊的运算符，含有NULL的列很难进行查询优化\n\n应当指定列为not null，用0、空串或其他特殊的值代替空值，比如定义为int not null default 0\n\n**最小数据长度**\n\n越小的数据类型长度通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快\n\n**使用最简单数据类型**\n\n简单的数据类型操作代价更低，比如：能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高\n\n**尽量少定义 text 类型**\n\ntext 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率\n\n**适当分表、分库策略**\n\n分表是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率\n\n分库是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率\n\n## 常见类型选择\n\n**整数类型宽度设置**\n\nMySQL可以为整数类型指定宽度，例如int(11)，实际上并没有意义，它并不会限制值的范围，对于存储和计算来说，int(1)和int(20)是相同的\n\n**VARCHAR和CHAR类型**\n\nchar类型是定长的，而varchar存储可变字符串，比定长更省空间，但是varchar需要额外1或2个字节记录字符串长度，更新时也容易产生碎片\n\n需要结合使用场景来选择：如果字符串列最大长度比平均长度大很多，或者列的更新很少，选择varchar较合适；如果要存很短的字符串，或者字符串值长度都相同，比如MD5值，或者列数据经常变更，选择使用char类型\n\n**DATETIME和TIMESTAMP类型**\n\ndatetime的范围更大，能表示从1001到9999年，timestamp只能表示从1970年到2038年。datetime与时区无关，timestamp显示值依赖于时区。在大多数场景下，这两种类型都能良好地工作，但是建议使用timestamp，因为datetime占用8个字节，timestamp只占用了4个字节，timestamp空间效率更高\n\n**BLOB和TEXT类型**\n\nblob和text都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储\n\n在实际使用中，要慎用这两种类型，它们的查询效率很低，如果字段必须要使用这两种类型，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率\n\n## 范式化\n\n当数据较好范式化时，修改的数据更少，而且范式化的表通常要小，可以有更多的数据缓存在内存中，所以执行操作会更快\n\n缺点则是查询时需要更多的关联\n\n第一范式：字段不可分割，数据库默认支持\n\n第二范式：消除对主键的部分依赖，可以在表中加上一个与业务逻辑无关的字段作为主键，比如用自增id\n\n第三范式：消除对主键的传递依赖，可以将表拆分，减少数据冗余\n\n# 硬件优化\n\nMySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存\n\n**磁盘**\n\n磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率\n\n磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样\n\n**网络**\n\n保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率\n\n**内存**\n\nMySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n公众号后台回复666，可以获得免费电子书籍\n\n参考资料：\n\n- 《高性能MySQL》\n- 《MySQL技术内幕：InnodDB存储引擎》","source":"_posts/公众号文章/MySQL优化.md","raw":"---\ntitle: MySQL优化\ncategories: \n- 公众号文章\n---\n\n# 前言\n\n面试题来自：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect)\n\n**MySQL常见的优化手段分为下面几个方面：**\n\nSQL优化、设计优化，硬件优化等，其中每个大的方向中又包含多个小的优化点\n\n![图片](https://mmbiz.qpic.cn/mmbiz_png/hC3oNAJqSRyHzQFLFcTsrVbcYguC9bVrFxWgMe5HPnMqoXwEBbPFPl3o1aBakiahmoD4Q1lZqphbiamncOKK4ZUA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)\n\n下面我们具体来看看\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n- 公众号后台回复666，可以获得免费电子书籍\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n# SQL优化\n\n此优化方案指的是通过优化 SQL 语句以及索引来提高 MySQL 数据库的运行效率，具体内容如下：\n\n## 分页优化\n\n例如：\n\n```sql\nselect * from table where type = 2 and level = 9 order by id asc limit 190289,10;\n```\n\n优化方案：\n\n- 延迟关联\n\n  先通过where条件提取出主键，在将该表与原数据表关联，通过主键id提取数据行，而不是通过原来的二级索引提取数据行\n\n  例如：\n\n```sql\nselect a.* from table a, (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b where a.id = b.id\n```\n\n- 书签方式\n\n  书签方式说白了就是找到limit第一个参数对应的主键值，再根据这个主键值再去过滤并limit\n\n  例如：\n\n```sql\nselect * from table where id > (select * from table where type = 2 and level = 9 order by id asc limit 190289, 1) limit 10;\n```\n\n## 索引优化\n\n**正确使用索引**\n\n假如我们没有添加索引，那么在查询时就会触发全表扫描，因此查询的数据就会很多，并且查询效率会很低，为了提高查询的性能，我们就需要给最常使用的查询字段上，添加相应的索引，这样才能提高查询的性能\n\n> 建立覆盖索引\n\nInnoDB使用辅助索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引\n\n例如对于如下查询：\n\n```sql\nselect name from test where city='上海'\n```\n\n我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取\n\n```sql\nalter table test add index idx_city_name (city, name);\n```\n\n> 在 MySQL 5.0 之前的版本尽量避免使用or查询\n\n在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，在 MySQL 5.0 之后的版本中引入了索引合并\n\n索引合并简单来说就是把多条件查询，比如or或and查询对多个索引分别进行条件扫描，然后将它们各自的结果进行合并，因此就不会导致索引失效的问题了\n\n如果从Explain执行计划的type列的值是`index_merge`可以看出MySQL使用索引合并的方式来执行对表的查询\n\n关于Explain的使用可以参考我之前的文章：[最完整的Explain总结，SQL优化不再困难](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect)\n\n> 避免在 where 查询条件中使用 != 或者 <> 操作符\n\nSQL中，不等于操作符会导致查询引擎放弃索引索引，引起全表扫描，即使比较的字段上有索引\n\n解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描\n\n例如，把`column<>’aaa’，改成column>’aaa’ or column<’aaa’`，就可以使用索引了\n\n> 适当使用前缀索引\n\nMySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引\n\n我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率\n\n比如，邮箱的后缀都是固定的“`@xxx.com`”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引\n\n```\nalter table test add index index2(email(6));\n```\n\n使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本\n\n需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引\n\n> 查询具体的字段而非全部字段\n\n要尽量避免使用`select *`，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力\n\n> 优化子查询\n\n尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大\n\n关于Join语句使用，可以参考我之前的文章：[写出好的Join语句，前提你得懂这些](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect)\n\n> 小表驱动大表\n\n我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：\n\n```\nselect name from A where id in (select id from B);\n```\n\n> 不要在列上进行运算操作\n\n不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率\n\n```sql\nselect * from test where id + 1 = 50;\nselect * from test where month(updateTime) = 7;\n```\n\n一个很容易踩的坑：隐式类型转换：\n\n```sql\nselect * from test where skuId=123456\n```\n\nskuId这个字段上有索引，但是explain的结果却显示这条语句会全表扫描\n\n原因在于skuId的字符类型是varchar(32)，比较值却是整型，故需要做类型转换\n\n**适当增加冗余字段**\n\n增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略\n\n**正确使用联合索引**\n\n使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序\n\n例如，我们创建了一个联合索引是`idx(name,age,sex)`，那么当我们使用，姓名+年龄+性别、姓名+年龄、姓名等这种最左前缀查询条件时，就会触发联合索引进行查询；然而如果非最左匹配的查询条件，例如，性别+姓名这种查询条件就不会触发联合索引\n\n## Join优化\n\nMySQL的join语句连接表使用的是nested-loop join算法，这个过程类似于嵌套循环，简单来说，就是遍历驱动表（外层表），每读出一行数据，取出连接字段到被驱动表（内层表）里查找满足条件的行，组成结果行\n\n要提升join语句的性能，就要尽可能减少嵌套循环的循环次数\n\n一个显著优化方式是对被驱动表的join字段建立索引，利用索引能快速匹配到对应的行，避免与内层表每一行记录做比较，极大地减少总循环次数。另一个优化点，就是连接时用小结果集驱动大结果集，在索引优化的基础上能进一步减少嵌套循环的次数\n\n如果难以判断哪个是大表，哪个是小表，可以用inner join连接，MySQL会自动选择**小表去驱动大表**\n\n关于Join语句使用，可以参考我之前的文章：[写出好的Join语句，前提你得懂这些](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect)\n\n**避免使用JOIN关联太多的表**\n\n对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由`join_buffer_size`参数进行设置\n\n在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大\n\n如果程序中大量的使用了多表关联的操作，同时`join_buffer_size`设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性\n\n## 排序优化\n\n**利用索引扫描做排序**\n\nMySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的\n\n但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢\n\n因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行\n\n例如：\n\n```sql\n--建立索引（date,staff_id,customer_id）\nselect staff_id, customer_id from test where date = '2010-01-01' order by staff_id,customer_id;\n```\n\n只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序\n\n## UNION优化\n\nMySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引\n\n最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化\n\n此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高\n\n## 慢查询日志\n\n出现慢查询通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 Explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理\n\n慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过`long_query_time`值的 SQL 将会被记录在日志中\n\n我们可以通过设置`“slow_query_log=1”`来开启慢查询\n\n需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能\n\n# 设计优化\n\n**尽量避免使用NULL**\n\nNULL在MySQL中不好处理，存储需要额外空间，运算也需要特殊的运算符，含有NULL的列很难进行查询优化\n\n应当指定列为not null，用0、空串或其他特殊的值代替空值，比如定义为int not null default 0\n\n**最小数据长度**\n\n越小的数据类型长度通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快\n\n**使用最简单数据类型**\n\n简单的数据类型操作代价更低，比如：能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高\n\n**尽量少定义 text 类型**\n\ntext 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率\n\n**适当分表、分库策略**\n\n分表是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率\n\n分库是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率\n\n## 常见类型选择\n\n**整数类型宽度设置**\n\nMySQL可以为整数类型指定宽度，例如int(11)，实际上并没有意义，它并不会限制值的范围，对于存储和计算来说，int(1)和int(20)是相同的\n\n**VARCHAR和CHAR类型**\n\nchar类型是定长的，而varchar存储可变字符串，比定长更省空间，但是varchar需要额外1或2个字节记录字符串长度，更新时也容易产生碎片\n\n需要结合使用场景来选择：如果字符串列最大长度比平均长度大很多，或者列的更新很少，选择varchar较合适；如果要存很短的字符串，或者字符串值长度都相同，比如MD5值，或者列数据经常变更，选择使用char类型\n\n**DATETIME和TIMESTAMP类型**\n\ndatetime的范围更大，能表示从1001到9999年，timestamp只能表示从1970年到2038年。datetime与时区无关，timestamp显示值依赖于时区。在大多数场景下，这两种类型都能良好地工作，但是建议使用timestamp，因为datetime占用8个字节，timestamp只占用了4个字节，timestamp空间效率更高\n\n**BLOB和TEXT类型**\n\nblob和text都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储\n\n在实际使用中，要慎用这两种类型，它们的查询效率很低，如果字段必须要使用这两种类型，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率\n\n## 范式化\n\n当数据较好范式化时，修改的数据更少，而且范式化的表通常要小，可以有更多的数据缓存在内存中，所以执行操作会更快\n\n缺点则是查询时需要更多的关联\n\n第一范式：字段不可分割，数据库默认支持\n\n第二范式：消除对主键的部分依赖，可以在表中加上一个与业务逻辑无关的字段作为主键，比如用自增id\n\n第三范式：消除对主键的传递依赖，可以将表拆分，减少数据冗余\n\n# 硬件优化\n\nMySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存\n\n**磁盘**\n\n磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I/O 运行的时间，从而提高了 MySQL 整体的运行效率\n\n磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样\n\n**网络**\n\n保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率\n\n**内存**\n\nMySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n公众号后台回复666，可以获得免费电子书籍\n\n参考资料：\n\n- 《高性能MySQL》\n- 《MySQL技术内幕：InnodDB存储引擎》","slug":"公众号文章/MySQL优化","published":1,"date":"2022-02-24T01:40:06.233Z","updated":"2022-02-24T01:43:10.331Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiu00ewfhji4x0gbiqd","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>面试题来自：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></p>\n<p><strong>MySQL常见的优化手段分为下面几个方面：</strong></p>\n<p>SQL优化、设计优化，硬件优化等，其中每个大的方向中又包含多个小的优化点</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/hC3oNAJqSRyHzQFLFcTsrVbcYguC9bVrFxWgMe5HPnMqoXwEBbPFPl3o1aBakiahmoD4Q1lZqphbiamncOKK4ZUA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>下面我们具体来看看</p>\n<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<h1 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h1><p>此优化方案指的是通过优化 SQL 语句以及索引来提高 MySQL 数据库的运行效率，具体内容如下：</p>\n<h2 id=\"分页优化\"><a href=\"#分页优化\" class=\"headerlink\" title=\"分页优化\"></a>分页优化</h2><p>例如：</p>\n<pre><code class=\"sql\">select * from table where type = 2 and level = 9 order by id asc limit 190289,10;\n</code></pre>\n<p>优化方案：</p>\n<ul>\n<li><p>延迟关联</p>\n<p>先通过where条件提取出主键，在将该表与原数据表关联，通过主键id提取数据行，而不是通过原来的二级索引提取数据行</p>\n<p>例如：</p>\n</li>\n</ul>\n<pre><code class=\"sql\">select a.* from table a, (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b where a.id = b.id\n</code></pre>\n<ul>\n<li><p>书签方式</p>\n<p>书签方式说白了就是找到limit第一个参数对应的主键值，再根据这个主键值再去过滤并limit</p>\n<p>例如：</p>\n</li>\n</ul>\n<pre><code class=\"sql\">select * from table where id &gt; (select * from table where type = 2 and level = 9 order by id asc limit 190289, 1) limit 10;\n</code></pre>\n<h2 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h2><p><strong>正确使用索引</strong></p>\n<p>假如我们没有添加索引，那么在查询时就会触发全表扫描，因此查询的数据就会很多，并且查询效率会很低，为了提高查询的性能，我们就需要给最常使用的查询字段上，添加相应的索引，这样才能提高查询的性能</p>\n<blockquote>\n<p>建立覆盖索引</p>\n</blockquote>\n<p>InnoDB使用辅助索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p>\n<p>例如对于如下查询：</p>\n<pre><code class=\"sql\">select name from test where city=&#39;上海&#39;\n</code></pre>\n<p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取</p>\n<pre><code class=\"sql\">alter table test add index idx_city_name (city, name);\n</code></pre>\n<blockquote>\n<p>在 MySQL 5.0 之前的版本尽量避免使用or查询</p>\n</blockquote>\n<p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，在 MySQL 5.0 之后的版本中引入了索引合并</p>\n<p>索引合并简单来说就是把多条件查询，比如or或and查询对多个索引分别进行条件扫描，然后将它们各自的结果进行合并，因此就不会导致索引失效的问题了</p>\n<p>如果从Explain执行计划的type列的值是<code>index_merge</code>可以看出MySQL使用索引合并的方式来执行对表的查询</p>\n<p>关于Explain的使用可以参考我之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect\">最完整的Explain总结，SQL优化不再困难</a></p>\n<blockquote>\n<p>避免在 where 查询条件中使用 !&#x3D; 或者 &lt;&gt; 操作符</p>\n</blockquote>\n<p>SQL中，不等于操作符会导致查询引擎放弃索引索引，引起全表扫描，即使比较的字段上有索引</p>\n<p>解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描</p>\n<p>例如，把<code>column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’</code>，就可以使用索引了</p>\n<blockquote>\n<p>适当使用前缀索引</p>\n</blockquote>\n<p>MySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引</p>\n<p>我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率</p>\n<p>比如，邮箱的后缀都是固定的“<code>@xxx.com</code>”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p>\n<pre><code>alter table test add index index2(email(6));\n</code></pre>\n<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</p>\n<p>需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引</p>\n<blockquote>\n<p>查询具体的字段而非全部字段</p>\n</blockquote>\n<p>要尽量避免使用<code>select *</code>，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力</p>\n<blockquote>\n<p>优化子查询</p>\n</blockquote>\n<p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p>\n<p>关于Join语句使用，可以参考我之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect\">写出好的Join语句，前提你得懂这些</a></p>\n<blockquote>\n<p>小表驱动大表</p>\n</blockquote>\n<p>我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：</p>\n<pre><code>select name from A where id in (select id from B);\n</code></pre>\n<blockquote>\n<p>不要在列上进行运算操作</p>\n</blockquote>\n<p>不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率</p>\n<pre><code class=\"sql\">select * from test where id + 1 = 50;\nselect * from test where month(updateTime) = 7;\n</code></pre>\n<p>一个很容易踩的坑：隐式类型转换：</p>\n<pre><code class=\"sql\">select * from test where skuId=123456\n</code></pre>\n<p>skuId这个字段上有索引，但是explain的结果却显示这条语句会全表扫描</p>\n<p>原因在于skuId的字符类型是varchar(32)，比较值却是整型，故需要做类型转换</p>\n<p><strong>适当增加冗余字段</strong></p>\n<p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p>\n<p><strong>正确使用联合索引</strong></p>\n<p>使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序</p>\n<p>例如，我们创建了一个联合索引是<code>idx(name,age,sex)</code>，那么当我们使用，姓名+年龄+性别、姓名+年龄、姓名等这种最左前缀查询条件时，就会触发联合索引进行查询；然而如果非最左匹配的查询条件，例如，性别+姓名这种查询条件就不会触发联合索引</p>\n<h2 id=\"Join优化\"><a href=\"#Join优化\" class=\"headerlink\" title=\"Join优化\"></a>Join优化</h2><p>MySQL的join语句连接表使用的是nested-loop join算法，这个过程类似于嵌套循环，简单来说，就是遍历驱动表（外层表），每读出一行数据，取出连接字段到被驱动表（内层表）里查找满足条件的行，组成结果行</p>\n<p>要提升join语句的性能，就要尽可能减少嵌套循环的循环次数</p>\n<p>一个显著优化方式是对被驱动表的join字段建立索引，利用索引能快速匹配到对应的行，避免与内层表每一行记录做比较，极大地减少总循环次数。另一个优化点，就是连接时用小结果集驱动大结果集，在索引优化的基础上能进一步减少嵌套循环的次数</p>\n<p>如果难以判断哪个是大表，哪个是小表，可以用inner join连接，MySQL会自动选择<strong>小表去驱动大表</strong></p>\n<p>关于Join语句使用，可以参考我之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect\">写出好的Join语句，前提你得懂这些</a></p>\n<p><strong>避免使用JOIN关联太多的表</strong></p>\n<p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由<code>join_buffer_size</code>参数进行设置</p>\n<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大</p>\n<p>如果程序中大量的使用了多表关联的操作，同时<code>join_buffer_size</code>设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性</p>\n<h2 id=\"排序优化\"><a href=\"#排序优化\" class=\"headerlink\" title=\"排序优化\"></a>排序优化</h2><p><strong>利用索引扫描做排序</strong></p>\n<p>MySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p>\n<p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢</p>\n<p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p>\n<p>例如：</p>\n<pre><code class=\"sql\">--建立索引（date,staff_id,customer_id）\nselect staff_id, customer_id from test where date = &#39;2010-01-01&#39; order by staff_id,customer_id;\n</code></pre>\n<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p>\n<h2 id=\"UNION优化\"><a href=\"#UNION优化\" class=\"headerlink\" title=\"UNION优化\"></a>UNION优化</h2><p>MySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引</p>\n<p>最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化</p>\n<p>此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高</p>\n<h2 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h2><p>出现慢查询通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 Explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理</p>\n<p>慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过<code>long_query_time</code>值的 SQL 将会被记录在日志中</p>\n<p>我们可以通过设置<code>“slow_query_log=1”</code>来开启慢查询</p>\n<p>需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能</p>\n<h1 id=\"设计优化\"><a href=\"#设计优化\" class=\"headerlink\" title=\"设计优化\"></a>设计优化</h1><p><strong>尽量避免使用NULL</strong></p>\n<p>NULL在MySQL中不好处理，存储需要额外空间，运算也需要特殊的运算符，含有NULL的列很难进行查询优化</p>\n<p>应当指定列为not null，用0、空串或其他特殊的值代替空值，比如定义为int not null default 0</p>\n<p><strong>最小数据长度</strong></p>\n<p>越小的数据类型长度通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快</p>\n<p><strong>使用最简单数据类型</strong></p>\n<p>简单的数据类型操作代价更低，比如：能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高</p>\n<p><strong>尽量少定义 text 类型</strong></p>\n<p>text 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率</p>\n<p><strong>适当分表、分库策略</strong></p>\n<p>分表是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率</p>\n<p>分库是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率</p>\n<h2 id=\"常见类型选择\"><a href=\"#常见类型选择\" class=\"headerlink\" title=\"常见类型选择\"></a>常见类型选择</h2><p><strong>整数类型宽度设置</strong></p>\n<p>MySQL可以为整数类型指定宽度，例如int(11)，实际上并没有意义，它并不会限制值的范围，对于存储和计算来说，int(1)和int(20)是相同的</p>\n<p><strong>VARCHAR和CHAR类型</strong></p>\n<p>char类型是定长的，而varchar存储可变字符串，比定长更省空间，但是varchar需要额外1或2个字节记录字符串长度，更新时也容易产生碎片</p>\n<p>需要结合使用场景来选择：如果字符串列最大长度比平均长度大很多，或者列的更新很少，选择varchar较合适；如果要存很短的字符串，或者字符串值长度都相同，比如MD5值，或者列数据经常变更，选择使用char类型</p>\n<p><strong>DATETIME和TIMESTAMP类型</strong></p>\n<p>datetime的范围更大，能表示从1001到9999年，timestamp只能表示从1970年到2038年。datetime与时区无关，timestamp显示值依赖于时区。在大多数场景下，这两种类型都能良好地工作，但是建议使用timestamp，因为datetime占用8个字节，timestamp只占用了4个字节，timestamp空间效率更高</p>\n<p><strong>BLOB和TEXT类型</strong></p>\n<p>blob和text都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储</p>\n<p>在实际使用中，要慎用这两种类型，它们的查询效率很低，如果字段必须要使用这两种类型，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率</p>\n<h2 id=\"范式化\"><a href=\"#范式化\" class=\"headerlink\" title=\"范式化\"></a>范式化</h2><p>当数据较好范式化时，修改的数据更少，而且范式化的表通常要小，可以有更多的数据缓存在内存中，所以执行操作会更快</p>\n<p>缺点则是查询时需要更多的关联</p>\n<p>第一范式：字段不可分割，数据库默认支持</p>\n<p>第二范式：消除对主键的部分依赖，可以在表中加上一个与业务逻辑无关的字段作为主键，比如用自增id</p>\n<p>第三范式：消除对主键的传递依赖，可以将表拆分，减少数据冗余</p>\n<h1 id=\"硬件优化\"><a href=\"#硬件优化\" class=\"headerlink\" title=\"硬件优化\"></a>硬件优化</h1><p>MySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存</p>\n<p><strong>磁盘</strong></p>\n<p>磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I&#x2F;O 运行的时间，从而提高了 MySQL 整体的运行效率</p>\n<p>磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样</p>\n<p><strong>网络</strong></p>\n<p>保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率</p>\n<p><strong>内存</strong></p>\n<p>MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n<p>参考资料：</p>\n<ul>\n<li>《高性能MySQL》</li>\n<li>《MySQL技术内幕：InnodDB存储引擎》</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>面试题来自：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></p>\n<p><strong>MySQL常见的优化手段分为下面几个方面：</strong></p>\n<p>SQL优化、设计优化，硬件优化等，其中每个大的方向中又包含多个小的优化点</p>\n<p><img src=\"https://mmbiz.qpic.cn/mmbiz_png/hC3oNAJqSRyHzQFLFcTsrVbcYguC9bVrFxWgMe5HPnMqoXwEBbPFPl3o1aBakiahmoD4Q1lZqphbiamncOKK4ZUA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1\" alt=\"图片\"></p>\n<p>下面我们具体来看看</p>\n<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<h1 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h1><p>此优化方案指的是通过优化 SQL 语句以及索引来提高 MySQL 数据库的运行效率，具体内容如下：</p>\n<h2 id=\"分页优化\"><a href=\"#分页优化\" class=\"headerlink\" title=\"分页优化\"></a>分页优化</h2><p>例如：</p>\n<pre><code class=\"sql\">select * from table where type = 2 and level = 9 order by id asc limit 190289,10;\n</code></pre>\n<p>优化方案：</p>\n<ul>\n<li><p>延迟关联</p>\n<p>先通过where条件提取出主键，在将该表与原数据表关联，通过主键id提取数据行，而不是通过原来的二级索引提取数据行</p>\n<p>例如：</p>\n</li>\n</ul>\n<pre><code class=\"sql\">select a.* from table a, (select id from table where type = 2 and level = 9 order by id asc limit 190289,10 ) b where a.id = b.id\n</code></pre>\n<ul>\n<li><p>书签方式</p>\n<p>书签方式说白了就是找到limit第一个参数对应的主键值，再根据这个主键值再去过滤并limit</p>\n<p>例如：</p>\n</li>\n</ul>\n<pre><code class=\"sql\">select * from table where id &gt; (select * from table where type = 2 and level = 9 order by id asc limit 190289, 1) limit 10;\n</code></pre>\n<h2 id=\"索引优化\"><a href=\"#索引优化\" class=\"headerlink\" title=\"索引优化\"></a>索引优化</h2><p><strong>正确使用索引</strong></p>\n<p>假如我们没有添加索引，那么在查询时就会触发全表扫描，因此查询的数据就会很多，并且查询效率会很低，为了提高查询的性能，我们就需要给最常使用的查询字段上，添加相应的索引，这样才能提高查询的性能</p>\n<blockquote>\n<p>建立覆盖索引</p>\n</blockquote>\n<p>InnoDB使用辅助索引查询数据时会回表，但是如果索引的叶节点中已经包含要查询的字段，那它没有必要再回表查询了，这就叫覆盖索引</p>\n<p>例如对于如下查询：</p>\n<pre><code class=\"sql\">select name from test where city=&#39;上海&#39;\n</code></pre>\n<p>我们将被查询的字段建立到联合索引中，这样查询结果就可以直接从索引中获取</p>\n<pre><code class=\"sql\">alter table test add index idx_city_name (city, name);\n</code></pre>\n<blockquote>\n<p>在 MySQL 5.0 之前的版本尽量避免使用or查询</p>\n</blockquote>\n<p>在 MySQL 5.0 之前的版本要尽量避免使用 or 查询，可以使用 union 或者子查询来替代，因为早期的 MySQL 版本使用 or 查询可能会导致索引失效，在 MySQL 5.0 之后的版本中引入了索引合并</p>\n<p>索引合并简单来说就是把多条件查询，比如or或and查询对多个索引分别进行条件扫描，然后将它们各自的结果进行合并，因此就不会导致索引失效的问题了</p>\n<p>如果从Explain执行计划的type列的值是<code>index_merge</code>可以看出MySQL使用索引合并的方式来执行对表的查询</p>\n<p>关于Explain的使用可以参考我之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect\">最完整的Explain总结，SQL优化不再困难</a></p>\n<blockquote>\n<p>避免在 where 查询条件中使用 !&#x3D; 或者 &lt;&gt; 操作符</p>\n</blockquote>\n<p>SQL中，不等于操作符会导致查询引擎放弃索引索引，引起全表扫描，即使比较的字段上有索引</p>\n<p>解决方法：通过把不等于操作符改成or，可以使用索引，避免全表扫描</p>\n<p>例如，把<code>column&lt;&gt;’aaa’，改成column&gt;’aaa’ or column&lt;’aaa’</code>，就可以使用索引了</p>\n<blockquote>\n<p>适当使用前缀索引</p>\n</blockquote>\n<p>MySQL 是支持前缀索引的，也就是说我们可以定义字符串的一部分来作为索引</p>\n<p>我们知道索引越长占用的磁盘空间就越大，那么在相同数据页中能放下的索引值也就越少，这就意味着搜索索引需要的查询时间也就越长，进而查询的效率就会降低，所以我们可以适当的选择使用前缀索引，以减少空间的占用和提高查询效率</p>\n<p>比如，邮箱的后缀都是固定的“<code>@xxx.com</code>”，那么类似这种后面几位为固定值的字段就非常适合定义为前缀索引</p>\n<pre><code>alter table test add index index2(email(6));\n</code></pre>\n<p>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本</p>\n<p>需要注意的是，前缀索引也存在缺点，MySQL无法利用前缀索引做order by和group by 操作，也无法作为覆盖索引</p>\n<blockquote>\n<p>查询具体的字段而非全部字段</p>\n</blockquote>\n<p>要尽量避免使用<code>select *</code>，而是查询需要的字段，这样可以提升速度，以及减少网络传输的带宽压力</p>\n<blockquote>\n<p>优化子查询</p>\n</blockquote>\n<p>尽量使用 Join 语句来替代子查询，因为子查询是嵌套查询，而嵌套查询会新创建一张临时表，而临时表的创建与销毁会占用一定的系统资源以及花费一定的时间，同时对于返回结果集比较大的子查询，其对查询性能的影响更大</p>\n<p>关于Join语句使用，可以参考我之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect\">写出好的Join语句，前提你得懂这些</a></p>\n<blockquote>\n<p>小表驱动大表</p>\n</blockquote>\n<p>我们要尽量使用小表驱动大表的方式进行查询，也就是如果 B 表的数据小于 A 表的数据，那执行的顺序就是先查 B 表再查 A 表，具体查询语句如下：</p>\n<pre><code>select name from A where id in (select id from B);\n</code></pre>\n<blockquote>\n<p>不要在列上进行运算操作</p>\n</blockquote>\n<p>不要在列字段上进行算术运算或其他表达式运算，否则可能会导致查询引擎无法正确使用索引，从而影响了查询的效率</p>\n<pre><code class=\"sql\">select * from test where id + 1 = 50;\nselect * from test where month(updateTime) = 7;\n</code></pre>\n<p>一个很容易踩的坑：隐式类型转换：</p>\n<pre><code class=\"sql\">select * from test where skuId=123456\n</code></pre>\n<p>skuId这个字段上有索引，但是explain的结果却显示这条语句会全表扫描</p>\n<p>原因在于skuId的字符类型是varchar(32)，比较值却是整型，故需要做类型转换</p>\n<p><strong>适当增加冗余字段</strong></p>\n<p>增加冗余字段可以减少大量的连表查询，因为多张表的连表查询性能很低，所有可以适当的增加冗余字段，以减少多张表的关联查询，这是以空间换时间的优化策略</p>\n<p><strong>正确使用联合索引</strong></p>\n<p>使用了 B+ 树的 MySQL 数据库引擎，比如 InnoDB 引擎，在每次查询复合字段时是从左往右匹配数据的，因此在创建联合索引的时候需要注意索引创建的顺序</p>\n<p>例如，我们创建了一个联合索引是<code>idx(name,age,sex)</code>，那么当我们使用，姓名+年龄+性别、姓名+年龄、姓名等这种最左前缀查询条件时，就会触发联合索引进行查询；然而如果非最左匹配的查询条件，例如，性别+姓名这种查询条件就不会触发联合索引</p>\n<h2 id=\"Join优化\"><a href=\"#Join优化\" class=\"headerlink\" title=\"Join优化\"></a>Join优化</h2><p>MySQL的join语句连接表使用的是nested-loop join算法，这个过程类似于嵌套循环，简单来说，就是遍历驱动表（外层表），每读出一行数据，取出连接字段到被驱动表（内层表）里查找满足条件的行，组成结果行</p>\n<p>要提升join语句的性能，就要尽可能减少嵌套循环的循环次数</p>\n<p>一个显著优化方式是对被驱动表的join字段建立索引，利用索引能快速匹配到对应的行，避免与内层表每一行记录做比较，极大地减少总循环次数。另一个优化点，就是连接时用小结果集驱动大结果集，在索引优化的基础上能进一步减少嵌套循环的次数</p>\n<p>如果难以判断哪个是大表，哪个是小表，可以用inner join连接，MySQL会自动选择<strong>小表去驱动大表</strong></p>\n<p>关于Join语句使用，可以参考我之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484851&idx=1&sn=47dd680db2a74cd0c04332ad6a3b8f12&scene=21#wechat_redirect\">写出好的Join语句，前提你得懂这些</a></p>\n<p><strong>避免使用JOIN关联太多的表</strong></p>\n<p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由<code>join_buffer_size</code>参数进行设置</p>\n<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大</p>\n<p>如果程序中大量的使用了多表关联的操作，同时<code>join_buffer_size</code>设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性</p>\n<h2 id=\"排序优化\"><a href=\"#排序优化\" class=\"headerlink\" title=\"排序优化\"></a>排序优化</h2><p><strong>利用索引扫描做排序</strong></p>\n<p>MySQL有两种方式生成有序结果：其一是对结果集进行排序的操作，其二是按照索引顺序扫描得出的结果自然是有序的</p>\n<p>但是如果索引不能覆盖查询所需列，就不得不每扫描一条记录回表查询一次，这个读操作是随机IO，通常会比顺序全表扫描还慢</p>\n<p>因此，在设计索引时，尽可能使用同一个索引既满足排序又用于查找行</p>\n<p>例如：</p>\n<pre><code class=\"sql\">--建立索引（date,staff_id,customer_id）\nselect staff_id, customer_id from test where date = &#39;2010-01-01&#39; order by staff_id,customer_id;\n</code></pre>\n<p>只有当索引的列顺序和ORDER BY子句的顺序完全一致，并且所有列的排序方向都一样时，才能够使用索引来对结果做排序</p>\n<h2 id=\"UNION优化\"><a href=\"#UNION优化\" class=\"headerlink\" title=\"UNION优化\"></a>UNION优化</h2><p>MySQL处理union的策略是先创建临时表，然后将各个查询结果填充到临时表中最后再来做查询，很多优化策略在union查询中都会失效，因为它无法利用索引</p>\n<p>最好手工将where、limit等子句下推到union的各个子查询中，以便优化器可以充分利用这些条件进行优化</p>\n<p>此外，除非确实需要服务器去重，一定要使用union all，如果不加all关键字，MySQL会给临时表加上distinct选项，这会导致对整个临时表做唯一性检查，代价很高</p>\n<h2 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h2><p>出现慢查询通常的排查手段是先使用慢查询日志功能，查询出比较慢的 SQL 语句，然后再通过 Explain 来查询 SQL 语句的执行计划，最后分析并定位出问题的根源，再进行处理</p>\n<p>慢查询日志指的是在 MySQL 中可以通过配置来开启慢查询日志的记录功能，超过<code>long_query_time</code>值的 SQL 将会被记录在日志中</p>\n<p>我们可以通过设置<code>“slow_query_log=1”</code>来开启慢查询</p>\n<p>需要注意的是，在开启慢日志功能之后，会对 MySQL 的性能造成一定的影响，因此在生产环境中要慎用此功能</p>\n<h1 id=\"设计优化\"><a href=\"#设计优化\" class=\"headerlink\" title=\"设计优化\"></a>设计优化</h1><p><strong>尽量避免使用NULL</strong></p>\n<p>NULL在MySQL中不好处理，存储需要额外空间，运算也需要特殊的运算符，含有NULL的列很难进行查询优化</p>\n<p>应当指定列为not null，用0、空串或其他特殊的值代替空值，比如定义为int not null default 0</p>\n<p><strong>最小数据长度</strong></p>\n<p>越小的数据类型长度通常在磁盘、内存和CPU缓存中都需要更少的空间，处理起来更快</p>\n<p><strong>使用最简单数据类型</strong></p>\n<p>简单的数据类型操作代价更低，比如：能使用 int 类型就不要使用 varchar 类型，因为 int 类型比 varchar 类型的查询效率更高</p>\n<p><strong>尽量少定义 text 类型</strong></p>\n<p>text 类型的查询效率很低，如果必须要使用 text 定义字段，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率</p>\n<p><strong>适当分表、分库策略</strong></p>\n<p>分表是指当一张表中的字段更多时，可以尝试将一张大表拆分为多张子表，把使用比较高频的主信息放入主表中，其他的放入子表，这样我们大部分查询只需要查询字段更少的主表就可以完成了，从而有效的提高了查询的效率</p>\n<p>分库是指将一个数据库分为多个数据库。比如我们把一个数据库拆分为了多个数据库，一个主数据库用于写入和修改数据，其他的用于同步主数据并提供给客户端查询，这样就把一个库的读和写的压力，分摊给了多个库，从而提高了数据库整体的运行效率</p>\n<h2 id=\"常见类型选择\"><a href=\"#常见类型选择\" class=\"headerlink\" title=\"常见类型选择\"></a>常见类型选择</h2><p><strong>整数类型宽度设置</strong></p>\n<p>MySQL可以为整数类型指定宽度，例如int(11)，实际上并没有意义，它并不会限制值的范围，对于存储和计算来说，int(1)和int(20)是相同的</p>\n<p><strong>VARCHAR和CHAR类型</strong></p>\n<p>char类型是定长的，而varchar存储可变字符串，比定长更省空间，但是varchar需要额外1或2个字节记录字符串长度，更新时也容易产生碎片</p>\n<p>需要结合使用场景来选择：如果字符串列最大长度比平均长度大很多，或者列的更新很少，选择varchar较合适；如果要存很短的字符串，或者字符串值长度都相同，比如MD5值，或者列数据经常变更，选择使用char类型</p>\n<p><strong>DATETIME和TIMESTAMP类型</strong></p>\n<p>datetime的范围更大，能表示从1001到9999年，timestamp只能表示从1970年到2038年。datetime与时区无关，timestamp显示值依赖于时区。在大多数场景下，这两种类型都能良好地工作，但是建议使用timestamp，因为datetime占用8个字节，timestamp只占用了4个字节，timestamp空间效率更高</p>\n<p><strong>BLOB和TEXT类型</strong></p>\n<p>blob和text都是为存储很大数据而设计的字符串数据类型，分别采用二进制和字符方式存储</p>\n<p>在实际使用中，要慎用这两种类型，它们的查询效率很低，如果字段必须要使用这两种类型，可以把此字段分离成子表，需要查询此字段时使用联合查询，这样可以提高主表的查询效率</p>\n<h2 id=\"范式化\"><a href=\"#范式化\" class=\"headerlink\" title=\"范式化\"></a>范式化</h2><p>当数据较好范式化时，修改的数据更少，而且范式化的表通常要小，可以有更多的数据缓存在内存中，所以执行操作会更快</p>\n<p>缺点则是查询时需要更多的关联</p>\n<p>第一范式：字段不可分割，数据库默认支持</p>\n<p>第二范式：消除对主键的部分依赖，可以在表中加上一个与业务逻辑无关的字段作为主键，比如用自增id</p>\n<p>第三范式：消除对主键的传递依赖，可以将表拆分，减少数据冗余</p>\n<h1 id=\"硬件优化\"><a href=\"#硬件优化\" class=\"headerlink\" title=\"硬件优化\"></a>硬件优化</h1><p>MySQL 对硬件的要求主要体现在三个方面：磁盘、网络和内存</p>\n<p><strong>磁盘</strong></p>\n<p>磁盘应该尽量使用有高性能读写能力的磁盘，比如固态硬盘，这样就可以减少 I&#x2F;O 运行的时间，从而提高了 MySQL 整体的运行效率</p>\n<p>磁盘也可以尽量使用多个小磁盘而不是一个大磁盘，因为磁盘的转速是固定的，有多个小磁盘就相当于拥有多个并行运行的磁盘一样</p>\n<p><strong>网络</strong></p>\n<p>保证网络带宽的通畅（低延迟）以及够大的网络带宽是 MySQL 正常运行的基本条件，如果条件允许的话也可以设置多个网卡，以提高网络高峰期 MySQL 服务器的运行效率</p>\n<p><strong>内存</strong></p>\n<p>MySQL 服务器的内存越大，那么存储和缓存的信息也就越多，而内存的性能是非常高的，从而提高了整个 MySQL 的运行效率</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n<p>参考资料：</p>\n<ul>\n<li>《高性能MySQL》</li>\n<li>《MySQL技术内幕：InnodDB存储引擎》</li>\n</ul>\n"},{"title":"Spring设计模式","_content":"\n# 前言\n\n前几天，一位**读者面阿里**被问到一个问题：Spring框架用到了哪些设计模式？，答的不是很好，于是打算写篇文章讲讲这个！\n\n* 文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n* 面经：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s/SOErvCCrmPaAVUphSO2Wqw)\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n# 代理模式\n\n所谓代理，是指它与被代理对象实现了相同的接口，客户端必须通过代理才能与被代理的目标类进行交互，而代理一般在交互的过程中（交互前后），进行某些特定的处理，比如在调用这个方法前做前置处理，调用这个方法后做后置处理。\n\n代理又分为静态代理和动态代理两种方式，Spring的AOP采用的是动态代理的方式\n\nSpring通过动态代理对类进行方法级别的切面增强，动态生成目标对象的代理类，并在代理类的方法中设置拦截器，通过执行拦截器中的逻辑增强了代理方法的功能，从而实现AOP。\n\n**关于动态代理可以看我之前的文章，写的很详细**：[动态代理总结，你要知道的都在这里，无废话！](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485541&idx=1&sn=371e92596b8e7ba47019b15767b18873&scene=21#wechat_redirect)\n\n# 策略模式\n\n我们前面讲到，Spring AOP是通过动态代理来实现的。\n\n具体到代码实现，Spring支持两种动态代理实现方式，一种是JDK提供的动态代理实现方式，另一种是Cglib提供的动态代理实现方式。\n\nSpring会在运行时动态地选择不同的动态代理实现方式。**这个应用场景实际上就是策略模式的典型应用场景。**\n\n我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到Spring源码，AopProxy是策略接口，JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类。\n\n**其中，AopProxy接口的定义如下所示：**\n\n![](https://img-blog.csdnimg.cn/d0266b32cacf4d8a9d4b47811b25730e.png)\n\n在策略模式中，策略的创建一般通过工厂方法来实现。对应到Spring源码，AopProxyFactory是一个工厂类接口，DefaultAopProxyFactory是一个默认的工厂类，用来创建AopProxy对象。\n\n源码如下所示：\n\n![](https://img-blog.csdnimg.cn/9eb06c1cf175456b9c2f56f7d78ff8a8.png)\n\n策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。\n\n对应到Spring源码中，我们可以参看刚刚给出的DefaultAopProxyFactory类中的createAopProxy()函数的代码实现。\n\n**其中，第10行代码是动态选择哪种策略的判断条件。**\n\n# 装饰器模式\n\n我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。\n\n为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。\n\n**实现这样一个功能，Spring使用到了装饰器模式。**\n\nTransactionAwareCacheDecorator增加了对事务的支持，在事务提交、回滚的时候分别对Cache的数据进行处理。\n\nTransactionAwareCacheDecorator实现Cache接口，并且将所有的操作都委托给targetCache来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现。\n\n![](https://img-blog.csdnimg.cn/0512c704ef2a48948122aeaa55935038.png)\n\n# 单例模式\n\n单例模式是指一个类在整个系统运行过程中，只允许产生一个实例\n\n在Spring中，Bean可以被定义为两种模式：Prototype（多例）和Singleton（单例），Spring Bean默认是单例模式。\n\n**那Spring是如何实现单例模式的呢？**\n\n答案是通过单例注册表的方式，具体来说就是使用了HashMap。简化代码如下：\n\n```java\npublic class DefaultSingletonBeanRegistry {\n    \n    //使用了线程安全容器ConcurrentHashMap，保存各种单实例对象\n    private final Map singletonObjects = new ConcurrentHashMap;\n\n    protected Object getSingleton(String beanName) {\n    //先到HashMap中拿Object\n    Object singletonObject = singletonObjects.get(beanName);\n    \n    //如果没拿到通过反射创建一个对象实例，并添加到HashMap中\n    if (singletonObject == null) {\n      singletonObjects.put(beanName,\n                           Class.forName(beanName).newInstance());\n   }\n   \n   //返回对象实例\n   return singletonObjects.get(beanName);\n  }\n}\n```\n\n上面的代码逻辑比较清晰，先到HashMap去拿单实例对象，没拿到就创建一个添加到HashMap。\n\n# 简单工厂模式\n\n**有这样一个场景：**\n\n当A对象需要调用B对象的方法时，我们需要在A中new一个B的实例，它的缺点是一旦需求发生变化，比如需要使用C类来代替B时，就要改写A类的方法。\n\n假如应用中有100个类以的方式耦合了B，那改起来就费劲了。\n\n**使用简单工厂模式：**\n\n简单工厂模式又叫静态工厂方法，其实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。\n\n其中Spring中的BeanFactory就是简单工厂模式的体现，BeanFactory是Spring IOC容器中的一个核心接口，它的定义如下：\n\n![](https://img-blog.csdnimg.cn/b7134f2874f64daab6e91cc7405049f1.png)\n\n我们可以通过它的具体实现类（比如ClassPathXmlApplicationContext）来获取Bean：\n\n```java\nBeanFactory bf = new ClassPathXmlApplicationContext(\"spring.xml\");\nFlyFish flyFishBean = (FlyFish) bf.getBean(\"flyfishBean\");\n```\n\n从上面代码可以看到，使用者不需要自己来new对象，而是通过工厂类的方法getBean来获取对象实例，这是典型的简单工厂模式，只不过Spring是用反射机制来创建Bean的。\n\n# 工厂方法模式\n\n在简单工厂中，由工厂类进行所有的逻辑判断、实例创建；如果不想在工厂类中进行判断，可以为不同的产品提供不同的工厂，不同的工厂生产不同的产品，每一个工厂都只对应一个相应的对象，这就是工厂方法模式。\n\nSpring中的FactoryBean就是这种思想的体现，FactoryBean可以理解为工厂Bean，先来看看它的定义：\n\n![](https://img-blog.csdnimg.cn/6cb8a14078d34b4188b4465ab3033128.png)\n\n我们定义一个类FlyFishFactoryBean来实现FactoryBean接口，主要是在getObject方法里new一个FlyFish对象。这样我们通过getBean(id) 获得的是该工厂所产生的FlyFish的实例，而不是FlyFishFactoryBean本身的实例，像下面这样：\n\n```java\nBeanFactory bf = new ClassPathXmlApplicationContext(\"spring.xml\");\nFlyFish flyFishBean = (FlyFish) bf.getBean(\"flyfishBean\");\n```\n\n# 观察者模式\n\nSpring中实现的观察者模式包含三部分：Event事件（相当于消息）、Listener监听者（相当于观察者）、Publisher发送者（相当于被观察者）\n\n我们通过一个例子来看下Spring提供的观察者模式是怎么使用的\n\n```java\n// Event事件\npublic class DemoEvent extends ApplicationEvent {\n  private String message;\n\n  public DemoEvent(Object source, String message) {\n    super(source);\n  }\n\n  public String getMessage() {\n    return this.message;\n  }\n}\n\n// Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener {\n  @Override\n  public void onApplicationEvent(DemoEvent demoEvent) {\n    String message = demoEvent.getMessage();\n    System.out.println(message);\n  }\n}\n\n// Publisher发送者\n@Component\npublic class DemoPublisher {\n  @Autowired\n  private ApplicationContext applicationContext;\n\n  public void publishEvent(DemoEvent demoEvent) {\n    this.applicationContext.publishEvent(demoEvent);\n  }\n}\n```\n\n从代码中，我们可以看出，主要包含三部分工作：\n\n- 定义一个继承ApplicationEvent的事件（DemoEvent）；\n- 定义一个实现了ApplicationListener的监听器（DemoListener）；\n- 定义一个发送者（DemoPublisher），发送者调用ApplicationContext来发送事件消息。\n\n**在Spring的实现中，观察者注册到了哪里呢？又是如何注册的呢？**\n\nSpring把观察者注册到了ApplicationContext对象中。\n\n实际上，具体到源码来说，ApplicationContext只是一个接口，具体的代码实现包含在它的实现类AbstractApplicationContext中。我把跟观察者模式相关的代码，如下。你只需要关注它是如何发送事件和注册监听者就好。\n\n![](https://img-blog.csdnimg.cn/5f2a44383f0846888d7cb4cc42581aa1.png)\n\n从上面的代码中，我们发现，真正的消息发送，实际上是通过ApplicationEventMulticaster这个类来完成的。\n\n下面这个类的源码我只摘抄了最关键的一部分，也就是multicastEvent()这个消息发送函数，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式。\n\n![](https://img-blog.csdnimg.cn/352ce797c65942c38659ea7cdeefc72a.png)\n\n借助Spring提供的观察者模式的骨架代码，如果我们要在Spring下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往ApplicationContext中发送事件就可以了，剩下的工作都由Spring框架来完成。\n\n实际上，这也体现了Spring框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听。\n\n# 模板模式\n\n我们经常在面试中被问到的一个问题：\n\n> 请你说下Spring Bean的创建过程包含哪些主要的步骤。\n\n这其中就涉及模板模式。它也体现了Spring的扩展性。利用模板模式，Spring能让用户定制Bean的创建过程。\n\n下面是Spring Bean的整个生命周期，一张图，清晰明了：\n\n更多详细内容，可以看看之前的文章：[Spring奇技淫巧之扩展点的应用](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485001&idx=1&sn=2b84dd07d216fde4cea4b0c31e16a90f&scene=21#wechat_redirect)\n\n![](https://img-blog.csdnimg.cn/df041737e435461a80ee1a74358d3fbf.png)\n\n如果你仔细看过源码会发现，实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似Callback回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成InitializingBean对象），传递给模板（BeanFactory）来执行。\n\n**观察者模式和模板模式，这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。**\n\n# 适配器模式\n\n在Spring MVC中，定义一个Controller最常用的方式是，通过@Controller注解来标记某个类是Controller类，通过@RequesMapping注解来标记函数对应的URL\n\n不过，我们还可以通过让类实现Controller接口或者Servlet接口，来定义一个Controller。\n\n**针对这三种定义方式，我写了三段示例代码，如下所示：**\n\n```java\n// 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController {\n    @RequestMapping(\"/FlyFish\")\n    public ModelAndView getEmployeeName() {\n        ModelAndView model = new ModelAndView(\"FlyFish\");        \n        model.addObject(\"message\", \"FlyFish\");       \n        return model; \n    }  \n}\n\n// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {\n        ModelAndView model = new ModelAndView(\"FlyFish\");\n        model.addObject(\"message\", \"FlyFish\");\n        return model;\n    }\n}\n\n// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req, resp);\n  }\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(\"Hello World.\");\n  }\n}\n```\n\n在应用启动的时候，Spring容器会加载这些Controller类，并且解析出URL对应的处理函数，封装成Handler对象，存储到HandlerMapping对象中。当有请求到来的时候，DispatcherServlet从HanderMapping中，查找请求URL对应的Handler，然后调用执行Handler对应的函数代码，最后将执行结果返回给客户端。\n\n但是，不同方式定义的Controller，其函数的定义（函数名、入参、返回值等）是不统一的。\n\nDispatcherServlet调用的是service()方法，DispatcherServlet需要根据不同类型的Controller，调用不同的函数。\n\nSpring利用适配器模式，我们将不同方式定义的Controller类中的函数，适配为统一的函数定义。\n\n**我们再具体看下Spring的代码实现。**\n\nSpring定义了统一的接口HandlerAdapter，并且对每种Controller定义了对应的适配器类。\n\n这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter等。\n\n![](https://img-blog.csdnimg.cn/6e53e7f9631c4257872b2d6b53c36185.png)\n\n在DispatcherServlet类中，我们就不需要区分对待不同的Controller对象了，统一调用HandlerAdapter的handle()函数就可以了\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，可以获得免费电子书籍","source":"_posts/公众号文章/Spring设计模式.md","raw":"---\ntitle: Spring设计模式\ncategories: \n- 公众号文章\n---\n\n# 前言\n\n前几天，一位**读者面阿里**被问到一个问题：Spring框架用到了哪些设计模式？，答的不是很好，于是打算写篇文章讲讲这个！\n\n* 文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n* 面经：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s/SOErvCCrmPaAVUphSO2Wqw)\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n# 代理模式\n\n所谓代理，是指它与被代理对象实现了相同的接口，客户端必须通过代理才能与被代理的目标类进行交互，而代理一般在交互的过程中（交互前后），进行某些特定的处理，比如在调用这个方法前做前置处理，调用这个方法后做后置处理。\n\n代理又分为静态代理和动态代理两种方式，Spring的AOP采用的是动态代理的方式\n\nSpring通过动态代理对类进行方法级别的切面增强，动态生成目标对象的代理类，并在代理类的方法中设置拦截器，通过执行拦截器中的逻辑增强了代理方法的功能，从而实现AOP。\n\n**关于动态代理可以看我之前的文章，写的很详细**：[动态代理总结，你要知道的都在这里，无废话！](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485541&idx=1&sn=371e92596b8e7ba47019b15767b18873&scene=21#wechat_redirect)\n\n# 策略模式\n\n我们前面讲到，Spring AOP是通过动态代理来实现的。\n\n具体到代码实现，Spring支持两种动态代理实现方式，一种是JDK提供的动态代理实现方式，另一种是Cglib提供的动态代理实现方式。\n\nSpring会在运行时动态地选择不同的动态代理实现方式。**这个应用场景实际上就是策略模式的典型应用场景。**\n\n我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到Spring源码，AopProxy是策略接口，JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类。\n\n**其中，AopProxy接口的定义如下所示：**\n\n![](https://img-blog.csdnimg.cn/d0266b32cacf4d8a9d4b47811b25730e.png)\n\n在策略模式中，策略的创建一般通过工厂方法来实现。对应到Spring源码，AopProxyFactory是一个工厂类接口，DefaultAopProxyFactory是一个默认的工厂类，用来创建AopProxy对象。\n\n源码如下所示：\n\n![](https://img-blog.csdnimg.cn/9eb06c1cf175456b9c2f56f7d78ff8a8.png)\n\n策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。\n\n对应到Spring源码中，我们可以参看刚刚给出的DefaultAopProxyFactory类中的createAopProxy()函数的代码实现。\n\n**其中，第10行代码是动态选择哪种策略的判断条件。**\n\n# 装饰器模式\n\n我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。\n\n为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。\n\n**实现这样一个功能，Spring使用到了装饰器模式。**\n\nTransactionAwareCacheDecorator增加了对事务的支持，在事务提交、回滚的时候分别对Cache的数据进行处理。\n\nTransactionAwareCacheDecorator实现Cache接口，并且将所有的操作都委托给targetCache来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现。\n\n![](https://img-blog.csdnimg.cn/0512c704ef2a48948122aeaa55935038.png)\n\n# 单例模式\n\n单例模式是指一个类在整个系统运行过程中，只允许产生一个实例\n\n在Spring中，Bean可以被定义为两种模式：Prototype（多例）和Singleton（单例），Spring Bean默认是单例模式。\n\n**那Spring是如何实现单例模式的呢？**\n\n答案是通过单例注册表的方式，具体来说就是使用了HashMap。简化代码如下：\n\n```java\npublic class DefaultSingletonBeanRegistry {\n    \n    //使用了线程安全容器ConcurrentHashMap，保存各种单实例对象\n    private final Map singletonObjects = new ConcurrentHashMap;\n\n    protected Object getSingleton(String beanName) {\n    //先到HashMap中拿Object\n    Object singletonObject = singletonObjects.get(beanName);\n    \n    //如果没拿到通过反射创建一个对象实例，并添加到HashMap中\n    if (singletonObject == null) {\n      singletonObjects.put(beanName,\n                           Class.forName(beanName).newInstance());\n   }\n   \n   //返回对象实例\n   return singletonObjects.get(beanName);\n  }\n}\n```\n\n上面的代码逻辑比较清晰，先到HashMap去拿单实例对象，没拿到就创建一个添加到HashMap。\n\n# 简单工厂模式\n\n**有这样一个场景：**\n\n当A对象需要调用B对象的方法时，我们需要在A中new一个B的实例，它的缺点是一旦需求发生变化，比如需要使用C类来代替B时，就要改写A类的方法。\n\n假如应用中有100个类以的方式耦合了B，那改起来就费劲了。\n\n**使用简单工厂模式：**\n\n简单工厂模式又叫静态工厂方法，其实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。\n\n其中Spring中的BeanFactory就是简单工厂模式的体现，BeanFactory是Spring IOC容器中的一个核心接口，它的定义如下：\n\n![](https://img-blog.csdnimg.cn/b7134f2874f64daab6e91cc7405049f1.png)\n\n我们可以通过它的具体实现类（比如ClassPathXmlApplicationContext）来获取Bean：\n\n```java\nBeanFactory bf = new ClassPathXmlApplicationContext(\"spring.xml\");\nFlyFish flyFishBean = (FlyFish) bf.getBean(\"flyfishBean\");\n```\n\n从上面代码可以看到，使用者不需要自己来new对象，而是通过工厂类的方法getBean来获取对象实例，这是典型的简单工厂模式，只不过Spring是用反射机制来创建Bean的。\n\n# 工厂方法模式\n\n在简单工厂中，由工厂类进行所有的逻辑判断、实例创建；如果不想在工厂类中进行判断，可以为不同的产品提供不同的工厂，不同的工厂生产不同的产品，每一个工厂都只对应一个相应的对象，这就是工厂方法模式。\n\nSpring中的FactoryBean就是这种思想的体现，FactoryBean可以理解为工厂Bean，先来看看它的定义：\n\n![](https://img-blog.csdnimg.cn/6cb8a14078d34b4188b4465ab3033128.png)\n\n我们定义一个类FlyFishFactoryBean来实现FactoryBean接口，主要是在getObject方法里new一个FlyFish对象。这样我们通过getBean(id) 获得的是该工厂所产生的FlyFish的实例，而不是FlyFishFactoryBean本身的实例，像下面这样：\n\n```java\nBeanFactory bf = new ClassPathXmlApplicationContext(\"spring.xml\");\nFlyFish flyFishBean = (FlyFish) bf.getBean(\"flyfishBean\");\n```\n\n# 观察者模式\n\nSpring中实现的观察者模式包含三部分：Event事件（相当于消息）、Listener监听者（相当于观察者）、Publisher发送者（相当于被观察者）\n\n我们通过一个例子来看下Spring提供的观察者模式是怎么使用的\n\n```java\n// Event事件\npublic class DemoEvent extends ApplicationEvent {\n  private String message;\n\n  public DemoEvent(Object source, String message) {\n    super(source);\n  }\n\n  public String getMessage() {\n    return this.message;\n  }\n}\n\n// Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener {\n  @Override\n  public void onApplicationEvent(DemoEvent demoEvent) {\n    String message = demoEvent.getMessage();\n    System.out.println(message);\n  }\n}\n\n// Publisher发送者\n@Component\npublic class DemoPublisher {\n  @Autowired\n  private ApplicationContext applicationContext;\n\n  public void publishEvent(DemoEvent demoEvent) {\n    this.applicationContext.publishEvent(demoEvent);\n  }\n}\n```\n\n从代码中，我们可以看出，主要包含三部分工作：\n\n- 定义一个继承ApplicationEvent的事件（DemoEvent）；\n- 定义一个实现了ApplicationListener的监听器（DemoListener）；\n- 定义一个发送者（DemoPublisher），发送者调用ApplicationContext来发送事件消息。\n\n**在Spring的实现中，观察者注册到了哪里呢？又是如何注册的呢？**\n\nSpring把观察者注册到了ApplicationContext对象中。\n\n实际上，具体到源码来说，ApplicationContext只是一个接口，具体的代码实现包含在它的实现类AbstractApplicationContext中。我把跟观察者模式相关的代码，如下。你只需要关注它是如何发送事件和注册监听者就好。\n\n![](https://img-blog.csdnimg.cn/5f2a44383f0846888d7cb4cc42581aa1.png)\n\n从上面的代码中，我们发现，真正的消息发送，实际上是通过ApplicationEventMulticaster这个类来完成的。\n\n下面这个类的源码我只摘抄了最关键的一部分，也就是multicastEvent()这个消息发送函数，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式。\n\n![](https://img-blog.csdnimg.cn/352ce797c65942c38659ea7cdeefc72a.png)\n\n借助Spring提供的观察者模式的骨架代码，如果我们要在Spring下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往ApplicationContext中发送事件就可以了，剩下的工作都由Spring框架来完成。\n\n实际上，这也体现了Spring框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听。\n\n# 模板模式\n\n我们经常在面试中被问到的一个问题：\n\n> 请你说下Spring Bean的创建过程包含哪些主要的步骤。\n\n这其中就涉及模板模式。它也体现了Spring的扩展性。利用模板模式，Spring能让用户定制Bean的创建过程。\n\n下面是Spring Bean的整个生命周期，一张图，清晰明了：\n\n更多详细内容，可以看看之前的文章：[Spring奇技淫巧之扩展点的应用](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485001&idx=1&sn=2b84dd07d216fde4cea4b0c31e16a90f&scene=21#wechat_redirect)\n\n![](https://img-blog.csdnimg.cn/df041737e435461a80ee1a74358d3fbf.png)\n\n如果你仔细看过源码会发现，实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似Callback回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成InitializingBean对象），传递给模板（BeanFactory）来执行。\n\n**观察者模式和模板模式，这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。**\n\n# 适配器模式\n\n在Spring MVC中，定义一个Controller最常用的方式是，通过@Controller注解来标记某个类是Controller类，通过@RequesMapping注解来标记函数对应的URL\n\n不过，我们还可以通过让类实现Controller接口或者Servlet接口，来定义一个Controller。\n\n**针对这三种定义方式，我写了三段示例代码，如下所示：**\n\n```java\n// 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController {\n    @RequestMapping(\"/FlyFish\")\n    public ModelAndView getEmployeeName() {\n        ModelAndView model = new ModelAndView(\"FlyFish\");        \n        model.addObject(\"message\", \"FlyFish\");       \n        return model; \n    }  \n}\n\n// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller {\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception {\n        ModelAndView model = new ModelAndView(\"FlyFish\");\n        model.addObject(\"message\", \"FlyFish\");\n        return model;\n    }\n}\n\n// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet {\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    this.doPost(req, resp);\n  }\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {\n    resp.getWriter().write(\"Hello World.\");\n  }\n}\n```\n\n在应用启动的时候，Spring容器会加载这些Controller类，并且解析出URL对应的处理函数，封装成Handler对象，存储到HandlerMapping对象中。当有请求到来的时候，DispatcherServlet从HanderMapping中，查找请求URL对应的Handler，然后调用执行Handler对应的函数代码，最后将执行结果返回给客户端。\n\n但是，不同方式定义的Controller，其函数的定义（函数名、入参、返回值等）是不统一的。\n\nDispatcherServlet调用的是service()方法，DispatcherServlet需要根据不同类型的Controller，调用不同的函数。\n\nSpring利用适配器模式，我们将不同方式定义的Controller类中的函数，适配为统一的函数定义。\n\n**我们再具体看下Spring的代码实现。**\n\nSpring定义了统一的接口HandlerAdapter，并且对每种Controller定义了对应的适配器类。\n\n这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter等。\n\n![](https://img-blog.csdnimg.cn/6e53e7f9631c4257872b2d6b53c36185.png)\n\n在DispatcherServlet类中，我们就不需要区分对待不同的Controller对象了，统一调用HandlerAdapter的handle()函数就可以了\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，可以获得免费电子书籍","slug":"公众号文章/Spring设计模式","published":1,"date":"2022-02-19T03:54:06.871Z","updated":"2022-02-19T04:05:03.868Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiv00exfhjihkdshi14","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前几天，一位<strong>读者面阿里</strong>被问到一个问题：Spring框架用到了哪些设计模式？，答的不是很好，于是打算写篇文章讲讲这个！</p>\n<ul>\n<li>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></li>\n<li>面经：<a href=\"https://mp.weixin.qq.com/s/SOErvCCrmPaAVUphSO2Wqw\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>所谓代理，是指它与被代理对象实现了相同的接口，客户端必须通过代理才能与被代理的目标类进行交互，而代理一般在交互的过程中（交互前后），进行某些特定的处理，比如在调用这个方法前做前置处理，调用这个方法后做后置处理。</p>\n<p>代理又分为静态代理和动态代理两种方式，Spring的AOP采用的是动态代理的方式</p>\n<p>Spring通过动态代理对类进行方法级别的切面增强，动态生成目标对象的代理类，并在代理类的方法中设置拦截器，通过执行拦截器中的逻辑增强了代理方法的功能，从而实现AOP。</p>\n<p><strong>关于动态代理可以看我之前的文章，写的很详细</strong>：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485541&idx=1&sn=371e92596b8e7ba47019b15767b18873&scene=21#wechat_redirect\">动态代理总结，你要知道的都在这里，无废话！</a></p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><p>我们前面讲到，Spring AOP是通过动态代理来实现的。</p>\n<p>具体到代码实现，Spring支持两种动态代理实现方式，一种是JDK提供的动态代理实现方式，另一种是Cglib提供的动态代理实现方式。</p>\n<p>Spring会在运行时动态地选择不同的动态代理实现方式。<strong>这个应用场景实际上就是策略模式的典型应用场景。</strong></p>\n<p>我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到Spring源码，AopProxy是策略接口，JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类。</p>\n<p><strong>其中，AopProxy接口的定义如下所示：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d0266b32cacf4d8a9d4b47811b25730e.png\"></p>\n<p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到Spring源码，AopProxyFactory是一个工厂类接口，DefaultAopProxyFactory是一个默认的工厂类，用来创建AopProxy对象。</p>\n<p>源码如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9eb06c1cf175456b9c2f56f7d78ff8a8.png\"></p>\n<p>策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。</p>\n<p>对应到Spring源码中，我们可以参看刚刚给出的DefaultAopProxyFactory类中的createAopProxy()函数的代码实现。</p>\n<p><strong>其中，第10行代码是动态选择哪种策略的判断条件。</strong></p>\n<h1 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h1><p>我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。</p>\n<p>为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。</p>\n<p><strong>实现这样一个功能，Spring使用到了装饰器模式。</strong></p>\n<p>TransactionAwareCacheDecorator增加了对事务的支持，在事务提交、回滚的时候分别对Cache的数据进行处理。</p>\n<p>TransactionAwareCacheDecorator实现Cache接口，并且将所有的操作都委托给targetCache来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0512c704ef2a48948122aeaa55935038.png\"></p>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>单例模式是指一个类在整个系统运行过程中，只允许产生一个实例</p>\n<p>在Spring中，Bean可以被定义为两种模式：Prototype（多例）和Singleton（单例），Spring Bean默认是单例模式。</p>\n<p><strong>那Spring是如何实现单例模式的呢？</strong></p>\n<p>答案是通过单例注册表的方式，具体来说就是使用了HashMap。简化代码如下：</p>\n<pre><code class=\"java\">public class DefaultSingletonBeanRegistry &#123;\n    \n    //使用了线程安全容器ConcurrentHashMap，保存各种单实例对象\n    private final Map singletonObjects = new ConcurrentHashMap;\n\n    protected Object getSingleton(String beanName) &#123;\n    //先到HashMap中拿Object\n    Object singletonObject = singletonObjects.get(beanName);\n    \n    //如果没拿到通过反射创建一个对象实例，并添加到HashMap中\n    if (singletonObject == null) &#123;\n      singletonObjects.put(beanName,\n                           Class.forName(beanName).newInstance());\n   &#125;\n   \n   //返回对象实例\n   return singletonObjects.get(beanName);\n  &#125;\n&#125;\n</code></pre>\n<p>上面的代码逻辑比较清晰，先到HashMap去拿单实例对象，没拿到就创建一个添加到HashMap。</p>\n<h1 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h1><p><strong>有这样一个场景：</strong></p>\n<p>当A对象需要调用B对象的方法时，我们需要在A中new一个B的实例，它的缺点是一旦需求发生变化，比如需要使用C类来代替B时，就要改写A类的方法。</p>\n<p>假如应用中有100个类以的方式耦合了B，那改起来就费劲了。</p>\n<p><strong>使用简单工厂模式：</strong></p>\n<p>简单工厂模式又叫静态工厂方法，其实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p>\n<p>其中Spring中的BeanFactory就是简单工厂模式的体现，BeanFactory是Spring IOC容器中的一个核心接口，它的定义如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b7134f2874f64daab6e91cc7405049f1.png\"></p>\n<p>我们可以通过它的具体实现类（比如ClassPathXmlApplicationContext）来获取Bean：</p>\n<pre><code class=\"java\">BeanFactory bf = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);\nFlyFish flyFishBean = (FlyFish) bf.getBean(&quot;flyfishBean&quot;);\n</code></pre>\n<p>从上面代码可以看到，使用者不需要自己来new对象，而是通过工厂类的方法getBean来获取对象实例，这是典型的简单工厂模式，只不过Spring是用反射机制来创建Bean的。</p>\n<h1 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h1><p>在简单工厂中，由工厂类进行所有的逻辑判断、实例创建；如果不想在工厂类中进行判断，可以为不同的产品提供不同的工厂，不同的工厂生产不同的产品，每一个工厂都只对应一个相应的对象，这就是工厂方法模式。</p>\n<p>Spring中的FactoryBean就是这种思想的体现，FactoryBean可以理解为工厂Bean，先来看看它的定义：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6cb8a14078d34b4188b4465ab3033128.png\"></p>\n<p>我们定义一个类FlyFishFactoryBean来实现FactoryBean接口，主要是在getObject方法里new一个FlyFish对象。这样我们通过getBean(id) 获得的是该工厂所产生的FlyFish的实例，而不是FlyFishFactoryBean本身的实例，像下面这样：</p>\n<pre><code class=\"java\">BeanFactory bf = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);\nFlyFish flyFishBean = (FlyFish) bf.getBean(&quot;flyfishBean&quot;);\n</code></pre>\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>Spring中实现的观察者模式包含三部分：Event事件（相当于消息）、Listener监听者（相当于观察者）、Publisher发送者（相当于被观察者）</p>\n<p>我们通过一个例子来看下Spring提供的观察者模式是怎么使用的</p>\n<pre><code class=\"java\">// Event事件\npublic class DemoEvent extends ApplicationEvent &#123;\n  private String message;\n\n  public DemoEvent(Object source, String message) &#123;\n    super(source);\n  &#125;\n\n  public String getMessage() &#123;\n    return this.message;\n  &#125;\n&#125;\n\n// Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener &#123;\n  @Override\n  public void onApplicationEvent(DemoEvent demoEvent) &#123;\n    String message = demoEvent.getMessage();\n    System.out.println(message);\n  &#125;\n&#125;\n\n// Publisher发送者\n@Component\npublic class DemoPublisher &#123;\n  @Autowired\n  private ApplicationContext applicationContext;\n\n  public void publishEvent(DemoEvent demoEvent) &#123;\n    this.applicationContext.publishEvent(demoEvent);\n  &#125;\n&#125;\n</code></pre>\n<p>从代码中，我们可以看出，主要包含三部分工作：</p>\n<ul>\n<li>定义一个继承ApplicationEvent的事件（DemoEvent）；</li>\n<li>定义一个实现了ApplicationListener的监听器（DemoListener）；</li>\n<li>定义一个发送者（DemoPublisher），发送者调用ApplicationContext来发送事件消息。</li>\n</ul>\n<p><strong>在Spring的实现中，观察者注册到了哪里呢？又是如何注册的呢？</strong></p>\n<p>Spring把观察者注册到了ApplicationContext对象中。</p>\n<p>实际上，具体到源码来说，ApplicationContext只是一个接口，具体的代码实现包含在它的实现类AbstractApplicationContext中。我把跟观察者模式相关的代码，如下。你只需要关注它是如何发送事件和注册监听者就好。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5f2a44383f0846888d7cb4cc42581aa1.png\"></p>\n<p>从上面的代码中，我们发现，真正的消息发送，实际上是通过ApplicationEventMulticaster这个类来完成的。</p>\n<p>下面这个类的源码我只摘抄了最关键的一部分，也就是multicastEvent()这个消息发送函数，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/352ce797c65942c38659ea7cdeefc72a.png\"></p>\n<p>借助Spring提供的观察者模式的骨架代码，如果我们要在Spring下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往ApplicationContext中发送事件就可以了，剩下的工作都由Spring框架来完成。</p>\n<p>实际上，这也体现了Spring框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听。</p>\n<h1 id=\"模板模式\"><a href=\"#模板模式\" class=\"headerlink\" title=\"模板模式\"></a>模板模式</h1><p>我们经常在面试中被问到的一个问题：</p>\n<blockquote>\n<p>请你说下Spring Bean的创建过程包含哪些主要的步骤。</p>\n</blockquote>\n<p>这其中就涉及模板模式。它也体现了Spring的扩展性。利用模板模式，Spring能让用户定制Bean的创建过程。</p>\n<p>下面是Spring Bean的整个生命周期，一张图，清晰明了：</p>\n<p>更多详细内容，可以看看之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485001&idx=1&sn=2b84dd07d216fde4cea4b0c31e16a90f&scene=21#wechat_redirect\">Spring奇技淫巧之扩展点的应用</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/df041737e435461a80ee1a74358d3fbf.png\"></p>\n<p>如果你仔细看过源码会发现，实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似Callback回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成InitializingBean对象），传递给模板（BeanFactory）来执行。</p>\n<p><strong>观察者模式和模板模式，这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。</strong></p>\n<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><p>在Spring MVC中，定义一个Controller最常用的方式是，通过@Controller注解来标记某个类是Controller类，通过@RequesMapping注解来标记函数对应的URL</p>\n<p>不过，我们还可以通过让类实现Controller接口或者Servlet接口，来定义一个Controller。</p>\n<p><strong>针对这三种定义方式，我写了三段示例代码，如下所示：</strong></p>\n<pre><code class=\"java\">// 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController &#123;\n    @RequestMapping(&quot;/FlyFish&quot;)\n    public ModelAndView getEmployeeName() &#123;\n        ModelAndView model = new ModelAndView(&quot;FlyFish&quot;);        \n        model.addObject(&quot;message&quot;, &quot;FlyFish&quot;);       \n        return model; \n    &#125;  \n&#125;\n\n// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller &#123;\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n        ModelAndView model = new ModelAndView(&quot;FlyFish&quot;);\n        model.addObject(&quot;message&quot;, &quot;FlyFish&quot;);\n        return model;\n    &#125;\n&#125;\n\n// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet &#123;\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    this.doPost(req, resp);\n  &#125;\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    resp.getWriter().write(&quot;Hello World.&quot;);\n  &#125;\n&#125;\n</code></pre>\n<p>在应用启动的时候，Spring容器会加载这些Controller类，并且解析出URL对应的处理函数，封装成Handler对象，存储到HandlerMapping对象中。当有请求到来的时候，DispatcherServlet从HanderMapping中，查找请求URL对应的Handler，然后调用执行Handler对应的函数代码，最后将执行结果返回给客户端。</p>\n<p>但是，不同方式定义的Controller，其函数的定义（函数名、入参、返回值等）是不统一的。</p>\n<p>DispatcherServlet调用的是service()方法，DispatcherServlet需要根据不同类型的Controller，调用不同的函数。</p>\n<p>Spring利用适配器模式，我们将不同方式定义的Controller类中的函数，适配为统一的函数定义。</p>\n<p><strong>我们再具体看下Spring的代码实现。</strong></p>\n<p>Spring定义了统一的接口HandlerAdapter，并且对每种Controller定义了对应的适配器类。</p>\n<p>这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter等。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6e53e7f9631c4257872b2d6b53c36185.png\"></p>\n<p>在DispatcherServlet类中，我们就不需要区分对待不同的Controller对象了，统一调用HandlerAdapter的handle()函数就可以了</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前几天，一位<strong>读者面阿里</strong>被问到一个问题：Spring框架用到了哪些设计模式？，答的不是很好，于是打算写篇文章讲讲这个！</p>\n<ul>\n<li>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></li>\n<li>面经：<a href=\"https://mp.weixin.qq.com/s/SOErvCCrmPaAVUphSO2Wqw\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>所谓代理，是指它与被代理对象实现了相同的接口，客户端必须通过代理才能与被代理的目标类进行交互，而代理一般在交互的过程中（交互前后），进行某些特定的处理，比如在调用这个方法前做前置处理，调用这个方法后做后置处理。</p>\n<p>代理又分为静态代理和动态代理两种方式，Spring的AOP采用的是动态代理的方式</p>\n<p>Spring通过动态代理对类进行方法级别的切面增强，动态生成目标对象的代理类，并在代理类的方法中设置拦截器，通过执行拦截器中的逻辑增强了代理方法的功能，从而实现AOP。</p>\n<p><strong>关于动态代理可以看我之前的文章，写的很详细</strong>：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485541&idx=1&sn=371e92596b8e7ba47019b15767b18873&scene=21#wechat_redirect\">动态代理总结，你要知道的都在这里，无废话！</a></p>\n<h1 id=\"策略模式\"><a href=\"#策略模式\" class=\"headerlink\" title=\"策略模式\"></a>策略模式</h1><p>我们前面讲到，Spring AOP是通过动态代理来实现的。</p>\n<p>具体到代码实现，Spring支持两种动态代理实现方式，一种是JDK提供的动态代理实现方式，另一种是Cglib提供的动态代理实现方式。</p>\n<p>Spring会在运行时动态地选择不同的动态代理实现方式。<strong>这个应用场景实际上就是策略模式的典型应用场景。</strong></p>\n<p>我们只需要定义一个策略接口，让不同的策略类都实现这一个策略接口。对应到Spring源码，AopProxy是策略接口，JdkDynamicAopProxy、CglibAopProxy是两个实现了AopProxy接口的策略类。</p>\n<p><strong>其中，AopProxy接口的定义如下所示：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/d0266b32cacf4d8a9d4b47811b25730e.png\"></p>\n<p>在策略模式中，策略的创建一般通过工厂方法来实现。对应到Spring源码，AopProxyFactory是一个工厂类接口，DefaultAopProxyFactory是一个默认的工厂类，用来创建AopProxy对象。</p>\n<p>源码如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9eb06c1cf175456b9c2f56f7d78ff8a8.png\"></p>\n<p>策略模式的典型应用场景，一般是通过环境变量、状态值、计算结果等动态地决定使用哪个策略。</p>\n<p>对应到Spring源码中，我们可以参看刚刚给出的DefaultAopProxyFactory类中的createAopProxy()函数的代码实现。</p>\n<p><strong>其中，第10行代码是动态选择哪种策略的判断条件。</strong></p>\n<h1 id=\"装饰器模式\"><a href=\"#装饰器模式\" class=\"headerlink\" title=\"装饰器模式\"></a>装饰器模式</h1><p>我们知道，缓存一般都是配合数据库来使用的。如果写缓存成功，但数据库事务回滚了，那缓存中就会有脏数据。</p>\n<p>为了解决这个问题，我们需要将缓存的写操作和数据库的写操作，放到同一个事务中，要么都成功，要么都失败。</p>\n<p><strong>实现这样一个功能，Spring使用到了装饰器模式。</strong></p>\n<p>TransactionAwareCacheDecorator增加了对事务的支持，在事务提交、回滚的时候分别对Cache的数据进行处理。</p>\n<p>TransactionAwareCacheDecorator实现Cache接口，并且将所有的操作都委托给targetCache来实现，对其中的写操作添加了事务功能。这是典型的装饰器模式的应用场景和代码实现。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0512c704ef2a48948122aeaa55935038.png\"></p>\n<h1 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h1><p>单例模式是指一个类在整个系统运行过程中，只允许产生一个实例</p>\n<p>在Spring中，Bean可以被定义为两种模式：Prototype（多例）和Singleton（单例），Spring Bean默认是单例模式。</p>\n<p><strong>那Spring是如何实现单例模式的呢？</strong></p>\n<p>答案是通过单例注册表的方式，具体来说就是使用了HashMap。简化代码如下：</p>\n<pre><code class=\"java\">public class DefaultSingletonBeanRegistry &#123;\n    \n    //使用了线程安全容器ConcurrentHashMap，保存各种单实例对象\n    private final Map singletonObjects = new ConcurrentHashMap;\n\n    protected Object getSingleton(String beanName) &#123;\n    //先到HashMap中拿Object\n    Object singletonObject = singletonObjects.get(beanName);\n    \n    //如果没拿到通过反射创建一个对象实例，并添加到HashMap中\n    if (singletonObject == null) &#123;\n      singletonObjects.put(beanName,\n                           Class.forName(beanName).newInstance());\n   &#125;\n   \n   //返回对象实例\n   return singletonObjects.get(beanName);\n  &#125;\n&#125;\n</code></pre>\n<p>上面的代码逻辑比较清晰，先到HashMap去拿单实例对象，没拿到就创建一个添加到HashMap。</p>\n<h1 id=\"简单工厂模式\"><a href=\"#简单工厂模式\" class=\"headerlink\" title=\"简单工厂模式\"></a>简单工厂模式</h1><p><strong>有这样一个场景：</strong></p>\n<p>当A对象需要调用B对象的方法时，我们需要在A中new一个B的实例，它的缺点是一旦需求发生变化，比如需要使用C类来代替B时，就要改写A类的方法。</p>\n<p>假如应用中有100个类以的方式耦合了B，那改起来就费劲了。</p>\n<p><strong>使用简单工厂模式：</strong></p>\n<p>简单工厂模式又叫静态工厂方法，其实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类。</p>\n<p>其中Spring中的BeanFactory就是简单工厂模式的体现，BeanFactory是Spring IOC容器中的一个核心接口，它的定义如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b7134f2874f64daab6e91cc7405049f1.png\"></p>\n<p>我们可以通过它的具体实现类（比如ClassPathXmlApplicationContext）来获取Bean：</p>\n<pre><code class=\"java\">BeanFactory bf = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);\nFlyFish flyFishBean = (FlyFish) bf.getBean(&quot;flyfishBean&quot;);\n</code></pre>\n<p>从上面代码可以看到，使用者不需要自己来new对象，而是通过工厂类的方法getBean来获取对象实例，这是典型的简单工厂模式，只不过Spring是用反射机制来创建Bean的。</p>\n<h1 id=\"工厂方法模式\"><a href=\"#工厂方法模式\" class=\"headerlink\" title=\"工厂方法模式\"></a>工厂方法模式</h1><p>在简单工厂中，由工厂类进行所有的逻辑判断、实例创建；如果不想在工厂类中进行判断，可以为不同的产品提供不同的工厂，不同的工厂生产不同的产品，每一个工厂都只对应一个相应的对象，这就是工厂方法模式。</p>\n<p>Spring中的FactoryBean就是这种思想的体现，FactoryBean可以理解为工厂Bean，先来看看它的定义：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6cb8a14078d34b4188b4465ab3033128.png\"></p>\n<p>我们定义一个类FlyFishFactoryBean来实现FactoryBean接口，主要是在getObject方法里new一个FlyFish对象。这样我们通过getBean(id) 获得的是该工厂所产生的FlyFish的实例，而不是FlyFishFactoryBean本身的实例，像下面这样：</p>\n<pre><code class=\"java\">BeanFactory bf = new ClassPathXmlApplicationContext(&quot;spring.xml&quot;);\nFlyFish flyFishBean = (FlyFish) bf.getBean(&quot;flyfishBean&quot;);\n</code></pre>\n<h1 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h1><p>Spring中实现的观察者模式包含三部分：Event事件（相当于消息）、Listener监听者（相当于观察者）、Publisher发送者（相当于被观察者）</p>\n<p>我们通过一个例子来看下Spring提供的观察者模式是怎么使用的</p>\n<pre><code class=\"java\">// Event事件\npublic class DemoEvent extends ApplicationEvent &#123;\n  private String message;\n\n  public DemoEvent(Object source, String message) &#123;\n    super(source);\n  &#125;\n\n  public String getMessage() &#123;\n    return this.message;\n  &#125;\n&#125;\n\n// Listener监听者\n@Component\npublic class DemoListener implements ApplicationListener &#123;\n  @Override\n  public void onApplicationEvent(DemoEvent demoEvent) &#123;\n    String message = demoEvent.getMessage();\n    System.out.println(message);\n  &#125;\n&#125;\n\n// Publisher发送者\n@Component\npublic class DemoPublisher &#123;\n  @Autowired\n  private ApplicationContext applicationContext;\n\n  public void publishEvent(DemoEvent demoEvent) &#123;\n    this.applicationContext.publishEvent(demoEvent);\n  &#125;\n&#125;\n</code></pre>\n<p>从代码中，我们可以看出，主要包含三部分工作：</p>\n<ul>\n<li>定义一个继承ApplicationEvent的事件（DemoEvent）；</li>\n<li>定义一个实现了ApplicationListener的监听器（DemoListener）；</li>\n<li>定义一个发送者（DemoPublisher），发送者调用ApplicationContext来发送事件消息。</li>\n</ul>\n<p><strong>在Spring的实现中，观察者注册到了哪里呢？又是如何注册的呢？</strong></p>\n<p>Spring把观察者注册到了ApplicationContext对象中。</p>\n<p>实际上，具体到源码来说，ApplicationContext只是一个接口，具体的代码实现包含在它的实现类AbstractApplicationContext中。我把跟观察者模式相关的代码，如下。你只需要关注它是如何发送事件和注册监听者就好。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5f2a44383f0846888d7cb4cc42581aa1.png\"></p>\n<p>从上面的代码中，我们发现，真正的消息发送，实际上是通过ApplicationEventMulticaster这个类来完成的。</p>\n<p>下面这个类的源码我只摘抄了最关键的一部分，也就是multicastEvent()这个消息发送函数，它通过线程池，支持异步非阻塞、同步阻塞这两种类型的观察者模式。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/352ce797c65942c38659ea7cdeefc72a.png\"></p>\n<p>借助Spring提供的观察者模式的骨架代码，如果我们要在Spring下实现某个事件的发送和监听，只需要做很少的工作，定义事件、定义监听器、往ApplicationContext中发送事件就可以了，剩下的工作都由Spring框架来完成。</p>\n<p>实际上，这也体现了Spring框架的扩展性，也就是在不需要修改任何代码的情况下，扩展新的事件和监听。</p>\n<h1 id=\"模板模式\"><a href=\"#模板模式\" class=\"headerlink\" title=\"模板模式\"></a>模板模式</h1><p>我们经常在面试中被问到的一个问题：</p>\n<blockquote>\n<p>请你说下Spring Bean的创建过程包含哪些主要的步骤。</p>\n</blockquote>\n<p>这其中就涉及模板模式。它也体现了Spring的扩展性。利用模板模式，Spring能让用户定制Bean的创建过程。</p>\n<p>下面是Spring Bean的整个生命周期，一张图，清晰明了：</p>\n<p>更多详细内容，可以看看之前的文章：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247485001&idx=1&sn=2b84dd07d216fde4cea4b0c31e16a90f&scene=21#wechat_redirect\">Spring奇技淫巧之扩展点的应用</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/df041737e435461a80ee1a74358d3fbf.png\"></p>\n<p>如果你仔细看过源码会发现，实际上，这里的模板模式的实现，并不是标准的抽象类的实现方式，而是有点类似Callback回调的实现方式，也就是将要执行的函数封装成对象（比如，初始化方法封装成InitializingBean对象），传递给模板（BeanFactory）来执行。</p>\n<p><strong>观察者模式和模板模式，这两种模式能够帮助我们创建扩展点，让框架的使用者在不修改源码的情况下，基于扩展点定制化框架功能。</strong></p>\n<h1 id=\"适配器模式\"><a href=\"#适配器模式\" class=\"headerlink\" title=\"适配器模式\"></a>适配器模式</h1><p>在Spring MVC中，定义一个Controller最常用的方式是，通过@Controller注解来标记某个类是Controller类，通过@RequesMapping注解来标记函数对应的URL</p>\n<p>不过，我们还可以通过让类实现Controller接口或者Servlet接口，来定义一个Controller。</p>\n<p><strong>针对这三种定义方式，我写了三段示例代码，如下所示：</strong></p>\n<pre><code class=\"java\">// 方法一：通过@Controller、@RequestMapping来定义\n@Controller\npublic class DemoController &#123;\n    @RequestMapping(&quot;/FlyFish&quot;)\n    public ModelAndView getEmployeeName() &#123;\n        ModelAndView model = new ModelAndView(&quot;FlyFish&quot;);        \n        model.addObject(&quot;message&quot;, &quot;FlyFish&quot;);       \n        return model; \n    &#125;  \n&#125;\n\n// 方法二：实现Controller接口 + xml配置文件:配置DemoController与URL的对应关系\npublic class DemoController implements Controller &#123;\n    @Override\n    public ModelAndView handleRequest(HttpServletRequest req, HttpServletResponse resp) throws Exception &#123;\n        ModelAndView model = new ModelAndView(&quot;FlyFish&quot;);\n        model.addObject(&quot;message&quot;, &quot;FlyFish&quot;);\n        return model;\n    &#125;\n&#125;\n\n// 方法三：实现Servlet接口 + xml配置文件:配置DemoController类与URL的对应关系\npublic class DemoServlet extends HttpServlet &#123;\n  @Override\n  protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    this.doPost(req, resp);\n  &#125;\n  \n  @Override\n  protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123;\n    resp.getWriter().write(&quot;Hello World.&quot;);\n  &#125;\n&#125;\n</code></pre>\n<p>在应用启动的时候，Spring容器会加载这些Controller类，并且解析出URL对应的处理函数，封装成Handler对象，存储到HandlerMapping对象中。当有请求到来的时候，DispatcherServlet从HanderMapping中，查找请求URL对应的Handler，然后调用执行Handler对应的函数代码，最后将执行结果返回给客户端。</p>\n<p>但是，不同方式定义的Controller，其函数的定义（函数名、入参、返回值等）是不统一的。</p>\n<p>DispatcherServlet调用的是service()方法，DispatcherServlet需要根据不同类型的Controller，调用不同的函数。</p>\n<p>Spring利用适配器模式，我们将不同方式定义的Controller类中的函数，适配为统一的函数定义。</p>\n<p><strong>我们再具体看下Spring的代码实现。</strong></p>\n<p>Spring定义了统一的接口HandlerAdapter，并且对每种Controller定义了对应的适配器类。</p>\n<p>这些适配器类包括：AnnotationMethodHandlerAdapter、SimpleControllerHandlerAdapter、SimpleServletHandlerAdapter等。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6e53e7f9631c4257872b2d6b53c36185.png\"></p>\n<p>在DispatcherServlet类中，我们就不需要区分对待不同的Controller对象了，统一调用HandlerAdapter的handle()函数就可以了</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n"},{"title":"ZooKeeper","_content":"\n这一个月，一直在鼓捣自己的个人网站，没更新\n\n之前分享过几个系列：\n\n* [Kafka核心知识总结！](https://mp.weixin.qq.com/s/zfHoSsuSpXWOaxQrm7uvkA)\n* [计算机网络常用知识总结！](https://mp.weixin.qq.com/s/m_awvdGYXd9SJQ8YePENGQ)\n* [操作系统常用知识总结！](https://mp.weixin.qq.com/s/RpMwJrEqAP8K0vRTH392kg)\n\n今天这篇介绍一下ZooKeeper！\n\n**文章较长，可以点赞，收藏再看！**\n\n文章内容会同步到个人网站上，方便阅读：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/dc49ec91428d4b12b7c11292fb51acb6.png)\n\n# 基本介绍\n\nApache ZooKeeper（以下简称ZK）是由Apache Hadoop的子项目发展而来，为分布式应用提供高效且可靠的分布式协调服务。\n\n* 在解决分布式数据一致性方面，ZK没有直接采用Paxos算法，而是采用了ZAB（ZooKeeper Atomic Broadcast）协议。\n\nZK可以提供诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知，集群管理，Master选举，分布式锁，分布式队列等功能。\n\n**它具有以下特性：**\n\n- **顺序一致性**：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；\n- **原子性**：要么所有应用，要么不应用；不存在部分机器应用了该事务，而**另一部分没有应用**的情况；\n- **单一视图**：所有客户端看到的服务端数据模型都是一致的，无论客户连接的是哪个ZK服务器；\n- **可靠性**：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；\n- **实时性**：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据（**一段时间**）。\n\n# 数据模型\n\nZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。\n\n* ZooKeeper的数据模型也具有一个固定的根节点`（/）`，我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。\n\n* ZooKeeper 树中的每一层级用斜杠`（/）`分隔开，且只能用绝对路径（如`get /work/task`）的方式查询 ZooKeeper 节点，而不能使用相对路径。\n\n<img src=\"https://img-blog.csdnimg.cn/63d002b469764d71b68897df6849a0f9.png\"/>\n\n**为什么 ZooKeeper 不能采用相对路径查找节点呢？**\n\n> 这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。\n\n像这种查找与给定值相等的记录问题最适合用散列来解决。\n\n因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 `hashtableConcurrentHashMap<String, DataNode> nodes `，用节点的完整路径来作为 key 存储节点数据。\n\n这样就大大提高了 ZooKeeper 的性能。\n\n**节点类型**\n\nZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：\n\n> 1、持久节点\n\n一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。\n\n> 2、临时节点\n\n如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。\n\n当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除，同样，我们可以像删除持久节点一样主动删除临时节点。\n\n在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为`/servers`节点，并为集群下的每台服务器创建一个临时节点`/servers/host`，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。\n\n> 3、有序节点\n\n节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。\n\n例如一个客户端创建了一个路径为 `works/task- `的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为` works/task-1`。\n\n* 通过这种方式我们可以直观的查看到节点的创建顺序。\n\nZooKeeper 中的每个节点都维护有这些内容：一个二进制数组`（byte data[]）`，用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。\n\n**节点的状态结构**\n\n执行` stat /zk_test`，可以看到控制台输出了一些信息，这些就是节点状态信息。\n\n每一个节点都有一个自己的状态属性，记录了节点本身的一些信息：\n\n| **状态属性**   | **说明**                                                     |\n| :------------- | :----------------------------------------------------------- |\n| czxid          | 数据节点创建时的事务 ID                                      |\n| ctime          | 数据节点创建时的时间                                         |\n| mzxid          | 数据节点最后一次更新时的事务 ID                              |\n| mtime          | 数据节点最后一次更新时的时间                                 |\n| pzxid          | 数据节点的子节点最后一次被修改时的事务 ID                    |\n| **cversion**   | **子节点的版本**                                             |\n| **version**    | **当前节点数据的版本**                                       |\n| **aversion**   | **节点的 ACL 的版本**                                        |\n| ephemeralOwner | 如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0 |\n| dataLength     | 数据内容的长度                                               |\n| numChildren    | 数据节点当前的子节点个数                                     |\n\n**数据节点的版本**\n\n在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。\n\nZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。\n\n# 数据存储\n\n从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。\n\n* 事务日志数据主要用于记录本地事务性会话操作，用于 ZooKeeper 集群服务器之间的数据同步。\n\n* 事务快照则是将内存数据持久化到本地磁盘。\n\n> 这里要注意的一点是，数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致。\n\n在单台 ZooKeeper 服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。\n\n**内存数据**\n\nZooKeeper 的数据模型可以看作一棵树形结构，而数据节点就是这棵树上的叶子节点。\n\n从数据存储的角度看，ZooKeeper 的数据模型是存储在内存中的。\n\n我们可以把 ZooKeeper 的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的 ACL 权限信息以及 stat 状态信息等。\n\n* 而在底层实现中，ZooKeeper 数据模型是通过 DataTree 类来定义的。\n\nDataTree 类定义了一个 ZooKeeper 数据的内存结构。\n\nDataTree 的内部定义类 nodes 节点类型、root 根节点信息、子节点的 WatchManager 监控信息等数据模型中的相关信息。\n\n可以说，一个 DataTree 类定义了 ZooKeeper 内存数据的逻辑结构。\n\n**事务日志**\n\n为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper 集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper 集群中的 Follow 和 Observer 服务器就会进行数据同步。\n\n> 而这两种角色服务器所接收到的信息就是 Leader 服务器的事务日志。\n\n在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个 ZooKeeper 集群的执行性能。\n\n# Watch机制\n\nZooKeeper 的客户端可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知；\n\n**如何实现：**\n\n我们可以通过向 ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：\n\n```java\nnew ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)\n```\n\n上面代码的意思是定义了一个了 ZooKeeper 客户端对象实例，并传入三个参数：\n\n* connectString 服务端地址\n\n* sessionTimeout：超时时间\n\n* Watcher：监控事件\n\n这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文 ，一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中。\n\n除此之外，ZooKeeper 客户端也可以通过 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：\n\n```java\ngetData(String path, Watcher watcher, Stat stat)\n```\n\n触发通知的条件：\n\n<img src=\"https://img-blog.csdnimg.cn/95ebb31561bd4ea2bed199cdf8b3bfce.png\"/>\n\n上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。\n\n* 例如在客户端连接服务端的时候，可以对数据节点的创建、删除、数据变更、子节点的更新等操作进行监控。\n\n**当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？**\n\n答案是否定的，Watch 事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的 Watch 事件。\n\n**订阅发布场景实现**\n\n> 提到 ZooKeeper 的应用场景，你可能第一时间会想到最为典型的发布订阅功能。\n\n发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。\n\n一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。\n\nZooKeeper 采用了两种模式结合的方式实现订阅发布功能。\n\n> 下面我们来分析一个具体案例：\n\n在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。\n\n通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper 的发布订阅功能就能解决这个问题。\n\n我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper 数据节点中。\n\n如`/confs/data_item1`。\n\n* 服务器集群客户端对该节点添加 Watch 事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。\n\n* 而当该节点数据发生变化时，ZooKeeper 服务器会发送 Watch 事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。\n\n我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对 ZooKeeper 服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。\n\n> 要注意一点是，我们提到 Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch 事件。\n\n# 会话机制\n\nZooKeeper 的工作方式一般是通过客户端向服务端发送请求而实现的。\n\n而在一个请求的发送过程中，首先，客户端要与服务端进行连接，而一个连接就是一个会话。\n\n> 在 ZooKeeper 中，一个会话可以看作是一个用于表示客户端与服务器端连接的数据结构 Session。\n\n这个数据结构由三个部分组成：分别是会话 ID（sessionID）、会话超时时间（TimeOut）、会话关闭状态（isClosing）\n\n- 会话 ID：会话 ID 作为一个会话的标识符，当我们创建一次会话的时候，ZooKeeper 会自动为其分配一个唯一的 ID 编码。\n\n- 会话超时时间：一般来说，一个会话的超时时间就是指一次会话从发起后到被服务器关闭的时长。而设置会话超时时间后，服务器会参考设置的超时时间，最终计算一个服务端自己的超时时间。而这个超时时间则是最终真正用于 ZooKeeper 中服务端用户会话管理的超时时间。\n\n- 会话关闭状态：会话关闭 isClosing 状态属性字段表示一个会话是否已经关闭。如果服务器检查到一个会话已经因为超时等原因失效时， ZooKeeper 会在该会话的 isClosing 属性值标记为关闭，再之后就不对该会话进行操作了。\n\n**会话状态**\n\n在 ZooKeeper 服务的运行过程中，会话会经历不同的状态变化。\n\n这些状态包括：\n\n> 正在连接（CONNECTING）、已经连接（CONNECTIED）、正在重新连接（RECONNECTING）、已经重新连接（RECONNECTED）、会话关闭（CLOSE）等。\n\n当客户端开始创建一个与服务端的会话操作时，它的会话状态就会变成 CONNECTING，之后客户端会根据服务器地址列表中的服务器 IP 地址分别尝试进行连接。如果遇到一个 IP 地址可以连接到服务器，那么客户端会话状态将变为 CONNECTIED。\n\n如果因为网络原因造成已经连接的客户端会话断开时，客户端会重新尝试连接服务端。而对应的客户端会话状态又变成 CONNECTING ，直到该会话连接到服务端最终又变成 CONNECTIED。\n\n> 在 ZooKeeper 服务的整个运行过程中，会话状态经常会在 CONNECTING 与 CONNECTIED 之间进行切换。\n\n最后，当出现超时或者客户端主动退出程序等情况时，客户端会话状态则会变为 CLOSE 状态。\n\n**会话异常**\n\n在 ZooKeeper 中，会话的超时异常包括客户端 readtimeout 异常和服务器端 sessionTimeout 异常。\n\n* 在我们平时的开发中，要明确这两个异常的不同之处在于一个是发生在客户端，而另一个是发生在服务端。\n\n而对于那些对 ZooKeeper 接触不深的开发人员来说，他们常常踩坑的地方在于，虽然设置了超时间，但是在实际服务运行的时候 ZooKeeper 并没有按照设置的超时时间来管理会话。\n\n* 这是因为 ZooKeeper 实际起作用的超时时间是通过客户端和服务端协商决定。 \n\nZooKeeper 客户端在和服务端建立连接的时候，会提交一个客户端设置的会话超时时间，而该超时时间会和服务端设置的最大超时时间和最小超时时间进行比对，如果正好在其允许的范围内，则采用客户端的超时时间管理会话。\n\n如果大于或者小于服务端设置的超时时间，则采用服务端设置的值管理会话。\n\n**分桶策略**\n\n我们知道在 ZooKeeper 中为了保证一个会话的存活状态，客户端需要向服务器周期性地发送心跳信息。\n\n* 而客户端所发送的心跳信息可以是一个 ping 请求，也可以是一个普通的业务请求。\n\nZooKeeper 服务端接收请求后，会更新会话的过期时间，来保证会话的存活状态。\n\n* 所以在 ZooKeeper 的会话管理中，最主要的工作就是管理会话的过期时间。\n\n> ZooKeeper 中采用了独特的会话管理方式来管理会话的过期时间。\n\n在 ZooKeeper 中，会话将按照不同的时间间隔进行划分，超时时间相近的会话将被放在同一个间隔区间中，这种方式避免了 ZooKeeper 对每一个会话进行检查，而是采用分批次的方式管理会话。\n\n这就降低了会话管理的难度，因为每次小批量的处理会话过期也提高了会话处理的效率。\n\n**ZooKeeper 这种会话管理的好处？**\n\nZooKeeper 这种分段的会话管理策略大大提高了计算会话过期的效率，如果是在一个实际生产环境中，一个大型的分布式系统往往具有很高的访问量。\n\n而 ZooKeeper 作为其中的组件，对外提供服务往往要承担数千个客户端的访问，这其中就要对这几千个会话进行管理。\n\n在这种场景下，要想通过对每一个会话进行管理和检查并不合适，所以采用将同一个时间段的会话进行统一管理，这样就大大提高了服务的运行效率。\n\n**底层实现**\n\nZooKeeper 底层实现的原理，核心的一点就是过期队列这个数据结构。所有会话过期的相关操作都是围绕这个队列进行的。\n\n* 可以说 ZooKeeper 底层就是采用这个队列结构来管理会话过期的。\n\n**一个会话过期队列是由若干个 bucket 组成的。**\n\n* bucket 是一个按照时间划分的区间。\n\n* 在 ZooKeeper 中，通常以 expirationInterval 为单位进行时间区间的划分，它是 ZooKeeper 分桶策略中用于划分时间区间的最小单位。\n\n* 在 ZooKeeper 中，一个过期队列由不同的 bucket 组成。\n\n* 每个 bucket 中存放了在某一时间内过期的会话。\n\n将会话按照不同的过期时间段分别维护到过期队列之后，在 ZooKeeper 服务运行的过程中，具体的执行过程如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/86243433c4674237b3339452d2bc0e7c.png\"/>\n\n首先，ZooKeeper 服务会开启一个线程专门用来检索过期队列，找出要过期的 bucket，而 ZooKeeper 每次只会让一个 bucket 的会话过期，每当要进行会话过期操作时，ZooKeeper 会唤醒一个处于休眠状态的线程进行会话过期操作，之后会按照上面介绍的操作检索过期队列，取出过期的会话后会执行过期操作。\n\n# ACL权限\n\nZooKeeper的ACL可针对znodes设置相应的权限信息。\n\n一个 ACL 权限设置通常可以分为 3 部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。\n\n* 最终组成一条例如`scheme:id:permission`格式的 ACL 请求信息。\n\n**权限模式：Scheme**\n\nZooKeeper 的权限验证方式大体分为两种类型，一种是范围验证，另外一种是口令验证。\n\n> 范围验证\n\n所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。\n\n比如我们可以让一个 IP 地址为`ip：192.168.0.11`的机器对服务器上的某个数据节点具有写入的权限。\n\n或者也可以通过`ip:192.168.0.11/22`给一段 IP 地址的机器赋权。\n\n> 口令验证\n\n可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。\n\n在 ZooKeeper 中这种验证方式是 Digest 认证，我们知道通过网络传输相对来说并不安全，所以绝不通过明文在网络发送密码也是程序设计中很重要的原则之一，而 Digest 这种认证方式首先在客户端传送`username:password`这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。\n\n> Super 权限模式\n\n权限模式 Super 可以认为是一种特殊的 Digest 认证。\n\n\n具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。\n\n下面这段代码给出了 Digest 模式下客户端的调用方式。\n\n```\n//创建节点\ncreate /digest_node1\n//设置digest权限验证\nsetAcl /digest_node1 digest:用户名:base64格式密码:rwadc \n//查询节点Acl权限\ngetAcl /digest_node1 \n//授权操作\naddauth digest user:passwd\n```\n\n> 如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。\n\n对其创建的节点要想进行修改应该怎么做呢？\n\n我们可以通过**super 模式**即超级管理员的方式删除该节点或变更该节点的权限验证方式。\n\n正因为**super 模式**有如此大的权限，我们在平时使用时也应该更加谨慎。\n\n> world 模式\n\n这种授权模式对应于系统中的所有用户，本质上起不到任何作用。\n\n设置了 world 权限模式系统中的所有用户操作都可以不进行权限验证。\n\n**授权对象（ID）**\n\n所谓的授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。\n\n如果是 World 模式，是授权系统中所有的用户。\n\n**权限信息（Permission）**\n\n权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：\n\n* 数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；\n\n* 数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；\n\n* 数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；\n\n* 数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；\n\n* 数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。\n\n> 需要注意的一点是，每个节点都有维护自身的 ACL 权限数据，即使是该节点的子节点也是有自己的 ACL 权限而不是直接继承其父节点的权限。\n\n**实现自己的权限口控制**\n\n虽然 ZooKeeper 自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。\n\n官方文档中对这种机制的定义是 `Pluggable ZooKeeper Authenication`，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。那么这种机制是如何实现的呢？\n\n> 要想实现自定义的权限控制机制，最核心的一点是实现 ZooKeeper 提供的权限控制器接口 AuthenticationProvider。\n\n实现了自定义权限后，如何才能让 ZooKeeper 服务端使用自定义的权限验证方式呢？\n\n接下来就需要将自定义的权限控制注册到 ZooKeeper 服务器中，而注册的方式通常有两种。\n\n* 第一种是通过设置系统属性来注册自定义的权限控制器：\n\n```java\n-Dzookeeper.authProvider.x=CustomAuthenticationProvider\n```\n\n* 另一种是在配置文件` zoo.cfg `中进行配置：\n\n```java\nauthProvider.x=CustomAuthenticationProvider\n```\n\n**实现原理**\n\n首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。\n\n在授权接口中，值得注意的是会话的授权信息存储在 ZooKeeper 服务端的内存中，如果客户端会话关闭，授权信息会被删除。\n\n下次连接服务器后，需要重新调用授权接口进行授权。\n\n# 序列化方式\n\n在 ZooKeeper 中并没有采用和 Java 一样的序列化方式，而是采用了一个 Jute 的序列解决方案作为 ZooKeeper 框架自身的序列化方式。\n\n> ZooKeeper 从最开始就采用 Jute 作为其序列化解决方案，直到其最新的版本依然没有更改。\n\n虽然 ZooKeeper 一直将 Jute 框架作为序列化解决方案，但这并不意味着 Jute 相对其他框架性能更好，反倒是 Apache Avro、Thrift 等框架在性能上优于前者。\n\n之所以 ZooKeeper 一直采用 Jute 作为序列化解决方案，主要是新老版本的兼容等问题。\n\n**如何 使用 Jute 实现序列化**\n\n如果我们要想将某个定义的类进行序列化，首先需要该类实现 Record 接口的 serilize 和 deserialize 方法，这两个方法分别是序列化和反序列化方法。\n\n> 下边这段代码给出了我们一般在 ZooKeeper 中进行序列化的具体实现：\n\n首先，我们定义了一个` test_jute `类，为了能够对它进行序列化，需要该` test_jute `类实现 Record 接口，并在对应的 serialize 序列化方法和 deserialize 反序列化方法中编辑具体的实现逻辑。\n\n```java\nclass test_jute implements Record{\n  private long ids；\n  private String name;\n  ...\n  public void serialize(OutpurArchive a_,String tag){\n    ...\n  }\n  public void deserialize(INputArchive a_,String tag){\n    ...\n  }\n}\n```\n\n在序列化方法 serialize 中，我们要实现的逻辑是，首先通过字符类型参数 tag 传递标记序列化标识符，之后使用 writeLong 和 writeString 等方法分别将对象属性字段进行序列化。\n\n```java\npublic void serialize(OutpurArchive a_,String tag) throws ...{\n  a_.startRecord(this.tag);\n  a_.writeLong(ids,\"ids\");\n  a_.writeString(type,\"name\");\n  a_.endRecord(this,tag);\n}\n```\n\n调用 derseralize 在实现反序列化的过程则与我们上边说的序列化过程正好相反。\n\n```java\npublic void deserialize(INputArchive a_,String tag) throws {\n  a_.startRecord(tag);\n  ids = a_.readLong(\"ids\");\n  name = a_.readString(\"name\");\n  a_.endRecord(tag);\n}\n```\n\n序列化和反序列化的实现逻辑编码方式相对固定，首先通过 startRecord 开启一段序列化操作，之后通过 writeLong、writeString 或 readLong、 readString 等方法执行序列化或反序列化。\n\n本例中只是实现了长整型和字符型的序列化和反序列化操作，除此之外 ZooKeeper 中的 Jute 框架还支持整数类型（Int）、布尔类型（Bool）、双精度类型（Double）以及 Byte/Buffer 类型。\n\n# 集群\n\n**ZooKeeper集群模式的特点**\n\n在 ZooKeeper 集群中将服务器分成 **Leader 、Follow 、Observer 三**种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：\n\n- Leader 角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者，既可以为客户端提供写服务又能提供读服务。\n\n- Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader 服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个 Follow 服务器作为新的 Leader 服务器，只能提供读服务。\n\n- Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与 Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器，只能提供读服务。\n\n在 ZooKeeper 集群接收到来自客户端的会话请求操作后，首先会判断该条请求是否是事务性的会话请求。\n\n> 对于事务性的会话请求，ZooKeeper 集群服务端会将该请求统一转发给 Leader 服务器进行操作。\n>\n> 所谓事务性请求，是指 ZooKeeper 服务器执行完该条会话请求后，是否会导致执行该条会话请求的服务器的数据或状态发生改变，进而导致与其他集群中的服务器出现数据不一致的情况。\n\nLeader 服务器内部执行该条事务性的会话请求后，再将数据同步给其他角色服务器，从而保证事务性会话请求的执行顺序，进而保证整个 ZooKeeper 集群的数据一致性。\n\n> 在 ZooKeeper 集群的内部实现中，是通过什么方法保证所有 ZooKeeper 集群接收到的事务性会话请求都能交给 Leader 服务器进行处理的呢？\n\n在 ZooKeeper 集群内部，集群中除 Leader 服务器外的其他角色服务器接收到来自客户端的事务性会话请求后，必须将该条会话请求转发给 Leader 服务器进行处理。\n\nZooKeeper 集群中的 Follow 和 Observer 服务器，都会检查当前接收到的会话请求是否是事务性的请求，如果是事务性的请求，那么就将该请求以 REQUEST 消息类型转发给 Leader 服务器。\n\n在 ZooKeeper集群中的服务器接收到该条消息后，会对该条消息进行解析。\n\n* 分析出该条消息所包含的原始客户端会话请求。\n\n* 之后将该条消息提交到自己的 Leader 服务器请求处理链中，开始进行事务性的会话请求操作。\n\n* 如果不是事务性请求，ZooKeeper 集群则交由 Follow 和 Observer 角色服务器处理该条会话请求，如查询数据节点信息。\n\n当一个业务场景在查询操作多而创建删除等事务性操作少的情况下，ZooKeeper 集群的性能表现的就会很好。\n\n> 如果是在极端情况下，ZooKeeper 集群只有事务性的会话请求而没有查询操作，那么 Follow 和 Observer 服务器就只能充当一个请求转发服务器的角色， 所有的会话的处理压力都在 Leader 服务器。\n\n在处理性能上整个集群服务器的瓶颈取决于 Leader 服务器的性能。\n\n> ZooKeeper 集群的作用只能保证在 Leader 节点崩溃的时候，重新选举出 Leader 服务器保证系统的稳定性。\n\n这也是 ZooKeeper 设计的一个缺点。\n\n**Leader选举**\n\nLeader 服务器的选举操作主要发生在两种情况下。\n\n第一种就是 ZooKeeper 集群服务启动的时候，第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时，这时 ZooKeeper 集群需要选举出新的 Leader 服务器。\n\n> ZooKeeper 集群重新选举 Leader 的过程只有 Follow 服务器参与工作。\n\n> 服务器状态\n\n服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。\n\n* **LOOKING**：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。\n\n* **FOLLOWING**：跟随者状态。表明当前服务器角色是Follower。\n\n* **LEADING**：领导者状态。表明当前服务器角色是Leader。\n\n* **OBSERVING**：观察者状态。表明当前服务器角色是Observer。\n\n**事务ID（zxid）**\n\nZookeeper的状态变化，都会由一个Zookeeper事务ID（ZXID）标识。\n\n> 写入Zookeeper，会导致状态变化，每次写入都会导致ZXID发生变化。\n\nZXID由Leader统一分配，全局唯一，长度64位，递增。\n\nZXID展示了所有的Zookeeper转台变更顺序，每次变更都有一个唯一ZXID，如果zxid1小于zxid2，则说明zxid1的事务在zxid2的事务之前发生。\n\n**选举过程**\n\n在 ZooKeeper 集群重新选举 Leader 节点的过程中，主要可以分为 Leader 失效发现、重新选举 Leader 、Follow 服务器角色变更、集群同步这几个步骤。\n\n> Leader 失效发现\n\n在 ZooKeeper 集群中，当 Leader 服务器失效时，ZooKeeper 集群会重新选举出新的 Leader 服务器。\n\n* 在 ZooKeeper 集群中，探测 Leader 服务器是否存活的方式与保持客户端活跃性的方法非常相似。\n\n首先，Follow 服务器会定期向 Leader 服务器发送 网络请求，在接收到请求后，Leader 服务器会返回响应数据包给 Follow 服务器，而在 Follow 服务器接收到 Leader 服务器的响应后，如果判断 Leader 服务器运行正常，则继续进行数据同步和服务转发等工作，反之，则进行 Leader 服务器的重新选举操作。\n\n> Leader重新选举\n\n当 Follow 服务器向 Leader 服务器发送状态请求包后，如果没有得到 Leader 服务器的返回信息，这时，如果是集群中个别的 Follow 服务器发现返回错误，并不会导致 ZooKeeper 集群立刻重新选举 Leader 服务器，而是将该 Follow 服务器的状态变更为 LOOKING 状态，并向网络中发起投票，当 ZooKeeper 集群中有更多的机器发起投票，最后当投票结果满足多数原则的情况下。\n\nZooKeeper 会重新选举出 Leader 服务器。\n\n> Follow 角色变更\n\n在 ZooKeeper 集群中，Follow 服务器作为 Leader 服务器的候选者，当被选举为 Leader 服务器之后，其在 ZooKeeper 集群中的 Follow 角色，也随之发生改变。也就是要转变为 Leader 服务器，并作为 ZooKeeper 集群中的 Leader 角色服务器对外提供服务。\n\n> 集群同步数据\n\n在 ZooKeeper 集群成功选举 Leader 服务器，并且候选 Follow 服务器的角色变更后。\n\n为避免在这期间导致的数据不一致问题，ZooKeeper 集群在对外提供服务之前，会通过 Leader 角色服务器管理同步其他角色服务器。\n\n**底层实现**\n\n首先，ZooKeeper 集群会先判断 Leader 服务器是否失效，而判断的方式就是 Follow 服务器向 Leader 服务器发送请求包，之后 Follow 服务器接收到响应数据后，进行解析，Follow 服务器会根据返回的数据，判断 Leader 服务器的运行状态，如果返回的是 LOOKING 关键字，表明与集群中 Leader 服务器无法正常通信。\n\n* 之后，在 ZooKeeper 集群选举 Leader 服务器时，是通过 **FastLeaderElection** 类实现的。\n\n该类实现了 TCP 方式的通信连接，用于在 ZooKeeper 集群中与其他 Follow 服务器进行协调沟通。\n\nFastLeaderElection 类继承了 Election 接口，定义其是用来进行选举的实现类。\n\n* 而在其内部，又定义了选举通信相关的一些配置参数，比如 finalizeWait 最终等待时间、最大通知间隔时间 maxNotificationInterval 等。\n\n在选举的过程中，首先调用 ToSend 函数向 ZooKeeper 集群中的其他角色服务器发送本机的投票信息，其他服务器在接收投票信息后，会对投票信息进行有效性验证等操作，之后 ZooKeeper 集群统计投票信息，如果过半数的机器投票信息一致，则集群就重新选出新的 Leader 服务器。\n\n> 这里我们要注意一个问题，那就是在重新选举 Leader 服务器的过程中，ZooKeeper 集群理论上是无法进行事务性的请求处理的。\n\n因此，发送到 ZooKeeper 集群中的事务性会话会被挂起，暂时不执行，等到选举出新的 Leader 服务器后再进行操作。 \n\n**Observer**\n\n在 ZooKeeper 集群服务运行的过程中，Observer 服务器与 Follow 服务器具有一个相同的功能，那就是负责处理来自客户端的诸如查询数据节点等非事务性的会话请求操作。\n\n* 但与 Follow 服务器不同的是，Observer 不参与 Leader 服务器的选举工作，也不会被选举为 Leader 服务器。\n\n在早期的 ZooKeeper 集群服务运行过程中，只有 Leader 服务器和 Follow 服务器。\n\n不过随着 ZooKeeper 在分布式环境下的广泛应用，早期模式的设计缺点也随之产生，主要带来的问题有如下几点：\n\n* 随着集群规模的变大，集群处理写入的性能反而下降。\n\n* ZooKeeper 集群无法做到跨域部署。\n\n其中最主要的问题在于，当 ZooKeeper 集群的规模变大，集群中 Follow 服务器数量逐渐增多的时候，ZooKeeper 处理创建数据节点等事务性请求操作的性能就会逐渐下降。\n\n这是因为 ZooKeeper 集群在处理事务性请求操作时，要在 ZooKeeper 集群中对该事务性的请求发起投票，只有超过半数的 Follow 服务器投票一致，才会执行该条写入操作。\n\n正因如此，随着集群中 Follow 服务器的数量越来越多，一次写入等相关操作的投票也就变得越来越复杂，并且 Follow 服务器之间彼此的网络通信也变得越来越耗时，导致随着 Follow 服务器数量的逐步增加，事务性的处理性能反而变得越来越低。\n\n* 为了解决这一问题，在 ZooKeeper 3.6 版本后，ZooKeeper 集群中创建了一种新的服务器角色，即 Observer——观察者角色服务器。\n\nObserver 可以处理 ZooKeeper 集群中的非事务性请求，并且不参与 Leader 节点等投票相关的操作。\n\n这样既保证了 ZooKeeper 集群性能的扩展性，又避免了因为过多的服务器参与投票相关的操作而影响 ZooKeeper 集群处理事务性会话请求的能力。\n\n* 在实际部署的时候，因为 Observer 不参与 Leader 节点等操作，并不会像 Follow 服务器那样频繁的与 Leader 服务器进行通信。\n\n因此，可以将 Observer 服务器部署在不同的网络区间中，这样也不会影响整个 ZooKeeper 集群的性能，也就是所谓的跨域部署。\n\n**在我们日常使用 ZooKeeper 集群服务器的时候，集群中的机器个数应该选择奇数个？**\n\n两个原因：\n\n> 在容错能力相同的情况下，奇数台更节省资源\n\nZookeeper中 Leader 选举算法采用了Zab协议。\n\nZab核心思想是当多数 Server 写成功，则写成功。\n\n举两个例子：\n\n* 假如zookeeper集群1 ，有3个节点，3/2=1.5 ,  即zookeeper想要正常对外提供服务（即leader选举成功），至少需要2个节点是正常的。换句话说，3个节点的zookeeper集群，允许有一个节点宕机。\n\n* 假如zookeeper集群2，有4个节点，4/2=2 , 即zookeeper想要正常对外提供服务（即leader选举成功），至少需要3个节点是正常的。换句话说，4个节点的zookeeper集群，也允许有一个节点宕机。\n\n集群1与集群2都有 允许1个节点宕机 的容错能力，但是集群2比集群1多了1个节点。在相同容错能力的情况下，本着节约资源的原则，zookeeper集群的节点数维持奇数个更好一些。\n\n> 防止由脑裂造成的集群不可用。\n\n集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。\n\n下面举例说一下为什么采用奇数台节点，就可以防止由于脑裂造成的服务不可用：\n\n假如zookeeper集群有 5 个节点，发生了脑裂，脑裂成了A、B两个小集群： \n\n* A ： 1个节点 ，B ：4个节点 \n\n* A ： 2个节点， B ：3个节点 \n\n可以看出，上面这两种情况下，A、B中总会有一个小集群满足 可用节点数量 > 总节点数量/2 。\n\n所以zookeeper集群仍然能够选举出leader ， 仍然能对外提供服务，只不过是有一部分节点失效了而已。\n\n假如zookeeper集群有4个节点，同样发生脑裂，脑裂成了A、B两个小集群：\n\n* A：1个节点 ，  B：3个节点 \n\n* A：2个节点 ， B：2个节点\n\n因为A和B都是2个节点，都不满足 可用节点数量 > 总节点数量/2 的选举条件， 所以此时zookeeper就彻底不能提供服务了。\n\n# ZAB协议\n\n**ZAB 协议算法**\n\nZooKeeper 最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。\n\n> 为了解决这个问题，ZooKeeper 采用了 ZAB 协议算法。\n\nZAB 协议算法（Zookeeper Atomic Broadcast  ，Zookeeper 原子广播协议）是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是崩溃恢复和原子广播协议。\n\n* 在整个 ZAB 协议的底层实现中，ZooKeeper 集群主要采用主从模式的系统架构方式来保证 ZooKeeper 集群系统的一致性。\n\n当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。\n\n> 以 ZooKeeper 集群为例，这个操作过程可以概括为：\n\n当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。\n\n当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。\n\n然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。\n\n**崩溃恢复**\n\n当集群中的 Leader 发生故障的时候，整个集群就会因为缺少 Leader 服务器而无法处理来自客户端的事务性的会话请求。\n\n> 因此，为了解决这个问题。在 ZAB 协议中也设置了处理该问题的崩溃恢复机制。\n\n崩溃恢复机制是保证 ZooKeeper 集群服务高可用的关键。触发 ZooKeeper 集群执行崩溃恢复的事件是集群中的 Leader 节点服务器发生了异常而无法工作，于是 Follow 服务器会通过投票来决定是否选出新的 Leader 节点服务器。\n\n> 投票过程如下：\n\n当崩溃恢复机制开始的时候，整个 ZooKeeper 集群的每台 Follow 服务器会发起投票，并同步给集群中的其他 Follow 服务器。\n\n在接收到来自集群中的其他 Follow 服务器的投票信息后，集群中的每个 Follow 服务器都会与自身的投票信息进行对比，如果判断新的投票信息更合适，则采用新的投票信息作为自己的投票信息。在集群中的投票信息还没有达到超过半数原则的情况下，再进行新一轮的投票，最终当整个 ZooKeeper 集群中的 Follow 服务器超过半数投出的结果相同的时候，就会产生新的 Leader 服务器。\n\n> 选票结构：\n\n以 Fast Leader Election 选举的实现方式来讲，如下图所示，一个选票的整体结果可以分为一下六个部分：\n\n<img src=\"https://img-blog.csdnimg.cn/2956e37edd2d482fb3545a7b35ffe7ae.png\"/>\n\n* logicClock：用来记录服务器的投票轮次。logicClock 会从 1 开始计数，每当该台服务经过一轮投票后，logicClock 的数值就会加 1 。\n\n* state：用来标记当前服务器的状态。在 ZooKeeper 集群中一台服务器具有 LOOKING、FOLLOWING、LEADERING、OBSERVING 这四种状态。\n\n* `self_id`：用来表示当前服务器的 ID 信息，该字段在 ZooKeeper 集群中主要用来作为服务器的身份标识符。\n\n* `self_zxid`： 当前服务器上所保存的数据的最大事务 ID ，从 0 开始计数。\n\n* `vote_id`：投票要被推举的服务器的唯一 ID 。\n\n* `vote_zxid`：被推举的服务器上所保存的数据的最大事务 ID ，从 0 开始计数。\n\n当 ZooKeeper 集群需要重新选举出新的 Leader 服务器的时候，就会根据上面介绍的投票信息内容进行对比，以找出最适合的服务器。\n\n> 选票筛选\n\n当一台 Follow 服务器接收到网络中的其他 Follow 服务器的投票信息后，是如何进行对比来更新自己的投票信息的。\n\nFollow 服务器进行选票对比的过程，如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/977516cbd09d4fb8aad57004147221a6.png\" />\n\n首先，会对比 logicClock 服务器的投票轮次，当 logicClock 相同时，表明两张选票处于相同的投票阶段，并进入下一阶段，否则跳过。\n\n接下来再对比` vote_zxid `被选举的服务器 ID 信息，若接收到的外部投票信息中的 `vote_zxid `字段较大，则将自己的票中的` vote_zxid `与` vote_myid `更新为收到的票中的` vote_zxid `与` vote_myid` ，并广播出去。\n\n要是对比的结果相同，则继续对比` vote_myid `被选举服务器上所保存的最大事务 ID ，若外部投票的` vote_myid` 比较大，则将自己的票中的 `vote_myid `更新为收到的票中的` vote_myid` 。 \n\n经过这些对比和替换后，最终该台 Follow 服务器会产生新的投票信息，并在下一轮的投票中发送到 ZooKeeper 集群中。\n\n**消息广播**\n\n在 Leader 节点服务器处理请求后，需要通知集群中的其他角色服务器进行数据同步。ZooKeeper 集群采用消息广播的方式发送通知。\n\nZooKeeper 集群使用原子广播协议进行消息发送，该协议的底层实现过程与二阶段提交过程非常相似，如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/fb518bd2f20c45539765e0b76e54387d.png\"/>\n\n当要在集群中的其他角色服务器进行数据同步的时候，Leader 服务器将该操作过程封装成一个 Proposal 提交事务，并将其发送给集群中其他需要进行数据同步的服务器。\n\n当这些服务器接收到 Leader 服务器的数据同步事务后，会将该条事务能否在本地正常执行的结果反馈给 Leader 服务器，Leader 服务器在接收到其他 Follow 服务器的反馈信息后进行统计，判断是否在集群中执行本次事务操作。\n\n这里请注意 ，与二阶段提交过程不同（即需要集群中所有服务器都反馈可以执行事务操作后，主服务器再次发送 commit 提交请求执行数据变更） ，ZAB 协议算法省去了中断的逻辑，当 ZooKeeper 集群中有超过一半的 Follow 服务器能够正常执行事务操作后，整个 ZooKeeper 集群就可以提交 Proposal 事务了。\n\n# 日志清理\n\n**日志类型**\n\n在 ZooKeeper 服务运行的时候，一般会产生数据快照和日志文件，数据快照用于集群服务中的数据同步，而数据日志则记录了 ZooKeeper 服务运行的相关状态信息。\n\n> 其中，数据日志是我们在生产环境中需要定期维护和管理的文件。\n\n**清理方案**\n\n如上面所介绍的，面对生产系统中产生的日志，一般的维护操作是备份和清理。\n\n备份是为了之后对系统的运行情况进行排查和优化，而清理主要因为随着系统日志的增加，日志会逐渐占用系统的存储空间，如果一直不进行清理，可能耗尽系统的磁盘存储空间，并最终影响服务的运行。\n\n**清理工具**\n\n> Corntab\n\n首先，我们介绍的是 Linux corntab ，它是 Linux 系统下的软件，可以自动地按照我们设定的时间，周期性地执行我们编写的相关脚本。\n\ncrontab 定时脚本的方式相对灵活，可以按照我们的业务需求来设置处理日志的维护方式，比如这里我们希望定期清除 ZooKeeper 服务运行的日志，而不想清除数据快照的文件，则可以通过脚本设置，达到只对数据日志文件进行清理的目的。\n\n> PurgeTxnLog\n\nZooKeeper 自身还提供了 PurgeTxnLog 工具类，用来清理 snapshot 数据快照文件和系统日志。\n\nPurgeTxnLog 清理方式和我们上面介绍的方式十分相似，也是通过定时脚本执行任务，唯一的不同是，上面提到在编写日志清除 logsCleanWeek 的时候 ，我们使用的是原生 shell 脚本自己手动编写的数据日志清理逻辑，而使用 PurgeTxnLog 则可以在编写清除脚本的时候调用 ZooKeeper 为我们提供的工具类完成日志清理工作。\n\n如下面的代码所示，首先，我们在` /usr/bin `目录下创建一个 PurgeLogsClean 脚本。注意这里的脚本也是一个 shell 文件。\n\n在脚本中我们只需要编写 PurgeTxnLog 类的调用程序，系统就会自动通过 PurgeTxnLog 工具类为我们完成对应日志文件的清理工作。\n\n```\n#!/bin/sh  \njava -cp \"$CLASSPATH\" org.apache.zookeeper.server.PurgeTxnLog \necho \"清理完成\" \n```\n\nPurgeTxnLog 方式与 crontab 相比，使用起来更加容易而且也更加稳定安全，不过 crontab 方式更加灵活，我们可以根据不同的业务需求编写自己的清理逻辑。\n\n# 实现分布式锁\n\n分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。\n\n> 实现分布式锁目前有三种流行方案，即基于数据库、Redis、ZooKeeper 的方案\n\n**方案一：**\n\n使用节点中的存储数据区域，ZK中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识\n\n**方案二：**\n\n使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可\n\n<img src=\"https://img-blog.csdnimg.cn/b4f8396f620f4a778b01bb573ca5969f.png\"/>\n\n**死锁风险:**\n\n两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁\n\n* 方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行\n\n* 方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与ZK的连接，ZK检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的\n\n**避免羊群效应**\n\n把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。\n\n如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。\n\n> 为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。\n\n每次锁被释放，只会有一个锁请求者 会被通知到。\n\n这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。\n\n<img src=\"https://img-blog.csdnimg.cn/20b0e4cf4ae3424c999ba9fb4f704a8a.png\"/>\n\n**用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：**\n\n- 客户端连接 ZooKeeper，并`在/lock `下创建临时有序子节点，第一个客户端对应的子节点为` /lock/lock01/00000001`，第二个为 `/lock/lock01/00000002`；\n- 其他客户端获取` /lock01 `下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；\n\n- 如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听`/lock01 `的子节点变更消息，获得变更通知后重复此步骤直至获得锁；\n- 完成业务流程后，删除对应的子节点，释放分布式锁；\n\n在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。\n\n# 实现分布式ID\n\n我们可以通过 ZooKeeper 自身的客户端和服务器运行模式，来实现一个分布式网络环境下的 ID 请求和分发过程。\n\n> 每个需要 ID 编码的业务服务器可以看作是 ZooKeeper 的客户端。ID 编码生成器可以作为 ZooKeeper 的服务端。\n\n客户端通过发送请求到 ZooKeeper 服务器，来获取编码信息，服务端接收到请求后，发送 ID 编码给客户端。\n\n**实现原理：**\n\n可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。\n\n* 客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。\n\n* 客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。\n\n利用 ZooKeeper 中的顺序节点特性，很容易使我们创建的 ID 编码具有有序的特性。并且我们也可以通过客户端传递节点的名称，根据不同的业务编码区分不同的业务系统，从而使编码的扩展能力更强。\n\n> 虽然使用 ZooKeeper 的实现方式有这么多优点，但也会有一些潜在的问题。\n\n其中最主要的是，在定义编码的规则上还是强烈依赖于程序员自身的能力和对业务的深入理解。\n\n很容易出现因为考虑不周，造成设置的规则在运行一段时间后，无法满足业务要求或者安全性不够等问题。\n\n# 实现负载均衡\n\n**常见负载均衡算法**\n\n> 轮询法\n\n轮询法是最为简单的负载均衡算法，当接收到来自网络中的客户端请求后，负载均衡服务器会按顺序逐个分配给后端服务。\n\n比如集群中有 3 台服务器，分别是 server1、server2、server3，轮询法会按照 sever1、server2、server3 这个顺序依次分发会话请求给每个服务器。当第一次轮询结束后，会重新开始下一轮的循环。\n\n> 随机法\n\n随机算法是指负载均衡服务器在接收到来自客户端的请求后，会根据一定的随机算法选中后台集群中的一台服务器来处理这次会话请求。\n\n不过，当集群中备选机器变的越来越多时，通过统计学我们可以知道每台机器被抽中的概率基本相等，因此随机算法的实际效果越来越趋近轮询算法。\n\n> 原地址哈希法\n\n原地址哈希算法的核心思想是根据客户端的 IP 地址进行哈希计算，用计算结果进行取模后，根据最终结果选择服务器地址列表中的一台机器，处理该条会话请求。\n\n采用这种算法后，当同一 IP 的客户端再次访问服务端后，负载均衡服务器最终选举的还是上次处理该台机器会话请求的服务器，也就是每次都会分配同一台服务器给客户端。\n\n> 加权轮询法\n\n加权轮询的方式与轮询算法的方式很相似，唯一的不同在于选择机器的时候，不只是单纯按照顺序的方式选择，还根据机器的配置和性能高低有所侧重，配置性能好的机器往往首先分配。\n\n> 加权随机法\n\n加权随机法和我们上面提到的随机算法一样，在采用随机算法选举服务器的时候，会考虑系统性能作为权值条件。\n\n> 最小连接数法\n\n最小连接数算法是指，根据后台处理客户端的连接会话条数，计算应该把新会话分配给哪一台服务器。\n\n一般认为，连接数越少的机器，在网络带宽和计算性能上都有很大优势，会作为最优先分配的对象。\n\n**利用 ZooKeeper 实现 负载均衡 算法**\n\n> 这里我们通过采用最小连接数算法，来确定究竟如何均衡地分配网络会话请求给后台客户端。\n\n如下图所示，建立的 ZooKeeper 数据模型中 Severs 节点可以作为存储服务器列表的父节点。\n\n在它下面创建 servers_host1、servers_host2、servers_host3等临时节点来存储集群中的服务器运行状态信息。\n\n<img src=\"https://img-blog.csdnimg.cn/2c6c94ef4c1443ecbe0084b5d4ad7ea2.png\"/>\n\n整个实现的过程如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/b3ad367c3c024fd6ae57e4f7a2c9aa40.png\"/>\n\n* 首先，在接收到客户端的请求后，通过 getData 方法获取服务端 Severs 节点下的服务器列表，其中每个节点信息都存储有当前服务器的连接数。\n\n* 通过判断选择最少的连接数作为当前会话的处理服务器，并通过 setData 方法将该节点连接数加 1。\n\n* 最后，当客户端执行完毕，再调用 setData 方法将该节点信息减 1。\n* 我们定义当服务器接收到会话请求后。在 ZooKeeper 服务端增加连接数的 addBlance 方法。\n* 我们通过 readData 方法获取服务器最新的连接数，之后将该连接数加 1，再通过 writeData 方法将新的连接数信息写入到服务端对应节点信息中。\n\n* 当服务器处理完该会话请求后，需要更新服务端相关节点的连接数。\n\n* 具体的操作与 addBlance 方法基本一样，只是对获取的连接信息进行减一操作。\n\n**这里注意：**\n\n我们日常用到的负载均衡器主要是选择后台处理的服务器，并给其分发请求。\n\n> 而通过 ZooKeeper 实现的服务器，只提供了服务器的筛选工作。\n\n在请求分发的过程中，还是通过负载算法计算出要访问的服务器，之后客户端自己连接该服务器，完成请求操作。\n\n# 开源框架使用案例\n\n**Dubbo与ZooKeeper**\n\nDubbo 是阿里巴巴开发的一套开源的技术框架，是一款高性能、轻量级的开源 Java RPC 框架。\n\n**用ZooKeeper做注册中心**\n\n在整个 Dubbo 框架的实现过程中，注册中心是其中最为关键的一点，它保证了整个 PRC 过程中服务对外的透明性。\n\n而 Dubbo 的注册中心也是通过 ZooKeeper 来实现的。\n\n如下图所示，在整个 Dubbo 服务的启动过程中，服务提供者会在启动时向 `/dubbo/com.foo.BarService/providers `目录写入自己的 URL 地址，这个操作可以看作是一个 ZooKeeper 客户端在 ZooKeeper 服务器的数据模型上创建一个数据节点。\n\n服务消费者在启动时订阅 `/dubbo/com.foo.BarService/providers` 目录下的提供者 URL 地址，并向 `/dubbo/com.foo.BarService/consumers` 目录写入自己的 URL 地址。\n\n该操作是通过 ZooKeeper 服务器在 /consumers 节点路径下创建一个子数据节点，然后再在请求会话中发起对 /providers 节点的 watch 监控\n\n<img src=\"https://img-blog.csdnimg.cn/a27e2d30709947d7b995da6c091de3ba.png\"/>\n\n**Kafka与ZooKeeper**\n\n**Zookeeper的作用**\n\n由于 Broker 服务器采用分布式集群的方式工作，那么在服务的运行过程中，难免出现某台机器因异常而关闭的状况。\n\n为了保证整个 Kafka 集群的可用性，需要在系统中监控整个机器的运行情况。而 Kafka 可以通过 ZooKeeper 中的数据节点，将网络中机器的运行统计存储在数据模型中的 brokers 节点下。\n\n在 Kafka 的 Topic 信息注册中也需要使用到 ZooKeeper ，在 Kafka 中同一个Topic 消息容器可以分成多个不同片，而这些分区既可以存在于一台 Broker 服务器中，也可以存在于不同的 Broker 服务器中。\n\n而在 Kafka 集群中，每台 Broker 服务器又相对独立。\n\n为了能够读取这些以分布式方式存储的分区信息，Kafka 会将这些分区信息在 Broker 服务器中的对应关系存储在 ZooKeeper 数据模型的 topic 节点上，每一个 topic 在 ZooKeeper 数据节点上都会以 `/brokers/topics/[topic]` 的形式存在。\n\n![](https://img-blog.csdnimg.cn/058b3613e6204da8a467d8aa19f611b8.png)\n\n# 参考资料\n\n《从Paxos到Zookeeper 分布式一致性原理与实践》","source":"_posts/公众号文章/ZooKeeper.md","raw":"---\ntitle: ZooKeeper\ncategories: \n- 公众号文章\n---\n\n这一个月，一直在鼓捣自己的个人网站，没更新\n\n之前分享过几个系列：\n\n* [Kafka核心知识总结！](https://mp.weixin.qq.com/s/zfHoSsuSpXWOaxQrm7uvkA)\n* [计算机网络常用知识总结！](https://mp.weixin.qq.com/s/m_awvdGYXd9SJQ8YePENGQ)\n* [操作系统常用知识总结！](https://mp.weixin.qq.com/s/RpMwJrEqAP8K0vRTH392kg)\n\n今天这篇介绍一下ZooKeeper！\n\n**文章较长，可以点赞，收藏再看！**\n\n文章内容会同步到个人网站上，方便阅读：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/dc49ec91428d4b12b7c11292fb51acb6.png)\n\n# 基本介绍\n\nApache ZooKeeper（以下简称ZK）是由Apache Hadoop的子项目发展而来，为分布式应用提供高效且可靠的分布式协调服务。\n\n* 在解决分布式数据一致性方面，ZK没有直接采用Paxos算法，而是采用了ZAB（ZooKeeper Atomic Broadcast）协议。\n\nZK可以提供诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知，集群管理，Master选举，分布式锁，分布式队列等功能。\n\n**它具有以下特性：**\n\n- **顺序一致性**：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；\n- **原子性**：要么所有应用，要么不应用；不存在部分机器应用了该事务，而**另一部分没有应用**的情况；\n- **单一视图**：所有客户端看到的服务端数据模型都是一致的，无论客户连接的是哪个ZK服务器；\n- **可靠性**：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；\n- **实时性**：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据（**一段时间**）。\n\n# 数据模型\n\nZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。\n\n* ZooKeeper的数据模型也具有一个固定的根节点`（/）`，我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。\n\n* ZooKeeper 树中的每一层级用斜杠`（/）`分隔开，且只能用绝对路径（如`get /work/task`）的方式查询 ZooKeeper 节点，而不能使用相对路径。\n\n<img src=\"https://img-blog.csdnimg.cn/63d002b469764d71b68897df6849a0f9.png\"/>\n\n**为什么 ZooKeeper 不能采用相对路径查找节点呢？**\n\n> 这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。\n\n像这种查找与给定值相等的记录问题最适合用散列来解决。\n\n因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 `hashtableConcurrentHashMap<String, DataNode> nodes `，用节点的完整路径来作为 key 存储节点数据。\n\n这样就大大提高了 ZooKeeper 的性能。\n\n**节点类型**\n\nZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：\n\n> 1、持久节点\n\n一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。\n\n> 2、临时节点\n\n如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。\n\n当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除，同样，我们可以像删除持久节点一样主动删除临时节点。\n\n在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为`/servers`节点，并为集群下的每台服务器创建一个临时节点`/servers/host`，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。\n\n> 3、有序节点\n\n节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。\n\n例如一个客户端创建了一个路径为 `works/task- `的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为` works/task-1`。\n\n* 通过这种方式我们可以直观的查看到节点的创建顺序。\n\nZooKeeper 中的每个节点都维护有这些内容：一个二进制数组`（byte data[]）`，用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。\n\n**节点的状态结构**\n\n执行` stat /zk_test`，可以看到控制台输出了一些信息，这些就是节点状态信息。\n\n每一个节点都有一个自己的状态属性，记录了节点本身的一些信息：\n\n| **状态属性**   | **说明**                                                     |\n| :------------- | :----------------------------------------------------------- |\n| czxid          | 数据节点创建时的事务 ID                                      |\n| ctime          | 数据节点创建时的时间                                         |\n| mzxid          | 数据节点最后一次更新时的事务 ID                              |\n| mtime          | 数据节点最后一次更新时的时间                                 |\n| pzxid          | 数据节点的子节点最后一次被修改时的事务 ID                    |\n| **cversion**   | **子节点的版本**                                             |\n| **version**    | **当前节点数据的版本**                                       |\n| **aversion**   | **节点的 ACL 的版本**                                        |\n| ephemeralOwner | 如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0 |\n| dataLength     | 数据内容的长度                                               |\n| numChildren    | 数据节点当前的子节点个数                                     |\n\n**数据节点的版本**\n\n在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。\n\nZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。\n\n# 数据存储\n\n从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。\n\n* 事务日志数据主要用于记录本地事务性会话操作，用于 ZooKeeper 集群服务器之间的数据同步。\n\n* 事务快照则是将内存数据持久化到本地磁盘。\n\n> 这里要注意的一点是，数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致。\n\n在单台 ZooKeeper 服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。\n\n**内存数据**\n\nZooKeeper 的数据模型可以看作一棵树形结构，而数据节点就是这棵树上的叶子节点。\n\n从数据存储的角度看，ZooKeeper 的数据模型是存储在内存中的。\n\n我们可以把 ZooKeeper 的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的 ACL 权限信息以及 stat 状态信息等。\n\n* 而在底层实现中，ZooKeeper 数据模型是通过 DataTree 类来定义的。\n\nDataTree 类定义了一个 ZooKeeper 数据的内存结构。\n\nDataTree 的内部定义类 nodes 节点类型、root 根节点信息、子节点的 WatchManager 监控信息等数据模型中的相关信息。\n\n可以说，一个 DataTree 类定义了 ZooKeeper 内存数据的逻辑结构。\n\n**事务日志**\n\n为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper 集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper 集群中的 Follow 和 Observer 服务器就会进行数据同步。\n\n> 而这两种角色服务器所接收到的信息就是 Leader 服务器的事务日志。\n\n在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个 ZooKeeper 集群的执行性能。\n\n# Watch机制\n\nZooKeeper 的客户端可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知；\n\n**如何实现：**\n\n我们可以通过向 ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：\n\n```java\nnew ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)\n```\n\n上面代码的意思是定义了一个了 ZooKeeper 客户端对象实例，并传入三个参数：\n\n* connectString 服务端地址\n\n* sessionTimeout：超时时间\n\n* Watcher：监控事件\n\n这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文 ，一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中。\n\n除此之外，ZooKeeper 客户端也可以通过 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：\n\n```java\ngetData(String path, Watcher watcher, Stat stat)\n```\n\n触发通知的条件：\n\n<img src=\"https://img-blog.csdnimg.cn/95ebb31561bd4ea2bed199cdf8b3bfce.png\"/>\n\n上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。\n\n* 例如在客户端连接服务端的时候，可以对数据节点的创建、删除、数据变更、子节点的更新等操作进行监控。\n\n**当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？**\n\n答案是否定的，Watch 事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的 Watch 事件。\n\n**订阅发布场景实现**\n\n> 提到 ZooKeeper 的应用场景，你可能第一时间会想到最为典型的发布订阅功能。\n\n发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。\n\n一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。\n\nZooKeeper 采用了两种模式结合的方式实现订阅发布功能。\n\n> 下面我们来分析一个具体案例：\n\n在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。\n\n通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper 的发布订阅功能就能解决这个问题。\n\n我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper 数据节点中。\n\n如`/confs/data_item1`。\n\n* 服务器集群客户端对该节点添加 Watch 事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。\n\n* 而当该节点数据发生变化时，ZooKeeper 服务器会发送 Watch 事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。\n\n我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对 ZooKeeper 服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。\n\n> 要注意一点是，我们提到 Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch 事件。\n\n# 会话机制\n\nZooKeeper 的工作方式一般是通过客户端向服务端发送请求而实现的。\n\n而在一个请求的发送过程中，首先，客户端要与服务端进行连接，而一个连接就是一个会话。\n\n> 在 ZooKeeper 中，一个会话可以看作是一个用于表示客户端与服务器端连接的数据结构 Session。\n\n这个数据结构由三个部分组成：分别是会话 ID（sessionID）、会话超时时间（TimeOut）、会话关闭状态（isClosing）\n\n- 会话 ID：会话 ID 作为一个会话的标识符，当我们创建一次会话的时候，ZooKeeper 会自动为其分配一个唯一的 ID 编码。\n\n- 会话超时时间：一般来说，一个会话的超时时间就是指一次会话从发起后到被服务器关闭的时长。而设置会话超时时间后，服务器会参考设置的超时时间，最终计算一个服务端自己的超时时间。而这个超时时间则是最终真正用于 ZooKeeper 中服务端用户会话管理的超时时间。\n\n- 会话关闭状态：会话关闭 isClosing 状态属性字段表示一个会话是否已经关闭。如果服务器检查到一个会话已经因为超时等原因失效时， ZooKeeper 会在该会话的 isClosing 属性值标记为关闭，再之后就不对该会话进行操作了。\n\n**会话状态**\n\n在 ZooKeeper 服务的运行过程中，会话会经历不同的状态变化。\n\n这些状态包括：\n\n> 正在连接（CONNECTING）、已经连接（CONNECTIED）、正在重新连接（RECONNECTING）、已经重新连接（RECONNECTED）、会话关闭（CLOSE）等。\n\n当客户端开始创建一个与服务端的会话操作时，它的会话状态就会变成 CONNECTING，之后客户端会根据服务器地址列表中的服务器 IP 地址分别尝试进行连接。如果遇到一个 IP 地址可以连接到服务器，那么客户端会话状态将变为 CONNECTIED。\n\n如果因为网络原因造成已经连接的客户端会话断开时，客户端会重新尝试连接服务端。而对应的客户端会话状态又变成 CONNECTING ，直到该会话连接到服务端最终又变成 CONNECTIED。\n\n> 在 ZooKeeper 服务的整个运行过程中，会话状态经常会在 CONNECTING 与 CONNECTIED 之间进行切换。\n\n最后，当出现超时或者客户端主动退出程序等情况时，客户端会话状态则会变为 CLOSE 状态。\n\n**会话异常**\n\n在 ZooKeeper 中，会话的超时异常包括客户端 readtimeout 异常和服务器端 sessionTimeout 异常。\n\n* 在我们平时的开发中，要明确这两个异常的不同之处在于一个是发生在客户端，而另一个是发生在服务端。\n\n而对于那些对 ZooKeeper 接触不深的开发人员来说，他们常常踩坑的地方在于，虽然设置了超时间，但是在实际服务运行的时候 ZooKeeper 并没有按照设置的超时时间来管理会话。\n\n* 这是因为 ZooKeeper 实际起作用的超时时间是通过客户端和服务端协商决定。 \n\nZooKeeper 客户端在和服务端建立连接的时候，会提交一个客户端设置的会话超时时间，而该超时时间会和服务端设置的最大超时时间和最小超时时间进行比对，如果正好在其允许的范围内，则采用客户端的超时时间管理会话。\n\n如果大于或者小于服务端设置的超时时间，则采用服务端设置的值管理会话。\n\n**分桶策略**\n\n我们知道在 ZooKeeper 中为了保证一个会话的存活状态，客户端需要向服务器周期性地发送心跳信息。\n\n* 而客户端所发送的心跳信息可以是一个 ping 请求，也可以是一个普通的业务请求。\n\nZooKeeper 服务端接收请求后，会更新会话的过期时间，来保证会话的存活状态。\n\n* 所以在 ZooKeeper 的会话管理中，最主要的工作就是管理会话的过期时间。\n\n> ZooKeeper 中采用了独特的会话管理方式来管理会话的过期时间。\n\n在 ZooKeeper 中，会话将按照不同的时间间隔进行划分，超时时间相近的会话将被放在同一个间隔区间中，这种方式避免了 ZooKeeper 对每一个会话进行检查，而是采用分批次的方式管理会话。\n\n这就降低了会话管理的难度，因为每次小批量的处理会话过期也提高了会话处理的效率。\n\n**ZooKeeper 这种会话管理的好处？**\n\nZooKeeper 这种分段的会话管理策略大大提高了计算会话过期的效率，如果是在一个实际生产环境中，一个大型的分布式系统往往具有很高的访问量。\n\n而 ZooKeeper 作为其中的组件，对外提供服务往往要承担数千个客户端的访问，这其中就要对这几千个会话进行管理。\n\n在这种场景下，要想通过对每一个会话进行管理和检查并不合适，所以采用将同一个时间段的会话进行统一管理，这样就大大提高了服务的运行效率。\n\n**底层实现**\n\nZooKeeper 底层实现的原理，核心的一点就是过期队列这个数据结构。所有会话过期的相关操作都是围绕这个队列进行的。\n\n* 可以说 ZooKeeper 底层就是采用这个队列结构来管理会话过期的。\n\n**一个会话过期队列是由若干个 bucket 组成的。**\n\n* bucket 是一个按照时间划分的区间。\n\n* 在 ZooKeeper 中，通常以 expirationInterval 为单位进行时间区间的划分，它是 ZooKeeper 分桶策略中用于划分时间区间的最小单位。\n\n* 在 ZooKeeper 中，一个过期队列由不同的 bucket 组成。\n\n* 每个 bucket 中存放了在某一时间内过期的会话。\n\n将会话按照不同的过期时间段分别维护到过期队列之后，在 ZooKeeper 服务运行的过程中，具体的执行过程如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/86243433c4674237b3339452d2bc0e7c.png\"/>\n\n首先，ZooKeeper 服务会开启一个线程专门用来检索过期队列，找出要过期的 bucket，而 ZooKeeper 每次只会让一个 bucket 的会话过期，每当要进行会话过期操作时，ZooKeeper 会唤醒一个处于休眠状态的线程进行会话过期操作，之后会按照上面介绍的操作检索过期队列，取出过期的会话后会执行过期操作。\n\n# ACL权限\n\nZooKeeper的ACL可针对znodes设置相应的权限信息。\n\n一个 ACL 权限设置通常可以分为 3 部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。\n\n* 最终组成一条例如`scheme:id:permission`格式的 ACL 请求信息。\n\n**权限模式：Scheme**\n\nZooKeeper 的权限验证方式大体分为两种类型，一种是范围验证，另外一种是口令验证。\n\n> 范围验证\n\n所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。\n\n比如我们可以让一个 IP 地址为`ip：192.168.0.11`的机器对服务器上的某个数据节点具有写入的权限。\n\n或者也可以通过`ip:192.168.0.11/22`给一段 IP 地址的机器赋权。\n\n> 口令验证\n\n可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。\n\n在 ZooKeeper 中这种验证方式是 Digest 认证，我们知道通过网络传输相对来说并不安全，所以绝不通过明文在网络发送密码也是程序设计中很重要的原则之一，而 Digest 这种认证方式首先在客户端传送`username:password`这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。\n\n> Super 权限模式\n\n权限模式 Super 可以认为是一种特殊的 Digest 认证。\n\n\n具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。\n\n下面这段代码给出了 Digest 模式下客户端的调用方式。\n\n```\n//创建节点\ncreate /digest_node1\n//设置digest权限验证\nsetAcl /digest_node1 digest:用户名:base64格式密码:rwadc \n//查询节点Acl权限\ngetAcl /digest_node1 \n//授权操作\naddauth digest user:passwd\n```\n\n> 如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。\n\n对其创建的节点要想进行修改应该怎么做呢？\n\n我们可以通过**super 模式**即超级管理员的方式删除该节点或变更该节点的权限验证方式。\n\n正因为**super 模式**有如此大的权限，我们在平时使用时也应该更加谨慎。\n\n> world 模式\n\n这种授权模式对应于系统中的所有用户，本质上起不到任何作用。\n\n设置了 world 权限模式系统中的所有用户操作都可以不进行权限验证。\n\n**授权对象（ID）**\n\n所谓的授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。\n\n如果是 World 模式，是授权系统中所有的用户。\n\n**权限信息（Permission）**\n\n权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：\n\n* 数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；\n\n* 数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；\n\n* 数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；\n\n* 数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；\n\n* 数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。\n\n> 需要注意的一点是，每个节点都有维护自身的 ACL 权限数据，即使是该节点的子节点也是有自己的 ACL 权限而不是直接继承其父节点的权限。\n\n**实现自己的权限口控制**\n\n虽然 ZooKeeper 自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。\n\n官方文档中对这种机制的定义是 `Pluggable ZooKeeper Authenication`，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。那么这种机制是如何实现的呢？\n\n> 要想实现自定义的权限控制机制，最核心的一点是实现 ZooKeeper 提供的权限控制器接口 AuthenticationProvider。\n\n实现了自定义权限后，如何才能让 ZooKeeper 服务端使用自定义的权限验证方式呢？\n\n接下来就需要将自定义的权限控制注册到 ZooKeeper 服务器中，而注册的方式通常有两种。\n\n* 第一种是通过设置系统属性来注册自定义的权限控制器：\n\n```java\n-Dzookeeper.authProvider.x=CustomAuthenticationProvider\n```\n\n* 另一种是在配置文件` zoo.cfg `中进行配置：\n\n```java\nauthProvider.x=CustomAuthenticationProvider\n```\n\n**实现原理**\n\n首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。\n\n在授权接口中，值得注意的是会话的授权信息存储在 ZooKeeper 服务端的内存中，如果客户端会话关闭，授权信息会被删除。\n\n下次连接服务器后，需要重新调用授权接口进行授权。\n\n# 序列化方式\n\n在 ZooKeeper 中并没有采用和 Java 一样的序列化方式，而是采用了一个 Jute 的序列解决方案作为 ZooKeeper 框架自身的序列化方式。\n\n> ZooKeeper 从最开始就采用 Jute 作为其序列化解决方案，直到其最新的版本依然没有更改。\n\n虽然 ZooKeeper 一直将 Jute 框架作为序列化解决方案，但这并不意味着 Jute 相对其他框架性能更好，反倒是 Apache Avro、Thrift 等框架在性能上优于前者。\n\n之所以 ZooKeeper 一直采用 Jute 作为序列化解决方案，主要是新老版本的兼容等问题。\n\n**如何 使用 Jute 实现序列化**\n\n如果我们要想将某个定义的类进行序列化，首先需要该类实现 Record 接口的 serilize 和 deserialize 方法，这两个方法分别是序列化和反序列化方法。\n\n> 下边这段代码给出了我们一般在 ZooKeeper 中进行序列化的具体实现：\n\n首先，我们定义了一个` test_jute `类，为了能够对它进行序列化，需要该` test_jute `类实现 Record 接口，并在对应的 serialize 序列化方法和 deserialize 反序列化方法中编辑具体的实现逻辑。\n\n```java\nclass test_jute implements Record{\n  private long ids；\n  private String name;\n  ...\n  public void serialize(OutpurArchive a_,String tag){\n    ...\n  }\n  public void deserialize(INputArchive a_,String tag){\n    ...\n  }\n}\n```\n\n在序列化方法 serialize 中，我们要实现的逻辑是，首先通过字符类型参数 tag 传递标记序列化标识符，之后使用 writeLong 和 writeString 等方法分别将对象属性字段进行序列化。\n\n```java\npublic void serialize(OutpurArchive a_,String tag) throws ...{\n  a_.startRecord(this.tag);\n  a_.writeLong(ids,\"ids\");\n  a_.writeString(type,\"name\");\n  a_.endRecord(this,tag);\n}\n```\n\n调用 derseralize 在实现反序列化的过程则与我们上边说的序列化过程正好相反。\n\n```java\npublic void deserialize(INputArchive a_,String tag) throws {\n  a_.startRecord(tag);\n  ids = a_.readLong(\"ids\");\n  name = a_.readString(\"name\");\n  a_.endRecord(tag);\n}\n```\n\n序列化和反序列化的实现逻辑编码方式相对固定，首先通过 startRecord 开启一段序列化操作，之后通过 writeLong、writeString 或 readLong、 readString 等方法执行序列化或反序列化。\n\n本例中只是实现了长整型和字符型的序列化和反序列化操作，除此之外 ZooKeeper 中的 Jute 框架还支持整数类型（Int）、布尔类型（Bool）、双精度类型（Double）以及 Byte/Buffer 类型。\n\n# 集群\n\n**ZooKeeper集群模式的特点**\n\n在 ZooKeeper 集群中将服务器分成 **Leader 、Follow 、Observer 三**种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：\n\n- Leader 角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者，既可以为客户端提供写服务又能提供读服务。\n\n- Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader 服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个 Follow 服务器作为新的 Leader 服务器，只能提供读服务。\n\n- Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与 Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器，只能提供读服务。\n\n在 ZooKeeper 集群接收到来自客户端的会话请求操作后，首先会判断该条请求是否是事务性的会话请求。\n\n> 对于事务性的会话请求，ZooKeeper 集群服务端会将该请求统一转发给 Leader 服务器进行操作。\n>\n> 所谓事务性请求，是指 ZooKeeper 服务器执行完该条会话请求后，是否会导致执行该条会话请求的服务器的数据或状态发生改变，进而导致与其他集群中的服务器出现数据不一致的情况。\n\nLeader 服务器内部执行该条事务性的会话请求后，再将数据同步给其他角色服务器，从而保证事务性会话请求的执行顺序，进而保证整个 ZooKeeper 集群的数据一致性。\n\n> 在 ZooKeeper 集群的内部实现中，是通过什么方法保证所有 ZooKeeper 集群接收到的事务性会话请求都能交给 Leader 服务器进行处理的呢？\n\n在 ZooKeeper 集群内部，集群中除 Leader 服务器外的其他角色服务器接收到来自客户端的事务性会话请求后，必须将该条会话请求转发给 Leader 服务器进行处理。\n\nZooKeeper 集群中的 Follow 和 Observer 服务器，都会检查当前接收到的会话请求是否是事务性的请求，如果是事务性的请求，那么就将该请求以 REQUEST 消息类型转发给 Leader 服务器。\n\n在 ZooKeeper集群中的服务器接收到该条消息后，会对该条消息进行解析。\n\n* 分析出该条消息所包含的原始客户端会话请求。\n\n* 之后将该条消息提交到自己的 Leader 服务器请求处理链中，开始进行事务性的会话请求操作。\n\n* 如果不是事务性请求，ZooKeeper 集群则交由 Follow 和 Observer 角色服务器处理该条会话请求，如查询数据节点信息。\n\n当一个业务场景在查询操作多而创建删除等事务性操作少的情况下，ZooKeeper 集群的性能表现的就会很好。\n\n> 如果是在极端情况下，ZooKeeper 集群只有事务性的会话请求而没有查询操作，那么 Follow 和 Observer 服务器就只能充当一个请求转发服务器的角色， 所有的会话的处理压力都在 Leader 服务器。\n\n在处理性能上整个集群服务器的瓶颈取决于 Leader 服务器的性能。\n\n> ZooKeeper 集群的作用只能保证在 Leader 节点崩溃的时候，重新选举出 Leader 服务器保证系统的稳定性。\n\n这也是 ZooKeeper 设计的一个缺点。\n\n**Leader选举**\n\nLeader 服务器的选举操作主要发生在两种情况下。\n\n第一种就是 ZooKeeper 集群服务启动的时候，第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时，这时 ZooKeeper 集群需要选举出新的 Leader 服务器。\n\n> ZooKeeper 集群重新选举 Leader 的过程只有 Follow 服务器参与工作。\n\n> 服务器状态\n\n服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。\n\n* **LOOKING**：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。\n\n* **FOLLOWING**：跟随者状态。表明当前服务器角色是Follower。\n\n* **LEADING**：领导者状态。表明当前服务器角色是Leader。\n\n* **OBSERVING**：观察者状态。表明当前服务器角色是Observer。\n\n**事务ID（zxid）**\n\nZookeeper的状态变化，都会由一个Zookeeper事务ID（ZXID）标识。\n\n> 写入Zookeeper，会导致状态变化，每次写入都会导致ZXID发生变化。\n\nZXID由Leader统一分配，全局唯一，长度64位，递增。\n\nZXID展示了所有的Zookeeper转台变更顺序，每次变更都有一个唯一ZXID，如果zxid1小于zxid2，则说明zxid1的事务在zxid2的事务之前发生。\n\n**选举过程**\n\n在 ZooKeeper 集群重新选举 Leader 节点的过程中，主要可以分为 Leader 失效发现、重新选举 Leader 、Follow 服务器角色变更、集群同步这几个步骤。\n\n> Leader 失效发现\n\n在 ZooKeeper 集群中，当 Leader 服务器失效时，ZooKeeper 集群会重新选举出新的 Leader 服务器。\n\n* 在 ZooKeeper 集群中，探测 Leader 服务器是否存活的方式与保持客户端活跃性的方法非常相似。\n\n首先，Follow 服务器会定期向 Leader 服务器发送 网络请求，在接收到请求后，Leader 服务器会返回响应数据包给 Follow 服务器，而在 Follow 服务器接收到 Leader 服务器的响应后，如果判断 Leader 服务器运行正常，则继续进行数据同步和服务转发等工作，反之，则进行 Leader 服务器的重新选举操作。\n\n> Leader重新选举\n\n当 Follow 服务器向 Leader 服务器发送状态请求包后，如果没有得到 Leader 服务器的返回信息，这时，如果是集群中个别的 Follow 服务器发现返回错误，并不会导致 ZooKeeper 集群立刻重新选举 Leader 服务器，而是将该 Follow 服务器的状态变更为 LOOKING 状态，并向网络中发起投票，当 ZooKeeper 集群中有更多的机器发起投票，最后当投票结果满足多数原则的情况下。\n\nZooKeeper 会重新选举出 Leader 服务器。\n\n> Follow 角色变更\n\n在 ZooKeeper 集群中，Follow 服务器作为 Leader 服务器的候选者，当被选举为 Leader 服务器之后，其在 ZooKeeper 集群中的 Follow 角色，也随之发生改变。也就是要转变为 Leader 服务器，并作为 ZooKeeper 集群中的 Leader 角色服务器对外提供服务。\n\n> 集群同步数据\n\n在 ZooKeeper 集群成功选举 Leader 服务器，并且候选 Follow 服务器的角色变更后。\n\n为避免在这期间导致的数据不一致问题，ZooKeeper 集群在对外提供服务之前，会通过 Leader 角色服务器管理同步其他角色服务器。\n\n**底层实现**\n\n首先，ZooKeeper 集群会先判断 Leader 服务器是否失效，而判断的方式就是 Follow 服务器向 Leader 服务器发送请求包，之后 Follow 服务器接收到响应数据后，进行解析，Follow 服务器会根据返回的数据，判断 Leader 服务器的运行状态，如果返回的是 LOOKING 关键字，表明与集群中 Leader 服务器无法正常通信。\n\n* 之后，在 ZooKeeper 集群选举 Leader 服务器时，是通过 **FastLeaderElection** 类实现的。\n\n该类实现了 TCP 方式的通信连接，用于在 ZooKeeper 集群中与其他 Follow 服务器进行协调沟通。\n\nFastLeaderElection 类继承了 Election 接口，定义其是用来进行选举的实现类。\n\n* 而在其内部，又定义了选举通信相关的一些配置参数，比如 finalizeWait 最终等待时间、最大通知间隔时间 maxNotificationInterval 等。\n\n在选举的过程中，首先调用 ToSend 函数向 ZooKeeper 集群中的其他角色服务器发送本机的投票信息，其他服务器在接收投票信息后，会对投票信息进行有效性验证等操作，之后 ZooKeeper 集群统计投票信息，如果过半数的机器投票信息一致，则集群就重新选出新的 Leader 服务器。\n\n> 这里我们要注意一个问题，那就是在重新选举 Leader 服务器的过程中，ZooKeeper 集群理论上是无法进行事务性的请求处理的。\n\n因此，发送到 ZooKeeper 集群中的事务性会话会被挂起，暂时不执行，等到选举出新的 Leader 服务器后再进行操作。 \n\n**Observer**\n\n在 ZooKeeper 集群服务运行的过程中，Observer 服务器与 Follow 服务器具有一个相同的功能，那就是负责处理来自客户端的诸如查询数据节点等非事务性的会话请求操作。\n\n* 但与 Follow 服务器不同的是，Observer 不参与 Leader 服务器的选举工作，也不会被选举为 Leader 服务器。\n\n在早期的 ZooKeeper 集群服务运行过程中，只有 Leader 服务器和 Follow 服务器。\n\n不过随着 ZooKeeper 在分布式环境下的广泛应用，早期模式的设计缺点也随之产生，主要带来的问题有如下几点：\n\n* 随着集群规模的变大，集群处理写入的性能反而下降。\n\n* ZooKeeper 集群无法做到跨域部署。\n\n其中最主要的问题在于，当 ZooKeeper 集群的规模变大，集群中 Follow 服务器数量逐渐增多的时候，ZooKeeper 处理创建数据节点等事务性请求操作的性能就会逐渐下降。\n\n这是因为 ZooKeeper 集群在处理事务性请求操作时，要在 ZooKeeper 集群中对该事务性的请求发起投票，只有超过半数的 Follow 服务器投票一致，才会执行该条写入操作。\n\n正因如此，随着集群中 Follow 服务器的数量越来越多，一次写入等相关操作的投票也就变得越来越复杂，并且 Follow 服务器之间彼此的网络通信也变得越来越耗时，导致随着 Follow 服务器数量的逐步增加，事务性的处理性能反而变得越来越低。\n\n* 为了解决这一问题，在 ZooKeeper 3.6 版本后，ZooKeeper 集群中创建了一种新的服务器角色，即 Observer——观察者角色服务器。\n\nObserver 可以处理 ZooKeeper 集群中的非事务性请求，并且不参与 Leader 节点等投票相关的操作。\n\n这样既保证了 ZooKeeper 集群性能的扩展性，又避免了因为过多的服务器参与投票相关的操作而影响 ZooKeeper 集群处理事务性会话请求的能力。\n\n* 在实际部署的时候，因为 Observer 不参与 Leader 节点等操作，并不会像 Follow 服务器那样频繁的与 Leader 服务器进行通信。\n\n因此，可以将 Observer 服务器部署在不同的网络区间中，这样也不会影响整个 ZooKeeper 集群的性能，也就是所谓的跨域部署。\n\n**在我们日常使用 ZooKeeper 集群服务器的时候，集群中的机器个数应该选择奇数个？**\n\n两个原因：\n\n> 在容错能力相同的情况下，奇数台更节省资源\n\nZookeeper中 Leader 选举算法采用了Zab协议。\n\nZab核心思想是当多数 Server 写成功，则写成功。\n\n举两个例子：\n\n* 假如zookeeper集群1 ，有3个节点，3/2=1.5 ,  即zookeeper想要正常对外提供服务（即leader选举成功），至少需要2个节点是正常的。换句话说，3个节点的zookeeper集群，允许有一个节点宕机。\n\n* 假如zookeeper集群2，有4个节点，4/2=2 , 即zookeeper想要正常对外提供服务（即leader选举成功），至少需要3个节点是正常的。换句话说，4个节点的zookeeper集群，也允许有一个节点宕机。\n\n集群1与集群2都有 允许1个节点宕机 的容错能力，但是集群2比集群1多了1个节点。在相同容错能力的情况下，本着节约资源的原则，zookeeper集群的节点数维持奇数个更好一些。\n\n> 防止由脑裂造成的集群不可用。\n\n集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。\n\n下面举例说一下为什么采用奇数台节点，就可以防止由于脑裂造成的服务不可用：\n\n假如zookeeper集群有 5 个节点，发生了脑裂，脑裂成了A、B两个小集群： \n\n* A ： 1个节点 ，B ：4个节点 \n\n* A ： 2个节点， B ：3个节点 \n\n可以看出，上面这两种情况下，A、B中总会有一个小集群满足 可用节点数量 > 总节点数量/2 。\n\n所以zookeeper集群仍然能够选举出leader ， 仍然能对外提供服务，只不过是有一部分节点失效了而已。\n\n假如zookeeper集群有4个节点，同样发生脑裂，脑裂成了A、B两个小集群：\n\n* A：1个节点 ，  B：3个节点 \n\n* A：2个节点 ， B：2个节点\n\n因为A和B都是2个节点，都不满足 可用节点数量 > 总节点数量/2 的选举条件， 所以此时zookeeper就彻底不能提供服务了。\n\n# ZAB协议\n\n**ZAB 协议算法**\n\nZooKeeper 最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。\n\n> 为了解决这个问题，ZooKeeper 采用了 ZAB 协议算法。\n\nZAB 协议算法（Zookeeper Atomic Broadcast  ，Zookeeper 原子广播协议）是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是崩溃恢复和原子广播协议。\n\n* 在整个 ZAB 协议的底层实现中，ZooKeeper 集群主要采用主从模式的系统架构方式来保证 ZooKeeper 集群系统的一致性。\n\n当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。\n\n> 以 ZooKeeper 集群为例，这个操作过程可以概括为：\n\n当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。\n\n当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。\n\n然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。\n\n**崩溃恢复**\n\n当集群中的 Leader 发生故障的时候，整个集群就会因为缺少 Leader 服务器而无法处理来自客户端的事务性的会话请求。\n\n> 因此，为了解决这个问题。在 ZAB 协议中也设置了处理该问题的崩溃恢复机制。\n\n崩溃恢复机制是保证 ZooKeeper 集群服务高可用的关键。触发 ZooKeeper 集群执行崩溃恢复的事件是集群中的 Leader 节点服务器发生了异常而无法工作，于是 Follow 服务器会通过投票来决定是否选出新的 Leader 节点服务器。\n\n> 投票过程如下：\n\n当崩溃恢复机制开始的时候，整个 ZooKeeper 集群的每台 Follow 服务器会发起投票，并同步给集群中的其他 Follow 服务器。\n\n在接收到来自集群中的其他 Follow 服务器的投票信息后，集群中的每个 Follow 服务器都会与自身的投票信息进行对比，如果判断新的投票信息更合适，则采用新的投票信息作为自己的投票信息。在集群中的投票信息还没有达到超过半数原则的情况下，再进行新一轮的投票，最终当整个 ZooKeeper 集群中的 Follow 服务器超过半数投出的结果相同的时候，就会产生新的 Leader 服务器。\n\n> 选票结构：\n\n以 Fast Leader Election 选举的实现方式来讲，如下图所示，一个选票的整体结果可以分为一下六个部分：\n\n<img src=\"https://img-blog.csdnimg.cn/2956e37edd2d482fb3545a7b35ffe7ae.png\"/>\n\n* logicClock：用来记录服务器的投票轮次。logicClock 会从 1 开始计数，每当该台服务经过一轮投票后，logicClock 的数值就会加 1 。\n\n* state：用来标记当前服务器的状态。在 ZooKeeper 集群中一台服务器具有 LOOKING、FOLLOWING、LEADERING、OBSERVING 这四种状态。\n\n* `self_id`：用来表示当前服务器的 ID 信息，该字段在 ZooKeeper 集群中主要用来作为服务器的身份标识符。\n\n* `self_zxid`： 当前服务器上所保存的数据的最大事务 ID ，从 0 开始计数。\n\n* `vote_id`：投票要被推举的服务器的唯一 ID 。\n\n* `vote_zxid`：被推举的服务器上所保存的数据的最大事务 ID ，从 0 开始计数。\n\n当 ZooKeeper 集群需要重新选举出新的 Leader 服务器的时候，就会根据上面介绍的投票信息内容进行对比，以找出最适合的服务器。\n\n> 选票筛选\n\n当一台 Follow 服务器接收到网络中的其他 Follow 服务器的投票信息后，是如何进行对比来更新自己的投票信息的。\n\nFollow 服务器进行选票对比的过程，如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/977516cbd09d4fb8aad57004147221a6.png\" />\n\n首先，会对比 logicClock 服务器的投票轮次，当 logicClock 相同时，表明两张选票处于相同的投票阶段，并进入下一阶段，否则跳过。\n\n接下来再对比` vote_zxid `被选举的服务器 ID 信息，若接收到的外部投票信息中的 `vote_zxid `字段较大，则将自己的票中的` vote_zxid `与` vote_myid `更新为收到的票中的` vote_zxid `与` vote_myid` ，并广播出去。\n\n要是对比的结果相同，则继续对比` vote_myid `被选举服务器上所保存的最大事务 ID ，若外部投票的` vote_myid` 比较大，则将自己的票中的 `vote_myid `更新为收到的票中的` vote_myid` 。 \n\n经过这些对比和替换后，最终该台 Follow 服务器会产生新的投票信息，并在下一轮的投票中发送到 ZooKeeper 集群中。\n\n**消息广播**\n\n在 Leader 节点服务器处理请求后，需要通知集群中的其他角色服务器进行数据同步。ZooKeeper 集群采用消息广播的方式发送通知。\n\nZooKeeper 集群使用原子广播协议进行消息发送，该协议的底层实现过程与二阶段提交过程非常相似，如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/fb518bd2f20c45539765e0b76e54387d.png\"/>\n\n当要在集群中的其他角色服务器进行数据同步的时候，Leader 服务器将该操作过程封装成一个 Proposal 提交事务，并将其发送给集群中其他需要进行数据同步的服务器。\n\n当这些服务器接收到 Leader 服务器的数据同步事务后，会将该条事务能否在本地正常执行的结果反馈给 Leader 服务器，Leader 服务器在接收到其他 Follow 服务器的反馈信息后进行统计，判断是否在集群中执行本次事务操作。\n\n这里请注意 ，与二阶段提交过程不同（即需要集群中所有服务器都反馈可以执行事务操作后，主服务器再次发送 commit 提交请求执行数据变更） ，ZAB 协议算法省去了中断的逻辑，当 ZooKeeper 集群中有超过一半的 Follow 服务器能够正常执行事务操作后，整个 ZooKeeper 集群就可以提交 Proposal 事务了。\n\n# 日志清理\n\n**日志类型**\n\n在 ZooKeeper 服务运行的时候，一般会产生数据快照和日志文件，数据快照用于集群服务中的数据同步，而数据日志则记录了 ZooKeeper 服务运行的相关状态信息。\n\n> 其中，数据日志是我们在生产环境中需要定期维护和管理的文件。\n\n**清理方案**\n\n如上面所介绍的，面对生产系统中产生的日志，一般的维护操作是备份和清理。\n\n备份是为了之后对系统的运行情况进行排查和优化，而清理主要因为随着系统日志的增加，日志会逐渐占用系统的存储空间，如果一直不进行清理，可能耗尽系统的磁盘存储空间，并最终影响服务的运行。\n\n**清理工具**\n\n> Corntab\n\n首先，我们介绍的是 Linux corntab ，它是 Linux 系统下的软件，可以自动地按照我们设定的时间，周期性地执行我们编写的相关脚本。\n\ncrontab 定时脚本的方式相对灵活，可以按照我们的业务需求来设置处理日志的维护方式，比如这里我们希望定期清除 ZooKeeper 服务运行的日志，而不想清除数据快照的文件，则可以通过脚本设置，达到只对数据日志文件进行清理的目的。\n\n> PurgeTxnLog\n\nZooKeeper 自身还提供了 PurgeTxnLog 工具类，用来清理 snapshot 数据快照文件和系统日志。\n\nPurgeTxnLog 清理方式和我们上面介绍的方式十分相似，也是通过定时脚本执行任务，唯一的不同是，上面提到在编写日志清除 logsCleanWeek 的时候 ，我们使用的是原生 shell 脚本自己手动编写的数据日志清理逻辑，而使用 PurgeTxnLog 则可以在编写清除脚本的时候调用 ZooKeeper 为我们提供的工具类完成日志清理工作。\n\n如下面的代码所示，首先，我们在` /usr/bin `目录下创建一个 PurgeLogsClean 脚本。注意这里的脚本也是一个 shell 文件。\n\n在脚本中我们只需要编写 PurgeTxnLog 类的调用程序，系统就会自动通过 PurgeTxnLog 工具类为我们完成对应日志文件的清理工作。\n\n```\n#!/bin/sh  \njava -cp \"$CLASSPATH\" org.apache.zookeeper.server.PurgeTxnLog \necho \"清理完成\" \n```\n\nPurgeTxnLog 方式与 crontab 相比，使用起来更加容易而且也更加稳定安全，不过 crontab 方式更加灵活，我们可以根据不同的业务需求编写自己的清理逻辑。\n\n# 实现分布式锁\n\n分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。\n\n> 实现分布式锁目前有三种流行方案，即基于数据库、Redis、ZooKeeper 的方案\n\n**方案一：**\n\n使用节点中的存储数据区域，ZK中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识\n\n**方案二：**\n\n使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可\n\n<img src=\"https://img-blog.csdnimg.cn/b4f8396f620f4a778b01bb573ca5969f.png\"/>\n\n**死锁风险:**\n\n两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁\n\n* 方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行\n\n* 方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与ZK的连接，ZK检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的\n\n**避免羊群效应**\n\n把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。\n\n如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。\n\n> 为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。\n\n每次锁被释放，只会有一个锁请求者 会被通知到。\n\n这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。\n\n<img src=\"https://img-blog.csdnimg.cn/20b0e4cf4ae3424c999ba9fb4f704a8a.png\"/>\n\n**用 ZooKeeper 实现分布式锁的算法流程，根节点为 /lock：**\n\n- 客户端连接 ZooKeeper，并`在/lock `下创建临时有序子节点，第一个客户端对应的子节点为` /lock/lock01/00000001`，第二个为 `/lock/lock01/00000002`；\n- 其他客户端获取` /lock01 `下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；\n\n- 如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听`/lock01 `的子节点变更消息，获得变更通知后重复此步骤直至获得锁；\n- 完成业务流程后，删除对应的子节点，释放分布式锁；\n\n在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。\n\n# 实现分布式ID\n\n我们可以通过 ZooKeeper 自身的客户端和服务器运行模式，来实现一个分布式网络环境下的 ID 请求和分发过程。\n\n> 每个需要 ID 编码的业务服务器可以看作是 ZooKeeper 的客户端。ID 编码生成器可以作为 ZooKeeper 的服务端。\n\n客户端通过发送请求到 ZooKeeper 服务器，来获取编码信息，服务端接收到请求后，发送 ID 编码给客户端。\n\n**实现原理：**\n\n可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。\n\n* 客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。\n\n* 客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。\n\n利用 ZooKeeper 中的顺序节点特性，很容易使我们创建的 ID 编码具有有序的特性。并且我们也可以通过客户端传递节点的名称，根据不同的业务编码区分不同的业务系统，从而使编码的扩展能力更强。\n\n> 虽然使用 ZooKeeper 的实现方式有这么多优点，但也会有一些潜在的问题。\n\n其中最主要的是，在定义编码的规则上还是强烈依赖于程序员自身的能力和对业务的深入理解。\n\n很容易出现因为考虑不周，造成设置的规则在运行一段时间后，无法满足业务要求或者安全性不够等问题。\n\n# 实现负载均衡\n\n**常见负载均衡算法**\n\n> 轮询法\n\n轮询法是最为简单的负载均衡算法，当接收到来自网络中的客户端请求后，负载均衡服务器会按顺序逐个分配给后端服务。\n\n比如集群中有 3 台服务器，分别是 server1、server2、server3，轮询法会按照 sever1、server2、server3 这个顺序依次分发会话请求给每个服务器。当第一次轮询结束后，会重新开始下一轮的循环。\n\n> 随机法\n\n随机算法是指负载均衡服务器在接收到来自客户端的请求后，会根据一定的随机算法选中后台集群中的一台服务器来处理这次会话请求。\n\n不过，当集群中备选机器变的越来越多时，通过统计学我们可以知道每台机器被抽中的概率基本相等，因此随机算法的实际效果越来越趋近轮询算法。\n\n> 原地址哈希法\n\n原地址哈希算法的核心思想是根据客户端的 IP 地址进行哈希计算，用计算结果进行取模后，根据最终结果选择服务器地址列表中的一台机器，处理该条会话请求。\n\n采用这种算法后，当同一 IP 的客户端再次访问服务端后，负载均衡服务器最终选举的还是上次处理该台机器会话请求的服务器，也就是每次都会分配同一台服务器给客户端。\n\n> 加权轮询法\n\n加权轮询的方式与轮询算法的方式很相似，唯一的不同在于选择机器的时候，不只是单纯按照顺序的方式选择，还根据机器的配置和性能高低有所侧重，配置性能好的机器往往首先分配。\n\n> 加权随机法\n\n加权随机法和我们上面提到的随机算法一样，在采用随机算法选举服务器的时候，会考虑系统性能作为权值条件。\n\n> 最小连接数法\n\n最小连接数算法是指，根据后台处理客户端的连接会话条数，计算应该把新会话分配给哪一台服务器。\n\n一般认为，连接数越少的机器，在网络带宽和计算性能上都有很大优势，会作为最优先分配的对象。\n\n**利用 ZooKeeper 实现 负载均衡 算法**\n\n> 这里我们通过采用最小连接数算法，来确定究竟如何均衡地分配网络会话请求给后台客户端。\n\n如下图所示，建立的 ZooKeeper 数据模型中 Severs 节点可以作为存储服务器列表的父节点。\n\n在它下面创建 servers_host1、servers_host2、servers_host3等临时节点来存储集群中的服务器运行状态信息。\n\n<img src=\"https://img-blog.csdnimg.cn/2c6c94ef4c1443ecbe0084b5d4ad7ea2.png\"/>\n\n整个实现的过程如下图所示。\n\n<img src=\"https://img-blog.csdnimg.cn/b3ad367c3c024fd6ae57e4f7a2c9aa40.png\"/>\n\n* 首先，在接收到客户端的请求后，通过 getData 方法获取服务端 Severs 节点下的服务器列表，其中每个节点信息都存储有当前服务器的连接数。\n\n* 通过判断选择最少的连接数作为当前会话的处理服务器，并通过 setData 方法将该节点连接数加 1。\n\n* 最后，当客户端执行完毕，再调用 setData 方法将该节点信息减 1。\n* 我们定义当服务器接收到会话请求后。在 ZooKeeper 服务端增加连接数的 addBlance 方法。\n* 我们通过 readData 方法获取服务器最新的连接数，之后将该连接数加 1，再通过 writeData 方法将新的连接数信息写入到服务端对应节点信息中。\n\n* 当服务器处理完该会话请求后，需要更新服务端相关节点的连接数。\n\n* 具体的操作与 addBlance 方法基本一样，只是对获取的连接信息进行减一操作。\n\n**这里注意：**\n\n我们日常用到的负载均衡器主要是选择后台处理的服务器，并给其分发请求。\n\n> 而通过 ZooKeeper 实现的服务器，只提供了服务器的筛选工作。\n\n在请求分发的过程中，还是通过负载算法计算出要访问的服务器，之后客户端自己连接该服务器，完成请求操作。\n\n# 开源框架使用案例\n\n**Dubbo与ZooKeeper**\n\nDubbo 是阿里巴巴开发的一套开源的技术框架，是一款高性能、轻量级的开源 Java RPC 框架。\n\n**用ZooKeeper做注册中心**\n\n在整个 Dubbo 框架的实现过程中，注册中心是其中最为关键的一点，它保证了整个 PRC 过程中服务对外的透明性。\n\n而 Dubbo 的注册中心也是通过 ZooKeeper 来实现的。\n\n如下图所示，在整个 Dubbo 服务的启动过程中，服务提供者会在启动时向 `/dubbo/com.foo.BarService/providers `目录写入自己的 URL 地址，这个操作可以看作是一个 ZooKeeper 客户端在 ZooKeeper 服务器的数据模型上创建一个数据节点。\n\n服务消费者在启动时订阅 `/dubbo/com.foo.BarService/providers` 目录下的提供者 URL 地址，并向 `/dubbo/com.foo.BarService/consumers` 目录写入自己的 URL 地址。\n\n该操作是通过 ZooKeeper 服务器在 /consumers 节点路径下创建一个子数据节点，然后再在请求会话中发起对 /providers 节点的 watch 监控\n\n<img src=\"https://img-blog.csdnimg.cn/a27e2d30709947d7b995da6c091de3ba.png\"/>\n\n**Kafka与ZooKeeper**\n\n**Zookeeper的作用**\n\n由于 Broker 服务器采用分布式集群的方式工作，那么在服务的运行过程中，难免出现某台机器因异常而关闭的状况。\n\n为了保证整个 Kafka 集群的可用性，需要在系统中监控整个机器的运行情况。而 Kafka 可以通过 ZooKeeper 中的数据节点，将网络中机器的运行统计存储在数据模型中的 brokers 节点下。\n\n在 Kafka 的 Topic 信息注册中也需要使用到 ZooKeeper ，在 Kafka 中同一个Topic 消息容器可以分成多个不同片，而这些分区既可以存在于一台 Broker 服务器中，也可以存在于不同的 Broker 服务器中。\n\n而在 Kafka 集群中，每台 Broker 服务器又相对独立。\n\n为了能够读取这些以分布式方式存储的分区信息，Kafka 会将这些分区信息在 Broker 服务器中的对应关系存储在 ZooKeeper 数据模型的 topic 节点上，每一个 topic 在 ZooKeeper 数据节点上都会以 `/brokers/topics/[topic]` 的形式存在。\n\n![](https://img-blog.csdnimg.cn/058b3613e6204da8a467d8aa19f611b8.png)\n\n# 参考资料\n\n《从Paxos到Zookeeper 分布式一致性原理与实践》","slug":"公众号文章/ZooKeeper","published":1,"date":"2022-02-06T11:06:16.690Z","updated":"2022-02-06T16:49:23.538Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiv00f0fhji5784d73p","content":"<p>这一个月，一直在鼓捣自己的个人网站，没更新</p>\n<p>之前分享过几个系列：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/zfHoSsuSpXWOaxQrm7uvkA\">Kafka核心知识总结！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/m_awvdGYXd9SJQ8YePENGQ\">计算机网络常用知识总结！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/RpMwJrEqAP8K0vRTH392kg\">操作系统常用知识总结！</a></li>\n</ul>\n<p>今天这篇介绍一下ZooKeeper！</p>\n<p><strong>文章较长，可以点赞，收藏再看！</strong></p>\n<p>文章内容会同步到个人网站上，方便阅读：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/dc49ec91428d4b12b7c11292fb51acb6.png\"></p>\n<h1 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h1><p>Apache ZooKeeper（以下简称ZK）是由Apache Hadoop的子项目发展而来，为分布式应用提供高效且可靠的分布式协调服务。</p>\n<ul>\n<li>在解决分布式数据一致性方面，ZK没有直接采用Paxos算法，而是采用了ZAB（ZooKeeper Atomic Broadcast）协议。</li>\n</ul>\n<p>ZK可以提供诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知，集群管理，Master选举，分布式锁，分布式队列等功能。</p>\n<p><strong>它具有以下特性：</strong></p>\n<ul>\n<li><strong>顺序一致性</strong>：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；</li>\n<li><strong>原子性</strong>：要么所有应用，要么不应用；不存在部分机器应用了该事务，而<strong>另一部分没有应用</strong>的情况；</li>\n<li><strong>单一视图</strong>：所有客户端看到的服务端数据模型都是一致的，无论客户连接的是哪个ZK服务器；</li>\n<li><strong>可靠性</strong>：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；</li>\n<li><strong>实时性</strong>：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据（<strong>一段时间</strong>）。</li>\n</ul>\n<h1 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h1><p>ZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。</p>\n<ul>\n<li><p>ZooKeeper的数据模型也具有一个固定的根节点<code>（/）</code>，我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。</p>\n</li>\n<li><p>ZooKeeper 树中的每一层级用斜杠<code>（/）</code>分隔开，且只能用绝对路径（如<code>get /work/task</code>）的方式查询 ZooKeeper 节点，而不能使用相对路径。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/63d002b469764d71b68897df6849a0f9.png\"/>\n\n<p><strong>为什么 ZooKeeper 不能采用相对路径查找节点呢？</strong></p>\n<blockquote>\n<p>这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。</p>\n</blockquote>\n<p>像这种查找与给定值相等的记录问题最适合用散列来解决。</p>\n<p>因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 <code>hashtableConcurrentHashMap&lt;String, DataNode&gt; nodes </code>，用节点的完整路径来作为 key 存储节点数据。</p>\n<p>这样就大大提高了 ZooKeeper 的性能。</p>\n<p><strong>节点类型</strong></p>\n<p>ZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：</p>\n<blockquote>\n<p>1、持久节点</p>\n</blockquote>\n<p>一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。</p>\n<blockquote>\n<p>2、临时节点</p>\n</blockquote>\n<p>如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。</p>\n<p>当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除，同样，我们可以像删除持久节点一样主动删除临时节点。</p>\n<p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为<code>/servers</code>节点，并为集群下的每台服务器创建一个临时节点<code>/servers/host</code>，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。</p>\n<blockquote>\n<p>3、有序节点</p>\n</blockquote>\n<p>节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。</p>\n<p>例如一个客户端创建了一个路径为 <code>works/task- </code>的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为<code> works/task-1</code>。</p>\n<ul>\n<li>通过这种方式我们可以直观的查看到节点的创建顺序。</li>\n</ul>\n<p>ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组<code>（byte data[]）</code>，用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p>\n<p><strong>节点的状态结构</strong></p>\n<p>执行<code> stat /zk_test</code>，可以看到控制台输出了一些信息，这些就是节点状态信息。</p>\n<p>每一个节点都有一个自己的状态属性，记录了节点本身的一些信息：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>状态属性</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">czxid</td>\n<td align=\"left\">数据节点创建时的事务 ID</td>\n</tr>\n<tr>\n<td align=\"left\">ctime</td>\n<td align=\"left\">数据节点创建时的时间</td>\n</tr>\n<tr>\n<td align=\"left\">mzxid</td>\n<td align=\"left\">数据节点最后一次更新时的事务 ID</td>\n</tr>\n<tr>\n<td align=\"left\">mtime</td>\n<td align=\"left\">数据节点最后一次更新时的时间</td>\n</tr>\n<tr>\n<td align=\"left\">pzxid</td>\n<td align=\"left\">数据节点的子节点最后一次被修改时的事务 ID</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>cversion</strong></td>\n<td align=\"left\"><strong>子节点的版本</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>version</strong></td>\n<td align=\"left\"><strong>当前节点数据的版本</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>aversion</strong></td>\n<td align=\"left\"><strong>节点的 ACL 的版本</strong></td>\n</tr>\n<tr>\n<td align=\"left\">ephemeralOwner</td>\n<td align=\"left\">如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0</td>\n</tr>\n<tr>\n<td align=\"left\">dataLength</td>\n<td align=\"left\">数据内容的长度</td>\n</tr>\n<tr>\n<td align=\"left\">numChildren</td>\n<td align=\"left\">数据节点当前的子节点个数</td>\n</tr>\n</tbody></table>\n<p><strong>数据节点的版本</strong></p>\n<p>在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。</p>\n<p>ZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。</p>\n<h1 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h1><p>从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。</p>\n<ul>\n<li><p>事务日志数据主要用于记录本地事务性会话操作，用于 ZooKeeper 集群服务器之间的数据同步。</p>\n</li>\n<li><p>事务快照则是将内存数据持久化到本地磁盘。</p>\n</li>\n</ul>\n<blockquote>\n<p>这里要注意的一点是，数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致。</p>\n</blockquote>\n<p>在单台 ZooKeeper 服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。</p>\n<p><strong>内存数据</strong></p>\n<p>ZooKeeper 的数据模型可以看作一棵树形结构，而数据节点就是这棵树上的叶子节点。</p>\n<p>从数据存储的角度看，ZooKeeper 的数据模型是存储在内存中的。</p>\n<p>我们可以把 ZooKeeper 的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的 ACL 权限信息以及 stat 状态信息等。</p>\n<ul>\n<li>而在底层实现中，ZooKeeper 数据模型是通过 DataTree 类来定义的。</li>\n</ul>\n<p>DataTree 类定义了一个 ZooKeeper 数据的内存结构。</p>\n<p>DataTree 的内部定义类 nodes 节点类型、root 根节点信息、子节点的 WatchManager 监控信息等数据模型中的相关信息。</p>\n<p>可以说，一个 DataTree 类定义了 ZooKeeper 内存数据的逻辑结构。</p>\n<p><strong>事务日志</strong></p>\n<p>为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper 集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper 集群中的 Follow 和 Observer 服务器就会进行数据同步。</p>\n<blockquote>\n<p>而这两种角色服务器所接收到的信息就是 Leader 服务器的事务日志。</p>\n</blockquote>\n<p>在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个 ZooKeeper 集群的执行性能。</p>\n<h1 id=\"Watch机制\"><a href=\"#Watch机制\" class=\"headerlink\" title=\"Watch机制\"></a>Watch机制</h1><p>ZooKeeper 的客户端可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知；</p>\n<p><strong>如何实现：</strong></p>\n<p>我们可以通过向 ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：</p>\n<pre><code class=\"java\">new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)\n</code></pre>\n<p>上面代码的意思是定义了一个了 ZooKeeper 客户端对象实例，并传入三个参数：</p>\n<ul>\n<li><p>connectString 服务端地址</p>\n</li>\n<li><p>sessionTimeout：超时时间</p>\n</li>\n<li><p>Watcher：监控事件</p>\n</li>\n</ul>\n<p>这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文 ，一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中。</p>\n<p>除此之外，ZooKeeper 客户端也可以通过 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：</p>\n<pre><code class=\"java\">getData(String path, Watcher watcher, Stat stat)\n</code></pre>\n<p>触发通知的条件：</p>\n<img src=\"https://img-blog.csdnimg.cn/95ebb31561bd4ea2bed199cdf8b3bfce.png\"/>\n\n<p>上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。</p>\n<ul>\n<li>例如在客户端连接服务端的时候，可以对数据节点的创建、删除、数据变更、子节点的更新等操作进行监控。</li>\n</ul>\n<p><strong>当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？</strong></p>\n<p>答案是否定的，Watch 事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的 Watch 事件。</p>\n<p><strong>订阅发布场景实现</strong></p>\n<blockquote>\n<p>提到 ZooKeeper 的应用场景，你可能第一时间会想到最为典型的发布订阅功能。</p>\n</blockquote>\n<p>发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。</p>\n<p>一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。</p>\n<p>ZooKeeper 采用了两种模式结合的方式实现订阅发布功能。</p>\n<blockquote>\n<p>下面我们来分析一个具体案例：</p>\n</blockquote>\n<p>在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。</p>\n<p>通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper 的发布订阅功能就能解决这个问题。</p>\n<p>我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper 数据节点中。</p>\n<p>如<code>/confs/data_item1</code>。</p>\n<ul>\n<li><p>服务器集群客户端对该节点添加 Watch 事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。</p>\n</li>\n<li><p>而当该节点数据发生变化时，ZooKeeper 服务器会发送 Watch 事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。</p>\n</li>\n</ul>\n<p>我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对 ZooKeeper 服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。</p>\n<blockquote>\n<p>要注意一点是，我们提到 Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch 事件。</p>\n</blockquote>\n<h1 id=\"会话机制\"><a href=\"#会话机制\" class=\"headerlink\" title=\"会话机制\"></a>会话机制</h1><p>ZooKeeper 的工作方式一般是通过客户端向服务端发送请求而实现的。</p>\n<p>而在一个请求的发送过程中，首先，客户端要与服务端进行连接，而一个连接就是一个会话。</p>\n<blockquote>\n<p>在 ZooKeeper 中，一个会话可以看作是一个用于表示客户端与服务器端连接的数据结构 Session。</p>\n</blockquote>\n<p>这个数据结构由三个部分组成：分别是会话 ID（sessionID）、会话超时时间（TimeOut）、会话关闭状态（isClosing）</p>\n<ul>\n<li><p>会话 ID：会话 ID 作为一个会话的标识符，当我们创建一次会话的时候，ZooKeeper 会自动为其分配一个唯一的 ID 编码。</p>\n</li>\n<li><p>会话超时时间：一般来说，一个会话的超时时间就是指一次会话从发起后到被服务器关闭的时长。而设置会话超时时间后，服务器会参考设置的超时时间，最终计算一个服务端自己的超时时间。而这个超时时间则是最终真正用于 ZooKeeper 中服务端用户会话管理的超时时间。</p>\n</li>\n<li><p>会话关闭状态：会话关闭 isClosing 状态属性字段表示一个会话是否已经关闭。如果服务器检查到一个会话已经因为超时等原因失效时， ZooKeeper 会在该会话的 isClosing 属性值标记为关闭，再之后就不对该会话进行操作了。</p>\n</li>\n</ul>\n<p><strong>会话状态</strong></p>\n<p>在 ZooKeeper 服务的运行过程中，会话会经历不同的状态变化。</p>\n<p>这些状态包括：</p>\n<blockquote>\n<p>正在连接（CONNECTING）、已经连接（CONNECTIED）、正在重新连接（RECONNECTING）、已经重新连接（RECONNECTED）、会话关闭（CLOSE）等。</p>\n</blockquote>\n<p>当客户端开始创建一个与服务端的会话操作时，它的会话状态就会变成 CONNECTING，之后客户端会根据服务器地址列表中的服务器 IP 地址分别尝试进行连接。如果遇到一个 IP 地址可以连接到服务器，那么客户端会话状态将变为 CONNECTIED。</p>\n<p>如果因为网络原因造成已经连接的客户端会话断开时，客户端会重新尝试连接服务端。而对应的客户端会话状态又变成 CONNECTING ，直到该会话连接到服务端最终又变成 CONNECTIED。</p>\n<blockquote>\n<p>在 ZooKeeper 服务的整个运行过程中，会话状态经常会在 CONNECTING 与 CONNECTIED 之间进行切换。</p>\n</blockquote>\n<p>最后，当出现超时或者客户端主动退出程序等情况时，客户端会话状态则会变为 CLOSE 状态。</p>\n<p><strong>会话异常</strong></p>\n<p>在 ZooKeeper 中，会话的超时异常包括客户端 readtimeout 异常和服务器端 sessionTimeout 异常。</p>\n<ul>\n<li>在我们平时的开发中，要明确这两个异常的不同之处在于一个是发生在客户端，而另一个是发生在服务端。</li>\n</ul>\n<p>而对于那些对 ZooKeeper 接触不深的开发人员来说，他们常常踩坑的地方在于，虽然设置了超时间，但是在实际服务运行的时候 ZooKeeper 并没有按照设置的超时时间来管理会话。</p>\n<ul>\n<li>这是因为 ZooKeeper 实际起作用的超时时间是通过客户端和服务端协商决定。</li>\n</ul>\n<p>ZooKeeper 客户端在和服务端建立连接的时候，会提交一个客户端设置的会话超时时间，而该超时时间会和服务端设置的最大超时时间和最小超时时间进行比对，如果正好在其允许的范围内，则采用客户端的超时时间管理会话。</p>\n<p>如果大于或者小于服务端设置的超时时间，则采用服务端设置的值管理会话。</p>\n<p><strong>分桶策略</strong></p>\n<p>我们知道在 ZooKeeper 中为了保证一个会话的存活状态，客户端需要向服务器周期性地发送心跳信息。</p>\n<ul>\n<li>而客户端所发送的心跳信息可以是一个 ping 请求，也可以是一个普通的业务请求。</li>\n</ul>\n<p>ZooKeeper 服务端接收请求后，会更新会话的过期时间，来保证会话的存活状态。</p>\n<ul>\n<li>所以在 ZooKeeper 的会话管理中，最主要的工作就是管理会话的过期时间。</li>\n</ul>\n<blockquote>\n<p>ZooKeeper 中采用了独特的会话管理方式来管理会话的过期时间。</p>\n</blockquote>\n<p>在 ZooKeeper 中，会话将按照不同的时间间隔进行划分，超时时间相近的会话将被放在同一个间隔区间中，这种方式避免了 ZooKeeper 对每一个会话进行检查，而是采用分批次的方式管理会话。</p>\n<p>这就降低了会话管理的难度，因为每次小批量的处理会话过期也提高了会话处理的效率。</p>\n<p><strong>ZooKeeper 这种会话管理的好处？</strong></p>\n<p>ZooKeeper 这种分段的会话管理策略大大提高了计算会话过期的效率，如果是在一个实际生产环境中，一个大型的分布式系统往往具有很高的访问量。</p>\n<p>而 ZooKeeper 作为其中的组件，对外提供服务往往要承担数千个客户端的访问，这其中就要对这几千个会话进行管理。</p>\n<p>在这种场景下，要想通过对每一个会话进行管理和检查并不合适，所以采用将同一个时间段的会话进行统一管理，这样就大大提高了服务的运行效率。</p>\n<p><strong>底层实现</strong></p>\n<p>ZooKeeper 底层实现的原理，核心的一点就是过期队列这个数据结构。所有会话过期的相关操作都是围绕这个队列进行的。</p>\n<ul>\n<li>可以说 ZooKeeper 底层就是采用这个队列结构来管理会话过期的。</li>\n</ul>\n<p><strong>一个会话过期队列是由若干个 bucket 组成的。</strong></p>\n<ul>\n<li><p>bucket 是一个按照时间划分的区间。</p>\n</li>\n<li><p>在 ZooKeeper 中，通常以 expirationInterval 为单位进行时间区间的划分，它是 ZooKeeper 分桶策略中用于划分时间区间的最小单位。</p>\n</li>\n<li><p>在 ZooKeeper 中，一个过期队列由不同的 bucket 组成。</p>\n</li>\n<li><p>每个 bucket 中存放了在某一时间内过期的会话。</p>\n</li>\n</ul>\n<p>将会话按照不同的过期时间段分别维护到过期队列之后，在 ZooKeeper 服务运行的过程中，具体的执行过程如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/86243433c4674237b3339452d2bc0e7c.png\"/>\n\n<p>首先，ZooKeeper 服务会开启一个线程专门用来检索过期队列，找出要过期的 bucket，而 ZooKeeper 每次只会让一个 bucket 的会话过期，每当要进行会话过期操作时，ZooKeeper 会唤醒一个处于休眠状态的线程进行会话过期操作，之后会按照上面介绍的操作检索过期队列，取出过期的会话后会执行过期操作。</p>\n<h1 id=\"ACL权限\"><a href=\"#ACL权限\" class=\"headerlink\" title=\"ACL权限\"></a>ACL权限</h1><p>ZooKeeper的ACL可针对znodes设置相应的权限信息。</p>\n<p>一个 ACL 权限设置通常可以分为 3 部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。</p>\n<ul>\n<li>最终组成一条例如<code>scheme:id:permission</code>格式的 ACL 请求信息。</li>\n</ul>\n<p><strong>权限模式：Scheme</strong></p>\n<p>ZooKeeper 的权限验证方式大体分为两种类型，一种是范围验证，另外一种是口令验证。</p>\n<blockquote>\n<p>范围验证</p>\n</blockquote>\n<p>所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。</p>\n<p>比如我们可以让一个 IP 地址为<code>ip：192.168.0.11</code>的机器对服务器上的某个数据节点具有写入的权限。</p>\n<p>或者也可以通过<code>ip:192.168.0.11/22</code>给一段 IP 地址的机器赋权。</p>\n<blockquote>\n<p>口令验证</p>\n</blockquote>\n<p>可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。</p>\n<p>在 ZooKeeper 中这种验证方式是 Digest 认证，我们知道通过网络传输相对来说并不安全，所以绝不通过明文在网络发送密码也是程序设计中很重要的原则之一，而 Digest 这种认证方式首先在客户端传送<code>username:password</code>这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。</p>\n<blockquote>\n<p>Super 权限模式</p>\n</blockquote>\n<p>权限模式 Super 可以认为是一种特殊的 Digest 认证。</p>\n<p>具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</p>\n<p>下面这段代码给出了 Digest 模式下客户端的调用方式。</p>\n<pre><code>//创建节点\ncreate /digest_node1\n//设置digest权限验证\nsetAcl /digest_node1 digest:用户名:base64格式密码:rwadc \n//查询节点Acl权限\ngetAcl /digest_node1 \n//授权操作\naddauth digest user:passwd\n</code></pre>\n<blockquote>\n<p>如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。</p>\n</blockquote>\n<p>对其创建的节点要想进行修改应该怎么做呢？</p>\n<p>我们可以通过<strong>super 模式</strong>即超级管理员的方式删除该节点或变更该节点的权限验证方式。</p>\n<p>正因为<strong>super 模式</strong>有如此大的权限，我们在平时使用时也应该更加谨慎。</p>\n<blockquote>\n<p>world 模式</p>\n</blockquote>\n<p>这种授权模式对应于系统中的所有用户，本质上起不到任何作用。</p>\n<p>设置了 world 权限模式系统中的所有用户操作都可以不进行权限验证。</p>\n<p><strong>授权对象（ID）</strong></p>\n<p>所谓的授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。</p>\n<p>如果是 World 模式，是授权系统中所有的用户。</p>\n<p><strong>权限信息（Permission）</strong></p>\n<p>权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：</p>\n<ul>\n<li><p>数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；</p>\n</li>\n<li><p>数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；</p>\n</li>\n<li><p>数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；</p>\n</li>\n<li><p>数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</p>\n</li>\n<li><p>数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</p>\n</li>\n</ul>\n<blockquote>\n<p>需要注意的一点是，每个节点都有维护自身的 ACL 权限数据，即使是该节点的子节点也是有自己的 ACL 权限而不是直接继承其父节点的权限。</p>\n</blockquote>\n<p><strong>实现自己的权限口控制</strong></p>\n<p>虽然 ZooKeeper 自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。</p>\n<p>官方文档中对这种机制的定义是 <code>Pluggable ZooKeeper Authenication</code>，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。那么这种机制是如何实现的呢？</p>\n<blockquote>\n<p>要想实现自定义的权限控制机制，最核心的一点是实现 ZooKeeper 提供的权限控制器接口 AuthenticationProvider。</p>\n</blockquote>\n<p>实现了自定义权限后，如何才能让 ZooKeeper 服务端使用自定义的权限验证方式呢？</p>\n<p>接下来就需要将自定义的权限控制注册到 ZooKeeper 服务器中，而注册的方式通常有两种。</p>\n<ul>\n<li>第一种是通过设置系统属性来注册自定义的权限控制器：</li>\n</ul>\n<pre><code class=\"java\">-Dzookeeper.authProvider.x=CustomAuthenticationProvider\n</code></pre>\n<ul>\n<li>另一种是在配置文件<code>zoo.cfg</code>中进行配置：</li>\n</ul>\n<pre><code class=\"java\">authProvider.x=CustomAuthenticationProvider\n</code></pre>\n<p><strong>实现原理</strong></p>\n<p>首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。</p>\n<p>在授权接口中，值得注意的是会话的授权信息存储在 ZooKeeper 服务端的内存中，如果客户端会话关闭，授权信息会被删除。</p>\n<p>下次连接服务器后，需要重新调用授权接口进行授权。</p>\n<h1 id=\"序列化方式\"><a href=\"#序列化方式\" class=\"headerlink\" title=\"序列化方式\"></a>序列化方式</h1><p>在 ZooKeeper 中并没有采用和 Java 一样的序列化方式，而是采用了一个 Jute 的序列解决方案作为 ZooKeeper 框架自身的序列化方式。</p>\n<blockquote>\n<p>ZooKeeper 从最开始就采用 Jute 作为其序列化解决方案，直到其最新的版本依然没有更改。</p>\n</blockquote>\n<p>虽然 ZooKeeper 一直将 Jute 框架作为序列化解决方案，但这并不意味着 Jute 相对其他框架性能更好，反倒是 Apache Avro、Thrift 等框架在性能上优于前者。</p>\n<p>之所以 ZooKeeper 一直采用 Jute 作为序列化解决方案，主要是新老版本的兼容等问题。</p>\n<p><strong>如何 使用 Jute 实现序列化</strong></p>\n<p>如果我们要想将某个定义的类进行序列化，首先需要该类实现 Record 接口的 serilize 和 deserialize 方法，这两个方法分别是序列化和反序列化方法。</p>\n<blockquote>\n<p>下边这段代码给出了我们一般在 ZooKeeper 中进行序列化的具体实现：</p>\n</blockquote>\n<p>首先，我们定义了一个<code>test_jute</code>类，为了能够对它进行序列化，需要该<code>test_jute</code>类实现 Record 接口，并在对应的 serialize 序列化方法和 deserialize 反序列化方法中编辑具体的实现逻辑。</p>\n<pre><code class=\"java\">class test_jute implements Record&#123;\n  private long ids；\n  private String name;\n  ...\n  public void serialize(OutpurArchive a_,String tag)&#123;\n    ...\n  &#125;\n  public void deserialize(INputArchive a_,String tag)&#123;\n    ...\n  &#125;\n&#125;\n</code></pre>\n<p>在序列化方法 serialize 中，我们要实现的逻辑是，首先通过字符类型参数 tag 传递标记序列化标识符，之后使用 writeLong 和 writeString 等方法分别将对象属性字段进行序列化。</p>\n<pre><code class=\"java\">public void serialize(OutpurArchive a_,String tag) throws ...&#123;\n  a_.startRecord(this.tag);\n  a_.writeLong(ids,&quot;ids&quot;);\n  a_.writeString(type,&quot;name&quot;);\n  a_.endRecord(this,tag);\n&#125;\n</code></pre>\n<p>调用 derseralize 在实现反序列化的过程则与我们上边说的序列化过程正好相反。</p>\n<pre><code class=\"java\">public void deserialize(INputArchive a_,String tag) throws &#123;\n  a_.startRecord(tag);\n  ids = a_.readLong(&quot;ids&quot;);\n  name = a_.readString(&quot;name&quot;);\n  a_.endRecord(tag);\n&#125;\n</code></pre>\n<p>序列化和反序列化的实现逻辑编码方式相对固定，首先通过 startRecord 开启一段序列化操作，之后通过 writeLong、writeString 或 readLong、 readString 等方法执行序列化或反序列化。</p>\n<p>本例中只是实现了长整型和字符型的序列化和反序列化操作，除此之外 ZooKeeper 中的 Jute 框架还支持整数类型（Int）、布尔类型（Bool）、双精度类型（Double）以及 Byte&#x2F;Buffer 类型。</p>\n<h1 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h1><p><strong>ZooKeeper集群模式的特点</strong></p>\n<p>在 ZooKeeper 集群中将服务器分成 <strong>Leader 、Follow 、Observer 三</strong>种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p>\n<ul>\n<li><p>Leader 角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者，既可以为客户端提供写服务又能提供读服务。</p>\n</li>\n<li><p>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader 服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个 Follow 服务器作为新的 Leader 服务器，只能提供读服务。</p>\n</li>\n<li><p>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与 Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器，只能提供读服务。</p>\n</li>\n</ul>\n<p>在 ZooKeeper 集群接收到来自客户端的会话请求操作后，首先会判断该条请求是否是事务性的会话请求。</p>\n<blockquote>\n<p>对于事务性的会话请求，ZooKeeper 集群服务端会将该请求统一转发给 Leader 服务器进行操作。</p>\n<p>所谓事务性请求，是指 ZooKeeper 服务器执行完该条会话请求后，是否会导致执行该条会话请求的服务器的数据或状态发生改变，进而导致与其他集群中的服务器出现数据不一致的情况。</p>\n</blockquote>\n<p>Leader 服务器内部执行该条事务性的会话请求后，再将数据同步给其他角色服务器，从而保证事务性会话请求的执行顺序，进而保证整个 ZooKeeper 集群的数据一致性。</p>\n<blockquote>\n<p>在 ZooKeeper 集群的内部实现中，是通过什么方法保证所有 ZooKeeper 集群接收到的事务性会话请求都能交给 Leader 服务器进行处理的呢？</p>\n</blockquote>\n<p>在 ZooKeeper 集群内部，集群中除 Leader 服务器外的其他角色服务器接收到来自客户端的事务性会话请求后，必须将该条会话请求转发给 Leader 服务器进行处理。</p>\n<p>ZooKeeper 集群中的 Follow 和 Observer 服务器，都会检查当前接收到的会话请求是否是事务性的请求，如果是事务性的请求，那么就将该请求以 REQUEST 消息类型转发给 Leader 服务器。</p>\n<p>在 ZooKeeper集群中的服务器接收到该条消息后，会对该条消息进行解析。</p>\n<ul>\n<li><p>分析出该条消息所包含的原始客户端会话请求。</p>\n</li>\n<li><p>之后将该条消息提交到自己的 Leader 服务器请求处理链中，开始进行事务性的会话请求操作。</p>\n</li>\n<li><p>如果不是事务性请求，ZooKeeper 集群则交由 Follow 和 Observer 角色服务器处理该条会话请求，如查询数据节点信息。</p>\n</li>\n</ul>\n<p>当一个业务场景在查询操作多而创建删除等事务性操作少的情况下，ZooKeeper 集群的性能表现的就会很好。</p>\n<blockquote>\n<p>如果是在极端情况下，ZooKeeper 集群只有事务性的会话请求而没有查询操作，那么 Follow 和 Observer 服务器就只能充当一个请求转发服务器的角色， 所有的会话的处理压力都在 Leader 服务器。</p>\n</blockquote>\n<p>在处理性能上整个集群服务器的瓶颈取决于 Leader 服务器的性能。</p>\n<blockquote>\n<p>ZooKeeper 集群的作用只能保证在 Leader 节点崩溃的时候，重新选举出 Leader 服务器保证系统的稳定性。</p>\n</blockquote>\n<p>这也是 ZooKeeper 设计的一个缺点。</p>\n<p><strong>Leader选举</strong></p>\n<p>Leader 服务器的选举操作主要发生在两种情况下。</p>\n<p>第一种就是 ZooKeeper 集群服务启动的时候，第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时，这时 ZooKeeper 集群需要选举出新的 Leader 服务器。</p>\n<blockquote>\n<p>ZooKeeper 集群重新选举 Leader 的过程只有 Follow 服务器参与工作。</p>\n</blockquote>\n<blockquote>\n<p>服务器状态</p>\n</blockquote>\n<p>服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。</p>\n<ul>\n<li><p><strong>LOOKING</strong>：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</p>\n</li>\n<li><p><strong>FOLLOWING</strong>：跟随者状态。表明当前服务器角色是Follower。</p>\n</li>\n<li><p><strong>LEADING</strong>：领导者状态。表明当前服务器角色是Leader。</p>\n</li>\n<li><p><strong>OBSERVING</strong>：观察者状态。表明当前服务器角色是Observer。</p>\n</li>\n</ul>\n<p><strong>事务ID（zxid）</strong></p>\n<p>Zookeeper的状态变化，都会由一个Zookeeper事务ID（ZXID）标识。</p>\n<blockquote>\n<p>写入Zookeeper，会导致状态变化，每次写入都会导致ZXID发生变化。</p>\n</blockquote>\n<p>ZXID由Leader统一分配，全局唯一，长度64位，递增。</p>\n<p>ZXID展示了所有的Zookeeper转台变更顺序，每次变更都有一个唯一ZXID，如果zxid1小于zxid2，则说明zxid1的事务在zxid2的事务之前发生。</p>\n<p><strong>选举过程</strong></p>\n<p>在 ZooKeeper 集群重新选举 Leader 节点的过程中，主要可以分为 Leader 失效发现、重新选举 Leader 、Follow 服务器角色变更、集群同步这几个步骤。</p>\n<blockquote>\n<p>Leader 失效发现</p>\n</blockquote>\n<p>在 ZooKeeper 集群中，当 Leader 服务器失效时，ZooKeeper 集群会重新选举出新的 Leader 服务器。</p>\n<ul>\n<li>在 ZooKeeper 集群中，探测 Leader 服务器是否存活的方式与保持客户端活跃性的方法非常相似。</li>\n</ul>\n<p>首先，Follow 服务器会定期向 Leader 服务器发送 网络请求，在接收到请求后，Leader 服务器会返回响应数据包给 Follow 服务器，而在 Follow 服务器接收到 Leader 服务器的响应后，如果判断 Leader 服务器运行正常，则继续进行数据同步和服务转发等工作，反之，则进行 Leader 服务器的重新选举操作。</p>\n<blockquote>\n<p>Leader重新选举</p>\n</blockquote>\n<p>当 Follow 服务器向 Leader 服务器发送状态请求包后，如果没有得到 Leader 服务器的返回信息，这时，如果是集群中个别的 Follow 服务器发现返回错误，并不会导致 ZooKeeper 集群立刻重新选举 Leader 服务器，而是将该 Follow 服务器的状态变更为 LOOKING 状态，并向网络中发起投票，当 ZooKeeper 集群中有更多的机器发起投票，最后当投票结果满足多数原则的情况下。</p>\n<p>ZooKeeper 会重新选举出 Leader 服务器。</p>\n<blockquote>\n<p>Follow 角色变更</p>\n</blockquote>\n<p>在 ZooKeeper 集群中，Follow 服务器作为 Leader 服务器的候选者，当被选举为 Leader 服务器之后，其在 ZooKeeper 集群中的 Follow 角色，也随之发生改变。也就是要转变为 Leader 服务器，并作为 ZooKeeper 集群中的 Leader 角色服务器对外提供服务。</p>\n<blockquote>\n<p>集群同步数据</p>\n</blockquote>\n<p>在 ZooKeeper 集群成功选举 Leader 服务器，并且候选 Follow 服务器的角色变更后。</p>\n<p>为避免在这期间导致的数据不一致问题，ZooKeeper 集群在对外提供服务之前，会通过 Leader 角色服务器管理同步其他角色服务器。</p>\n<p><strong>底层实现</strong></p>\n<p>首先，ZooKeeper 集群会先判断 Leader 服务器是否失效，而判断的方式就是 Follow 服务器向 Leader 服务器发送请求包，之后 Follow 服务器接收到响应数据后，进行解析，Follow 服务器会根据返回的数据，判断 Leader 服务器的运行状态，如果返回的是 LOOKING 关键字，表明与集群中 Leader 服务器无法正常通信。</p>\n<ul>\n<li>之后，在 ZooKeeper 集群选举 Leader 服务器时，是通过 <strong>FastLeaderElection</strong> 类实现的。</li>\n</ul>\n<p>该类实现了 TCP 方式的通信连接，用于在 ZooKeeper 集群中与其他 Follow 服务器进行协调沟通。</p>\n<p>FastLeaderElection 类继承了 Election 接口，定义其是用来进行选举的实现类。</p>\n<ul>\n<li>而在其内部，又定义了选举通信相关的一些配置参数，比如 finalizeWait 最终等待时间、最大通知间隔时间 maxNotificationInterval 等。</li>\n</ul>\n<p>在选举的过程中，首先调用 ToSend 函数向 ZooKeeper 集群中的其他角色服务器发送本机的投票信息，其他服务器在接收投票信息后，会对投票信息进行有效性验证等操作，之后 ZooKeeper 集群统计投票信息，如果过半数的机器投票信息一致，则集群就重新选出新的 Leader 服务器。</p>\n<blockquote>\n<p>这里我们要注意一个问题，那就是在重新选举 Leader 服务器的过程中，ZooKeeper 集群理论上是无法进行事务性的请求处理的。</p>\n</blockquote>\n<p>因此，发送到 ZooKeeper 集群中的事务性会话会被挂起，暂时不执行，等到选举出新的 Leader 服务器后再进行操作。 </p>\n<p><strong>Observer</strong></p>\n<p>在 ZooKeeper 集群服务运行的过程中，Observer 服务器与 Follow 服务器具有一个相同的功能，那就是负责处理来自客户端的诸如查询数据节点等非事务性的会话请求操作。</p>\n<ul>\n<li>但与 Follow 服务器不同的是，Observer 不参与 Leader 服务器的选举工作，也不会被选举为 Leader 服务器。</li>\n</ul>\n<p>在早期的 ZooKeeper 集群服务运行过程中，只有 Leader 服务器和 Follow 服务器。</p>\n<p>不过随着 ZooKeeper 在分布式环境下的广泛应用，早期模式的设计缺点也随之产生，主要带来的问题有如下几点：</p>\n<ul>\n<li><p>随着集群规模的变大，集群处理写入的性能反而下降。</p>\n</li>\n<li><p>ZooKeeper 集群无法做到跨域部署。</p>\n</li>\n</ul>\n<p>其中最主要的问题在于，当 ZooKeeper 集群的规模变大，集群中 Follow 服务器数量逐渐增多的时候，ZooKeeper 处理创建数据节点等事务性请求操作的性能就会逐渐下降。</p>\n<p>这是因为 ZooKeeper 集群在处理事务性请求操作时，要在 ZooKeeper 集群中对该事务性的请求发起投票，只有超过半数的 Follow 服务器投票一致，才会执行该条写入操作。</p>\n<p>正因如此，随着集群中 Follow 服务器的数量越来越多，一次写入等相关操作的投票也就变得越来越复杂，并且 Follow 服务器之间彼此的网络通信也变得越来越耗时，导致随着 Follow 服务器数量的逐步增加，事务性的处理性能反而变得越来越低。</p>\n<ul>\n<li>为了解决这一问题，在 ZooKeeper 3.6 版本后，ZooKeeper 集群中创建了一种新的服务器角色，即 Observer——观察者角色服务器。</li>\n</ul>\n<p>Observer 可以处理 ZooKeeper 集群中的非事务性请求，并且不参与 Leader 节点等投票相关的操作。</p>\n<p>这样既保证了 ZooKeeper 集群性能的扩展性，又避免了因为过多的服务器参与投票相关的操作而影响 ZooKeeper 集群处理事务性会话请求的能力。</p>\n<ul>\n<li>在实际部署的时候，因为 Observer 不参与 Leader 节点等操作，并不会像 Follow 服务器那样频繁的与 Leader 服务器进行通信。</li>\n</ul>\n<p>因此，可以将 Observer 服务器部署在不同的网络区间中，这样也不会影响整个 ZooKeeper 集群的性能，也就是所谓的跨域部署。</p>\n<p><strong>在我们日常使用 ZooKeeper 集群服务器的时候，集群中的机器个数应该选择奇数个？</strong></p>\n<p>两个原因：</p>\n<blockquote>\n<p>在容错能力相同的情况下，奇数台更节省资源</p>\n</blockquote>\n<p>Zookeeper中 Leader 选举算法采用了Zab协议。</p>\n<p>Zab核心思想是当多数 Server 写成功，则写成功。</p>\n<p>举两个例子：</p>\n<ul>\n<li><p>假如zookeeper集群1 ，有3个节点，3&#x2F;2&#x3D;1.5 ,  即zookeeper想要正常对外提供服务（即leader选举成功），至少需要2个节点是正常的。换句话说，3个节点的zookeeper集群，允许有一个节点宕机。</p>\n</li>\n<li><p>假如zookeeper集群2，有4个节点，4&#x2F;2&#x3D;2 , 即zookeeper想要正常对外提供服务（即leader选举成功），至少需要3个节点是正常的。换句话说，4个节点的zookeeper集群，也允许有一个节点宕机。</p>\n</li>\n</ul>\n<p>集群1与集群2都有 允许1个节点宕机 的容错能力，但是集群2比集群1多了1个节点。在相同容错能力的情况下，本着节约资源的原则，zookeeper集群的节点数维持奇数个更好一些。</p>\n<blockquote>\n<p>防止由脑裂造成的集群不可用。</p>\n</blockquote>\n<p>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。</p>\n<p>下面举例说一下为什么采用奇数台节点，就可以防止由于脑裂造成的服务不可用：</p>\n<p>假如zookeeper集群有 5 个节点，发生了脑裂，脑裂成了A、B两个小集群： </p>\n<ul>\n<li><p>A ： 1个节点 ，B ：4个节点 </p>\n</li>\n<li><p>A ： 2个节点， B ：3个节点</p>\n</li>\n</ul>\n<p>可以看出，上面这两种情况下，A、B中总会有一个小集群满足 可用节点数量 &gt; 总节点数量&#x2F;2 。</p>\n<p>所以zookeeper集群仍然能够选举出leader ， 仍然能对外提供服务，只不过是有一部分节点失效了而已。</p>\n<p>假如zookeeper集群有4个节点，同样发生脑裂，脑裂成了A、B两个小集群：</p>\n<ul>\n<li><p>A：1个节点 ，  B：3个节点 </p>\n</li>\n<li><p>A：2个节点 ， B：2个节点</p>\n</li>\n</ul>\n<p>因为A和B都是2个节点，都不满足 可用节点数量 &gt; 总节点数量&#x2F;2 的选举条件， 所以此时zookeeper就彻底不能提供服务了。</p>\n<h1 id=\"ZAB协议\"><a href=\"#ZAB协议\" class=\"headerlink\" title=\"ZAB协议\"></a>ZAB协议</h1><p><strong>ZAB 协议算法</strong></p>\n<p>ZooKeeper 最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。</p>\n<blockquote>\n<p>为了解决这个问题，ZooKeeper 采用了 ZAB 协议算法。</p>\n</blockquote>\n<p>ZAB 协议算法（Zookeeper Atomic Broadcast  ，Zookeeper 原子广播协议）是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是崩溃恢复和原子广播协议。</p>\n<ul>\n<li>在整个 ZAB 协议的底层实现中，ZooKeeper 集群主要采用主从模式的系统架构方式来保证 ZooKeeper 集群系统的一致性。</li>\n</ul>\n<p>当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。</p>\n<blockquote>\n<p>以 ZooKeeper 集群为例，这个操作过程可以概括为：</p>\n</blockquote>\n<p>当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。</p>\n<p>当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。</p>\n<p>然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。</p>\n<p><strong>崩溃恢复</strong></p>\n<p>当集群中的 Leader 发生故障的时候，整个集群就会因为缺少 Leader 服务器而无法处理来自客户端的事务性的会话请求。</p>\n<blockquote>\n<p>因此，为了解决这个问题。在 ZAB 协议中也设置了处理该问题的崩溃恢复机制。</p>\n</blockquote>\n<p>崩溃恢复机制是保证 ZooKeeper 集群服务高可用的关键。触发 ZooKeeper 集群执行崩溃恢复的事件是集群中的 Leader 节点服务器发生了异常而无法工作，于是 Follow 服务器会通过投票来决定是否选出新的 Leader 节点服务器。</p>\n<blockquote>\n<p>投票过程如下：</p>\n</blockquote>\n<p>当崩溃恢复机制开始的时候，整个 ZooKeeper 集群的每台 Follow 服务器会发起投票，并同步给集群中的其他 Follow 服务器。</p>\n<p>在接收到来自集群中的其他 Follow 服务器的投票信息后，集群中的每个 Follow 服务器都会与自身的投票信息进行对比，如果判断新的投票信息更合适，则采用新的投票信息作为自己的投票信息。在集群中的投票信息还没有达到超过半数原则的情况下，再进行新一轮的投票，最终当整个 ZooKeeper 集群中的 Follow 服务器超过半数投出的结果相同的时候，就会产生新的 Leader 服务器。</p>\n<blockquote>\n<p>选票结构：</p>\n</blockquote>\n<p>以 Fast Leader Election 选举的实现方式来讲，如下图所示，一个选票的整体结果可以分为一下六个部分：</p>\n<img src=\"https://img-blog.csdnimg.cn/2956e37edd2d482fb3545a7b35ffe7ae.png\"/>\n\n<ul>\n<li><p>logicClock：用来记录服务器的投票轮次。logicClock 会从 1 开始计数，每当该台服务经过一轮投票后，logicClock 的数值就会加 1 。</p>\n</li>\n<li><p>state：用来标记当前服务器的状态。在 ZooKeeper 集群中一台服务器具有 LOOKING、FOLLOWING、LEADERING、OBSERVING 这四种状态。</p>\n</li>\n<li><p><code>self_id</code>：用来表示当前服务器的 ID 信息，该字段在 ZooKeeper 集群中主要用来作为服务器的身份标识符。</p>\n</li>\n<li><p><code>self_zxid</code>： 当前服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</p>\n</li>\n<li><p><code>vote_id</code>：投票要被推举的服务器的唯一 ID 。</p>\n</li>\n<li><p><code>vote_zxid</code>：被推举的服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</p>\n</li>\n</ul>\n<p>当 ZooKeeper 集群需要重新选举出新的 Leader 服务器的时候，就会根据上面介绍的投票信息内容进行对比，以找出最适合的服务器。</p>\n<blockquote>\n<p>选票筛选</p>\n</blockquote>\n<p>当一台 Follow 服务器接收到网络中的其他 Follow 服务器的投票信息后，是如何进行对比来更新自己的投票信息的。</p>\n<p>Follow 服务器进行选票对比的过程，如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/977516cbd09d4fb8aad57004147221a6.png\" />\n\n<p>首先，会对比 logicClock 服务器的投票轮次，当 logicClock 相同时，表明两张选票处于相同的投票阶段，并进入下一阶段，否则跳过。</p>\n<p>接下来再对比<code>vote_zxid</code>被选举的服务器 ID 信息，若接收到的外部投票信息中的 <code>vote_zxid </code>字段较大，则将自己的票中的<code>vote_zxid</code>与<code>vote_myid</code>更新为收到的票中的<code>vote_zxid</code>与<code> vote_myid</code> ，并广播出去。</p>\n<p>要是对比的结果相同，则继续对比<code>vote_myid</code>被选举服务器上所保存的最大事务 ID ，若外部投票的<code> vote_myid</code> 比较大，则将自己的票中的 <code>vote_myid </code>更新为收到的票中的<code> vote_myid</code> 。 </p>\n<p>经过这些对比和替换后，最终该台 Follow 服务器会产生新的投票信息，并在下一轮的投票中发送到 ZooKeeper 集群中。</p>\n<p><strong>消息广播</strong></p>\n<p>在 Leader 节点服务器处理请求后，需要通知集群中的其他角色服务器进行数据同步。ZooKeeper 集群采用消息广播的方式发送通知。</p>\n<p>ZooKeeper 集群使用原子广播协议进行消息发送，该协议的底层实现过程与二阶段提交过程非常相似，如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/fb518bd2f20c45539765e0b76e54387d.png\"/>\n\n<p>当要在集群中的其他角色服务器进行数据同步的时候，Leader 服务器将该操作过程封装成一个 Proposal 提交事务，并将其发送给集群中其他需要进行数据同步的服务器。</p>\n<p>当这些服务器接收到 Leader 服务器的数据同步事务后，会将该条事务能否在本地正常执行的结果反馈给 Leader 服务器，Leader 服务器在接收到其他 Follow 服务器的反馈信息后进行统计，判断是否在集群中执行本次事务操作。</p>\n<p>这里请注意 ，与二阶段提交过程不同（即需要集群中所有服务器都反馈可以执行事务操作后，主服务器再次发送 commit 提交请求执行数据变更） ，ZAB 协议算法省去了中断的逻辑，当 ZooKeeper 集群中有超过一半的 Follow 服务器能够正常执行事务操作后，整个 ZooKeeper 集群就可以提交 Proposal 事务了。</p>\n<h1 id=\"日志清理\"><a href=\"#日志清理\" class=\"headerlink\" title=\"日志清理\"></a>日志清理</h1><p><strong>日志类型</strong></p>\n<p>在 ZooKeeper 服务运行的时候，一般会产生数据快照和日志文件，数据快照用于集群服务中的数据同步，而数据日志则记录了 ZooKeeper 服务运行的相关状态信息。</p>\n<blockquote>\n<p>其中，数据日志是我们在生产环境中需要定期维护和管理的文件。</p>\n</blockquote>\n<p><strong>清理方案</strong></p>\n<p>如上面所介绍的，面对生产系统中产生的日志，一般的维护操作是备份和清理。</p>\n<p>备份是为了之后对系统的运行情况进行排查和优化，而清理主要因为随着系统日志的增加，日志会逐渐占用系统的存储空间，如果一直不进行清理，可能耗尽系统的磁盘存储空间，并最终影响服务的运行。</p>\n<p><strong>清理工具</strong></p>\n<blockquote>\n<p>Corntab</p>\n</blockquote>\n<p>首先，我们介绍的是 Linux corntab ，它是 Linux 系统下的软件，可以自动地按照我们设定的时间，周期性地执行我们编写的相关脚本。</p>\n<p>crontab 定时脚本的方式相对灵活，可以按照我们的业务需求来设置处理日志的维护方式，比如这里我们希望定期清除 ZooKeeper 服务运行的日志，而不想清除数据快照的文件，则可以通过脚本设置，达到只对数据日志文件进行清理的目的。</p>\n<blockquote>\n<p>PurgeTxnLog</p>\n</blockquote>\n<p>ZooKeeper 自身还提供了 PurgeTxnLog 工具类，用来清理 snapshot 数据快照文件和系统日志。</p>\n<p>PurgeTxnLog 清理方式和我们上面介绍的方式十分相似，也是通过定时脚本执行任务，唯一的不同是，上面提到在编写日志清除 logsCleanWeek 的时候 ，我们使用的是原生 shell 脚本自己手动编写的数据日志清理逻辑，而使用 PurgeTxnLog 则可以在编写清除脚本的时候调用 ZooKeeper 为我们提供的工具类完成日志清理工作。</p>\n<p>如下面的代码所示，首先，我们在<code>/usr/bin</code>目录下创建一个 PurgeLogsClean 脚本。注意这里的脚本也是一个 shell 文件。</p>\n<p>在脚本中我们只需要编写 PurgeTxnLog 类的调用程序，系统就会自动通过 PurgeTxnLog 工具类为我们完成对应日志文件的清理工作。</p>\n<pre><code>#!/bin/sh  \njava -cp &quot;$CLASSPATH&quot; org.apache.zookeeper.server.PurgeTxnLog \necho &quot;清理完成&quot; \n</code></pre>\n<p>PurgeTxnLog 方式与 crontab 相比，使用起来更加容易而且也更加稳定安全，不过 crontab 方式更加灵活，我们可以根据不同的业务需求编写自己的清理逻辑。</p>\n<h1 id=\"实现分布式锁\"><a href=\"#实现分布式锁\" class=\"headerlink\" title=\"实现分布式锁\"></a>实现分布式锁</h1><p>分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</p>\n<blockquote>\n<p>实现分布式锁目前有三种流行方案，即基于数据库、Redis、ZooKeeper 的方案</p>\n</blockquote>\n<p><strong>方案一：</strong></p>\n<p>使用节点中的存储数据区域，ZK中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识</p>\n<p><strong>方案二：</strong></p>\n<p>使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可</p>\n<img src=\"https://img-blog.csdnimg.cn/b4f8396f620f4a778b01bb573ca5969f.png\"/>\n\n<p><strong>死锁风险:</strong></p>\n<p>两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁</p>\n<ul>\n<li><p>方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行</p>\n</li>\n<li><p>方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与ZK的连接，ZK检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的</p>\n</li>\n</ul>\n<p><strong>避免羊群效应</strong></p>\n<p>把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。</p>\n<p>如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。</p>\n<blockquote>\n<p>为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。</p>\n</blockquote>\n<p>每次锁被释放，只会有一个锁请求者 会被通知到。</p>\n<p>这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。</p>\n<img src=\"https://img-blog.csdnimg.cn/20b0e4cf4ae3424c999ba9fb4f704a8a.png\"/>\n\n<p><strong>用 ZooKeeper 实现分布式锁的算法流程，根节点为 &#x2F;lock：</strong></p>\n<ul>\n<li><p>客户端连接 ZooKeeper，并<code>在/lock </code>下创建临时有序子节点，第一个客户端对应的子节点为<code> /lock/lock01/00000001</code>，第二个为 <code>/lock/lock01/00000002</code>；</p>\n</li>\n<li><p>其他客户端获取<code>/lock01</code>下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</p>\n</li>\n<li><p>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听<code>/lock01 </code>的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</p>\n</li>\n<li><p>完成业务流程后，删除对应的子节点，释放分布式锁；</p>\n</li>\n</ul>\n<p>在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。</p>\n<h1 id=\"实现分布式ID\"><a href=\"#实现分布式ID\" class=\"headerlink\" title=\"实现分布式ID\"></a>实现分布式ID</h1><p>我们可以通过 ZooKeeper 自身的客户端和服务器运行模式，来实现一个分布式网络环境下的 ID 请求和分发过程。</p>\n<blockquote>\n<p>每个需要 ID 编码的业务服务器可以看作是 ZooKeeper 的客户端。ID 编码生成器可以作为 ZooKeeper 的服务端。</p>\n</blockquote>\n<p>客户端通过发送请求到 ZooKeeper 服务器，来获取编码信息，服务端接收到请求后，发送 ID 编码给客户端。</p>\n<p><strong>实现原理：</strong></p>\n<p>可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。</p>\n<ul>\n<li><p>客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。</p>\n</li>\n<li><p>客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。</p>\n</li>\n</ul>\n<p>利用 ZooKeeper 中的顺序节点特性，很容易使我们创建的 ID 编码具有有序的特性。并且我们也可以通过客户端传递节点的名称，根据不同的业务编码区分不同的业务系统，从而使编码的扩展能力更强。</p>\n<blockquote>\n<p>虽然使用 ZooKeeper 的实现方式有这么多优点，但也会有一些潜在的问题。</p>\n</blockquote>\n<p>其中最主要的是，在定义编码的规则上还是强烈依赖于程序员自身的能力和对业务的深入理解。</p>\n<p>很容易出现因为考虑不周，造成设置的规则在运行一段时间后，无法满足业务要求或者安全性不够等问题。</p>\n<h1 id=\"实现负载均衡\"><a href=\"#实现负载均衡\" class=\"headerlink\" title=\"实现负载均衡\"></a>实现负载均衡</h1><p><strong>常见负载均衡算法</strong></p>\n<blockquote>\n<p>轮询法</p>\n</blockquote>\n<p>轮询法是最为简单的负载均衡算法，当接收到来自网络中的客户端请求后，负载均衡服务器会按顺序逐个分配给后端服务。</p>\n<p>比如集群中有 3 台服务器，分别是 server1、server2、server3，轮询法会按照 sever1、server2、server3 这个顺序依次分发会话请求给每个服务器。当第一次轮询结束后，会重新开始下一轮的循环。</p>\n<blockquote>\n<p>随机法</p>\n</blockquote>\n<p>随机算法是指负载均衡服务器在接收到来自客户端的请求后，会根据一定的随机算法选中后台集群中的一台服务器来处理这次会话请求。</p>\n<p>不过，当集群中备选机器变的越来越多时，通过统计学我们可以知道每台机器被抽中的概率基本相等，因此随机算法的实际效果越来越趋近轮询算法。</p>\n<blockquote>\n<p>原地址哈希法</p>\n</blockquote>\n<p>原地址哈希算法的核心思想是根据客户端的 IP 地址进行哈希计算，用计算结果进行取模后，根据最终结果选择服务器地址列表中的一台机器，处理该条会话请求。</p>\n<p>采用这种算法后，当同一 IP 的客户端再次访问服务端后，负载均衡服务器最终选举的还是上次处理该台机器会话请求的服务器，也就是每次都会分配同一台服务器给客户端。</p>\n<blockquote>\n<p>加权轮询法</p>\n</blockquote>\n<p>加权轮询的方式与轮询算法的方式很相似，唯一的不同在于选择机器的时候，不只是单纯按照顺序的方式选择，还根据机器的配置和性能高低有所侧重，配置性能好的机器往往首先分配。</p>\n<blockquote>\n<p>加权随机法</p>\n</blockquote>\n<p>加权随机法和我们上面提到的随机算法一样，在采用随机算法选举服务器的时候，会考虑系统性能作为权值条件。</p>\n<blockquote>\n<p>最小连接数法</p>\n</blockquote>\n<p>最小连接数算法是指，根据后台处理客户端的连接会话条数，计算应该把新会话分配给哪一台服务器。</p>\n<p>一般认为，连接数越少的机器，在网络带宽和计算性能上都有很大优势，会作为最优先分配的对象。</p>\n<p><strong>利用 ZooKeeper 实现 负载均衡 算法</strong></p>\n<blockquote>\n<p>这里我们通过采用最小连接数算法，来确定究竟如何均衡地分配网络会话请求给后台客户端。</p>\n</blockquote>\n<p>如下图所示，建立的 ZooKeeper 数据模型中 Severs 节点可以作为存储服务器列表的父节点。</p>\n<p>在它下面创建 servers_host1、servers_host2、servers_host3等临时节点来存储集群中的服务器运行状态信息。</p>\n<img src=\"https://img-blog.csdnimg.cn/2c6c94ef4c1443ecbe0084b5d4ad7ea2.png\"/>\n\n<p>整个实现的过程如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/b3ad367c3c024fd6ae57e4f7a2c9aa40.png\"/>\n\n<ul>\n<li><p>首先，在接收到客户端的请求后，通过 getData 方法获取服务端 Severs 节点下的服务器列表，其中每个节点信息都存储有当前服务器的连接数。</p>\n</li>\n<li><p>通过判断选择最少的连接数作为当前会话的处理服务器，并通过 setData 方法将该节点连接数加 1。</p>\n</li>\n<li><p>最后，当客户端执行完毕，再调用 setData 方法将该节点信息减 1。</p>\n</li>\n<li><p>我们定义当服务器接收到会话请求后。在 ZooKeeper 服务端增加连接数的 addBlance 方法。</p>\n</li>\n<li><p>我们通过 readData 方法获取服务器最新的连接数，之后将该连接数加 1，再通过 writeData 方法将新的连接数信息写入到服务端对应节点信息中。</p>\n</li>\n<li><p>当服务器处理完该会话请求后，需要更新服务端相关节点的连接数。</p>\n</li>\n<li><p>具体的操作与 addBlance 方法基本一样，只是对获取的连接信息进行减一操作。</p>\n</li>\n</ul>\n<p><strong>这里注意：</strong></p>\n<p>我们日常用到的负载均衡器主要是选择后台处理的服务器，并给其分发请求。</p>\n<blockquote>\n<p>而通过 ZooKeeper 实现的服务器，只提供了服务器的筛选工作。</p>\n</blockquote>\n<p>在请求分发的过程中，还是通过负载算法计算出要访问的服务器，之后客户端自己连接该服务器，完成请求操作。</p>\n<h1 id=\"开源框架使用案例\"><a href=\"#开源框架使用案例\" class=\"headerlink\" title=\"开源框架使用案例\"></a>开源框架使用案例</h1><p><strong>Dubbo与ZooKeeper</strong></p>\n<p>Dubbo 是阿里巴巴开发的一套开源的技术框架，是一款高性能、轻量级的开源 Java RPC 框架。</p>\n<p><strong>用ZooKeeper做注册中心</strong></p>\n<p>在整个 Dubbo 框架的实现过程中，注册中心是其中最为关键的一点，它保证了整个 PRC 过程中服务对外的透明性。</p>\n<p>而 Dubbo 的注册中心也是通过 ZooKeeper 来实现的。</p>\n<p>如下图所示，在整个 Dubbo 服务的启动过程中，服务提供者会在启动时向 <code>/dubbo/com.foo.BarService/providers </code>目录写入自己的 URL 地址，这个操作可以看作是一个 ZooKeeper 客户端在 ZooKeeper 服务器的数据模型上创建一个数据节点。</p>\n<p>服务消费者在启动时订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址，并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录写入自己的 URL 地址。</p>\n<p>该操作是通过 ZooKeeper 服务器在 &#x2F;consumers 节点路径下创建一个子数据节点，然后再在请求会话中发起对 &#x2F;providers 节点的 watch 监控</p>\n<img src=\"https://img-blog.csdnimg.cn/a27e2d30709947d7b995da6c091de3ba.png\"/>\n\n<p><strong>Kafka与ZooKeeper</strong></p>\n<p><strong>Zookeeper的作用</strong></p>\n<p>由于 Broker 服务器采用分布式集群的方式工作，那么在服务的运行过程中，难免出现某台机器因异常而关闭的状况。</p>\n<p>为了保证整个 Kafka 集群的可用性，需要在系统中监控整个机器的运行情况。而 Kafka 可以通过 ZooKeeper 中的数据节点，将网络中机器的运行统计存储在数据模型中的 brokers 节点下。</p>\n<p>在 Kafka 的 Topic 信息注册中也需要使用到 ZooKeeper ，在 Kafka 中同一个Topic 消息容器可以分成多个不同片，而这些分区既可以存在于一台 Broker 服务器中，也可以存在于不同的 Broker 服务器中。</p>\n<p>而在 Kafka 集群中，每台 Broker 服务器又相对独立。</p>\n<p>为了能够读取这些以分布式方式存储的分区信息，Kafka 会将这些分区信息在 Broker 服务器中的对应关系存储在 ZooKeeper 数据模型的 topic 节点上，每一个 topic 在 ZooKeeper 数据节点上都会以 <code>/brokers/topics/[topic]</code> 的形式存在。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/058b3613e6204da8a467d8aa19f611b8.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>《从Paxos到Zookeeper 分布式一致性原理与实践》</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这一个月，一直在鼓捣自己的个人网站，没更新</p>\n<p>之前分享过几个系列：</p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/zfHoSsuSpXWOaxQrm7uvkA\">Kafka核心知识总结！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/m_awvdGYXd9SJQ8YePENGQ\">计算机网络常用知识总结！</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/RpMwJrEqAP8K0vRTH392kg\">操作系统常用知识总结！</a></li>\n</ul>\n<p>今天这篇介绍一下ZooKeeper！</p>\n<p><strong>文章较长，可以点赞，收藏再看！</strong></p>\n<p>文章内容会同步到个人网站上，方便阅读：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/dc49ec91428d4b12b7c11292fb51acb6.png\"></p>\n<h1 id=\"基本介绍\"><a href=\"#基本介绍\" class=\"headerlink\" title=\"基本介绍\"></a>基本介绍</h1><p>Apache ZooKeeper（以下简称ZK）是由Apache Hadoop的子项目发展而来，为分布式应用提供高效且可靠的分布式协调服务。</p>\n<ul>\n<li>在解决分布式数据一致性方面，ZK没有直接采用Paxos算法，而是采用了ZAB（ZooKeeper Atomic Broadcast）协议。</li>\n</ul>\n<p>ZK可以提供诸如数据发布&#x2F;订阅、负载均衡、命名服务、分布式协调&#x2F;通知，集群管理，Master选举，分布式锁，分布式队列等功能。</p>\n<p><strong>它具有以下特性：</strong></p>\n<ul>\n<li><strong>顺序一致性</strong>：从一个客户端发起的事务请求，最终都会严格按照其发起顺序被应用到 Zookeeper 中；</li>\n<li><strong>原子性</strong>：要么所有应用，要么不应用；不存在部分机器应用了该事务，而<strong>另一部分没有应用</strong>的情况；</li>\n<li><strong>单一视图</strong>：所有客户端看到的服务端数据模型都是一致的，无论客户连接的是哪个ZK服务器；</li>\n<li><strong>可靠性</strong>：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改；</li>\n<li><strong>实时性</strong>：一旦一个事务被成功应用后，Zookeeper 可以保证客户端立即可以读取到这个事务变更后的最新状态的数据（<strong>一段时间</strong>）。</li>\n</ul>\n<h1 id=\"数据模型\"><a href=\"#数据模型\" class=\"headerlink\" title=\"数据模型\"></a>数据模型</h1><p>ZooKeeper 中的数据模型是一种树形结构，非常像电脑中的文件系统，有一个根文件夹，下面还有很多子文件夹。</p>\n<ul>\n<li><p>ZooKeeper的数据模型也具有一个固定的根节点<code>（/）</code>，我们可以在根节点下创建子节点，并在子节点下继续创建下一级节点。</p>\n</li>\n<li><p>ZooKeeper 树中的每一层级用斜杠<code>（/）</code>分隔开，且只能用绝对路径（如<code>get /work/task</code>）的方式查询 ZooKeeper 节点，而不能使用相对路径。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/63d002b469764d71b68897df6849a0f9.png\"/>\n\n<p><strong>为什么 ZooKeeper 不能采用相对路径查找节点呢？</strong></p>\n<blockquote>\n<p>这是因为 ZooKeeper 大多是应用场景是定位数据模型上的节点，并在相关节点上进行操作。</p>\n</blockquote>\n<p>像这种查找与给定值相等的记录问题最适合用散列来解决。</p>\n<p>因此 ZooKeeper 在底层实现的时候，使用了一个 hashtable，即 <code>hashtableConcurrentHashMap&lt;String, DataNode&gt; nodes </code>，用节点的完整路径来作为 key 存储节点数据。</p>\n<p>这样就大大提高了 ZooKeeper 的性能。</p>\n<p><strong>节点类型</strong></p>\n<p>ZooKeeper 中的数据节点也分为持久节点、临时节点和有序节点三种类型：</p>\n<blockquote>\n<p>1、持久节点</p>\n</blockquote>\n<p>一旦将节点创建为持久节点，该数据节点会一直存储在 ZooKeeper 服务器上，即使创建该节点的客户端与服务端的会话关闭了，该节点依然不会被删除。如果我们想删除持久节点，就要显式调用 delete 函数进行删除操作。</p>\n<blockquote>\n<p>2、临时节点</p>\n</blockquote>\n<p>如果将节点创建为临时节点，那么该节点数据不会一直存储在 ZooKeeper 服务器上。</p>\n<p>当创建该临时节点的客户端会话因超时或发生异常而关闭时，该节点也相应在 ZooKeeper 服务器上被删除，同样，我们可以像删除持久节点一样主动删除临时节点。</p>\n<p>在平时的开发中，我们可以利用临时节点的这一特性来做服务器集群内机器运行情况的统计，将集群设置为<code>/servers</code>节点，并为集群下的每台服务器创建一个临时节点<code>/servers/host</code>，当服务器下线时该节点自动被删除，最后统计临时节点个数就可以知道集群中的运行情况。</p>\n<blockquote>\n<p>3、有序节点</p>\n</blockquote>\n<p>节点有序是说在我们创建有序节点的时候，ZooKeeper 服务器会自动使用一个单调递增的数字作为后缀，追加到我们创建节点的后边。</p>\n<p>例如一个客户端创建了一个路径为 <code>works/task- </code>的有序节点，那么 ZooKeeper 将会生成一个序号并追加到该节点的路径后，最后该节点的路径为<code> works/task-1</code>。</p>\n<ul>\n<li>通过这种方式我们可以直观的查看到节点的创建顺序。</li>\n</ul>\n<p>ZooKeeper 中的每个节点都维护有这些内容：一个二进制数组<code>（byte data[]）</code>，用来存储节点的数据、ACL 访问控制信息、子节点数据（因为临时节点不允许有子节点，所以其子节点字段为 null），除此之外每个数据节点还有一个记录自身状态信息的字段 stat。</p>\n<p><strong>节点的状态结构</strong></p>\n<p>执行<code> stat /zk_test</code>，可以看到控制台输出了一些信息，这些就是节点状态信息。</p>\n<p>每一个节点都有一个自己的状态属性，记录了节点本身的一些信息：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>状态属性</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">czxid</td>\n<td align=\"left\">数据节点创建时的事务 ID</td>\n</tr>\n<tr>\n<td align=\"left\">ctime</td>\n<td align=\"left\">数据节点创建时的时间</td>\n</tr>\n<tr>\n<td align=\"left\">mzxid</td>\n<td align=\"left\">数据节点最后一次更新时的事务 ID</td>\n</tr>\n<tr>\n<td align=\"left\">mtime</td>\n<td align=\"left\">数据节点最后一次更新时的时间</td>\n</tr>\n<tr>\n<td align=\"left\">pzxid</td>\n<td align=\"left\">数据节点的子节点最后一次被修改时的事务 ID</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>cversion</strong></td>\n<td align=\"left\"><strong>子节点的版本</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>version</strong></td>\n<td align=\"left\"><strong>当前节点数据的版本</strong></td>\n</tr>\n<tr>\n<td align=\"left\"><strong>aversion</strong></td>\n<td align=\"left\"><strong>节点的 ACL 的版本</strong></td>\n</tr>\n<tr>\n<td align=\"left\">ephemeralOwner</td>\n<td align=\"left\">如果节点是临时节点，则表示创建该节点的会话的 SessionID；如果节点是持久节点，则该属性值为 0</td>\n</tr>\n<tr>\n<td align=\"left\">dataLength</td>\n<td align=\"left\">数据内容的长度</td>\n</tr>\n<tr>\n<td align=\"left\">numChildren</td>\n<td align=\"left\">数据节点当前的子节点个数</td>\n</tr>\n</tbody></table>\n<p><strong>数据节点的版本</strong></p>\n<p>在 ZooKeeper 中为数据节点引入了版本的概念，每个数据节点有 3 种类型的版本信息，对数据节点的任何更新操作都会引起版本号的变化。</p>\n<p>ZooKeeper 的版本信息表示的是对节点数据内容、子节点信息或者是 ACL 信息的修改次数。</p>\n<h1 id=\"数据存储\"><a href=\"#数据存储\" class=\"headerlink\" title=\"数据存储\"></a>数据存储</h1><p>从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。</p>\n<ul>\n<li><p>事务日志数据主要用于记录本地事务性会话操作，用于 ZooKeeper 集群服务器之间的数据同步。</p>\n</li>\n<li><p>事务快照则是将内存数据持久化到本地磁盘。</p>\n</li>\n</ul>\n<blockquote>\n<p>这里要注意的一点是，数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致。</p>\n</blockquote>\n<p>在单台 ZooKeeper 服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。</p>\n<p><strong>内存数据</strong></p>\n<p>ZooKeeper 的数据模型可以看作一棵树形结构，而数据节点就是这棵树上的叶子节点。</p>\n<p>从数据存储的角度看，ZooKeeper 的数据模型是存储在内存中的。</p>\n<p>我们可以把 ZooKeeper 的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的 ACL 权限信息以及 stat 状态信息等。</p>\n<ul>\n<li>而在底层实现中，ZooKeeper 数据模型是通过 DataTree 类来定义的。</li>\n</ul>\n<p>DataTree 类定义了一个 ZooKeeper 数据的内存结构。</p>\n<p>DataTree 的内部定义类 nodes 节点类型、root 根节点信息、子节点的 WatchManager 监控信息等数据模型中的相关信息。</p>\n<p>可以说，一个 DataTree 类定义了 ZooKeeper 内存数据的逻辑结构。</p>\n<p><strong>事务日志</strong></p>\n<p>为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper 集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper 集群中的 Follow 和 Observer 服务器就会进行数据同步。</p>\n<blockquote>\n<p>而这两种角色服务器所接收到的信息就是 Leader 服务器的事务日志。</p>\n</blockquote>\n<p>在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个 ZooKeeper 集群的执行性能。</p>\n<h1 id=\"Watch机制\"><a href=\"#Watch机制\" class=\"headerlink\" title=\"Watch机制\"></a>Watch机制</h1><p>ZooKeeper 的客户端可以通过 Watch 机制来订阅当服务器上某一节点的数据或状态发生变化时收到相应的通知；</p>\n<p><strong>如何实现：</strong></p>\n<p>我们可以通过向 ZooKeeper 客户端的构造方法中传递 Watcher 参数的方式实现：</p>\n<pre><code class=\"java\">new ZooKeeper(String connectString, int sessionTimeout, Watcher watcher)\n</code></pre>\n<p>上面代码的意思是定义了一个了 ZooKeeper 客户端对象实例，并传入三个参数：</p>\n<ul>\n<li><p>connectString 服务端地址</p>\n</li>\n<li><p>sessionTimeout：超时时间</p>\n</li>\n<li><p>Watcher：监控事件</p>\n</li>\n</ul>\n<p>这个 Watcher 将作为整个 ZooKeeper 会话期间的上下文 ，一直被保存在客户端 ZKWatchManager 的 defaultWatcher 中。</p>\n<p>除此之外，ZooKeeper 客户端也可以通过 getData、exists 和 getChildren 三个接口来向 ZooKeeper 服务器注册 Watcher，从而方便地在不同的情况下添加 Watch 事件：</p>\n<pre><code class=\"java\">getData(String path, Watcher watcher, Stat stat)\n</code></pre>\n<p>触发通知的条件：</p>\n<img src=\"https://img-blog.csdnimg.cn/95ebb31561bd4ea2bed199cdf8b3bfce.png\"/>\n\n<p>上图中列出了客户端在不同会话状态下，相应的在服务器节点所能支持的事件类型。</p>\n<ul>\n<li>例如在客户端连接服务端的时候，可以对数据节点的创建、删除、数据变更、子节点的更新等操作进行监控。</li>\n</ul>\n<p><strong>当服务端某一节点发生数据变更操作时，所有曾经设置了该节点监控事件的客户端都会收到服务器的通知吗？</strong></p>\n<p>答案是否定的，Watch 事件的触发机制取决于会话的连接状态和客户端注册事件的类型，所以当客户端会话状态或数据节点发生改变时，都会触发对应的 Watch 事件。</p>\n<p><strong>订阅发布场景实现</strong></p>\n<blockquote>\n<p>提到 ZooKeeper 的应用场景，你可能第一时间会想到最为典型的发布订阅功能。</p>\n</blockquote>\n<p>发布订阅功能可以看作是一个一对多的关系，即一个服务或数据的发布者可以被多个不同的消费者调用。</p>\n<p>一般一个发布订阅模式的数据交互可以分为消费者主动请求生产者信息的拉取模式，和生产者数据变更时主动推送给消费者的推送模式。</p>\n<p>ZooKeeper 采用了两种模式结合的方式实现订阅发布功能。</p>\n<blockquote>\n<p>下面我们来分析一个具体案例：</p>\n</blockquote>\n<p>在系统开发的过程中会用到各种各样的配置信息，如数据库配置项、第三方接口、服务地址等，这些配置操作在我们开发过程中很容易完成，但是放到一个大规模的集群中配置起来就比较麻烦了。</p>\n<p>通常这种集群中，我们可以用配置管理功能自动完成服务器配置信息的维护，利用ZooKeeper 的发布订阅功能就能解决这个问题。</p>\n<p>我们可以把诸如数据库配置项这样的信息存储在 ZooKeeper 数据节点中。</p>\n<p>如<code>/confs/data_item1</code>。</p>\n<ul>\n<li><p>服务器集群客户端对该节点添加 Watch 事件监控，当集群中的服务启动时，会读取该节点数据获取数据配置信息。</p>\n</li>\n<li><p>而当该节点数据发生变化时，ZooKeeper 服务器会发送 Watch 事件给各个客户端，集群中的客户端在接收到该通知后，重新读取节点的数据库配置信息。</p>\n</li>\n</ul>\n<p>我们使用 Watch 机制实现了一个分布式环境下的配置管理功能，通过对 ZooKeeper 服务器节点添加数据变更事件，实现当数据库配置项信息变更后，集群中的各个客户端能接收到该变更事件的通知，并获取最新的配置信息。</p>\n<blockquote>\n<p>要注意一点是，我们提到 Watch 具有一次性，所以当我们获得服务器通知后要再次添加 Watch 事件。</p>\n</blockquote>\n<h1 id=\"会话机制\"><a href=\"#会话机制\" class=\"headerlink\" title=\"会话机制\"></a>会话机制</h1><p>ZooKeeper 的工作方式一般是通过客户端向服务端发送请求而实现的。</p>\n<p>而在一个请求的发送过程中，首先，客户端要与服务端进行连接，而一个连接就是一个会话。</p>\n<blockquote>\n<p>在 ZooKeeper 中，一个会话可以看作是一个用于表示客户端与服务器端连接的数据结构 Session。</p>\n</blockquote>\n<p>这个数据结构由三个部分组成：分别是会话 ID（sessionID）、会话超时时间（TimeOut）、会话关闭状态（isClosing）</p>\n<ul>\n<li><p>会话 ID：会话 ID 作为一个会话的标识符，当我们创建一次会话的时候，ZooKeeper 会自动为其分配一个唯一的 ID 编码。</p>\n</li>\n<li><p>会话超时时间：一般来说，一个会话的超时时间就是指一次会话从发起后到被服务器关闭的时长。而设置会话超时时间后，服务器会参考设置的超时时间，最终计算一个服务端自己的超时时间。而这个超时时间则是最终真正用于 ZooKeeper 中服务端用户会话管理的超时时间。</p>\n</li>\n<li><p>会话关闭状态：会话关闭 isClosing 状态属性字段表示一个会话是否已经关闭。如果服务器检查到一个会话已经因为超时等原因失效时， ZooKeeper 会在该会话的 isClosing 属性值标记为关闭，再之后就不对该会话进行操作了。</p>\n</li>\n</ul>\n<p><strong>会话状态</strong></p>\n<p>在 ZooKeeper 服务的运行过程中，会话会经历不同的状态变化。</p>\n<p>这些状态包括：</p>\n<blockquote>\n<p>正在连接（CONNECTING）、已经连接（CONNECTIED）、正在重新连接（RECONNECTING）、已经重新连接（RECONNECTED）、会话关闭（CLOSE）等。</p>\n</blockquote>\n<p>当客户端开始创建一个与服务端的会话操作时，它的会话状态就会变成 CONNECTING，之后客户端会根据服务器地址列表中的服务器 IP 地址分别尝试进行连接。如果遇到一个 IP 地址可以连接到服务器，那么客户端会话状态将变为 CONNECTIED。</p>\n<p>如果因为网络原因造成已经连接的客户端会话断开时，客户端会重新尝试连接服务端。而对应的客户端会话状态又变成 CONNECTING ，直到该会话连接到服务端最终又变成 CONNECTIED。</p>\n<blockquote>\n<p>在 ZooKeeper 服务的整个运行过程中，会话状态经常会在 CONNECTING 与 CONNECTIED 之间进行切换。</p>\n</blockquote>\n<p>最后，当出现超时或者客户端主动退出程序等情况时，客户端会话状态则会变为 CLOSE 状态。</p>\n<p><strong>会话异常</strong></p>\n<p>在 ZooKeeper 中，会话的超时异常包括客户端 readtimeout 异常和服务器端 sessionTimeout 异常。</p>\n<ul>\n<li>在我们平时的开发中，要明确这两个异常的不同之处在于一个是发生在客户端，而另一个是发生在服务端。</li>\n</ul>\n<p>而对于那些对 ZooKeeper 接触不深的开发人员来说，他们常常踩坑的地方在于，虽然设置了超时间，但是在实际服务运行的时候 ZooKeeper 并没有按照设置的超时时间来管理会话。</p>\n<ul>\n<li>这是因为 ZooKeeper 实际起作用的超时时间是通过客户端和服务端协商决定。</li>\n</ul>\n<p>ZooKeeper 客户端在和服务端建立连接的时候，会提交一个客户端设置的会话超时时间，而该超时时间会和服务端设置的最大超时时间和最小超时时间进行比对，如果正好在其允许的范围内，则采用客户端的超时时间管理会话。</p>\n<p>如果大于或者小于服务端设置的超时时间，则采用服务端设置的值管理会话。</p>\n<p><strong>分桶策略</strong></p>\n<p>我们知道在 ZooKeeper 中为了保证一个会话的存活状态，客户端需要向服务器周期性地发送心跳信息。</p>\n<ul>\n<li>而客户端所发送的心跳信息可以是一个 ping 请求，也可以是一个普通的业务请求。</li>\n</ul>\n<p>ZooKeeper 服务端接收请求后，会更新会话的过期时间，来保证会话的存活状态。</p>\n<ul>\n<li>所以在 ZooKeeper 的会话管理中，最主要的工作就是管理会话的过期时间。</li>\n</ul>\n<blockquote>\n<p>ZooKeeper 中采用了独特的会话管理方式来管理会话的过期时间。</p>\n</blockquote>\n<p>在 ZooKeeper 中，会话将按照不同的时间间隔进行划分，超时时间相近的会话将被放在同一个间隔区间中，这种方式避免了 ZooKeeper 对每一个会话进行检查，而是采用分批次的方式管理会话。</p>\n<p>这就降低了会话管理的难度，因为每次小批量的处理会话过期也提高了会话处理的效率。</p>\n<p><strong>ZooKeeper 这种会话管理的好处？</strong></p>\n<p>ZooKeeper 这种分段的会话管理策略大大提高了计算会话过期的效率，如果是在一个实际生产环境中，一个大型的分布式系统往往具有很高的访问量。</p>\n<p>而 ZooKeeper 作为其中的组件，对外提供服务往往要承担数千个客户端的访问，这其中就要对这几千个会话进行管理。</p>\n<p>在这种场景下，要想通过对每一个会话进行管理和检查并不合适，所以采用将同一个时间段的会话进行统一管理，这样就大大提高了服务的运行效率。</p>\n<p><strong>底层实现</strong></p>\n<p>ZooKeeper 底层实现的原理，核心的一点就是过期队列这个数据结构。所有会话过期的相关操作都是围绕这个队列进行的。</p>\n<ul>\n<li>可以说 ZooKeeper 底层就是采用这个队列结构来管理会话过期的。</li>\n</ul>\n<p><strong>一个会话过期队列是由若干个 bucket 组成的。</strong></p>\n<ul>\n<li><p>bucket 是一个按照时间划分的区间。</p>\n</li>\n<li><p>在 ZooKeeper 中，通常以 expirationInterval 为单位进行时间区间的划分，它是 ZooKeeper 分桶策略中用于划分时间区间的最小单位。</p>\n</li>\n<li><p>在 ZooKeeper 中，一个过期队列由不同的 bucket 组成。</p>\n</li>\n<li><p>每个 bucket 中存放了在某一时间内过期的会话。</p>\n</li>\n</ul>\n<p>将会话按照不同的过期时间段分别维护到过期队列之后，在 ZooKeeper 服务运行的过程中，具体的执行过程如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/86243433c4674237b3339452d2bc0e7c.png\"/>\n\n<p>首先，ZooKeeper 服务会开启一个线程专门用来检索过期队列，找出要过期的 bucket，而 ZooKeeper 每次只会让一个 bucket 的会话过期，每当要进行会话过期操作时，ZooKeeper 会唤醒一个处于休眠状态的线程进行会话过期操作，之后会按照上面介绍的操作检索过期队列，取出过期的会话后会执行过期操作。</p>\n<h1 id=\"ACL权限\"><a href=\"#ACL权限\" class=\"headerlink\" title=\"ACL权限\"></a>ACL权限</h1><p>ZooKeeper的ACL可针对znodes设置相应的权限信息。</p>\n<p>一个 ACL 权限设置通常可以分为 3 部分，分别是：权限模式（Scheme）、授权对象（ID）、权限信息（Permission）。</p>\n<ul>\n<li>最终组成一条例如<code>scheme:id:permission</code>格式的 ACL 请求信息。</li>\n</ul>\n<p><strong>权限模式：Scheme</strong></p>\n<p>ZooKeeper 的权限验证方式大体分为两种类型，一种是范围验证，另外一种是口令验证。</p>\n<blockquote>\n<p>范围验证</p>\n</blockquote>\n<p>所谓的范围验证就是说 ZooKeeper 可以针对一个 IP 或者一段 IP 地址授予某种权限。</p>\n<p>比如我们可以让一个 IP 地址为<code>ip：192.168.0.11</code>的机器对服务器上的某个数据节点具有写入的权限。</p>\n<p>或者也可以通过<code>ip:192.168.0.11/22</code>给一段 IP 地址的机器赋权。</p>\n<blockquote>\n<p>口令验证</p>\n</blockquote>\n<p>可以理解为用户名密码的方式，这是我们最熟悉也是日常生活中经常使用的模式，比如我们打开自己的电脑或者去银行取钱都需要提供相应的密码。</p>\n<p>在 ZooKeeper 中这种验证方式是 Digest 认证，我们知道通过网络传输相对来说并不安全，所以绝不通过明文在网络发送密码也是程序设计中很重要的原则之一，而 Digest 这种认证方式首先在客户端传送<code>username:password</code>这种形式的权限表示符后，ZooKeeper 服务端会对密码部分使用 SHA-1 和 BASE64 算法进行加密，以保证安全性。</p>\n<blockquote>\n<p>Super 权限模式</p>\n</blockquote>\n<p>权限模式 Super 可以认为是一种特殊的 Digest 认证。</p>\n<p>具有 Super 权限的客户端可以对 ZooKeeper 上的任意数据节点进行任意操作。</p>\n<p>下面这段代码给出了 Digest 模式下客户端的调用方式。</p>\n<pre><code>//创建节点\ncreate /digest_node1\n//设置digest权限验证\nsetAcl /digest_node1 digest:用户名:base64格式密码:rwadc \n//查询节点Acl权限\ngetAcl /digest_node1 \n//授权操作\naddauth digest user:passwd\n</code></pre>\n<blockquote>\n<p>如果一个客户端对服务器上的一个节点设置了只有它自己才能操作的权限，那么等这个客户端下线或被删除后。</p>\n</blockquote>\n<p>对其创建的节点要想进行修改应该怎么做呢？</p>\n<p>我们可以通过<strong>super 模式</strong>即超级管理员的方式删除该节点或变更该节点的权限验证方式。</p>\n<p>正因为<strong>super 模式</strong>有如此大的权限，我们在平时使用时也应该更加谨慎。</p>\n<blockquote>\n<p>world 模式</p>\n</blockquote>\n<p>这种授权模式对应于系统中的所有用户，本质上起不到任何作用。</p>\n<p>设置了 world 权限模式系统中的所有用户操作都可以不进行权限验证。</p>\n<p><strong>授权对象（ID）</strong></p>\n<p>所谓的授权对象就是说我们要把权限赋予谁，而对应于 4 种不同的权限模式来说，如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。</p>\n<p>如果是 World 模式，是授权系统中所有的用户。</p>\n<p><strong>权限信息（Permission）</strong></p>\n<p>权限就是指我们可以在数据节点上执行的操作种类，在 ZooKeeper 中已经定义好的权限有 5 种：</p>\n<ul>\n<li><p>数据节点（create）创建权限，授予权限的对象可以在数据节点下创建子节点；</p>\n</li>\n<li><p>数据节点（wirte）更新权限，授予权限的对象可以更新该数据节点；</p>\n</li>\n<li><p>数据节点（read）读取权限，授予权限的对象可以读取该节点的内容以及子节点的信息；</p>\n</li>\n<li><p>数据节点（delete）删除权限，授予权限的对象可以删除该数据节点的子节点；</p>\n</li>\n<li><p>数据节点（admin）管理者权限，授予权限的对象可以对该数据节点体进行 ACL 权限设置。</p>\n</li>\n</ul>\n<blockquote>\n<p>需要注意的一点是，每个节点都有维护自身的 ACL 权限数据，即使是该节点的子节点也是有自己的 ACL 权限而不是直接继承其父节点的权限。</p>\n</blockquote>\n<p><strong>实现自己的权限口控制</strong></p>\n<p>虽然 ZooKeeper 自身的权限控制机制已经做得很细，但是它还是提供了一种权限扩展机制来让用户实现自己的权限控制方式。</p>\n<p>官方文档中对这种机制的定义是 <code>Pluggable ZooKeeper Authenication</code>，意思是可插拔的授权机制，从名称上我们可以看出它的灵活性。那么这种机制是如何实现的呢？</p>\n<blockquote>\n<p>要想实现自定义的权限控制机制，最核心的一点是实现 ZooKeeper 提供的权限控制器接口 AuthenticationProvider。</p>\n</blockquote>\n<p>实现了自定义权限后，如何才能让 ZooKeeper 服务端使用自定义的权限验证方式呢？</p>\n<p>接下来就需要将自定义的权限控制注册到 ZooKeeper 服务器中，而注册的方式通常有两种。</p>\n<ul>\n<li>第一种是通过设置系统属性来注册自定义的权限控制器：</li>\n</ul>\n<pre><code class=\"java\">-Dzookeeper.authProvider.x=CustomAuthenticationProvider\n</code></pre>\n<ul>\n<li>另一种是在配置文件<code>zoo.cfg</code>中进行配置：</li>\n</ul>\n<pre><code class=\"java\">authProvider.x=CustomAuthenticationProvider\n</code></pre>\n<p><strong>实现原理</strong></p>\n<p>首先是封装该请求的类型，之后将权限信息封装到 request 中并发送给服务端。而服务器的实现比较复杂，首先分析请求类型是否是权限相关操作，之后根据不同的权限模式（scheme）调用不同的实现类验证权限最后存储权限信息。</p>\n<p>在授权接口中，值得注意的是会话的授权信息存储在 ZooKeeper 服务端的内存中，如果客户端会话关闭，授权信息会被删除。</p>\n<p>下次连接服务器后，需要重新调用授权接口进行授权。</p>\n<h1 id=\"序列化方式\"><a href=\"#序列化方式\" class=\"headerlink\" title=\"序列化方式\"></a>序列化方式</h1><p>在 ZooKeeper 中并没有采用和 Java 一样的序列化方式，而是采用了一个 Jute 的序列解决方案作为 ZooKeeper 框架自身的序列化方式。</p>\n<blockquote>\n<p>ZooKeeper 从最开始就采用 Jute 作为其序列化解决方案，直到其最新的版本依然没有更改。</p>\n</blockquote>\n<p>虽然 ZooKeeper 一直将 Jute 框架作为序列化解决方案，但这并不意味着 Jute 相对其他框架性能更好，反倒是 Apache Avro、Thrift 等框架在性能上优于前者。</p>\n<p>之所以 ZooKeeper 一直采用 Jute 作为序列化解决方案，主要是新老版本的兼容等问题。</p>\n<p><strong>如何 使用 Jute 实现序列化</strong></p>\n<p>如果我们要想将某个定义的类进行序列化，首先需要该类实现 Record 接口的 serilize 和 deserialize 方法，这两个方法分别是序列化和反序列化方法。</p>\n<blockquote>\n<p>下边这段代码给出了我们一般在 ZooKeeper 中进行序列化的具体实现：</p>\n</blockquote>\n<p>首先，我们定义了一个<code>test_jute</code>类，为了能够对它进行序列化，需要该<code>test_jute</code>类实现 Record 接口，并在对应的 serialize 序列化方法和 deserialize 反序列化方法中编辑具体的实现逻辑。</p>\n<pre><code class=\"java\">class test_jute implements Record&#123;\n  private long ids；\n  private String name;\n  ...\n  public void serialize(OutpurArchive a_,String tag)&#123;\n    ...\n  &#125;\n  public void deserialize(INputArchive a_,String tag)&#123;\n    ...\n  &#125;\n&#125;\n</code></pre>\n<p>在序列化方法 serialize 中，我们要实现的逻辑是，首先通过字符类型参数 tag 传递标记序列化标识符，之后使用 writeLong 和 writeString 等方法分别将对象属性字段进行序列化。</p>\n<pre><code class=\"java\">public void serialize(OutpurArchive a_,String tag) throws ...&#123;\n  a_.startRecord(this.tag);\n  a_.writeLong(ids,&quot;ids&quot;);\n  a_.writeString(type,&quot;name&quot;);\n  a_.endRecord(this,tag);\n&#125;\n</code></pre>\n<p>调用 derseralize 在实现反序列化的过程则与我们上边说的序列化过程正好相反。</p>\n<pre><code class=\"java\">public void deserialize(INputArchive a_,String tag) throws &#123;\n  a_.startRecord(tag);\n  ids = a_.readLong(&quot;ids&quot;);\n  name = a_.readString(&quot;name&quot;);\n  a_.endRecord(tag);\n&#125;\n</code></pre>\n<p>序列化和反序列化的实现逻辑编码方式相对固定，首先通过 startRecord 开启一段序列化操作，之后通过 writeLong、writeString 或 readLong、 readString 等方法执行序列化或反序列化。</p>\n<p>本例中只是实现了长整型和字符型的序列化和反序列化操作，除此之外 ZooKeeper 中的 Jute 框架还支持整数类型（Int）、布尔类型（Bool）、双精度类型（Double）以及 Byte&#x2F;Buffer 类型。</p>\n<h1 id=\"集群\"><a href=\"#集群\" class=\"headerlink\" title=\"集群\"></a>集群</h1><p><strong>ZooKeeper集群模式的特点</strong></p>\n<p>在 ZooKeeper 集群中将服务器分成 <strong>Leader 、Follow 、Observer 三</strong>种角色服务器，在集群运行期间这三种服务器所负责的工作各不相同：</p>\n<ul>\n<li><p>Leader 角色服务器负责管理集群中其他的服务器，是集群中工作的分配和调度者，既可以为客户端提供写服务又能提供读服务。</p>\n</li>\n<li><p>Follow 服务器的主要工作是选举出 Leader 服务器，在发生 Leader 服务器选举的时候，系统会从 Follow 服务器之间根据多数投票原则，选举出一个 Follow 服务器作为新的 Leader 服务器，只能提供读服务。</p>\n</li>\n<li><p>Observer 服务器则主要负责处理来自客户端的获取数据等请求，并不参与 Leader 服务器的选举操作，也不会作为候选者被选举为 Leader 服务器，只能提供读服务。</p>\n</li>\n</ul>\n<p>在 ZooKeeper 集群接收到来自客户端的会话请求操作后，首先会判断该条请求是否是事务性的会话请求。</p>\n<blockquote>\n<p>对于事务性的会话请求，ZooKeeper 集群服务端会将该请求统一转发给 Leader 服务器进行操作。</p>\n<p>所谓事务性请求，是指 ZooKeeper 服务器执行完该条会话请求后，是否会导致执行该条会话请求的服务器的数据或状态发生改变，进而导致与其他集群中的服务器出现数据不一致的情况。</p>\n</blockquote>\n<p>Leader 服务器内部执行该条事务性的会话请求后，再将数据同步给其他角色服务器，从而保证事务性会话请求的执行顺序，进而保证整个 ZooKeeper 集群的数据一致性。</p>\n<blockquote>\n<p>在 ZooKeeper 集群的内部实现中，是通过什么方法保证所有 ZooKeeper 集群接收到的事务性会话请求都能交给 Leader 服务器进行处理的呢？</p>\n</blockquote>\n<p>在 ZooKeeper 集群内部，集群中除 Leader 服务器外的其他角色服务器接收到来自客户端的事务性会话请求后，必须将该条会话请求转发给 Leader 服务器进行处理。</p>\n<p>ZooKeeper 集群中的 Follow 和 Observer 服务器，都会检查当前接收到的会话请求是否是事务性的请求，如果是事务性的请求，那么就将该请求以 REQUEST 消息类型转发给 Leader 服务器。</p>\n<p>在 ZooKeeper集群中的服务器接收到该条消息后，会对该条消息进行解析。</p>\n<ul>\n<li><p>分析出该条消息所包含的原始客户端会话请求。</p>\n</li>\n<li><p>之后将该条消息提交到自己的 Leader 服务器请求处理链中，开始进行事务性的会话请求操作。</p>\n</li>\n<li><p>如果不是事务性请求，ZooKeeper 集群则交由 Follow 和 Observer 角色服务器处理该条会话请求，如查询数据节点信息。</p>\n</li>\n</ul>\n<p>当一个业务场景在查询操作多而创建删除等事务性操作少的情况下，ZooKeeper 集群的性能表现的就会很好。</p>\n<blockquote>\n<p>如果是在极端情况下，ZooKeeper 集群只有事务性的会话请求而没有查询操作，那么 Follow 和 Observer 服务器就只能充当一个请求转发服务器的角色， 所有的会话的处理压力都在 Leader 服务器。</p>\n</blockquote>\n<p>在处理性能上整个集群服务器的瓶颈取决于 Leader 服务器的性能。</p>\n<blockquote>\n<p>ZooKeeper 集群的作用只能保证在 Leader 节点崩溃的时候，重新选举出 Leader 服务器保证系统的稳定性。</p>\n</blockquote>\n<p>这也是 ZooKeeper 设计的一个缺点。</p>\n<p><strong>Leader选举</strong></p>\n<p>Leader 服务器的选举操作主要发生在两种情况下。</p>\n<p>第一种就是 ZooKeeper 集群服务启动的时候，第二种就是在 ZooKeeper 集群中旧的 Leader 服务器失效时，这时 ZooKeeper 集群需要选举出新的 Leader 服务器。</p>\n<blockquote>\n<p>ZooKeeper 集群重新选举 Leader 的过程只有 Follow 服务器参与工作。</p>\n</blockquote>\n<blockquote>\n<p>服务器状态</p>\n</blockquote>\n<p>服务器具有四种状态，分别是LOOKING、FOLLOWING、LEADING、OBSERVING。</p>\n<ul>\n<li><p><strong>LOOKING</strong>：寻找Leader状态。当服务器处于该状态时，它会认为当前集群中没有Leader，因此需要进入Leader选举状态。</p>\n</li>\n<li><p><strong>FOLLOWING</strong>：跟随者状态。表明当前服务器角色是Follower。</p>\n</li>\n<li><p><strong>LEADING</strong>：领导者状态。表明当前服务器角色是Leader。</p>\n</li>\n<li><p><strong>OBSERVING</strong>：观察者状态。表明当前服务器角色是Observer。</p>\n</li>\n</ul>\n<p><strong>事务ID（zxid）</strong></p>\n<p>Zookeeper的状态变化，都会由一个Zookeeper事务ID（ZXID）标识。</p>\n<blockquote>\n<p>写入Zookeeper，会导致状态变化，每次写入都会导致ZXID发生变化。</p>\n</blockquote>\n<p>ZXID由Leader统一分配，全局唯一，长度64位，递增。</p>\n<p>ZXID展示了所有的Zookeeper转台变更顺序，每次变更都有一个唯一ZXID，如果zxid1小于zxid2，则说明zxid1的事务在zxid2的事务之前发生。</p>\n<p><strong>选举过程</strong></p>\n<p>在 ZooKeeper 集群重新选举 Leader 节点的过程中，主要可以分为 Leader 失效发现、重新选举 Leader 、Follow 服务器角色变更、集群同步这几个步骤。</p>\n<blockquote>\n<p>Leader 失效发现</p>\n</blockquote>\n<p>在 ZooKeeper 集群中，当 Leader 服务器失效时，ZooKeeper 集群会重新选举出新的 Leader 服务器。</p>\n<ul>\n<li>在 ZooKeeper 集群中，探测 Leader 服务器是否存活的方式与保持客户端活跃性的方法非常相似。</li>\n</ul>\n<p>首先，Follow 服务器会定期向 Leader 服务器发送 网络请求，在接收到请求后，Leader 服务器会返回响应数据包给 Follow 服务器，而在 Follow 服务器接收到 Leader 服务器的响应后，如果判断 Leader 服务器运行正常，则继续进行数据同步和服务转发等工作，反之，则进行 Leader 服务器的重新选举操作。</p>\n<blockquote>\n<p>Leader重新选举</p>\n</blockquote>\n<p>当 Follow 服务器向 Leader 服务器发送状态请求包后，如果没有得到 Leader 服务器的返回信息，这时，如果是集群中个别的 Follow 服务器发现返回错误，并不会导致 ZooKeeper 集群立刻重新选举 Leader 服务器，而是将该 Follow 服务器的状态变更为 LOOKING 状态，并向网络中发起投票，当 ZooKeeper 集群中有更多的机器发起投票，最后当投票结果满足多数原则的情况下。</p>\n<p>ZooKeeper 会重新选举出 Leader 服务器。</p>\n<blockquote>\n<p>Follow 角色变更</p>\n</blockquote>\n<p>在 ZooKeeper 集群中，Follow 服务器作为 Leader 服务器的候选者，当被选举为 Leader 服务器之后，其在 ZooKeeper 集群中的 Follow 角色，也随之发生改变。也就是要转变为 Leader 服务器，并作为 ZooKeeper 集群中的 Leader 角色服务器对外提供服务。</p>\n<blockquote>\n<p>集群同步数据</p>\n</blockquote>\n<p>在 ZooKeeper 集群成功选举 Leader 服务器，并且候选 Follow 服务器的角色变更后。</p>\n<p>为避免在这期间导致的数据不一致问题，ZooKeeper 集群在对外提供服务之前，会通过 Leader 角色服务器管理同步其他角色服务器。</p>\n<p><strong>底层实现</strong></p>\n<p>首先，ZooKeeper 集群会先判断 Leader 服务器是否失效，而判断的方式就是 Follow 服务器向 Leader 服务器发送请求包，之后 Follow 服务器接收到响应数据后，进行解析，Follow 服务器会根据返回的数据，判断 Leader 服务器的运行状态，如果返回的是 LOOKING 关键字，表明与集群中 Leader 服务器无法正常通信。</p>\n<ul>\n<li>之后，在 ZooKeeper 集群选举 Leader 服务器时，是通过 <strong>FastLeaderElection</strong> 类实现的。</li>\n</ul>\n<p>该类实现了 TCP 方式的通信连接，用于在 ZooKeeper 集群中与其他 Follow 服务器进行协调沟通。</p>\n<p>FastLeaderElection 类继承了 Election 接口，定义其是用来进行选举的实现类。</p>\n<ul>\n<li>而在其内部，又定义了选举通信相关的一些配置参数，比如 finalizeWait 最终等待时间、最大通知间隔时间 maxNotificationInterval 等。</li>\n</ul>\n<p>在选举的过程中，首先调用 ToSend 函数向 ZooKeeper 集群中的其他角色服务器发送本机的投票信息，其他服务器在接收投票信息后，会对投票信息进行有效性验证等操作，之后 ZooKeeper 集群统计投票信息，如果过半数的机器投票信息一致，则集群就重新选出新的 Leader 服务器。</p>\n<blockquote>\n<p>这里我们要注意一个问题，那就是在重新选举 Leader 服务器的过程中，ZooKeeper 集群理论上是无法进行事务性的请求处理的。</p>\n</blockquote>\n<p>因此，发送到 ZooKeeper 集群中的事务性会话会被挂起，暂时不执行，等到选举出新的 Leader 服务器后再进行操作。 </p>\n<p><strong>Observer</strong></p>\n<p>在 ZooKeeper 集群服务运行的过程中，Observer 服务器与 Follow 服务器具有一个相同的功能，那就是负责处理来自客户端的诸如查询数据节点等非事务性的会话请求操作。</p>\n<ul>\n<li>但与 Follow 服务器不同的是，Observer 不参与 Leader 服务器的选举工作，也不会被选举为 Leader 服务器。</li>\n</ul>\n<p>在早期的 ZooKeeper 集群服务运行过程中，只有 Leader 服务器和 Follow 服务器。</p>\n<p>不过随着 ZooKeeper 在分布式环境下的广泛应用，早期模式的设计缺点也随之产生，主要带来的问题有如下几点：</p>\n<ul>\n<li><p>随着集群规模的变大，集群处理写入的性能反而下降。</p>\n</li>\n<li><p>ZooKeeper 集群无法做到跨域部署。</p>\n</li>\n</ul>\n<p>其中最主要的问题在于，当 ZooKeeper 集群的规模变大，集群中 Follow 服务器数量逐渐增多的时候，ZooKeeper 处理创建数据节点等事务性请求操作的性能就会逐渐下降。</p>\n<p>这是因为 ZooKeeper 集群在处理事务性请求操作时，要在 ZooKeeper 集群中对该事务性的请求发起投票，只有超过半数的 Follow 服务器投票一致，才会执行该条写入操作。</p>\n<p>正因如此，随着集群中 Follow 服务器的数量越来越多，一次写入等相关操作的投票也就变得越来越复杂，并且 Follow 服务器之间彼此的网络通信也变得越来越耗时，导致随着 Follow 服务器数量的逐步增加，事务性的处理性能反而变得越来越低。</p>\n<ul>\n<li>为了解决这一问题，在 ZooKeeper 3.6 版本后，ZooKeeper 集群中创建了一种新的服务器角色，即 Observer——观察者角色服务器。</li>\n</ul>\n<p>Observer 可以处理 ZooKeeper 集群中的非事务性请求，并且不参与 Leader 节点等投票相关的操作。</p>\n<p>这样既保证了 ZooKeeper 集群性能的扩展性，又避免了因为过多的服务器参与投票相关的操作而影响 ZooKeeper 集群处理事务性会话请求的能力。</p>\n<ul>\n<li>在实际部署的时候，因为 Observer 不参与 Leader 节点等操作，并不会像 Follow 服务器那样频繁的与 Leader 服务器进行通信。</li>\n</ul>\n<p>因此，可以将 Observer 服务器部署在不同的网络区间中，这样也不会影响整个 ZooKeeper 集群的性能，也就是所谓的跨域部署。</p>\n<p><strong>在我们日常使用 ZooKeeper 集群服务器的时候，集群中的机器个数应该选择奇数个？</strong></p>\n<p>两个原因：</p>\n<blockquote>\n<p>在容错能力相同的情况下，奇数台更节省资源</p>\n</blockquote>\n<p>Zookeeper中 Leader 选举算法采用了Zab协议。</p>\n<p>Zab核心思想是当多数 Server 写成功，则写成功。</p>\n<p>举两个例子：</p>\n<ul>\n<li><p>假如zookeeper集群1 ，有3个节点，3&#x2F;2&#x3D;1.5 ,  即zookeeper想要正常对外提供服务（即leader选举成功），至少需要2个节点是正常的。换句话说，3个节点的zookeeper集群，允许有一个节点宕机。</p>\n</li>\n<li><p>假如zookeeper集群2，有4个节点，4&#x2F;2&#x3D;2 , 即zookeeper想要正常对外提供服务（即leader选举成功），至少需要3个节点是正常的。换句话说，4个节点的zookeeper集群，也允许有一个节点宕机。</p>\n</li>\n</ul>\n<p>集群1与集群2都有 允许1个节点宕机 的容错能力，但是集群2比集群1多了1个节点。在相同容错能力的情况下，本着节约资源的原则，zookeeper集群的节点数维持奇数个更好一些。</p>\n<blockquote>\n<p>防止由脑裂造成的集群不可用。</p>\n</blockquote>\n<p>集群的脑裂通常是发生在节点之间通信不可达的情况下，集群会分裂成不同的小集群，小集群各自选出自己的master节点，导致原有的集群出现多个master节点的情况，这就是脑裂。</p>\n<p>下面举例说一下为什么采用奇数台节点，就可以防止由于脑裂造成的服务不可用：</p>\n<p>假如zookeeper集群有 5 个节点，发生了脑裂，脑裂成了A、B两个小集群： </p>\n<ul>\n<li><p>A ： 1个节点 ，B ：4个节点 </p>\n</li>\n<li><p>A ： 2个节点， B ：3个节点</p>\n</li>\n</ul>\n<p>可以看出，上面这两种情况下，A、B中总会有一个小集群满足 可用节点数量 &gt; 总节点数量&#x2F;2 。</p>\n<p>所以zookeeper集群仍然能够选举出leader ， 仍然能对外提供服务，只不过是有一部分节点失效了而已。</p>\n<p>假如zookeeper集群有4个节点，同样发生脑裂，脑裂成了A、B两个小集群：</p>\n<ul>\n<li><p>A：1个节点 ，  B：3个节点 </p>\n</li>\n<li><p>A：2个节点 ， B：2个节点</p>\n</li>\n</ul>\n<p>因为A和B都是2个节点，都不满足 可用节点数量 &gt; 总节点数量&#x2F;2 的选举条件， 所以此时zookeeper就彻底不能提供服务了。</p>\n<h1 id=\"ZAB协议\"><a href=\"#ZAB协议\" class=\"headerlink\" title=\"ZAB协议\"></a>ZAB协议</h1><p><strong>ZAB 协议算法</strong></p>\n<p>ZooKeeper 最核心的作用就是保证分布式系统的数据一致性，而无论是处理来自客户端的会话请求时，还是集群 Leader 节点发生重新选举时，都会产生数据不一致的情况。</p>\n<blockquote>\n<p>为了解决这个问题，ZooKeeper 采用了 ZAB 协议算法。</p>\n</blockquote>\n<p>ZAB 协议算法（Zookeeper Atomic Broadcast  ，Zookeeper 原子广播协议）是 ZooKeeper 专门设计用来解决集群最终一致性问题的算法，它的两个核心功能点是崩溃恢复和原子广播协议。</p>\n<ul>\n<li>在整个 ZAB 协议的底层实现中，ZooKeeper 集群主要采用主从模式的系统架构方式来保证 ZooKeeper 集群系统的一致性。</li>\n</ul>\n<p>当接收到来自客户端的事务性会话请求后，系统集群采用主服务器来处理该条会话请求，经过主服务器处理的结果会通过网络发送给集群中其他从节点服务器进行数据同步操作。</p>\n<blockquote>\n<p>以 ZooKeeper 集群为例，这个操作过程可以概括为：</p>\n</blockquote>\n<p>当 ZooKeeper 集群接收到来自客户端的事务性的会话请求后，集群中的其他 Follow 角色服务器会将该请求转发给 Leader 角色服务器进行处理。</p>\n<p>当 Leader 节点服务器在处理完该条会话请求后，会将结果通过操作日志的方式同步给集群中的 Follow 角色服务器。</p>\n<p>然后 Follow 角色服务器根据接收到的操作日志，在本地执行相关的数据处理操作，最终完成整个 ZooKeeper 集群对客户端会话的处理工作。</p>\n<p><strong>崩溃恢复</strong></p>\n<p>当集群中的 Leader 发生故障的时候，整个集群就会因为缺少 Leader 服务器而无法处理来自客户端的事务性的会话请求。</p>\n<blockquote>\n<p>因此，为了解决这个问题。在 ZAB 协议中也设置了处理该问题的崩溃恢复机制。</p>\n</blockquote>\n<p>崩溃恢复机制是保证 ZooKeeper 集群服务高可用的关键。触发 ZooKeeper 集群执行崩溃恢复的事件是集群中的 Leader 节点服务器发生了异常而无法工作，于是 Follow 服务器会通过投票来决定是否选出新的 Leader 节点服务器。</p>\n<blockquote>\n<p>投票过程如下：</p>\n</blockquote>\n<p>当崩溃恢复机制开始的时候，整个 ZooKeeper 集群的每台 Follow 服务器会发起投票，并同步给集群中的其他 Follow 服务器。</p>\n<p>在接收到来自集群中的其他 Follow 服务器的投票信息后，集群中的每个 Follow 服务器都会与自身的投票信息进行对比，如果判断新的投票信息更合适，则采用新的投票信息作为自己的投票信息。在集群中的投票信息还没有达到超过半数原则的情况下，再进行新一轮的投票，最终当整个 ZooKeeper 集群中的 Follow 服务器超过半数投出的结果相同的时候，就会产生新的 Leader 服务器。</p>\n<blockquote>\n<p>选票结构：</p>\n</blockquote>\n<p>以 Fast Leader Election 选举的实现方式来讲，如下图所示，一个选票的整体结果可以分为一下六个部分：</p>\n<img src=\"https://img-blog.csdnimg.cn/2956e37edd2d482fb3545a7b35ffe7ae.png\"/>\n\n<ul>\n<li><p>logicClock：用来记录服务器的投票轮次。logicClock 会从 1 开始计数，每当该台服务经过一轮投票后，logicClock 的数值就会加 1 。</p>\n</li>\n<li><p>state：用来标记当前服务器的状态。在 ZooKeeper 集群中一台服务器具有 LOOKING、FOLLOWING、LEADERING、OBSERVING 这四种状态。</p>\n</li>\n<li><p><code>self_id</code>：用来表示当前服务器的 ID 信息，该字段在 ZooKeeper 集群中主要用来作为服务器的身份标识符。</p>\n</li>\n<li><p><code>self_zxid</code>： 当前服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</p>\n</li>\n<li><p><code>vote_id</code>：投票要被推举的服务器的唯一 ID 。</p>\n</li>\n<li><p><code>vote_zxid</code>：被推举的服务器上所保存的数据的最大事务 ID ，从 0 开始计数。</p>\n</li>\n</ul>\n<p>当 ZooKeeper 集群需要重新选举出新的 Leader 服务器的时候，就会根据上面介绍的投票信息内容进行对比，以找出最适合的服务器。</p>\n<blockquote>\n<p>选票筛选</p>\n</blockquote>\n<p>当一台 Follow 服务器接收到网络中的其他 Follow 服务器的投票信息后，是如何进行对比来更新自己的投票信息的。</p>\n<p>Follow 服务器进行选票对比的过程，如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/977516cbd09d4fb8aad57004147221a6.png\" />\n\n<p>首先，会对比 logicClock 服务器的投票轮次，当 logicClock 相同时，表明两张选票处于相同的投票阶段，并进入下一阶段，否则跳过。</p>\n<p>接下来再对比<code>vote_zxid</code>被选举的服务器 ID 信息，若接收到的外部投票信息中的 <code>vote_zxid </code>字段较大，则将自己的票中的<code>vote_zxid</code>与<code>vote_myid</code>更新为收到的票中的<code>vote_zxid</code>与<code> vote_myid</code> ，并广播出去。</p>\n<p>要是对比的结果相同，则继续对比<code>vote_myid</code>被选举服务器上所保存的最大事务 ID ，若外部投票的<code> vote_myid</code> 比较大，则将自己的票中的 <code>vote_myid </code>更新为收到的票中的<code> vote_myid</code> 。 </p>\n<p>经过这些对比和替换后，最终该台 Follow 服务器会产生新的投票信息，并在下一轮的投票中发送到 ZooKeeper 集群中。</p>\n<p><strong>消息广播</strong></p>\n<p>在 Leader 节点服务器处理请求后，需要通知集群中的其他角色服务器进行数据同步。ZooKeeper 集群采用消息广播的方式发送通知。</p>\n<p>ZooKeeper 集群使用原子广播协议进行消息发送，该协议的底层实现过程与二阶段提交过程非常相似，如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/fb518bd2f20c45539765e0b76e54387d.png\"/>\n\n<p>当要在集群中的其他角色服务器进行数据同步的时候，Leader 服务器将该操作过程封装成一个 Proposal 提交事务，并将其发送给集群中其他需要进行数据同步的服务器。</p>\n<p>当这些服务器接收到 Leader 服务器的数据同步事务后，会将该条事务能否在本地正常执行的结果反馈给 Leader 服务器，Leader 服务器在接收到其他 Follow 服务器的反馈信息后进行统计，判断是否在集群中执行本次事务操作。</p>\n<p>这里请注意 ，与二阶段提交过程不同（即需要集群中所有服务器都反馈可以执行事务操作后，主服务器再次发送 commit 提交请求执行数据变更） ，ZAB 协议算法省去了中断的逻辑，当 ZooKeeper 集群中有超过一半的 Follow 服务器能够正常执行事务操作后，整个 ZooKeeper 集群就可以提交 Proposal 事务了。</p>\n<h1 id=\"日志清理\"><a href=\"#日志清理\" class=\"headerlink\" title=\"日志清理\"></a>日志清理</h1><p><strong>日志类型</strong></p>\n<p>在 ZooKeeper 服务运行的时候，一般会产生数据快照和日志文件，数据快照用于集群服务中的数据同步，而数据日志则记录了 ZooKeeper 服务运行的相关状态信息。</p>\n<blockquote>\n<p>其中，数据日志是我们在生产环境中需要定期维护和管理的文件。</p>\n</blockquote>\n<p><strong>清理方案</strong></p>\n<p>如上面所介绍的，面对生产系统中产生的日志，一般的维护操作是备份和清理。</p>\n<p>备份是为了之后对系统的运行情况进行排查和优化，而清理主要因为随着系统日志的增加，日志会逐渐占用系统的存储空间，如果一直不进行清理，可能耗尽系统的磁盘存储空间，并最终影响服务的运行。</p>\n<p><strong>清理工具</strong></p>\n<blockquote>\n<p>Corntab</p>\n</blockquote>\n<p>首先，我们介绍的是 Linux corntab ，它是 Linux 系统下的软件，可以自动地按照我们设定的时间，周期性地执行我们编写的相关脚本。</p>\n<p>crontab 定时脚本的方式相对灵活，可以按照我们的业务需求来设置处理日志的维护方式，比如这里我们希望定期清除 ZooKeeper 服务运行的日志，而不想清除数据快照的文件，则可以通过脚本设置，达到只对数据日志文件进行清理的目的。</p>\n<blockquote>\n<p>PurgeTxnLog</p>\n</blockquote>\n<p>ZooKeeper 自身还提供了 PurgeTxnLog 工具类，用来清理 snapshot 数据快照文件和系统日志。</p>\n<p>PurgeTxnLog 清理方式和我们上面介绍的方式十分相似，也是通过定时脚本执行任务，唯一的不同是，上面提到在编写日志清除 logsCleanWeek 的时候 ，我们使用的是原生 shell 脚本自己手动编写的数据日志清理逻辑，而使用 PurgeTxnLog 则可以在编写清除脚本的时候调用 ZooKeeper 为我们提供的工具类完成日志清理工作。</p>\n<p>如下面的代码所示，首先，我们在<code>/usr/bin</code>目录下创建一个 PurgeLogsClean 脚本。注意这里的脚本也是一个 shell 文件。</p>\n<p>在脚本中我们只需要编写 PurgeTxnLog 类的调用程序，系统就会自动通过 PurgeTxnLog 工具类为我们完成对应日志文件的清理工作。</p>\n<pre><code>#!/bin/sh  \njava -cp &quot;$CLASSPATH&quot; org.apache.zookeeper.server.PurgeTxnLog \necho &quot;清理完成&quot; \n</code></pre>\n<p>PurgeTxnLog 方式与 crontab 相比，使用起来更加容易而且也更加稳定安全，不过 crontab 方式更加灵活，我们可以根据不同的业务需求编写自己的清理逻辑。</p>\n<h1 id=\"实现分布式锁\"><a href=\"#实现分布式锁\" class=\"headerlink\" title=\"实现分布式锁\"></a>实现分布式锁</h1><p>分布式锁的目的是保证在分布式部署的应用集群中，多个服务在请求同一个方法或者同一个业务操作的情况下，对应业务逻辑只能被一台机器上的一个线程执行，避免出现并发问题。</p>\n<blockquote>\n<p>实现分布式锁目前有三种流行方案，即基于数据库、Redis、ZooKeeper 的方案</p>\n</blockquote>\n<p><strong>方案一：</strong></p>\n<p>使用节点中的存储数据区域，ZK中节点存储数据的大小不能超过1M，但是只是存放一个标识是足够的，线程获得锁时，先检查该标识是否是无锁标识，若是可修改为占用标识，使用完再恢复为无锁标识</p>\n<p><strong>方案二：</strong></p>\n<p>使用子节点，每当有线程来请求锁的时候，便在锁的节点下创建一个子节点，子节点类型必须维护一个顺序，对子节点的自增序号进行排序，默认总是最小的子节点对应的线程获得锁，释放锁时删除对应子节点便可</p>\n<img src=\"https://img-blog.csdnimg.cn/b4f8396f620f4a778b01bb573ca5969f.png\"/>\n\n<p><strong>死锁风险:</strong></p>\n<p>两种方案其实都是可行的，但是使用锁的时候一定要去规避死锁</p>\n<ul>\n<li><p>方案一看上去是没问题的，用的时候设置标识，用完清除标识，但是要是持有锁的线程发生了意外，释放锁的代码无法执行，锁就无法释放，其他线程就会一直等待锁，相关同步代码便无法执行</p>\n</li>\n<li><p>方案二也存在这个问题，但方案二可以利用ZK的临时顺序节点来解决这个问题，只要线程发生了异常导致程序中断，就会丢失与ZK的连接，ZK检测到该链接断开，就会自动删除该链接创建的临时节点，这样就可以达到即使占用锁的线程程序发生意外，也能保证锁正常释放的目的</p>\n</li>\n</ul>\n<p><strong>避免羊群效应</strong></p>\n<p>把锁请求者按照后缀数字进行排队，后缀数字小的锁请求者先获取锁。</p>\n<p>如果所有的锁请求者都 watch 锁持有者，当代表锁请求者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。</p>\n<blockquote>\n<p>为了避免羊群效应，每个锁请求者 watch 它前面的锁请求者。</p>\n</blockquote>\n<p>每次锁被释放，只会有一个锁请求者 会被通知到。</p>\n<p>这样做还让锁的分配具有公平性，锁定的分配遵循先到先得的原则。</p>\n<img src=\"https://img-blog.csdnimg.cn/20b0e4cf4ae3424c999ba9fb4f704a8a.png\"/>\n\n<p><strong>用 ZooKeeper 实现分布式锁的算法流程，根节点为 &#x2F;lock：</strong></p>\n<ul>\n<li><p>客户端连接 ZooKeeper，并<code>在/lock </code>下创建临时有序子节点，第一个客户端对应的子节点为<code> /lock/lock01/00000001</code>，第二个为 <code>/lock/lock01/00000002</code>；</p>\n</li>\n<li><p>其他客户端获取<code>/lock01</code>下的子节点列表，判断自己创建的子节点是否为当前列表中序号最小的子节点；</p>\n</li>\n<li><p>如果是则认为获得锁，执行业务代码，否则通过 watch 事件监听<code>/lock01 </code>的子节点变更消息，获得变更通知后重复此步骤直至获得锁；</p>\n</li>\n<li><p>完成业务流程后，删除对应的子节点，释放分布式锁；</p>\n</li>\n</ul>\n<p>在实际开发中，可以应用 Apache Curator 来快速实现分布式锁，Curator 是 Netflix 公司开源的一个 ZooKeeper 客户端，对 ZooKeeper 原生 API 做了抽象和封装。</p>\n<h1 id=\"实现分布式ID\"><a href=\"#实现分布式ID\" class=\"headerlink\" title=\"实现分布式ID\"></a>实现分布式ID</h1><p>我们可以通过 ZooKeeper 自身的客户端和服务器运行模式，来实现一个分布式网络环境下的 ID 请求和分发过程。</p>\n<blockquote>\n<p>每个需要 ID 编码的业务服务器可以看作是 ZooKeeper 的客户端。ID 编码生成器可以作为 ZooKeeper 的服务端。</p>\n</blockquote>\n<p>客户端通过发送请求到 ZooKeeper 服务器，来获取编码信息，服务端接收到请求后，发送 ID 编码给客户端。</p>\n<p><strong>实现原理：</strong></p>\n<p>可以利用 ZooKeeper 数据模型中的顺序节点作为 ID 编码。</p>\n<ul>\n<li><p>客户端通过调用 create 函数创建顺序节点。服务器成功创建节点后，会响应客户端请求，把创建好的节点信息发送给客户端。</p>\n</li>\n<li><p>客户端用数据节点名称作为 ID 编码，进行之后的本地业务操作。</p>\n</li>\n</ul>\n<p>利用 ZooKeeper 中的顺序节点特性，很容易使我们创建的 ID 编码具有有序的特性。并且我们也可以通过客户端传递节点的名称，根据不同的业务编码区分不同的业务系统，从而使编码的扩展能力更强。</p>\n<blockquote>\n<p>虽然使用 ZooKeeper 的实现方式有这么多优点，但也会有一些潜在的问题。</p>\n</blockquote>\n<p>其中最主要的是，在定义编码的规则上还是强烈依赖于程序员自身的能力和对业务的深入理解。</p>\n<p>很容易出现因为考虑不周，造成设置的规则在运行一段时间后，无法满足业务要求或者安全性不够等问题。</p>\n<h1 id=\"实现负载均衡\"><a href=\"#实现负载均衡\" class=\"headerlink\" title=\"实现负载均衡\"></a>实现负载均衡</h1><p><strong>常见负载均衡算法</strong></p>\n<blockquote>\n<p>轮询法</p>\n</blockquote>\n<p>轮询法是最为简单的负载均衡算法，当接收到来自网络中的客户端请求后，负载均衡服务器会按顺序逐个分配给后端服务。</p>\n<p>比如集群中有 3 台服务器，分别是 server1、server2、server3，轮询法会按照 sever1、server2、server3 这个顺序依次分发会话请求给每个服务器。当第一次轮询结束后，会重新开始下一轮的循环。</p>\n<blockquote>\n<p>随机法</p>\n</blockquote>\n<p>随机算法是指负载均衡服务器在接收到来自客户端的请求后，会根据一定的随机算法选中后台集群中的一台服务器来处理这次会话请求。</p>\n<p>不过，当集群中备选机器变的越来越多时，通过统计学我们可以知道每台机器被抽中的概率基本相等，因此随机算法的实际效果越来越趋近轮询算法。</p>\n<blockquote>\n<p>原地址哈希法</p>\n</blockquote>\n<p>原地址哈希算法的核心思想是根据客户端的 IP 地址进行哈希计算，用计算结果进行取模后，根据最终结果选择服务器地址列表中的一台机器，处理该条会话请求。</p>\n<p>采用这种算法后，当同一 IP 的客户端再次访问服务端后，负载均衡服务器最终选举的还是上次处理该台机器会话请求的服务器，也就是每次都会分配同一台服务器给客户端。</p>\n<blockquote>\n<p>加权轮询法</p>\n</blockquote>\n<p>加权轮询的方式与轮询算法的方式很相似，唯一的不同在于选择机器的时候，不只是单纯按照顺序的方式选择，还根据机器的配置和性能高低有所侧重，配置性能好的机器往往首先分配。</p>\n<blockquote>\n<p>加权随机法</p>\n</blockquote>\n<p>加权随机法和我们上面提到的随机算法一样，在采用随机算法选举服务器的时候，会考虑系统性能作为权值条件。</p>\n<blockquote>\n<p>最小连接数法</p>\n</blockquote>\n<p>最小连接数算法是指，根据后台处理客户端的连接会话条数，计算应该把新会话分配给哪一台服务器。</p>\n<p>一般认为，连接数越少的机器，在网络带宽和计算性能上都有很大优势，会作为最优先分配的对象。</p>\n<p><strong>利用 ZooKeeper 实现 负载均衡 算法</strong></p>\n<blockquote>\n<p>这里我们通过采用最小连接数算法，来确定究竟如何均衡地分配网络会话请求给后台客户端。</p>\n</blockquote>\n<p>如下图所示，建立的 ZooKeeper 数据模型中 Severs 节点可以作为存储服务器列表的父节点。</p>\n<p>在它下面创建 servers_host1、servers_host2、servers_host3等临时节点来存储集群中的服务器运行状态信息。</p>\n<img src=\"https://img-blog.csdnimg.cn/2c6c94ef4c1443ecbe0084b5d4ad7ea2.png\"/>\n\n<p>整个实现的过程如下图所示。</p>\n<img src=\"https://img-blog.csdnimg.cn/b3ad367c3c024fd6ae57e4f7a2c9aa40.png\"/>\n\n<ul>\n<li><p>首先，在接收到客户端的请求后，通过 getData 方法获取服务端 Severs 节点下的服务器列表，其中每个节点信息都存储有当前服务器的连接数。</p>\n</li>\n<li><p>通过判断选择最少的连接数作为当前会话的处理服务器，并通过 setData 方法将该节点连接数加 1。</p>\n</li>\n<li><p>最后，当客户端执行完毕，再调用 setData 方法将该节点信息减 1。</p>\n</li>\n<li><p>我们定义当服务器接收到会话请求后。在 ZooKeeper 服务端增加连接数的 addBlance 方法。</p>\n</li>\n<li><p>我们通过 readData 方法获取服务器最新的连接数，之后将该连接数加 1，再通过 writeData 方法将新的连接数信息写入到服务端对应节点信息中。</p>\n</li>\n<li><p>当服务器处理完该会话请求后，需要更新服务端相关节点的连接数。</p>\n</li>\n<li><p>具体的操作与 addBlance 方法基本一样，只是对获取的连接信息进行减一操作。</p>\n</li>\n</ul>\n<p><strong>这里注意：</strong></p>\n<p>我们日常用到的负载均衡器主要是选择后台处理的服务器，并给其分发请求。</p>\n<blockquote>\n<p>而通过 ZooKeeper 实现的服务器，只提供了服务器的筛选工作。</p>\n</blockquote>\n<p>在请求分发的过程中，还是通过负载算法计算出要访问的服务器，之后客户端自己连接该服务器，完成请求操作。</p>\n<h1 id=\"开源框架使用案例\"><a href=\"#开源框架使用案例\" class=\"headerlink\" title=\"开源框架使用案例\"></a>开源框架使用案例</h1><p><strong>Dubbo与ZooKeeper</strong></p>\n<p>Dubbo 是阿里巴巴开发的一套开源的技术框架，是一款高性能、轻量级的开源 Java RPC 框架。</p>\n<p><strong>用ZooKeeper做注册中心</strong></p>\n<p>在整个 Dubbo 框架的实现过程中，注册中心是其中最为关键的一点，它保证了整个 PRC 过程中服务对外的透明性。</p>\n<p>而 Dubbo 的注册中心也是通过 ZooKeeper 来实现的。</p>\n<p>如下图所示，在整个 Dubbo 服务的启动过程中，服务提供者会在启动时向 <code>/dubbo/com.foo.BarService/providers </code>目录写入自己的 URL 地址，这个操作可以看作是一个 ZooKeeper 客户端在 ZooKeeper 服务器的数据模型上创建一个数据节点。</p>\n<p>服务消费者在启动时订阅 <code>/dubbo/com.foo.BarService/providers</code> 目录下的提供者 URL 地址，并向 <code>/dubbo/com.foo.BarService/consumers</code> 目录写入自己的 URL 地址。</p>\n<p>该操作是通过 ZooKeeper 服务器在 &#x2F;consumers 节点路径下创建一个子数据节点，然后再在请求会话中发起对 &#x2F;providers 节点的 watch 监控</p>\n<img src=\"https://img-blog.csdnimg.cn/a27e2d30709947d7b995da6c091de3ba.png\"/>\n\n<p><strong>Kafka与ZooKeeper</strong></p>\n<p><strong>Zookeeper的作用</strong></p>\n<p>由于 Broker 服务器采用分布式集群的方式工作，那么在服务的运行过程中，难免出现某台机器因异常而关闭的状况。</p>\n<p>为了保证整个 Kafka 集群的可用性，需要在系统中监控整个机器的运行情况。而 Kafka 可以通过 ZooKeeper 中的数据节点，将网络中机器的运行统计存储在数据模型中的 brokers 节点下。</p>\n<p>在 Kafka 的 Topic 信息注册中也需要使用到 ZooKeeper ，在 Kafka 中同一个Topic 消息容器可以分成多个不同片，而这些分区既可以存在于一台 Broker 服务器中，也可以存在于不同的 Broker 服务器中。</p>\n<p>而在 Kafka 集群中，每台 Broker 服务器又相对独立。</p>\n<p>为了能够读取这些以分布式方式存储的分区信息，Kafka 会将这些分区信息在 Broker 服务器中的对应关系存储在 ZooKeeper 数据模型的 topic 节点上，每一个 topic 在 ZooKeeper 数据节点上都会以 <code>/brokers/topics/[topic]</code> 的形式存在。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/058b3613e6204da8a467d8aa19f611b8.png\"></p>\n<h1 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h1><p>《从Paxos到Zookeeper 分布式一致性原理与实践》</p>\n"},{"title":"动态代理","_content":"\n# 前言\n\n> 面试题：讲讲jdk动态代理，cglib区别，实现原理，优缺点，怎么实现方法的调用的\n\n来自：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect)\n\n这篇文章总结你需要回答的知识点，全程少废话，怼干货，文章较长，可以**点赞在看**，喜欢这种文章的话，我之后也会一直分享的，硬核文章也会定期分享！\n\n文章会同步到个人网站，方便阅读：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png)\n\n# 代理模式\n\n代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能\n\n**一个比方：在租房的时候，有的人会通过房东直租，有的人会通过中介租房。**\n\n这两种情况哪种比较方便呢？当然是通过中介更加方便。\n\n这里的中介就相当于代理，用户通过中介完成租房的一系列操作（看房、交押金、租房、清扫卫生）代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部。\n\n![](https://img-blog.csdnimg.cn/b9d15e7c8abd4c3cb400c578caa3192a.png)\n\n**分类：**\n\n**静态代理：** 在编译时就已经实现，编译完成后代理类是一个实际的class文件\n\n**动态代理：** 在运行时动态生成的，即编译完成后没有实际的class文件，而是**在运行时动态生成类字节码，并加载到JVM中**\n\n# 静态代理\n\n**使用方式**\n\n创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。\n\n```java\npublic interface UserDao {    \n  void save();     \n}\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void save() {\n        System.out.println(\"正在保存用户...\");\n    }\n}\npublic class TransactionHandler implements UserDao {\n    //目标代理对象\n    private UserDao target;\n    //构造代理对象时传入目标对象\n    public TransactionHandler(UserDao target) {\n        this.target = target;\n    }\n    @Override\n    public void save() {\n        //调用目标方法前的处理\n        System.out.println(\"开启事务控制...\");\n        //调用目标对象的方法\n        target.save();\n        //调用目标方法后的处理\n        System.out.println(\"关闭事务控制...\");\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        //新建目标对象\n        UserDaoImpl target = new UserDaoImpl();\n        //创建代理对象, 并使用接口对其进行引用\n        UserDao userDao = new TransactionHandler(target);\n        //针对接口进行调用\n        userDao.save();\n    }\n}\n```\n\n使用JDK静态代理很容易就完成了对一个类的代理操作。但是`JDK`静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐\n\n# JDK动态代理\n\n**使用JDK动态代理的五大步骤：**\n\n1. 通过实现InvocationHandler接口来自定义自己的InvocationHandler；\n2. 通过`Proxy.getProxyClass`获得动态代理类；\n3. 通过反射机制获得代理类的构造方法，方法签名为`getConstructor(InvocationHandler.class)`；\n4. 通过构造函数获得代理对象并将自定义的`InvocationHandler`实例对象传为参数传入；\n5. 通过代理对象调用目标方法；\n\n```java\npublic interface IHello {\n    void sayHello();\n}\n public class HelloImpl implements IHello {\n    @Override\n    public void sayHello() {\n        System.out.println(\"Hello world!\");\n    }\n}\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n \npublic class MyInvocationHandler implements InvocationHandler {\n \n    /** 目标对象 */\n    private Object target;\n \n    public MyInvocationHandler(Object target){\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"------插入前置通知代码-------------\");\n        // 执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(\"------插入后置处理代码-------------\");\n        return rs;\n    }\n}\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Proxy;\n\npublic class MyProxyTest {\n    public static void main(String[] args)\n            throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {\n        // =========================第一种==========================\n        // 1、生成$Proxy0的class文件\n        System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n        // 2、获取动态代理类\n        Class proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(),IHello.class);\n        // 3、获得代理类的构造函数，并传入参数类型InvocationHandler.class\n        Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);\n        // 4、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入\n        IHello iHello1 = (IHello) constructor.newInstance(new MyInvocationHandler(new HelloImpl()));\n        // 5、通过代理对象调用目标方法\n        iHello1.sayHello();\n \n        // ==========================第二种=============================\n        /**\n         * Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象，\n         *其方法签名为：newProxyInstance(ClassLoader loader,Class<?>[] instance, InvocationHandler h)\n         */\n        IHello  iHello2 = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), // 加载接口的类加载器\n                new Class[]{IHello.class}, // 一组接口\n                new MyInvocationHandler(new HelloImpl())); // 自定义的InvocationHandler\n        iHello2.sayHello();\n    }\n}\n```\n\nJDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。\n\n**不同之处：** 在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。\n\n**一句话来总结一下JDK静态代理和JDK动态代理的区别：**\n\nJDK静态代理是通过直接编码创建的，而`JDK`动态代理是利用反射机制在运行时创建代理类的。\n\n其实在动态代理中，核心是`InvocationHandler`。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的`invoke`方法\n\n对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。\n\n# CGLIB\n\nCGLIB包的底层是通过使用一个小而快的字节码处理框架`ASM`，来转换字节码并生成新的类\n\n**CGLIB代理实现如下：**\n\n1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。\n2. 然后在需要使用的时候，通过CGLIB动态代理获取代理对象。\n\n**使用案例**\n\n```java\n public class HelloService {\n \n    public HelloService() {\n        System.out.println(\"HelloService构造\");\n    }\n \n    /**\n     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的\n     */\n    final public String sayOthers(String name) {\n        System.out.println(\"HelloService:sayOthers>>\"+name);\n        return null;\n    }\n \n    public void sayHello() {\n        System.out.println(\"HelloService:sayHello\");\n    }\n}\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n \nimport java.lang.reflect.Method;\n \n/**\n * 自定义MethodInterceptor\n */\npublic class MyMethodInterceptor implements MethodInterceptor{\n \n    /**\n     * sub：cglib生成的代理对象\n     * method：被代理对象方法\n     * objects：方法入参\n     * methodProxy: 代理方法\n     */\n    @Override\n    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"======插入前置通知======\");\n        Object object = methodProxy.invokeSuper(sub, objects);\n        System.out.println(\"======插入后者通知======\");\n        return object;\n    }\n}\nimport net.sf.cglib.core.DebuggingClassWriter;\nimport net.sf.cglib.proxy.Enhancer;\n \npublic class Client {\n    public static void main(String[] args) {\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"D:\\\\code\");\n        // 通过CGLIB动态代理获取代理对象的过程\n        Enhancer enhancer = new Enhancer();\n        // 设置enhancer对象的父类\n        enhancer.setSuperclass(HelloService.class);\n        // 设置enhancer的回调对象\n        enhancer.setCallback(new MyMethodInterceptor());\n        // 创建代理对象\n        HelloService proxy= (HelloService)enhancer.create();\n        // 通过代理对象调用目标方法\n        proxy.sayHello();\n    }\n}\n```\n\nJDK代理要求被代理的类必须实现接口，有很强的局限性。\n\n而CGLIB动态代理则没有此类强制性要求。简单的说，`CGLIB`会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。\n\n**总结一下CGLIB在进行代理的时候都进行了哪些工作**\n\n- 生成的代理类继承被代理类。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理\n- 代理类会为委托方法生成两个方法，一个是与委托方法签名相同的方法，它在方法中会通过`super`调用委托方法；另一个是代理类独有的方法\n- 当执行代理对象的方法时，会首先判断一下是否存在实现了`MethodInterceptor`接口的`CGLIB$CALLBACK_0`;，如果存在，则将调用`MethodInterceptor`中的`intercept`方法\n\n在`intercept`方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录\n\n在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：通过**FastClass机制**对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用\n\n## Fastclass机制\n\nCGLIB采用了FastClass的机制来实现对被拦截方法的调用。\n\nFastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法\n\n```java\npublic class test10 {\n  //这里，tt可以看作目标对象，fc可以看作是代理对象；首先根据代理对象的getIndex方法获取目标方法的索引，\n  //然后再调用代理对象的invoke方法就可以直接调用目标类的方法，避免了反射\n    public static void main(String[] args){\n        Test tt = new Test();\n        Test2 fc = new Test2();\n        int index = fc.getIndex(\"f()V\");\n        fc.invoke(index, tt, null);\n    }\n}\n\nclass Test{\n    public void f(){\n        System.out.println(\"f method\");\n    }\n    \n    public void g(){\n        System.out.println(\"g method\");\n    }\n}\nclass Test2{\n    public Object invoke(int index, Object o, Object[] ol){\n        Test t = (Test) o;\n        switch(index){\n        case 1:\n            t.f();\n            return null;\n        case 2:\n            t.g();\n            return null;\n        }\n        return null;\n    }\n    //这个方法对Test类中的方法建立索引\n    public int getIndex(String signature){\n        switch(signature.hashCode()){\n        case 3078479:\n            return 1;\n        case 3108270:\n            return 2;\n        }\n        return -1;\n    }\n}\n```\n\n上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。\n\n在getIndex方法中对Test的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。\n\nInvoke根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率\n\n**三种代理方式之间对比**\n\n| 代理方式      | 实现                                                         | 优点                                                         | 缺点                                                         | 特点                                                       |\n| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------------------------------------------------------- |\n| JDK静态代理   | 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口     | 实现简单，容易理解                                           | 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 | 好像没啥特点                                               |\n| JDK动态代理   | 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写`invoke`方法来进行动态代理的，在invoke方法中将对方法进行增强处理 | 不需要硬编码接口，代码复用率高                               | 只能够代理实现了接口的委托类                                 | 底层使用反射机制进行方法的调用                             |\n| CGLIB动态代理 | 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过`super`调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了`MethodInterceptor`接口的对象，若存在则将调用intercept方法对委托方法进行代理 | 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 | 不能对`final`类以及final方法进行代理                         | 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 |\n\n# 问题\n\n**CGlib比JDK快？**\n\n- 使用CGLiB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。\n- 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。\n\n**Spring如何选择用JDK还是CGLIB？**\n\n- 当Bean实现接口时，Spring就会用JDK的动态代理。\n- 当Bean没有实现接口时，Spring使用CGlib实现。\n- 可以强制使用CGlib","source":"_posts/公众号文章/动态代理.md","raw":"---\ntitle: 动态代理\ncategories: \n- 公众号文章\n---\n\n# 前言\n\n> 面试题：讲讲jdk动态代理，cglib区别，实现原理，优缺点，怎么实现方法的调用的\n\n来自：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect)\n\n这篇文章总结你需要回答的知识点，全程少废话，怼干货，文章较长，可以**点赞在看**，喜欢这种文章的话，我之后也会一直分享的，硬核文章也会定期分享！\n\n文章会同步到个人网站，方便阅读：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png)\n\n# 代理模式\n\n代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能\n\n**一个比方：在租房的时候，有的人会通过房东直租，有的人会通过中介租房。**\n\n这两种情况哪种比较方便呢？当然是通过中介更加方便。\n\n这里的中介就相当于代理，用户通过中介完成租房的一系列操作（看房、交押金、租房、清扫卫生）代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部。\n\n![](https://img-blog.csdnimg.cn/b9d15e7c8abd4c3cb400c578caa3192a.png)\n\n**分类：**\n\n**静态代理：** 在编译时就已经实现，编译完成后代理类是一个实际的class文件\n\n**动态代理：** 在运行时动态生成的，即编译完成后没有实际的class文件，而是**在运行时动态生成类字节码，并加载到JVM中**\n\n# 静态代理\n\n**使用方式**\n\n创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。\n\n```java\npublic interface UserDao {    \n  void save();     \n}\npublic class UserDaoImpl implements UserDao {\n    @Override\n    public void save() {\n        System.out.println(\"正在保存用户...\");\n    }\n}\npublic class TransactionHandler implements UserDao {\n    //目标代理对象\n    private UserDao target;\n    //构造代理对象时传入目标对象\n    public TransactionHandler(UserDao target) {\n        this.target = target;\n    }\n    @Override\n    public void save() {\n        //调用目标方法前的处理\n        System.out.println(\"开启事务控制...\");\n        //调用目标对象的方法\n        target.save();\n        //调用目标方法后的处理\n        System.out.println(\"关闭事务控制...\");\n    }\n}\npublic class Main {\n    public static void main(String[] args) {\n        //新建目标对象\n        UserDaoImpl target = new UserDaoImpl();\n        //创建代理对象, 并使用接口对其进行引用\n        UserDao userDao = new TransactionHandler(target);\n        //针对接口进行调用\n        userDao.save();\n    }\n}\n```\n\n使用JDK静态代理很容易就完成了对一个类的代理操作。但是`JDK`静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐\n\n# JDK动态代理\n\n**使用JDK动态代理的五大步骤：**\n\n1. 通过实现InvocationHandler接口来自定义自己的InvocationHandler；\n2. 通过`Proxy.getProxyClass`获得动态代理类；\n3. 通过反射机制获得代理类的构造方法，方法签名为`getConstructor(InvocationHandler.class)`；\n4. 通过构造函数获得代理对象并将自定义的`InvocationHandler`实例对象传为参数传入；\n5. 通过代理对象调用目标方法；\n\n```java\npublic interface IHello {\n    void sayHello();\n}\n public class HelloImpl implements IHello {\n    @Override\n    public void sayHello() {\n        System.out.println(\"Hello world!\");\n    }\n}\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n \npublic class MyInvocationHandler implements InvocationHandler {\n \n    /** 目标对象 */\n    private Object target;\n \n    public MyInvocationHandler(Object target){\n        this.target = target;\n    }\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"------插入前置通知代码-------------\");\n        // 执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(\"------插入后置处理代码-------------\");\n        return rs;\n    }\n}\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Proxy;\n\npublic class MyProxyTest {\n    public static void main(String[] args)\n            throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException {\n        // =========================第一种==========================\n        // 1、生成$Proxy0的class文件\n        System.getProperties().put(\"sun.misc.ProxyGenerator.saveGeneratedFiles\", \"true\");\n        // 2、获取动态代理类\n        Class proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(),IHello.class);\n        // 3、获得代理类的构造函数，并传入参数类型InvocationHandler.class\n        Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);\n        // 4、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入\n        IHello iHello1 = (IHello) constructor.newInstance(new MyInvocationHandler(new HelloImpl()));\n        // 5、通过代理对象调用目标方法\n        iHello1.sayHello();\n \n        // ==========================第二种=============================\n        /**\n         * Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象，\n         *其方法签名为：newProxyInstance(ClassLoader loader,Class<?>[] instance, InvocationHandler h)\n         */\n        IHello  iHello2 = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), // 加载接口的类加载器\n                new Class[]{IHello.class}, // 一组接口\n                new MyInvocationHandler(new HelloImpl())); // 自定义的InvocationHandler\n        iHello2.sayHello();\n    }\n}\n```\n\nJDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。\n\n**不同之处：** 在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。\n\n**一句话来总结一下JDK静态代理和JDK动态代理的区别：**\n\nJDK静态代理是通过直接编码创建的，而`JDK`动态代理是利用反射机制在运行时创建代理类的。\n\n其实在动态代理中，核心是`InvocationHandler`。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的`invoke`方法\n\n对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。\n\n# CGLIB\n\nCGLIB包的底层是通过使用一个小而快的字节码处理框架`ASM`，来转换字节码并生成新的类\n\n**CGLIB代理实现如下：**\n\n1. 首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。\n2. 然后在需要使用的时候，通过CGLIB动态代理获取代理对象。\n\n**使用案例**\n\n```java\n public class HelloService {\n \n    public HelloService() {\n        System.out.println(\"HelloService构造\");\n    }\n \n    /**\n     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的\n     */\n    final public String sayOthers(String name) {\n        System.out.println(\"HelloService:sayOthers>>\"+name);\n        return null;\n    }\n \n    public void sayHello() {\n        System.out.println(\"HelloService:sayHello\");\n    }\n}\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n \nimport java.lang.reflect.Method;\n \n/**\n * 自定义MethodInterceptor\n */\npublic class MyMethodInterceptor implements MethodInterceptor{\n \n    /**\n     * sub：cglib生成的代理对象\n     * method：被代理对象方法\n     * objects：方法入参\n     * methodProxy: 代理方法\n     */\n    @Override\n    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        System.out.println(\"======插入前置通知======\");\n        Object object = methodProxy.invokeSuper(sub, objects);\n        System.out.println(\"======插入后者通知======\");\n        return object;\n    }\n}\nimport net.sf.cglib.core.DebuggingClassWriter;\nimport net.sf.cglib.proxy.Enhancer;\n \npublic class Client {\n    public static void main(String[] args) {\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, \"D:\\\\code\");\n        // 通过CGLIB动态代理获取代理对象的过程\n        Enhancer enhancer = new Enhancer();\n        // 设置enhancer对象的父类\n        enhancer.setSuperclass(HelloService.class);\n        // 设置enhancer的回调对象\n        enhancer.setCallback(new MyMethodInterceptor());\n        // 创建代理对象\n        HelloService proxy= (HelloService)enhancer.create();\n        // 通过代理对象调用目标方法\n        proxy.sayHello();\n    }\n}\n```\n\nJDK代理要求被代理的类必须实现接口，有很强的局限性。\n\n而CGLIB动态代理则没有此类强制性要求。简单的说，`CGLIB`会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。\n\n**总结一下CGLIB在进行代理的时候都进行了哪些工作**\n\n- 生成的代理类继承被代理类。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理\n- 代理类会为委托方法生成两个方法，一个是与委托方法签名相同的方法，它在方法中会通过`super`调用委托方法；另一个是代理类独有的方法\n- 当执行代理对象的方法时，会首先判断一下是否存在实现了`MethodInterceptor`接口的`CGLIB$CALLBACK_0`;，如果存在，则将调用`MethodInterceptor`中的`intercept`方法\n\n在`intercept`方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录\n\n在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：通过**FastClass机制**对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用\n\n## Fastclass机制\n\nCGLIB采用了FastClass的机制来实现对被拦截方法的调用。\n\nFastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法\n\n```java\npublic class test10 {\n  //这里，tt可以看作目标对象，fc可以看作是代理对象；首先根据代理对象的getIndex方法获取目标方法的索引，\n  //然后再调用代理对象的invoke方法就可以直接调用目标类的方法，避免了反射\n    public static void main(String[] args){\n        Test tt = new Test();\n        Test2 fc = new Test2();\n        int index = fc.getIndex(\"f()V\");\n        fc.invoke(index, tt, null);\n    }\n}\n\nclass Test{\n    public void f(){\n        System.out.println(\"f method\");\n    }\n    \n    public void g(){\n        System.out.println(\"g method\");\n    }\n}\nclass Test2{\n    public Object invoke(int index, Object o, Object[] ol){\n        Test t = (Test) o;\n        switch(index){\n        case 1:\n            t.f();\n            return null;\n        case 2:\n            t.g();\n            return null;\n        }\n        return null;\n    }\n    //这个方法对Test类中的方法建立索引\n    public int getIndex(String signature){\n        switch(signature.hashCode()){\n        case 3078479:\n            return 1;\n        case 3108270:\n            return 2;\n        }\n        return -1;\n    }\n}\n```\n\n上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。\n\n在getIndex方法中对Test的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。\n\nInvoke根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率\n\n**三种代理方式之间对比**\n\n| 代理方式      | 实现                                                         | 优点                                                         | 缺点                                                         | 特点                                                       |\n| :------------ | :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :--------------------------------------------------------- |\n| JDK静态代理   | 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口     | 实现简单，容易理解                                           | 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 | 好像没啥特点                                               |\n| JDK动态代理   | 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写`invoke`方法来进行动态代理的，在invoke方法中将对方法进行增强处理 | 不需要硬编码接口，代码复用率高                               | 只能够代理实现了接口的委托类                                 | 底层使用反射机制进行方法的调用                             |\n| CGLIB动态代理 | 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过`super`调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了`MethodInterceptor`接口的对象，若存在则将调用intercept方法对委托方法进行代理 | 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 | 不能对`final`类以及final方法进行代理                         | 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 |\n\n# 问题\n\n**CGlib比JDK快？**\n\n- 使用CGLiB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。\n- 在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。\n\n**Spring如何选择用JDK还是CGLIB？**\n\n- 当Bean实现接口时，Spring就会用JDK的动态代理。\n- 当Bean没有实现接口时，Spring使用CGlib实现。\n- 可以强制使用CGlib","slug":"公众号文章/动态代理","published":1,"date":"2022-02-08T12:31:07.666Z","updated":"2022-02-08T12:38:22.116Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiw00f1fhji105ucujv","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>面试题：讲讲jdk动态代理，cglib区别，实现原理，优缺点，怎么实现方法的调用的</p>\n</blockquote>\n<p>来自：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></p>\n<p>这篇文章总结你需要回答的知识点，全程少废话，怼干货，文章较长，可以<strong>点赞在看</strong>，喜欢这种文章的话，我之后也会一直分享的，硬核文章也会定期分享！</p>\n<p>文章会同步到个人网站，方便阅读：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png\"></p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能</p>\n<p><strong>一个比方：在租房的时候，有的人会通过房东直租，有的人会通过中介租房。</strong></p>\n<p>这两种情况哪种比较方便呢？当然是通过中介更加方便。</p>\n<p>这里的中介就相当于代理，用户通过中介完成租房的一系列操作（看房、交押金、租房、清扫卫生）代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b9d15e7c8abd4c3cb400c578caa3192a.png\"></p>\n<p><strong>分类：</strong></p>\n<p><strong>静态代理：</strong> 在编译时就已经实现，编译完成后代理类是一个实际的class文件</p>\n<p><strong>动态代理：</strong> 在运行时动态生成的，即编译完成后没有实际的class文件，而是<strong>在运行时动态生成类字节码，并加载到JVM中</strong></p>\n<h1 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h1><p><strong>使用方式</strong></p>\n<p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>\n<pre><code class=\"java\">public interface UserDao &#123;    \n  void save();     \n&#125;\npublic class UserDaoImpl implements UserDao &#123;\n    @Override\n    public void save() &#123;\n        System.out.println(&quot;正在保存用户...&quot;);\n    &#125;\n&#125;\npublic class TransactionHandler implements UserDao &#123;\n    //目标代理对象\n    private UserDao target;\n    //构造代理对象时传入目标对象\n    public TransactionHandler(UserDao target) &#123;\n        this.target = target;\n    &#125;\n    @Override\n    public void save() &#123;\n        //调用目标方法前的处理\n        System.out.println(&quot;开启事务控制...&quot;);\n        //调用目标对象的方法\n        target.save();\n        //调用目标方法后的处理\n        System.out.println(&quot;关闭事务控制...&quot;);\n    &#125;\n&#125;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        //新建目标对象\n        UserDaoImpl target = new UserDaoImpl();\n        //创建代理对象, 并使用接口对其进行引用\n        UserDao userDao = new TransactionHandler(target);\n        //针对接口进行调用\n        userDao.save();\n    &#125;\n&#125;\n</code></pre>\n<p>使用JDK静态代理很容易就完成了对一个类的代理操作。但是<code>JDK</code>静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐</p>\n<h1 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h1><p><strong>使用JDK动态代理的五大步骤：</strong></p>\n<ol>\n<li>通过实现InvocationHandler接口来自定义自己的InvocationHandler；</li>\n<li>通过<code>Proxy.getProxyClass</code>获得动态代理类；</li>\n<li>通过反射机制获得代理类的构造方法，方法签名为<code>getConstructor(InvocationHandler.class)</code>；</li>\n<li>通过构造函数获得代理对象并将自定义的<code>InvocationHandler</code>实例对象传为参数传入；</li>\n<li>通过代理对象调用目标方法；</li>\n</ol>\n<pre><code class=\"java\">public interface IHello &#123;\n    void sayHello();\n&#125;\n public class HelloImpl implements IHello &#123;\n    @Override\n    public void sayHello() &#123;\n        System.out.println(&quot;Hello world!&quot;);\n    &#125;\n&#125;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n \npublic class MyInvocationHandler implements InvocationHandler &#123;\n \n    /** 目标对象 */\n    private Object target;\n \n    public MyInvocationHandler(Object target)&#123;\n        this.target = target;\n    &#125;\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        System.out.println(&quot;------插入前置通知代码-------------&quot;);\n        // 执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(&quot;------插入后置处理代码-------------&quot;);\n        return rs;\n    &#125;\n&#125;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Proxy;\n\npublic class MyProxyTest &#123;\n    public static void main(String[] args)\n            throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;\n        // =========================第一种==========================\n        // 1、生成$Proxy0的class文件\n        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);\n        // 2、获取动态代理类\n        Class proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(),IHello.class);\n        // 3、获得代理类的构造函数，并传入参数类型InvocationHandler.class\n        Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);\n        // 4、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入\n        IHello iHello1 = (IHello) constructor.newInstance(new MyInvocationHandler(new HelloImpl()));\n        // 5、通过代理对象调用目标方法\n        iHello1.sayHello();\n \n        // ==========================第二种=============================\n        /**\n         * Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象，\n         *其方法签名为：newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] instance, InvocationHandler h)\n         */\n        IHello  iHello2 = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), // 加载接口的类加载器\n                new Class[]&#123;IHello.class&#125;, // 一组接口\n                new MyInvocationHandler(new HelloImpl())); // 自定义的InvocationHandler\n        iHello2.sayHello();\n    &#125;\n&#125;\n</code></pre>\n<p>JDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。</p>\n<p><strong>不同之处：</strong> 在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。</p>\n<p><strong>一句话来总结一下JDK静态代理和JDK动态代理的区别：</strong></p>\n<p>JDK静态代理是通过直接编码创建的，而<code>JDK</code>动态代理是利用反射机制在运行时创建代理类的。</p>\n<p>其实在动态代理中，核心是<code>InvocationHandler</code>。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的<code>invoke</code>方法</p>\n<p>对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。</p>\n<h1 id=\"CGLIB\"><a href=\"#CGLIB\" class=\"headerlink\" title=\"CGLIB\"></a>CGLIB</h1><p>CGLIB包的底层是通过使用一个小而快的字节码处理框架<code>ASM</code>，来转换字节码并生成新的类</p>\n<p><strong>CGLIB代理实现如下：</strong></p>\n<ol>\n<li>首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</li>\n<li>然后在需要使用的时候，通过CGLIB动态代理获取代理对象。</li>\n</ol>\n<p><strong>使用案例</strong></p>\n<pre><code class=\"java\"> public class HelloService &#123;\n \n    public HelloService() &#123;\n        System.out.println(&quot;HelloService构造&quot;);\n    &#125;\n \n    /**\n     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的\n     */\n    final public String sayOthers(String name) &#123;\n        System.out.println(&quot;HelloService:sayOthers&gt;&gt;&quot;+name);\n        return null;\n    &#125;\n \n    public void sayHello() &#123;\n        System.out.println(&quot;HelloService:sayHello&quot;);\n    &#125;\n&#125;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n \nimport java.lang.reflect.Method;\n \n/**\n * 自定义MethodInterceptor\n */\npublic class MyMethodInterceptor implements MethodInterceptor&#123;\n \n    /**\n     * sub：cglib生成的代理对象\n     * method：被代理对象方法\n     * objects：方法入参\n     * methodProxy: 代理方法\n     */\n    @Override\n    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n        System.out.println(&quot;======插入前置通知======&quot;);\n        Object object = methodProxy.invokeSuper(sub, objects);\n        System.out.println(&quot;======插入后者通知======&quot;);\n        return object;\n    &#125;\n&#125;\nimport net.sf.cglib.core.DebuggingClassWriter;\nimport net.sf.cglib.proxy.Enhancer;\n \npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:\\\\code&quot;);\n        // 通过CGLIB动态代理获取代理对象的过程\n        Enhancer enhancer = new Enhancer();\n        // 设置enhancer对象的父类\n        enhancer.setSuperclass(HelloService.class);\n        // 设置enhancer的回调对象\n        enhancer.setCallback(new MyMethodInterceptor());\n        // 创建代理对象\n        HelloService proxy= (HelloService)enhancer.create();\n        // 通过代理对象调用目标方法\n        proxy.sayHello();\n    &#125;\n&#125;\n</code></pre>\n<p>JDK代理要求被代理的类必须实现接口，有很强的局限性。</p>\n<p>而CGLIB动态代理则没有此类强制性要求。简单的说，<code>CGLIB</code>会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。</p>\n<p><strong>总结一下CGLIB在进行代理的时候都进行了哪些工作</strong></p>\n<ul>\n<li>生成的代理类继承被代理类。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理</li>\n<li>代理类会为委托方法生成两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法</li>\n<li>当执行代理对象的方法时，会首先判断一下是否存在实现了<code>MethodInterceptor</code>接口的<code>CGLIB$CALLBACK_0</code>;，如果存在，则将调用<code>MethodInterceptor</code>中的<code>intercept</code>方法</li>\n</ul>\n<p>在<code>intercept</code>方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录</p>\n<p>在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：通过<strong>FastClass机制</strong>对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用</p>\n<h2 id=\"Fastclass机制\"><a href=\"#Fastclass机制\" class=\"headerlink\" title=\"Fastclass机制\"></a>Fastclass机制</h2><p>CGLIB采用了FastClass的机制来实现对被拦截方法的调用。</p>\n<p>FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法</p>\n<pre><code class=\"java\">public class test10 &#123;\n  //这里，tt可以看作目标对象，fc可以看作是代理对象；首先根据代理对象的getIndex方法获取目标方法的索引，\n  //然后再调用代理对象的invoke方法就可以直接调用目标类的方法，避免了反射\n    public static void main(String[] args)&#123;\n        Test tt = new Test();\n        Test2 fc = new Test2();\n        int index = fc.getIndex(&quot;f()V&quot;);\n        fc.invoke(index, tt, null);\n    &#125;\n&#125;\n\nclass Test&#123;\n    public void f()&#123;\n        System.out.println(&quot;f method&quot;);\n    &#125;\n    \n    public void g()&#123;\n        System.out.println(&quot;g method&quot;);\n    &#125;\n&#125;\nclass Test2&#123;\n    public Object invoke(int index, Object o, Object[] ol)&#123;\n        Test t = (Test) o;\n        switch(index)&#123;\n        case 1:\n            t.f();\n            return null;\n        case 2:\n            t.g();\n            return null;\n        &#125;\n        return null;\n    &#125;\n    //这个方法对Test类中的方法建立索引\n    public int getIndex(String signature)&#123;\n        switch(signature.hashCode())&#123;\n        case 3078479:\n            return 1;\n        case 3108270:\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<p>上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。</p>\n<p>在getIndex方法中对Test的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。</p>\n<p>Invoke根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率</p>\n<p><strong>三种代理方式之间对比</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">代理方式</th>\n<th align=\"left\">实现</th>\n<th align=\"left\">优点</th>\n<th align=\"left\">缺点</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">JDK静态代理</td>\n<td align=\"left\">代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td>\n<td align=\"left\">实现简单，容易理解</td>\n<td align=\"left\">代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td>\n<td align=\"left\">好像没啥特点</td>\n</tr>\n<tr>\n<td align=\"left\">JDK动态代理</td>\n<td align=\"left\">代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写<code>invoke</code>方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td>\n<td align=\"left\">不需要硬编码接口，代码复用率高</td>\n<td align=\"left\">只能够代理实现了接口的委托类</td>\n<td align=\"left\">底层使用反射机制进行方法的调用</td>\n</tr>\n<tr>\n<td align=\"left\">CGLIB动态代理</td>\n<td align=\"left\">代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了<code>MethodInterceptor</code>接口的对象，若存在则将调用intercept方法对委托方法进行代理</td>\n<td align=\"left\">可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td>\n<td align=\"left\">不能对<code>final</code>类以及final方法进行代理</td>\n<td align=\"left\">底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td>\n</tr>\n</tbody></table>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p><strong>CGlib比JDK快？</strong></p>\n<ul>\n<li>使用CGLiB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。</li>\n<li>在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。</li>\n</ul>\n<p><strong>Spring如何选择用JDK还是CGLIB？</strong></p>\n<ul>\n<li>当Bean实现接口时，Spring就会用JDK的动态代理。</li>\n<li>当Bean没有实现接口时，Spring使用CGlib实现。</li>\n<li>可以强制使用CGlib</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><blockquote>\n<p>面试题：讲讲jdk动态代理，cglib区别，实现原理，优缺点，怎么实现方法的调用的</p>\n</blockquote>\n<p>来自：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></p>\n<p>这篇文章总结你需要回答的知识点，全程少废话，怼干货，文章较长，可以<strong>点赞在看</strong>，喜欢这种文章的话，我之后也会一直分享的，硬核文章也会定期分享！</p>\n<p>文章会同步到个人网站，方便阅读：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png\"></p>\n<h1 id=\"代理模式\"><a href=\"#代理模式\" class=\"headerlink\" title=\"代理模式\"></a>代理模式</h1><p>代理模式是一种设计模式，提供了对目标对象额外的访问方式，即通过代理对象访问目标对象，这样可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能</p>\n<p><strong>一个比方：在租房的时候，有的人会通过房东直租，有的人会通过中介租房。</strong></p>\n<p>这两种情况哪种比较方便呢？当然是通过中介更加方便。</p>\n<p>这里的中介就相当于代理，用户通过中介完成租房的一系列操作（看房、交押金、租房、清扫卫生）代理模式可以有效的将具体的实现与调用方进行解耦，通过面向接口进行编码完全将具体的实现隐藏在内部。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b9d15e7c8abd4c3cb400c578caa3192a.png\"></p>\n<p><strong>分类：</strong></p>\n<p><strong>静态代理：</strong> 在编译时就已经实现，编译完成后代理类是一个实际的class文件</p>\n<p><strong>动态代理：</strong> 在运行时动态生成的，即编译完成后没有实际的class文件，而是<strong>在运行时动态生成类字节码，并加载到JVM中</strong></p>\n<h1 id=\"静态代理\"><a href=\"#静态代理\" class=\"headerlink\" title=\"静态代理\"></a>静态代理</h1><p><strong>使用方式</strong></p>\n<p>创建一个接口，然后创建被代理的类实现该接口并且实现该接口中的抽象方法。之后再创建一个代理类，同时使其也实现这个接口。在代理类中持有一个被代理对象的引用，而后在代理类方法中调用该对象的方法。</p>\n<pre><code class=\"java\">public interface UserDao &#123;    \n  void save();     \n&#125;\npublic class UserDaoImpl implements UserDao &#123;\n    @Override\n    public void save() &#123;\n        System.out.println(&quot;正在保存用户...&quot;);\n    &#125;\n&#125;\npublic class TransactionHandler implements UserDao &#123;\n    //目标代理对象\n    private UserDao target;\n    //构造代理对象时传入目标对象\n    public TransactionHandler(UserDao target) &#123;\n        this.target = target;\n    &#125;\n    @Override\n    public void save() &#123;\n        //调用目标方法前的处理\n        System.out.println(&quot;开启事务控制...&quot;);\n        //调用目标对象的方法\n        target.save();\n        //调用目标方法后的处理\n        System.out.println(&quot;关闭事务控制...&quot;);\n    &#125;\n&#125;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        //新建目标对象\n        UserDaoImpl target = new UserDaoImpl();\n        //创建代理对象, 并使用接口对其进行引用\n        UserDao userDao = new TransactionHandler(target);\n        //针对接口进行调用\n        userDao.save();\n    &#125;\n&#125;\n</code></pre>\n<p>使用JDK静态代理很容易就完成了对一个类的代理操作。但是<code>JDK</code>静态代理的缺点也暴露了出来：由于代理只能为一个类服务，如果需要代理的类很多，那么就需要编写大量的代理类，比较繁琐</p>\n<h1 id=\"JDK动态代理\"><a href=\"#JDK动态代理\" class=\"headerlink\" title=\"JDK动态代理\"></a>JDK动态代理</h1><p><strong>使用JDK动态代理的五大步骤：</strong></p>\n<ol>\n<li>通过实现InvocationHandler接口来自定义自己的InvocationHandler；</li>\n<li>通过<code>Proxy.getProxyClass</code>获得动态代理类；</li>\n<li>通过反射机制获得代理类的构造方法，方法签名为<code>getConstructor(InvocationHandler.class)</code>；</li>\n<li>通过构造函数获得代理对象并将自定义的<code>InvocationHandler</code>实例对象传为参数传入；</li>\n<li>通过代理对象调用目标方法；</li>\n</ol>\n<pre><code class=\"java\">public interface IHello &#123;\n    void sayHello();\n&#125;\n public class HelloImpl implements IHello &#123;\n    @Override\n    public void sayHello() &#123;\n        System.out.println(&quot;Hello world!&quot;);\n    &#125;\n&#125;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\n \npublic class MyInvocationHandler implements InvocationHandler &#123;\n \n    /** 目标对象 */\n    private Object target;\n \n    public MyInvocationHandler(Object target)&#123;\n        this.target = target;\n    &#125;\n \n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        System.out.println(&quot;------插入前置通知代码-------------&quot;);\n        // 执行相应的目标方法\n        Object rs = method.invoke(target,args);\n        System.out.println(&quot;------插入后置处理代码-------------&quot;);\n        return rs;\n    &#125;\n&#125;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Proxy;\n\npublic class MyProxyTest &#123;\n    public static void main(String[] args)\n            throws NoSuchMethodException, IllegalAccessException, InstantiationException, InvocationTargetException &#123;\n        // =========================第一种==========================\n        // 1、生成$Proxy0的class文件\n        System.getProperties().put(&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;, &quot;true&quot;);\n        // 2、获取动态代理类\n        Class proxyClazz = Proxy.getProxyClass(IHello.class.getClassLoader(),IHello.class);\n        // 3、获得代理类的构造函数，并传入参数类型InvocationHandler.class\n        Constructor constructor = proxyClazz.getConstructor(InvocationHandler.class);\n        // 4、通过构造函数来创建动态代理对象，将自定义的InvocationHandler实例传入\n        IHello iHello1 = (IHello) constructor.newInstance(new MyInvocationHandler(new HelloImpl()));\n        // 5、通过代理对象调用目标方法\n        iHello1.sayHello();\n \n        // ==========================第二种=============================\n        /**\n         * Proxy类中还有个将2~4步骤封装好的简便方法来创建动态代理对象，\n         *其方法签名为：newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] instance, InvocationHandler h)\n         */\n        IHello  iHello2 = (IHello) Proxy.newProxyInstance(IHello.class.getClassLoader(), // 加载接口的类加载器\n                new Class[]&#123;IHello.class&#125;, // 一组接口\n                new MyInvocationHandler(new HelloImpl())); // 自定义的InvocationHandler\n        iHello2.sayHello();\n    &#125;\n&#125;\n</code></pre>\n<p>JDK静态代理与JDK动态代理之间有些许相似，比如说都要创建代理类，以及代理类都要实现接口等。</p>\n<p><strong>不同之处：</strong> 在静态代理中我们需要对哪个接口和哪个被代理类创建代理类，所以我们在编译前就需要代理类实现与被代理类相同的接口，并且直接在实现的方法中调用被代理类相应的方法；但是动态代理则不同，我们不知道要针对哪个接口、哪个被代理类创建代理类，因为它是在运行时被创建的。</p>\n<p><strong>一句话来总结一下JDK静态代理和JDK动态代理的区别：</strong></p>\n<p>JDK静态代理是通过直接编码创建的，而<code>JDK</code>动态代理是利用反射机制在运行时创建代理类的。</p>\n<p>其实在动态代理中，核心是<code>InvocationHandler</code>。每一个代理的实例都会有一个关联的调用处理程序(InvocationHandler)。对待代理实例进行调用时，将对方法的调用进行编码并指派到它的调用处理器(InvocationHandler)的<code>invoke</code>方法</p>\n<p>对代理对象实例方法的调用都是通过InvocationHandler中的invoke方法来完成的，而invoke方法会根据传入的代理对象、方法名称以及参数决定调用代理的哪个方法。</p>\n<h1 id=\"CGLIB\"><a href=\"#CGLIB\" class=\"headerlink\" title=\"CGLIB\"></a>CGLIB</h1><p>CGLIB包的底层是通过使用一个小而快的字节码处理框架<code>ASM</code>，来转换字节码并生成新的类</p>\n<p><strong>CGLIB代理实现如下：</strong></p>\n<ol>\n<li>首先实现一个MethodInterceptor，方法调用会被转发到该类的intercept()方法。</li>\n<li>然后在需要使用的时候，通过CGLIB动态代理获取代理对象。</li>\n</ol>\n<p><strong>使用案例</strong></p>\n<pre><code class=\"java\"> public class HelloService &#123;\n \n    public HelloService() &#123;\n        System.out.println(&quot;HelloService构造&quot;);\n    &#125;\n \n    /**\n     * 该方法不能被子类覆盖,Cglib是无法代理final修饰的方法的\n     */\n    final public String sayOthers(String name) &#123;\n        System.out.println(&quot;HelloService:sayOthers&gt;&gt;&quot;+name);\n        return null;\n    &#125;\n \n    public void sayHello() &#123;\n        System.out.println(&quot;HelloService:sayHello&quot;);\n    &#125;\n&#125;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n \nimport java.lang.reflect.Method;\n \n/**\n * 自定义MethodInterceptor\n */\npublic class MyMethodInterceptor implements MethodInterceptor&#123;\n \n    /**\n     * sub：cglib生成的代理对象\n     * method：被代理对象方法\n     * objects：方法入参\n     * methodProxy: 代理方法\n     */\n    @Override\n    public Object intercept(Object sub, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123;\n        System.out.println(&quot;======插入前置通知======&quot;);\n        Object object = methodProxy.invokeSuper(sub, objects);\n        System.out.println(&quot;======插入后者通知======&quot;);\n        return object;\n    &#125;\n&#125;\nimport net.sf.cglib.core.DebuggingClassWriter;\nimport net.sf.cglib.proxy.Enhancer;\n \npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        // 代理类class文件存入本地磁盘方便我们反编译查看源码\n        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, &quot;D:\\\\code&quot;);\n        // 通过CGLIB动态代理获取代理对象的过程\n        Enhancer enhancer = new Enhancer();\n        // 设置enhancer对象的父类\n        enhancer.setSuperclass(HelloService.class);\n        // 设置enhancer的回调对象\n        enhancer.setCallback(new MyMethodInterceptor());\n        // 创建代理对象\n        HelloService proxy= (HelloService)enhancer.create();\n        // 通过代理对象调用目标方法\n        proxy.sayHello();\n    &#125;\n&#125;\n</code></pre>\n<p>JDK代理要求被代理的类必须实现接口，有很强的局限性。</p>\n<p>而CGLIB动态代理则没有此类强制性要求。简单的说，<code>CGLIB</code>会让生成的代理类继承被代理类，并在代理类中对代理方法进行强化处理(前置处理、后置处理等)。</p>\n<p><strong>总结一下CGLIB在进行代理的时候都进行了哪些工作</strong></p>\n<ul>\n<li>生成的代理类继承被代理类。在这里我们需要注意一点：如果委托类被final修饰，那么它不可被继承，即不可被代理；同样，如果委托类中存在final修饰的方法，那么该方法也不可被代理</li>\n<li>代理类会为委托方法生成两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法</li>\n<li>当执行代理对象的方法时，会首先判断一下是否存在实现了<code>MethodInterceptor</code>接口的<code>CGLIB$CALLBACK_0</code>;，如果存在，则将调用<code>MethodInterceptor</code>中的<code>intercept</code>方法</li>\n</ul>\n<p>在<code>intercept</code>方法中，我们除了会调用委托方法，还会进行一些增强操作。在Spring AOP中，典型的应用场景就是在某些敏感方法执行前后进行操作日志记录</p>\n<p>在CGLIB中，方法的调用并不是通过反射来完成的，而是直接对方法进行调用：通过<strong>FastClass机制</strong>对Class对象进行特别的处理，比如将会用数组保存method的引用，每次调用方法的时候都是通过一个index下标来保持对方法的引用</p>\n<h2 id=\"Fastclass机制\"><a href=\"#Fastclass机制\" class=\"headerlink\" title=\"Fastclass机制\"></a>Fastclass机制</h2><p>CGLIB采用了FastClass的机制来实现对被拦截方法的调用。</p>\n<p>FastClass机制就是对一个类的方法建立索引，通过索引来直接调用相应的方法</p>\n<pre><code class=\"java\">public class test10 &#123;\n  //这里，tt可以看作目标对象，fc可以看作是代理对象；首先根据代理对象的getIndex方法获取目标方法的索引，\n  //然后再调用代理对象的invoke方法就可以直接调用目标类的方法，避免了反射\n    public static void main(String[] args)&#123;\n        Test tt = new Test();\n        Test2 fc = new Test2();\n        int index = fc.getIndex(&quot;f()V&quot;);\n        fc.invoke(index, tt, null);\n    &#125;\n&#125;\n\nclass Test&#123;\n    public void f()&#123;\n        System.out.println(&quot;f method&quot;);\n    &#125;\n    \n    public void g()&#123;\n        System.out.println(&quot;g method&quot;);\n    &#125;\n&#125;\nclass Test2&#123;\n    public Object invoke(int index, Object o, Object[] ol)&#123;\n        Test t = (Test) o;\n        switch(index)&#123;\n        case 1:\n            t.f();\n            return null;\n        case 2:\n            t.g();\n            return null;\n        &#125;\n        return null;\n    &#125;\n    //这个方法对Test类中的方法建立索引\n    public int getIndex(String signature)&#123;\n        switch(signature.hashCode())&#123;\n        case 3078479:\n            return 1;\n        case 3108270:\n            return 2;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<p>上例中，Test2是Test的Fastclass，在Test2中有两个方法getIndex和invoke。</p>\n<p>在getIndex方法中对Test的每个方法建立索引，并根据入参（方法名+方法的描述符）来返回相应的索引。</p>\n<p>Invoke根据指定的索引，以ol为入参调用对象O的方法。这样就避免了反射调用，提高了效率</p>\n<p><strong>三种代理方式之间对比</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">代理方式</th>\n<th align=\"left\">实现</th>\n<th align=\"left\">优点</th>\n<th align=\"left\">缺点</th>\n<th align=\"left\">特点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">JDK静态代理</td>\n<td align=\"left\">代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td>\n<td align=\"left\">实现简单，容易理解</td>\n<td align=\"left\">代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td>\n<td align=\"left\">好像没啥特点</td>\n</tr>\n<tr>\n<td align=\"left\">JDK动态代理</td>\n<td align=\"left\">代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写<code>invoke</code>方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td>\n<td align=\"left\">不需要硬编码接口，代码复用率高</td>\n<td align=\"left\">只能够代理实现了接口的委托类</td>\n<td align=\"left\">底层使用反射机制进行方法的调用</td>\n</tr>\n<tr>\n<td align=\"left\">CGLIB动态代理</td>\n<td align=\"left\">代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过<code>super</code>调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了<code>MethodInterceptor</code>接口的对象，若存在则将调用intercept方法对委托方法进行代理</td>\n<td align=\"left\">可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td>\n<td align=\"left\">不能对<code>final</code>类以及final方法进行代理</td>\n<td align=\"left\">底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td>\n</tr>\n</tbody></table>\n<h1 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h1><p><strong>CGlib比JDK快？</strong></p>\n<ul>\n<li>使用CGLiB实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类， 在jdk6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的方法进行代理， 因为CGLib原理是动态生成被代理类的子类。</li>\n<li>在jdk6、jdk7、jdk8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLIB代理效率。只有当进行大量调用的时候，jdk6和jdk7比CGLIB代理效率低一点，但是到jdk8的时候，jdk代理效率高于CGLIB代理，总之，每一次jdk版本升级，jdk代理效率都得到提升，而CGLIB代理消息确有点跟不上步伐。</li>\n</ul>\n<p><strong>Spring如何选择用JDK还是CGLIB？</strong></p>\n<ul>\n<li>当Bean实现接口时，Spring就会用JDK的动态代理。</li>\n<li>当Bean没有实现接口时，Spring使用CGlib实现。</li>\n<li>可以强制使用CGlib</li>\n</ul>\n"},{"title":"慢查询","_content":"\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n喜欢的话，之后会分享更多系列文章！\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n* 微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n# 前言\n\n前几天帮公司解决线上慢SQL告警问题，遇到了几个case。\n\n下面我会结合case案例分析自己这段时间在工作上遇到的慢查询谈谈数据库如何优化慢查询。\n\n一般我们遇到的慢sql都是索引没有正确使用导致的，所以我先介绍下索引相关知识\n\n# 索引介绍\n\n**索引概念**\n\n排好序的快速查找的数据结构（我们平时说的索引，如果没有特别指明，都是指B树，其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认使用的都是B+树索引，除B+树这种类型的索引外还有哈希索引等）\n\n**索引优缺点**\n\n优点：\n\n- 查找 ：提高数据检索效率，降低IO成本。\n- 排序：通过索引对数据进行排序，降低排序成本，降低cpu消耗\n\n缺点：\n\n- 实际上索引也是一张表，该表保存了主键与索引字段，并指向索引的记录，所以索引列也需要占空间。\n- 更新表时（insert、update、delete）不仅要保存数据还要更新保存索引文件新添加的索引列。\n\n**索引分类**\n\n- 单值索引（单列索引）：一个索引只包含单个列，一个表中可以有多个单列索引。\n- 唯一索引：索引列必须唯一，但可以允许有空值\n- 复合索引：一个索引包含多个列\n\n**索引结构**\n\n- BTree索引\n- Hash索引\n- full-text全文检索\n- R-Tree索引\n\n**哪些情况要建索引**\n\n- 主键自动建主键索引\n- 频繁作为查询条件的字段应该创建索引\n- 查询中与其他表关联的字段，外键关系建立索引\n- 在高并发下倾向建立组合索引\n- 查询中的排序字段，排序字段若通过索引去访问将大大提高排序速度\n- 查询中统计或者分组的数据\n\n**哪些情况不适合建索引**\n\n- 频繁更新的字段\n- where条件用不到的字段不创建索引\n- 表记录太少\n- 经常增删改的表\n- 数据重复太多的字段，为它建索引意义不大（假如一个表有10万，有一个字段只有T和F两种值，每个值的分布概率大约只有50%，那么对这个字段的建索引一般不会提高查询效率，索引的选择性是指索引列的不同值数据与表中索引记录的比，，如果一个表中有2000条记录，表中索引列的不同值记录有1980个，这个索引的选择性为`1980/2000=0.99`，如果索引项越接近1，这个索引效率越高）\n\n**explain字段分析**\n\nexplain是排查慢sql的一种最常用的手段\n\n```sql\nmysql> EXPLAIN SELECT 1;\n```\n\n![](https://img-blog.csdnimg.cn/cc04a8197a314065b59e38ff179d37db.png)\n\nid：表示select子句或者操作的顺序\n\n- id相同：执行顺序自上而下\n- id不同：id值越大优先级越高，越先被执行\n- id相同不同：id越大越先执行，相同的自上而下执行\n\nselect_type：主要是区分普通查询、联合查询、子查询等。\n\n- SIMPLE：简单的select查询，不包含子查询与union\n- PRIMARY：查询中包含复杂的子部分，最外层会被标记为primary\n- SUBQUERY：在select或者where列表中包含了子查询\n- DERIVED：在from列表中包含的子查询衍生表\n- UNION：若第二个select出现在union之后，则被标记为union\n- UNION RESESULT：从union表获取结果的select\n\ntable：这一行数据是哪个表的数据\n\ntype：查询中使用了何种类型\n\n**结果值从最好到最坏：system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>all**\n\n- 一般来说，得保证查询至少达到range级别，最好能到达ref\n- system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现\n- const：表示通过索引一次就能够找到\n- eq_ref:唯一性索引扫描，对于每个索引键，表示只有一条记录与之匹配，常见于主键或唯一索引扫描\n- ref：非唯一性索引扫描，返回匹配某个单独值的所有行\n- range：只检索给定范围的行，使用一个索引来选择行，一般就是在where语句中出现了between、<、>、in等的查询\n- index：index比all快，因为index是从索引中读取，all是从硬盘中读取\n- all：遍历全表才能找到\n\npossible_key：显示可能应用在这张表中的索引，但实际上不一定用到\n\nkey：实际上使用的索引，如果没有则为null\n\nkey_len：表示索引中使用的字节数（可能使用的，不是实际的），可通过该列查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好\n\nref：显示索引的哪一列被用到，如果可能的话是一个常数，哪些常量被用于查找索引列上的值\n\nrows：大致估算找出所需的记录要读取的行数\n\nExtra：包含不适合在其他列中显示，但十分重要的的额外信息\n\n- Using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，mysql中无法利用索引完成的排序成为文件排序\n- Using temporary 使了用临时表保存中间结果，mysql在对查询结果排序时使用了临时表，常见于排序order by 和分组查询group by\n- Using index 表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率高\n- Using where 表明使用了where进行过滤\n- Using join buffer 使用了连接缓存\n- impossible where 如果where子句的值总是false，不能用来获取任何元组\n- select table optimized away 在没有group by子句的情况下，基于索引优化min/max操作或者对于myisam存储引擎优化`count(*)`操作，不必等到执行阶段再进行计算\n\n**更详细的内容，请看我之前的文章：**\n\n[最完整的Explain总结，SQL优化不再困难](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect)\n\n最完整的Explain总结，SQL优化不再困难\n\n**索引失效**\n\n- 应该尽量全值匹配\n- 复合最佳左前缀法则（**第一个索引不能掉，中间不能断开**）\n- 不在索引列上做任何操作（计算、函数、类型转换）会导致索引失效而转向全表扫描\n- 存储存引擎不能使用索引中范围条件右边的列\n- 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少`select*`\n- mysql在使用不等于(!=或者<>)的时候无法使用索引会导致全表扫描\n- is null，is not null也会无法使用索引\n- like以统配符开头\n- 字符串不加单引号\n- 少用or\n\n**order by优化**\n\n- 避免filesort，尽量在索引上进行排序，遵照最佳左前缀原则\n\nfilesort有两种排序：\n\n- 双路排序：两次磁盘扫描\n\n- 单路排序：一次性读取保存在内存中，没拉完的数据再次拉\n- 单路排序总体好于双路排序\n- 优化策略：1、增大`sort_buffer_size`参数的设置，2、增大`max_length_for_sort_data`参数的设置，尽可能一次拿到内存\n\n# Case分析\n\n## 案例一\n\n**in中参数太多**\n\n```sql\nselect * from goods_info where goods_status = ? and id in(11,22,33......)\n```\n\nin中id数据量比较多，导致查询的数据量比较大，这是一个比较常见的慢查询类型，并且往往在业务数据量比较少的时候这条语句不是慢查；\n\n因为参数传进一个List集合，当参数比较多的时候，可以采用在业务层把List集合拆分为多个长度较小的集合，分多次查询，具体每一次拆长度为多少，可能需要具体根据业务及数据量进行评估\n\n**我的解决办法**：业务代码增加拆分集合操作，`LIMIT_SIZE`设置为1000\n\n```sql\nList<List<Integer>> partitionGoodsIdList = Lists.partition(goodsIdList, LIMIT_SIZE);\n```\n\n当SQL的查询参数过多，我觉得可以考虑使用上述拆分的方式\n\n## 案例二\n\n**返回的查询结果过多**\n\n```sql\nselect from goods where goods_status = ? and poi_id = ?\n```\n\n**解决办法**：将SQL修改为分页查询，并在业务代码上修改为分页查询，修改后的SQL语句如下：\n\n```sql\nselect from goods where goods_status = 1 and poi_id = 11 and goods_id > 22 order by goods_id limit 2000\n```\n\n通过分页的方式可以降低数据量，避免慢查询，但是会从而导致一次查询请求，增加为多次查询请求，对于limit的大小需要谨慎评估\n\n## 案例三\n\n**order by慢查询**\n\n```sql\nSELECT * FROM order FORCE INDEX (orderId)  WHERE userId = 11 AND status IN (0,22) ORDER BY id ASC ;\n```\n\n该SQL由于强制**指定了使用orderId索引，但条件中并没有orderId**，导致产生全表扫描（type: ALL）；\n\n如下为问题SQL的执行计划：\n\n![](https://img-blog.csdnimg.cn/e1e989057fdc444a8ca820344ca45e4a.png)\n\n直接原因是最终传给SQL查询函数的参数，orderId没有加入where子句，但forceindex一直生效\n\n## 案例四\n\n**join慢查询**\n\n```sql\nselect * from useract join userinfo order by useracct.id desc limit 11;\n```\n\n对sql进行explain可以发现，因为忘写了join的on条件，这是扫全表sql，如下图：\n\n我们首先看type级别两个表的级别都是ALL，说明该条语句没有用到索引，做了全表扫描是最差的情况\n\n![](https://img-blog.csdnimg.cn/d546f9f290bc45c2a4cfe160d7fb410d.png)\n\n优化：\n\n![](https://img-blog.csdnimg.cn/8b06006fb9cf4c35aa9e8d019b4bf085.png)\n\n## 案例五\n\n**不同索引尝试**\n\n```sql\nselect id from goods_info where id > ? and activity_id = ? and goods_switch in(?+) limit ?\nselect id from goods_info where id > 123991510 and activity_id = 0 and goods_switch in (2,3) limit 1000\n```\n\n通过执行计划可知，该语句走的是`activity_id`和主键的索引，但是这种命中率比较低，大量的数据被`goods_switch`筛掉\n\n**解决办法**：在不确定最优的索引的情况下，可以在测试环境下，分别添加不同的索引，观察执行计划及语句的执行时间。\n\n尝试强制走主键索引，效果不佳；尝试添加`activity_id_id`的联合索引，效果不佳；尝试添加`activity_id,goods_switch`的联合索引，问题解决！\n\n所以在不确定哪种索引是最优时，可以尝试建立不同的索引，观察语句在不同索引情况下的执行情况进行权衡。\n\n## 案例六\n\n**MySQL选错索引**\n\n```sql\nselect * from goods_info\nwhere goods_source = ? and goods_switch != ? and id > ? order by id limit ?\n\nselect * from goods_info  \nwhere goods_source = 2 and goods_switch != 8 and id > 12395070 order by id limit 1000\n```\n\n这条语句从语句本身猜测使用的是主键索引，但是查看该语句的执行计划，发现走的索引是`idx_goods_source`，即走了`goods_source`的单列索引！\n\n**解决办法**：修改SQL语句，强制走主键索引，查看执行计划，走了主键索引，查询时间大大降低。\n\n正常情况下MySQL会选择最优的索引，但是有时候也会选错，MySQL的优化器会依据扫描行数、是否排序，索引区分度来选择最优的索引，并且扫描行数不一定完成准确，只是MySQL的一个预估值\n\n# 总结\n\n**慢查询优化是一个长期的过程，长期有耐心！**\n\n# 最后\n\n**写文章很花时间，喜欢的话，希望帮忙点赞，转发下哈，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，获得免费电子书籍\n\n参考书籍：\n\n- 高性能MySQL","source":"_posts/公众号文章/慢查询.md","raw":"---\ntitle: 慢查询\ncategories: \n- 公众号文章\n---\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n喜欢的话，之后会分享更多系列文章！\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n* 微信搜索：月伴飞鱼，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n# 前言\n\n前几天帮公司解决线上慢SQL告警问题，遇到了几个case。\n\n下面我会结合case案例分析自己这段时间在工作上遇到的慢查询谈谈数据库如何优化慢查询。\n\n一般我们遇到的慢sql都是索引没有正确使用导致的，所以我先介绍下索引相关知识\n\n# 索引介绍\n\n**索引概念**\n\n排好序的快速查找的数据结构（我们平时说的索引，如果没有特别指明，都是指B树，其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认使用的都是B+树索引，除B+树这种类型的索引外还有哈希索引等）\n\n**索引优缺点**\n\n优点：\n\n- 查找 ：提高数据检索效率，降低IO成本。\n- 排序：通过索引对数据进行排序，降低排序成本，降低cpu消耗\n\n缺点：\n\n- 实际上索引也是一张表，该表保存了主键与索引字段，并指向索引的记录，所以索引列也需要占空间。\n- 更新表时（insert、update、delete）不仅要保存数据还要更新保存索引文件新添加的索引列。\n\n**索引分类**\n\n- 单值索引（单列索引）：一个索引只包含单个列，一个表中可以有多个单列索引。\n- 唯一索引：索引列必须唯一，但可以允许有空值\n- 复合索引：一个索引包含多个列\n\n**索引结构**\n\n- BTree索引\n- Hash索引\n- full-text全文检索\n- R-Tree索引\n\n**哪些情况要建索引**\n\n- 主键自动建主键索引\n- 频繁作为查询条件的字段应该创建索引\n- 查询中与其他表关联的字段，外键关系建立索引\n- 在高并发下倾向建立组合索引\n- 查询中的排序字段，排序字段若通过索引去访问将大大提高排序速度\n- 查询中统计或者分组的数据\n\n**哪些情况不适合建索引**\n\n- 频繁更新的字段\n- where条件用不到的字段不创建索引\n- 表记录太少\n- 经常增删改的表\n- 数据重复太多的字段，为它建索引意义不大（假如一个表有10万，有一个字段只有T和F两种值，每个值的分布概率大约只有50%，那么对这个字段的建索引一般不会提高查询效率，索引的选择性是指索引列的不同值数据与表中索引记录的比，，如果一个表中有2000条记录，表中索引列的不同值记录有1980个，这个索引的选择性为`1980/2000=0.99`，如果索引项越接近1，这个索引效率越高）\n\n**explain字段分析**\n\nexplain是排查慢sql的一种最常用的手段\n\n```sql\nmysql> EXPLAIN SELECT 1;\n```\n\n![](https://img-blog.csdnimg.cn/cc04a8197a314065b59e38ff179d37db.png)\n\nid：表示select子句或者操作的顺序\n\n- id相同：执行顺序自上而下\n- id不同：id值越大优先级越高，越先被执行\n- id相同不同：id越大越先执行，相同的自上而下执行\n\nselect_type：主要是区分普通查询、联合查询、子查询等。\n\n- SIMPLE：简单的select查询，不包含子查询与union\n- PRIMARY：查询中包含复杂的子部分，最外层会被标记为primary\n- SUBQUERY：在select或者where列表中包含了子查询\n- DERIVED：在from列表中包含的子查询衍生表\n- UNION：若第二个select出现在union之后，则被标记为union\n- UNION RESESULT：从union表获取结果的select\n\ntable：这一行数据是哪个表的数据\n\ntype：查询中使用了何种类型\n\n**结果值从最好到最坏：system>const>eq_ref>ref>fulltext>ref_or_null>index_merge>unique_subquery>index_subquery>range>index>all**\n\n- 一般来说，得保证查询至少达到range级别，最好能到达ref\n- system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现\n- const：表示通过索引一次就能够找到\n- eq_ref:唯一性索引扫描，对于每个索引键，表示只有一条记录与之匹配，常见于主键或唯一索引扫描\n- ref：非唯一性索引扫描，返回匹配某个单独值的所有行\n- range：只检索给定范围的行，使用一个索引来选择行，一般就是在where语句中出现了between、<、>、in等的查询\n- index：index比all快，因为index是从索引中读取，all是从硬盘中读取\n- all：遍历全表才能找到\n\npossible_key：显示可能应用在这张表中的索引，但实际上不一定用到\n\nkey：实际上使用的索引，如果没有则为null\n\nkey_len：表示索引中使用的字节数（可能使用的，不是实际的），可通过该列查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好\n\nref：显示索引的哪一列被用到，如果可能的话是一个常数，哪些常量被用于查找索引列上的值\n\nrows：大致估算找出所需的记录要读取的行数\n\nExtra：包含不适合在其他列中显示，但十分重要的的额外信息\n\n- Using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，mysql中无法利用索引完成的排序成为文件排序\n- Using temporary 使了用临时表保存中间结果，mysql在对查询结果排序时使用了临时表，常见于排序order by 和分组查询group by\n- Using index 表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率高\n- Using where 表明使用了where进行过滤\n- Using join buffer 使用了连接缓存\n- impossible where 如果where子句的值总是false，不能用来获取任何元组\n- select table optimized away 在没有group by子句的情况下，基于索引优化min/max操作或者对于myisam存储引擎优化`count(*)`操作，不必等到执行阶段再进行计算\n\n**更详细的内容，请看我之前的文章：**\n\n[最完整的Explain总结，SQL优化不再困难](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect)\n\n最完整的Explain总结，SQL优化不再困难\n\n**索引失效**\n\n- 应该尽量全值匹配\n- 复合最佳左前缀法则（**第一个索引不能掉，中间不能断开**）\n- 不在索引列上做任何操作（计算、函数、类型转换）会导致索引失效而转向全表扫描\n- 存储存引擎不能使用索引中范围条件右边的列\n- 尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少`select*`\n- mysql在使用不等于(!=或者<>)的时候无法使用索引会导致全表扫描\n- is null，is not null也会无法使用索引\n- like以统配符开头\n- 字符串不加单引号\n- 少用or\n\n**order by优化**\n\n- 避免filesort，尽量在索引上进行排序，遵照最佳左前缀原则\n\nfilesort有两种排序：\n\n- 双路排序：两次磁盘扫描\n\n- 单路排序：一次性读取保存在内存中，没拉完的数据再次拉\n- 单路排序总体好于双路排序\n- 优化策略：1、增大`sort_buffer_size`参数的设置，2、增大`max_length_for_sort_data`参数的设置，尽可能一次拿到内存\n\n# Case分析\n\n## 案例一\n\n**in中参数太多**\n\n```sql\nselect * from goods_info where goods_status = ? and id in(11,22,33......)\n```\n\nin中id数据量比较多，导致查询的数据量比较大，这是一个比较常见的慢查询类型，并且往往在业务数据量比较少的时候这条语句不是慢查；\n\n因为参数传进一个List集合，当参数比较多的时候，可以采用在业务层把List集合拆分为多个长度较小的集合，分多次查询，具体每一次拆长度为多少，可能需要具体根据业务及数据量进行评估\n\n**我的解决办法**：业务代码增加拆分集合操作，`LIMIT_SIZE`设置为1000\n\n```sql\nList<List<Integer>> partitionGoodsIdList = Lists.partition(goodsIdList, LIMIT_SIZE);\n```\n\n当SQL的查询参数过多，我觉得可以考虑使用上述拆分的方式\n\n## 案例二\n\n**返回的查询结果过多**\n\n```sql\nselect from goods where goods_status = ? and poi_id = ?\n```\n\n**解决办法**：将SQL修改为分页查询，并在业务代码上修改为分页查询，修改后的SQL语句如下：\n\n```sql\nselect from goods where goods_status = 1 and poi_id = 11 and goods_id > 22 order by goods_id limit 2000\n```\n\n通过分页的方式可以降低数据量，避免慢查询，但是会从而导致一次查询请求，增加为多次查询请求，对于limit的大小需要谨慎评估\n\n## 案例三\n\n**order by慢查询**\n\n```sql\nSELECT * FROM order FORCE INDEX (orderId)  WHERE userId = 11 AND status IN (0,22) ORDER BY id ASC ;\n```\n\n该SQL由于强制**指定了使用orderId索引，但条件中并没有orderId**，导致产生全表扫描（type: ALL）；\n\n如下为问题SQL的执行计划：\n\n![](https://img-blog.csdnimg.cn/e1e989057fdc444a8ca820344ca45e4a.png)\n\n直接原因是最终传给SQL查询函数的参数，orderId没有加入where子句，但forceindex一直生效\n\n## 案例四\n\n**join慢查询**\n\n```sql\nselect * from useract join userinfo order by useracct.id desc limit 11;\n```\n\n对sql进行explain可以发现，因为忘写了join的on条件，这是扫全表sql，如下图：\n\n我们首先看type级别两个表的级别都是ALL，说明该条语句没有用到索引，做了全表扫描是最差的情况\n\n![](https://img-blog.csdnimg.cn/d546f9f290bc45c2a4cfe160d7fb410d.png)\n\n优化：\n\n![](https://img-blog.csdnimg.cn/8b06006fb9cf4c35aa9e8d019b4bf085.png)\n\n## 案例五\n\n**不同索引尝试**\n\n```sql\nselect id from goods_info where id > ? and activity_id = ? and goods_switch in(?+) limit ?\nselect id from goods_info where id > 123991510 and activity_id = 0 and goods_switch in (2,3) limit 1000\n```\n\n通过执行计划可知，该语句走的是`activity_id`和主键的索引，但是这种命中率比较低，大量的数据被`goods_switch`筛掉\n\n**解决办法**：在不确定最优的索引的情况下，可以在测试环境下，分别添加不同的索引，观察执行计划及语句的执行时间。\n\n尝试强制走主键索引，效果不佳；尝试添加`activity_id_id`的联合索引，效果不佳；尝试添加`activity_id,goods_switch`的联合索引，问题解决！\n\n所以在不确定哪种索引是最优时，可以尝试建立不同的索引，观察语句在不同索引情况下的执行情况进行权衡。\n\n## 案例六\n\n**MySQL选错索引**\n\n```sql\nselect * from goods_info\nwhere goods_source = ? and goods_switch != ? and id > ? order by id limit ?\n\nselect * from goods_info  \nwhere goods_source = 2 and goods_switch != 8 and id > 12395070 order by id limit 1000\n```\n\n这条语句从语句本身猜测使用的是主键索引，但是查看该语句的执行计划，发现走的索引是`idx_goods_source`，即走了`goods_source`的单列索引！\n\n**解决办法**：修改SQL语句，强制走主键索引，查看执行计划，走了主键索引，查询时间大大降低。\n\n正常情况下MySQL会选择最优的索引，但是有时候也会选错，MySQL的优化器会依据扫描行数、是否排序，索引区分度来选择最优的索引，并且扫描行数不一定完成准确，只是MySQL的一个预估值\n\n# 总结\n\n**慢查询优化是一个长期的过程，长期有耐心！**\n\n# 最后\n\n**写文章很花时间，喜欢的话，希望帮忙点赞，转发下哈，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，获得免费电子书籍\n\n参考书籍：\n\n- 高性能MySQL","slug":"公众号文章/慢查询","published":1,"date":"2022-02-14T02:21:47.121Z","updated":"2022-02-14T02:32:26.548Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwix00f4fhji2qdr7wp6","content":"<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>喜欢的话，之后会分享更多系列文章！</p>\n<p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<ul>\n<li><p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n</li>\n<li><p>公众号后台回复666，可以获得免费电子书籍</p>\n</li>\n</ul>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前几天帮公司解决线上慢SQL告警问题，遇到了几个case。</p>\n<p>下面我会结合case案例分析自己这段时间在工作上遇到的慢查询谈谈数据库如何优化慢查询。</p>\n<p>一般我们遇到的慢sql都是索引没有正确使用导致的，所以我先介绍下索引相关知识</p>\n<h1 id=\"索引介绍\"><a href=\"#索引介绍\" class=\"headerlink\" title=\"索引介绍\"></a>索引介绍</h1><p><strong>索引概念</strong></p>\n<p>排好序的快速查找的数据结构（我们平时说的索引，如果没有特别指明，都是指B树，其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认使用的都是B+树索引，除B+树这种类型的索引外还有哈希索引等）</p>\n<p><strong>索引优缺点</strong></p>\n<p>优点：</p>\n<ul>\n<li>查找 ：提高数据检索效率，降低IO成本。</li>\n<li>排序：通过索引对数据进行排序，降低排序成本，降低cpu消耗</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向索引的记录，所以索引列也需要占空间。</li>\n<li>更新表时（insert、update、delete）不仅要保存数据还要更新保存索引文件新添加的索引列。</li>\n</ul>\n<p><strong>索引分类</strong></p>\n<ul>\n<li>单值索引（单列索引）：一个索引只包含单个列，一个表中可以有多个单列索引。</li>\n<li>唯一索引：索引列必须唯一，但可以允许有空值</li>\n<li>复合索引：一个索引包含多个列</li>\n</ul>\n<p><strong>索引结构</strong></p>\n<ul>\n<li>BTree索引</li>\n<li>Hash索引</li>\n<li>full-text全文检索</li>\n<li>R-Tree索引</li>\n</ul>\n<p><strong>哪些情况要建索引</strong></p>\n<ul>\n<li>主键自动建主键索引</li>\n<li>频繁作为查询条件的字段应该创建索引</li>\n<li>查询中与其他表关联的字段，外键关系建立索引</li>\n<li>在高并发下倾向建立组合索引</li>\n<li>查询中的排序字段，排序字段若通过索引去访问将大大提高排序速度</li>\n<li>查询中统计或者分组的数据</li>\n</ul>\n<p><strong>哪些情况不适合建索引</strong></p>\n<ul>\n<li>频繁更新的字段</li>\n<li>where条件用不到的字段不创建索引</li>\n<li>表记录太少</li>\n<li>经常增删改的表</li>\n<li>数据重复太多的字段，为它建索引意义不大（假如一个表有10万，有一个字段只有T和F两种值，每个值的分布概率大约只有50%，那么对这个字段的建索引一般不会提高查询效率，索引的选择性是指索引列的不同值数据与表中索引记录的比，，如果一个表中有2000条记录，表中索引列的不同值记录有1980个，这个索引的选择性为<code>1980/2000=0.99</code>，如果索引项越接近1，这个索引效率越高）</li>\n</ul>\n<p><strong>explain字段分析</strong></p>\n<p>explain是排查慢sql的一种最常用的手段</p>\n<pre><code class=\"sql\">mysql&gt; EXPLAIN SELECT 1;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/cc04a8197a314065b59e38ff179d37db.png\"></p>\n<p>id：表示select子句或者操作的顺序</p>\n<ul>\n<li>id相同：执行顺序自上而下</li>\n<li>id不同：id值越大优先级越高，越先被执行</li>\n<li>id相同不同：id越大越先执行，相同的自上而下执行</li>\n</ul>\n<p>select_type：主要是区分普通查询、联合查询、子查询等。</p>\n<ul>\n<li>SIMPLE：简单的select查询，不包含子查询与union</li>\n<li>PRIMARY：查询中包含复杂的子部分，最外层会被标记为primary</li>\n<li>SUBQUERY：在select或者where列表中包含了子查询</li>\n<li>DERIVED：在from列表中包含的子查询衍生表</li>\n<li>UNION：若第二个select出现在union之后，则被标记为union</li>\n<li>UNION RESESULT：从union表获取结果的select</li>\n</ul>\n<p>table：这一行数据是哪个表的数据</p>\n<p>type：查询中使用了何种类型</p>\n<p><strong>结果值从最好到最坏：system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;all</strong></p>\n<ul>\n<li>一般来说，得保证查询至少达到range级别，最好能到达ref</li>\n<li>system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</li>\n<li>const：表示通过索引一次就能够找到</li>\n<li>eq_ref:唯一性索引扫描，对于每个索引键，表示只有一条记录与之匹配，常见于主键或唯一索引扫描</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行</li>\n<li>range：只检索给定范围的行，使用一个索引来选择行，一般就是在where语句中出现了between、&lt;、&gt;、in等的查询</li>\n<li>index：index比all快，因为index是从索引中读取，all是从硬盘中读取</li>\n<li>all：遍历全表才能找到</li>\n</ul>\n<p>possible_key：显示可能应用在这张表中的索引，但实际上不一定用到</p>\n<p>key：实际上使用的索引，如果没有则为null</p>\n<p>key_len：表示索引中使用的字节数（可能使用的，不是实际的），可通过该列查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好</p>\n<p>ref：显示索引的哪一列被用到，如果可能的话是一个常数，哪些常量被用于查找索引列上的值</p>\n<p>rows：大致估算找出所需的记录要读取的行数</p>\n<p>Extra：包含不适合在其他列中显示，但十分重要的的额外信息</p>\n<ul>\n<li>Using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，mysql中无法利用索引完成的排序成为文件排序</li>\n<li>Using temporary 使了用临时表保存中间结果，mysql在对查询结果排序时使用了临时表，常见于排序order by 和分组查询group by</li>\n<li>Using index 表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率高</li>\n<li>Using where 表明使用了where进行过滤</li>\n<li>Using join buffer 使用了连接缓存</li>\n<li>impossible where 如果where子句的值总是false，不能用来获取任何元组</li>\n<li>select table optimized away 在没有group by子句的情况下，基于索引优化min&#x2F;max操作或者对于myisam存储引擎优化<code>count(*)</code>操作，不必等到执行阶段再进行计算</li>\n</ul>\n<p><strong>更详细的内容，请看我之前的文章：</strong></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect\">最完整的Explain总结，SQL优化不再困难</a></p>\n<p>最完整的Explain总结，SQL优化不再困难</p>\n<p><strong>索引失效</strong></p>\n<ul>\n<li>应该尽量全值匹配</li>\n<li>复合最佳左前缀法则（<strong>第一个索引不能掉，中间不能断开</strong>）</li>\n<li>不在索引列上做任何操作（计算、函数、类型转换）会导致索引失效而转向全表扫描</li>\n<li>存储存引擎不能使用索引中范围条件右边的列</li>\n<li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少<code>select*</code></li>\n<li>mysql在使用不等于(!&#x3D;或者&lt;&gt;)的时候无法使用索引会导致全表扫描</li>\n<li>is null，is not null也会无法使用索引</li>\n<li>like以统配符开头</li>\n<li>字符串不加单引号</li>\n<li>少用or</li>\n</ul>\n<p><strong>order by优化</strong></p>\n<ul>\n<li>避免filesort，尽量在索引上进行排序，遵照最佳左前缀原则</li>\n</ul>\n<p>filesort有两种排序：</p>\n<ul>\n<li><p>双路排序：两次磁盘扫描</p>\n</li>\n<li><p>单路排序：一次性读取保存在内存中，没拉完的数据再次拉</p>\n</li>\n<li><p>单路排序总体好于双路排序</p>\n</li>\n<li><p>优化策略：1、增大<code>sort_buffer_size</code>参数的设置，2、增大<code>max_length_for_sort_data</code>参数的设置，尽可能一次拿到内存</p>\n</li>\n</ul>\n<h1 id=\"Case分析\"><a href=\"#Case分析\" class=\"headerlink\" title=\"Case分析\"></a>Case分析</h1><h2 id=\"案例一\"><a href=\"#案例一\" class=\"headerlink\" title=\"案例一\"></a>案例一</h2><p><strong>in中参数太多</strong></p>\n<pre><code class=\"sql\">select * from goods_info where goods_status = ? and id in(11,22,33......)\n</code></pre>\n<p>in中id数据量比较多，导致查询的数据量比较大，这是一个比较常见的慢查询类型，并且往往在业务数据量比较少的时候这条语句不是慢查；</p>\n<p>因为参数传进一个List集合，当参数比较多的时候，可以采用在业务层把List集合拆分为多个长度较小的集合，分多次查询，具体每一次拆长度为多少，可能需要具体根据业务及数据量进行评估</p>\n<p><strong>我的解决办法</strong>：业务代码增加拆分集合操作，<code>LIMIT_SIZE</code>设置为1000</p>\n<pre><code class=\"sql\">List&lt;List&lt;Integer&gt;&gt; partitionGoodsIdList = Lists.partition(goodsIdList, LIMIT_SIZE);\n</code></pre>\n<p>当SQL的查询参数过多，我觉得可以考虑使用上述拆分的方式</p>\n<h2 id=\"案例二\"><a href=\"#案例二\" class=\"headerlink\" title=\"案例二\"></a>案例二</h2><p><strong>返回的查询结果过多</strong></p>\n<pre><code class=\"sql\">select from goods where goods_status = ? and poi_id = ?\n</code></pre>\n<p><strong>解决办法</strong>：将SQL修改为分页查询，并在业务代码上修改为分页查询，修改后的SQL语句如下：</p>\n<pre><code class=\"sql\">select from goods where goods_status = 1 and poi_id = 11 and goods_id &gt; 22 order by goods_id limit 2000\n</code></pre>\n<p>通过分页的方式可以降低数据量，避免慢查询，但是会从而导致一次查询请求，增加为多次查询请求，对于limit的大小需要谨慎评估</p>\n<h2 id=\"案例三\"><a href=\"#案例三\" class=\"headerlink\" title=\"案例三\"></a>案例三</h2><p><strong>order by慢查询</strong></p>\n<pre><code class=\"sql\">SELECT * FROM order FORCE INDEX (orderId)  WHERE userId = 11 AND status IN (0,22) ORDER BY id ASC ;\n</code></pre>\n<p>该SQL由于强制<strong>指定了使用orderId索引，但条件中并没有orderId</strong>，导致产生全表扫描（type: ALL）；</p>\n<p>如下为问题SQL的执行计划：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e1e989057fdc444a8ca820344ca45e4a.png\"></p>\n<p>直接原因是最终传给SQL查询函数的参数，orderId没有加入where子句，但forceindex一直生效</p>\n<h2 id=\"案例四\"><a href=\"#案例四\" class=\"headerlink\" title=\"案例四\"></a>案例四</h2><p><strong>join慢查询</strong></p>\n<pre><code class=\"sql\">select * from useract join userinfo order by useracct.id desc limit 11;\n</code></pre>\n<p>对sql进行explain可以发现，因为忘写了join的on条件，这是扫全表sql，如下图：</p>\n<p>我们首先看type级别两个表的级别都是ALL，说明该条语句没有用到索引，做了全表扫描是最差的情况</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d546f9f290bc45c2a4cfe160d7fb410d.png\"></p>\n<p>优化：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8b06006fb9cf4c35aa9e8d019b4bf085.png\"></p>\n<h2 id=\"案例五\"><a href=\"#案例五\" class=\"headerlink\" title=\"案例五\"></a>案例五</h2><p><strong>不同索引尝试</strong></p>\n<pre><code class=\"sql\">select id from goods_info where id &gt; ? and activity_id = ? and goods_switch in(?+) limit ?\nselect id from goods_info where id &gt; 123991510 and activity_id = 0 and goods_switch in (2,3) limit 1000\n</code></pre>\n<p>通过执行计划可知，该语句走的是<code>activity_id</code>和主键的索引，但是这种命中率比较低，大量的数据被<code>goods_switch</code>筛掉</p>\n<p><strong>解决办法</strong>：在不确定最优的索引的情况下，可以在测试环境下，分别添加不同的索引，观察执行计划及语句的执行时间。</p>\n<p>尝试强制走主键索引，效果不佳；尝试添加<code>activity_id_id</code>的联合索引，效果不佳；尝试添加<code>activity_id,goods_switch</code>的联合索引，问题解决！</p>\n<p>所以在不确定哪种索引是最优时，可以尝试建立不同的索引，观察语句在不同索引情况下的执行情况进行权衡。</p>\n<h2 id=\"案例六\"><a href=\"#案例六\" class=\"headerlink\" title=\"案例六\"></a>案例六</h2><p><strong>MySQL选错索引</strong></p>\n<pre><code class=\"sql\">select * from goods_info\nwhere goods_source = ? and goods_switch != ? and id &gt; ? order by id limit ?\n\nselect * from goods_info  \nwhere goods_source = 2 and goods_switch != 8 and id &gt; 12395070 order by id limit 1000\n</code></pre>\n<p>这条语句从语句本身猜测使用的是主键索引，但是查看该语句的执行计划，发现走的索引是<code>idx_goods_source</code>，即走了<code>goods_source</code>的单列索引！</p>\n<p><strong>解决办法</strong>：修改SQL语句，强制走主键索引，查看执行计划，走了主键索引，查询时间大大降低。</p>\n<p>正常情况下MySQL会选择最优的索引，但是有时候也会选错，MySQL的优化器会依据扫描行数、是否排序，索引区分度来选择最优的索引，并且扫描行数不一定完成准确，只是MySQL的一个预估值</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>慢查询优化是一个长期的过程，长期有耐心！</strong></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>写文章很花时间，喜欢的话，希望帮忙点赞，转发下哈，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，获得免费电子书籍</p>\n<p>参考书籍：</p>\n<ul>\n<li>高性能MySQL</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>喜欢的话，之后会分享更多系列文章！</p>\n<p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<ul>\n<li><p>微信搜索：月伴飞鱼，交个朋友，进面试交流群</p>\n</li>\n<li><p>公众号后台回复666，可以获得免费电子书籍</p>\n</li>\n</ul>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>前几天帮公司解决线上慢SQL告警问题，遇到了几个case。</p>\n<p>下面我会结合case案例分析自己这段时间在工作上遇到的慢查询谈谈数据库如何优化慢查询。</p>\n<p>一般我们遇到的慢sql都是索引没有正确使用导致的，所以我先介绍下索引相关知识</p>\n<h1 id=\"索引介绍\"><a href=\"#索引介绍\" class=\"headerlink\" title=\"索引介绍\"></a>索引介绍</h1><p><strong>索引概念</strong></p>\n<p>排好序的快速查找的数据结构（我们平时说的索引，如果没有特别指明，都是指B树，其中聚集索引、次要索引、覆盖索引、复合索引、前缀索引、唯一索引默认使用的都是B+树索引，除B+树这种类型的索引外还有哈希索引等）</p>\n<p><strong>索引优缺点</strong></p>\n<p>优点：</p>\n<ul>\n<li>查找 ：提高数据检索效率，降低IO成本。</li>\n<li>排序：通过索引对数据进行排序，降低排序成本，降低cpu消耗</li>\n</ul>\n<p>缺点：</p>\n<ul>\n<li>实际上索引也是一张表，该表保存了主键与索引字段，并指向索引的记录，所以索引列也需要占空间。</li>\n<li>更新表时（insert、update、delete）不仅要保存数据还要更新保存索引文件新添加的索引列。</li>\n</ul>\n<p><strong>索引分类</strong></p>\n<ul>\n<li>单值索引（单列索引）：一个索引只包含单个列，一个表中可以有多个单列索引。</li>\n<li>唯一索引：索引列必须唯一，但可以允许有空值</li>\n<li>复合索引：一个索引包含多个列</li>\n</ul>\n<p><strong>索引结构</strong></p>\n<ul>\n<li>BTree索引</li>\n<li>Hash索引</li>\n<li>full-text全文检索</li>\n<li>R-Tree索引</li>\n</ul>\n<p><strong>哪些情况要建索引</strong></p>\n<ul>\n<li>主键自动建主键索引</li>\n<li>频繁作为查询条件的字段应该创建索引</li>\n<li>查询中与其他表关联的字段，外键关系建立索引</li>\n<li>在高并发下倾向建立组合索引</li>\n<li>查询中的排序字段，排序字段若通过索引去访问将大大提高排序速度</li>\n<li>查询中统计或者分组的数据</li>\n</ul>\n<p><strong>哪些情况不适合建索引</strong></p>\n<ul>\n<li>频繁更新的字段</li>\n<li>where条件用不到的字段不创建索引</li>\n<li>表记录太少</li>\n<li>经常增删改的表</li>\n<li>数据重复太多的字段，为它建索引意义不大（假如一个表有10万，有一个字段只有T和F两种值，每个值的分布概率大约只有50%，那么对这个字段的建索引一般不会提高查询效率，索引的选择性是指索引列的不同值数据与表中索引记录的比，，如果一个表中有2000条记录，表中索引列的不同值记录有1980个，这个索引的选择性为<code>1980/2000=0.99</code>，如果索引项越接近1，这个索引效率越高）</li>\n</ul>\n<p><strong>explain字段分析</strong></p>\n<p>explain是排查慢sql的一种最常用的手段</p>\n<pre><code class=\"sql\">mysql&gt; EXPLAIN SELECT 1;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/cc04a8197a314065b59e38ff179d37db.png\"></p>\n<p>id：表示select子句或者操作的顺序</p>\n<ul>\n<li>id相同：执行顺序自上而下</li>\n<li>id不同：id值越大优先级越高，越先被执行</li>\n<li>id相同不同：id越大越先执行，相同的自上而下执行</li>\n</ul>\n<p>select_type：主要是区分普通查询、联合查询、子查询等。</p>\n<ul>\n<li>SIMPLE：简单的select查询，不包含子查询与union</li>\n<li>PRIMARY：查询中包含复杂的子部分，最外层会被标记为primary</li>\n<li>SUBQUERY：在select或者where列表中包含了子查询</li>\n<li>DERIVED：在from列表中包含的子查询衍生表</li>\n<li>UNION：若第二个select出现在union之后，则被标记为union</li>\n<li>UNION RESESULT：从union表获取结果的select</li>\n</ul>\n<p>table：这一行数据是哪个表的数据</p>\n<p>type：查询中使用了何种类型</p>\n<p><strong>结果值从最好到最坏：system&gt;const&gt;eq_ref&gt;ref&gt;fulltext&gt;ref_or_null&gt;index_merge&gt;unique_subquery&gt;index_subquery&gt;range&gt;index&gt;all</strong></p>\n<ul>\n<li>一般来说，得保证查询至少达到range级别，最好能到达ref</li>\n<li>system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现</li>\n<li>const：表示通过索引一次就能够找到</li>\n<li>eq_ref:唯一性索引扫描，对于每个索引键，表示只有一条记录与之匹配，常见于主键或唯一索引扫描</li>\n<li>ref：非唯一性索引扫描，返回匹配某个单独值的所有行</li>\n<li>range：只检索给定范围的行，使用一个索引来选择行，一般就是在where语句中出现了between、&lt;、&gt;、in等的查询</li>\n<li>index：index比all快，因为index是从索引中读取，all是从硬盘中读取</li>\n<li>all：遍历全表才能找到</li>\n</ul>\n<p>possible_key：显示可能应用在这张表中的索引，但实际上不一定用到</p>\n<p>key：实际上使用的索引，如果没有则为null</p>\n<p>key_len：表示索引中使用的字节数（可能使用的，不是实际的），可通过该列查询中使用的索引的长度，在不损失精确性的情况下，长度越短越好</p>\n<p>ref：显示索引的哪一列被用到，如果可能的话是一个常数，哪些常量被用于查找索引列上的值</p>\n<p>rows：大致估算找出所需的记录要读取的行数</p>\n<p>Extra：包含不适合在其他列中显示，但十分重要的的额外信息</p>\n<ul>\n<li>Using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取，mysql中无法利用索引完成的排序成为文件排序</li>\n<li>Using temporary 使了用临时表保存中间结果，mysql在对查询结果排序时使用了临时表，常见于排序order by 和分组查询group by</li>\n<li>Using index 表示相应的select操作中使用了覆盖索引，避免访问了表的数据行，效率高</li>\n<li>Using where 表明使用了where进行过滤</li>\n<li>Using join buffer 使用了连接缓存</li>\n<li>impossible where 如果where子句的值总是false，不能用来获取任何元组</li>\n<li>select table optimized away 在没有group by子句的情况下，基于索引优化min&#x2F;max操作或者对于myisam存储引擎优化<code>count(*)</code>操作，不必等到执行阶段再进行计算</li>\n</ul>\n<p><strong>更详细的内容，请看我之前的文章：</strong></p>\n<p><a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484391&idx=1&sn=c478efeed839831a5dc806536029f2b7&scene=21#wechat_redirect\">最完整的Explain总结，SQL优化不再困难</a></p>\n<p>最完整的Explain总结，SQL优化不再困难</p>\n<p><strong>索引失效</strong></p>\n<ul>\n<li>应该尽量全值匹配</li>\n<li>复合最佳左前缀法则（<strong>第一个索引不能掉，中间不能断开</strong>）</li>\n<li>不在索引列上做任何操作（计算、函数、类型转换）会导致索引失效而转向全表扫描</li>\n<li>存储存引擎不能使用索引中范围条件右边的列</li>\n<li>尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少<code>select*</code></li>\n<li>mysql在使用不等于(!&#x3D;或者&lt;&gt;)的时候无法使用索引会导致全表扫描</li>\n<li>is null，is not null也会无法使用索引</li>\n<li>like以统配符开头</li>\n<li>字符串不加单引号</li>\n<li>少用or</li>\n</ul>\n<p><strong>order by优化</strong></p>\n<ul>\n<li>避免filesort，尽量在索引上进行排序，遵照最佳左前缀原则</li>\n</ul>\n<p>filesort有两种排序：</p>\n<ul>\n<li><p>双路排序：两次磁盘扫描</p>\n</li>\n<li><p>单路排序：一次性读取保存在内存中，没拉完的数据再次拉</p>\n</li>\n<li><p>单路排序总体好于双路排序</p>\n</li>\n<li><p>优化策略：1、增大<code>sort_buffer_size</code>参数的设置，2、增大<code>max_length_for_sort_data</code>参数的设置，尽可能一次拿到内存</p>\n</li>\n</ul>\n<h1 id=\"Case分析\"><a href=\"#Case分析\" class=\"headerlink\" title=\"Case分析\"></a>Case分析</h1><h2 id=\"案例一\"><a href=\"#案例一\" class=\"headerlink\" title=\"案例一\"></a>案例一</h2><p><strong>in中参数太多</strong></p>\n<pre><code class=\"sql\">select * from goods_info where goods_status = ? and id in(11,22,33......)\n</code></pre>\n<p>in中id数据量比较多，导致查询的数据量比较大，这是一个比较常见的慢查询类型，并且往往在业务数据量比较少的时候这条语句不是慢查；</p>\n<p>因为参数传进一个List集合，当参数比较多的时候，可以采用在业务层把List集合拆分为多个长度较小的集合，分多次查询，具体每一次拆长度为多少，可能需要具体根据业务及数据量进行评估</p>\n<p><strong>我的解决办法</strong>：业务代码增加拆分集合操作，<code>LIMIT_SIZE</code>设置为1000</p>\n<pre><code class=\"sql\">List&lt;List&lt;Integer&gt;&gt; partitionGoodsIdList = Lists.partition(goodsIdList, LIMIT_SIZE);\n</code></pre>\n<p>当SQL的查询参数过多，我觉得可以考虑使用上述拆分的方式</p>\n<h2 id=\"案例二\"><a href=\"#案例二\" class=\"headerlink\" title=\"案例二\"></a>案例二</h2><p><strong>返回的查询结果过多</strong></p>\n<pre><code class=\"sql\">select from goods where goods_status = ? and poi_id = ?\n</code></pre>\n<p><strong>解决办法</strong>：将SQL修改为分页查询，并在业务代码上修改为分页查询，修改后的SQL语句如下：</p>\n<pre><code class=\"sql\">select from goods where goods_status = 1 and poi_id = 11 and goods_id &gt; 22 order by goods_id limit 2000\n</code></pre>\n<p>通过分页的方式可以降低数据量，避免慢查询，但是会从而导致一次查询请求，增加为多次查询请求，对于limit的大小需要谨慎评估</p>\n<h2 id=\"案例三\"><a href=\"#案例三\" class=\"headerlink\" title=\"案例三\"></a>案例三</h2><p><strong>order by慢查询</strong></p>\n<pre><code class=\"sql\">SELECT * FROM order FORCE INDEX (orderId)  WHERE userId = 11 AND status IN (0,22) ORDER BY id ASC ;\n</code></pre>\n<p>该SQL由于强制<strong>指定了使用orderId索引，但条件中并没有orderId</strong>，导致产生全表扫描（type: ALL）；</p>\n<p>如下为问题SQL的执行计划：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/e1e989057fdc444a8ca820344ca45e4a.png\"></p>\n<p>直接原因是最终传给SQL查询函数的参数，orderId没有加入where子句，但forceindex一直生效</p>\n<h2 id=\"案例四\"><a href=\"#案例四\" class=\"headerlink\" title=\"案例四\"></a>案例四</h2><p><strong>join慢查询</strong></p>\n<pre><code class=\"sql\">select * from useract join userinfo order by useracct.id desc limit 11;\n</code></pre>\n<p>对sql进行explain可以发现，因为忘写了join的on条件，这是扫全表sql，如下图：</p>\n<p>我们首先看type级别两个表的级别都是ALL，说明该条语句没有用到索引，做了全表扫描是最差的情况</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d546f9f290bc45c2a4cfe160d7fb410d.png\"></p>\n<p>优化：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8b06006fb9cf4c35aa9e8d019b4bf085.png\"></p>\n<h2 id=\"案例五\"><a href=\"#案例五\" class=\"headerlink\" title=\"案例五\"></a>案例五</h2><p><strong>不同索引尝试</strong></p>\n<pre><code class=\"sql\">select id from goods_info where id &gt; ? and activity_id = ? and goods_switch in(?+) limit ?\nselect id from goods_info where id &gt; 123991510 and activity_id = 0 and goods_switch in (2,3) limit 1000\n</code></pre>\n<p>通过执行计划可知，该语句走的是<code>activity_id</code>和主键的索引，但是这种命中率比较低，大量的数据被<code>goods_switch</code>筛掉</p>\n<p><strong>解决办法</strong>：在不确定最优的索引的情况下，可以在测试环境下，分别添加不同的索引，观察执行计划及语句的执行时间。</p>\n<p>尝试强制走主键索引，效果不佳；尝试添加<code>activity_id_id</code>的联合索引，效果不佳；尝试添加<code>activity_id,goods_switch</code>的联合索引，问题解决！</p>\n<p>所以在不确定哪种索引是最优时，可以尝试建立不同的索引，观察语句在不同索引情况下的执行情况进行权衡。</p>\n<h2 id=\"案例六\"><a href=\"#案例六\" class=\"headerlink\" title=\"案例六\"></a>案例六</h2><p><strong>MySQL选错索引</strong></p>\n<pre><code class=\"sql\">select * from goods_info\nwhere goods_source = ? and goods_switch != ? and id &gt; ? order by id limit ?\n\nselect * from goods_info  \nwhere goods_source = 2 and goods_switch != 8 and id &gt; 12395070 order by id limit 1000\n</code></pre>\n<p>这条语句从语句本身猜测使用的是主键索引，但是查看该语句的执行计划，发现走的索引是<code>idx_goods_source</code>，即走了<code>goods_source</code>的单列索引！</p>\n<p><strong>解决办法</strong>：修改SQL语句，强制走主键索引，查看执行计划，走了主键索引，查询时间大大降低。</p>\n<p>正常情况下MySQL会选择最优的索引，但是有时候也会选错，MySQL的优化器会依据扫描行数、是否排序，索引区分度来选择最优的索引，并且扫描行数不一定完成准确，只是MySQL的一个预估值</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p><strong>慢查询优化是一个长期的过程，长期有耐心！</strong></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>写文章很花时间，喜欢的话，希望帮忙点赞，转发下哈，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，获得免费电子书籍</p>\n<p>参考书籍：</p>\n<ul>\n<li>高性能MySQL</li>\n</ul>\n"},{"title":"散列表","_content":"\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢！**\n\n![](https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png)\n\n# 前言\n\n假设现在有一篇很长的文档，如果希望统计文档中每个单词在文档中出现了多少次，应该怎么做呢？\n\n很简单！\n\n我们可以建一个HashMap，以String类型为Key，Int类型为Value；\n\n* 遍历文档中的每个单词 `word` ，找到键值对中key为 `word` 的项，并对相关的value进行自增操作。\n\n* 如果该key= `word` 的项在 HashMap中不存在，我们就插入一个`(word,1)`的项表示新增。\n\n* 这样每组键值对表示的就是某个单词对应的数量，等整个文档遍历完成，我们就可以得到每个单词的数量了。\n\n简单实现下，代码示例如下：\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\npublic class Test {\n    public static void main(String[] args) {\n        Map map = new HashMap<>();\n        String doc = \"yue ban fei yu\";\n        String[] words = doc.split(\" \");\n        for (String s : words) {\n            if (!map.containsKey(s)) {\n                map.put(s, 1);\n            } else {\n                map.put(s, map.get(s) + 1);\n            }\n        }\n        System.out.println(map);\n    }\n}\n```\n\n那HashMap是怎么做到高效统计单词对应数量的？我们下面会逐步来研究一下！\n\n> 首先我们先来看看如果只统计某一个单词的数量？\n\n只需要开一个变量，同样遍历所有单词，遇到和目标单词一样的，才对这个变量进行自增操作；\n\n* 等遍历完成，我们就可以得到该单词的数量了。\n\n* 我们可以把所有可能出现的单词都列出来，每个单词，单独用一个变量去统计它出现的数量，遍历所有单词，判断当前单词应该被累计到哪个变量中。\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\npublic class Main {\n    public static void main(String[] args) {\n        int[] cnt = new int[20000];\n        String doc = \"a b c d\";\n        String[] words = doc.split(\" \");\n        int a = 0;\n        int b = 0;\n        int c = 0;\n        int d = 0;\n        \n        for (String s : words) {\n           if (s == \"a\") a++;\n           if (s == \"b\") b++;\n           if (s == \"c\") c++;\n           if (s == \"d\") d++;   \n        }\n    }\n}\n```\n\n注意：这样的代码显然有两个很大的问题：\n\n1. 对单词和计数器的映射关系是通过一堆if-else写死的，维护性很差；\n2. 必须已知所有可能出现的单词，如果遇到一个新的单词，就没有办法处理它了。\n\n# 优化1\n\n我们可以开一个数组去维护计数器。\n\n> 具体做法就是，给每个单词编个号，直接用编号对应下标的数组元素作为它的计数器就好啦。\n\n我们可以建立两个数组：\n\n* 第一个数组用于存放所有单词，数组下标就是单词编号了，我们称之为字典数组；\n\n* 第二个数组用于存放每个单词对应的计数器，我们称之为计数数组。\n\n每遇到一个新的单词，都遍历一遍字典数组，如果没有出现过，我们就将当前单词插入到字典数组结尾。\n\n这样做，整体的时间复杂度较高，还是不行。\n\n# 优化2\n\n优化方式：\n\n- 一种是我们维护一个有序的数据结构，让比较和插入的过程更加高效，而不是需要遍历每一个元素判断逐一判断。\n- 另一种思路就是我们是否能寻找到一种直接基于字符串快速计算出编号的方式，并将这个编号映射到一个可以在O(1)时间内基于下标访问的数组中。\n\n以单词为例，英文单词的每个字母只可能是 a-z。\n\n我们用0表示a、1表示b，以此类推，用25表示z，然后将一个单词看成一个26进制的数字即可。\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\npublic class Main {\n    public static void main(String[] args) {\n        int[] cnt = new int[20000];\n        String doc = \"a b c d\";\n        String[] words = doc.split(\" \");\n        for (String s : words) {\n            int tmp = 0;\n            for (char c: s.toCharArray()) {\n                tmp *= 26;\n                tmp += (c - 'a');\n            }\n            cnt[tmp]++;\n        }\n        String target = \"a\";\n        int hash = 0;\n        for (char c: target.toCharArray()) {\n            hash *= 26;\n            hash += c - 'a';\n        }\n        System.out.println(cnt[hash]);\n    }\n}\n```\n\n这样我们统计N个单词出现数量的时候，整体只需要O(N)的复杂度，相比于原来的需要遍历字典的做法就明显高效的多。\n\n> 这其实就是散列的思想了。\n\n# 优化3\n\n使用散列！\n\n散列函数的本质，就是**将一个更大且可能不连续空间（比如所有的单词），映射到一个空间有限的数组里，从而借用数组基于下标O(1)快速随机访问数组元素的能力**。\n\n但设计一个合理的散列函数是一个非常难的事情。\n\n* 比如对26进制的哈希值再进行一次对大质数取mod的运算，只有这样才能用比较有限的计数数组空间去表示整个哈希表。\n\n取了mod之后，我们很快就会发现，现在可能出现一种情况，把两个不同的单词用26进制表示并取模之后，得到的值很可能是一样的。\n\n这个问题被称之为**哈希碰撞**。\n\n# 如何实现\n\n最后我们考虑一下散列函数到底需要怎么设计。\n\n以JDK（JDK14）的HashMap为例：\n\n* 主要实现在 `java.util` 下的 `HashMap` 中，这是一个最简单的不考虑并发的、基于散列的Map实现。\n\n找到其中用于计算哈希值的hash方法：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n可以发现就是对`key.hashCode()`进行了一次特别的位运算。\n\n**hashcode方法**\n\n在Java中每个对象生成时都会产生一个对应的hashcode。\n\n* 当然数据类型不同，hashcode的计算方式是不一样的，但一定会保证的是两个一样的对象，对应的hashcode也是一样的；\n\n所以在比较两个对象是否相等时，我们可以先比较hashcode是否一致，如果不一致，就不需要继续调用equals，大大降低了比较对象相等的代价。\n\n我们就一起来看看JDK中对String类型的hashcode是怎么计算的，我们进入 `java.lang` 包查看String类型的实现：\n\n```java\npublic int hashCode() {\n    // The hash or hashIsZero fields are subject to a benign data race,\n    // making it crucial to ensure that any observable result of the\n    // calculation in this method stays correct under any possible read of\n    // these fields. Necessary restrictions to allow this to be correct\n    // without explicit memory fences or similar concurrency primitives is\n    // that we can ever only write to one of these two fields for a given\n    // String instance, and that the computation is idempotent and derived\n    // from immutable state\n    int h = hash;\n    if (h == 0 && !hashIsZero) {\n        h = isLatin1() ? StringLatin1.hashCode(value)\n                       : StringUTF16.hashCode(value);\n        if (h == 0) {\n            hashIsZero = true;\n        } else {\n            hash = h;\n        }\n    }\n    return h;\n}\n```\n\nLatin和UTF16是两种字符串的编码格式，实现思路其实差不多，我们来看看`StringUTF16`中hashcode的实现：\n\n```java\npublic static int hashCode(byte[] value) {\n    int h = 0;\n    int length = value.length >> 1;\n    for (int i = 0; i < length; i++) {\n        h = 31 * h + getChar(value, i);\n    }\n    return h;\n}\n```\n\n其实就是对字符串逐位按照下面的方式进行计算，和展开成26进制的想法本质上是相似的。\n\n```\ns[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n```\n\n> 为什么选择了31？\n\n首先在各种哈希计算中，我们比较倾向使用奇素数进行乘法运算，而不是用偶数。\n\n因为用偶数，尤其是2的幂次，进行乘法，相当于直接对原来的数据进行移位运算；这样溢出的时候，部分位的信息就完全丢失了，可能增加哈希冲突的概率。\n\n为什么选择了31这个奇怪的数，这是因为计算机在进行移位运算要比普通乘法运算快得多，而`31*i`可以直接转化为`(i << 5)- i` ，这是一个性能比较好的乘法计算方式，现代的编译器都可以推理并自动完成相关的优化。\n\n> 具体可以参考《Effective Java》中的相关章节。\n\n**h>>>16**\n\n我们现在来看 `^ h >>> 16` 又是一个什么样的作用呢？\n\n> 它的意思是就是将h右移16位并进行异或操作，为什么要这么做呢？\n\n因为那个hash值计算出来这么大，那怎么把它连续地映射到一个小一点的连续数组空间呢？\n\n> 所以需要取模，我们需要将hash值对数组的大小进行一次取模。\n\n我们需要对2的幂次大小的数组进行一次取模计算。\n\n但对二的幂次取模相当于直接截取数字比较低的若干位，这在数组元素较少的时候，相当于只使用了数字比较低位的信息，而放弃了高位的信息，可能会增加冲突的概率。\n\n所以，JDK的代码引入了`^ h >>> 16` 这样的位运算，其实就是把高16位的信息叠加到了低16位，这样我们在取模的时候就可以用到高位的信息了。\n\n**如何处理哈希冲突呢？**\n\nJDK中采用的是开链法。\n\n哈希表内置数组中的每个槽位，存储的是一个链表，链表节点的值存放的就是需要存储的键值对。\n\n如果碰到哈希冲突，也就是两个不同的key映射到了数组中的同一个槽位，我们就将该元素直接放到槽位对应链表的尾部。\n\n# 总结一下\n\n**手写数据结构统计单词的数量正确的思路就是：**\n\n根据全文长度大概预估一下会有多少个单词，开一个数倍于它的数组，再设计一个合理的hash函数，把每个单词映射到数组的某个下标，用这个数组计数统计就好啦。\n\n当然在实际工程中，我们不会为每个场景都单独写一个这样的散列表实现，也不用自己去处理复杂的扩容场景。","source":"_posts/公众号文章/散列表.md","raw":"---\ntitle: 散列表\ncategories: \n- 公众号文章\n---\n\n文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢！**\n\n![](https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png)\n\n# 前言\n\n假设现在有一篇很长的文档，如果希望统计文档中每个单词在文档中出现了多少次，应该怎么做呢？\n\n很简单！\n\n我们可以建一个HashMap，以String类型为Key，Int类型为Value；\n\n* 遍历文档中的每个单词 `word` ，找到键值对中key为 `word` 的项，并对相关的value进行自增操作。\n\n* 如果该key= `word` 的项在 HashMap中不存在，我们就插入一个`(word,1)`的项表示新增。\n\n* 这样每组键值对表示的就是某个单词对应的数量，等整个文档遍历完成，我们就可以得到每个单词的数量了。\n\n简单实现下，代码示例如下：\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\npublic class Test {\n    public static void main(String[] args) {\n        Map map = new HashMap<>();\n        String doc = \"yue ban fei yu\";\n        String[] words = doc.split(\" \");\n        for (String s : words) {\n            if (!map.containsKey(s)) {\n                map.put(s, 1);\n            } else {\n                map.put(s, map.get(s) + 1);\n            }\n        }\n        System.out.println(map);\n    }\n}\n```\n\n那HashMap是怎么做到高效统计单词对应数量的？我们下面会逐步来研究一下！\n\n> 首先我们先来看看如果只统计某一个单词的数量？\n\n只需要开一个变量，同样遍历所有单词，遇到和目标单词一样的，才对这个变量进行自增操作；\n\n* 等遍历完成，我们就可以得到该单词的数量了。\n\n* 我们可以把所有可能出现的单词都列出来，每个单词，单独用一个变量去统计它出现的数量，遍历所有单词，判断当前单词应该被累计到哪个变量中。\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\npublic class Main {\n    public static void main(String[] args) {\n        int[] cnt = new int[20000];\n        String doc = \"a b c d\";\n        String[] words = doc.split(\" \");\n        int a = 0;\n        int b = 0;\n        int c = 0;\n        int d = 0;\n        \n        for (String s : words) {\n           if (s == \"a\") a++;\n           if (s == \"b\") b++;\n           if (s == \"c\") c++;\n           if (s == \"d\") d++;   \n        }\n    }\n}\n```\n\n注意：这样的代码显然有两个很大的问题：\n\n1. 对单词和计数器的映射关系是通过一堆if-else写死的，维护性很差；\n2. 必须已知所有可能出现的单词，如果遇到一个新的单词，就没有办法处理它了。\n\n# 优化1\n\n我们可以开一个数组去维护计数器。\n\n> 具体做法就是，给每个单词编个号，直接用编号对应下标的数组元素作为它的计数器就好啦。\n\n我们可以建立两个数组：\n\n* 第一个数组用于存放所有单词，数组下标就是单词编号了，我们称之为字典数组；\n\n* 第二个数组用于存放每个单词对应的计数器，我们称之为计数数组。\n\n每遇到一个新的单词，都遍历一遍字典数组，如果没有出现过，我们就将当前单词插入到字典数组结尾。\n\n这样做，整体的时间复杂度较高，还是不行。\n\n# 优化2\n\n优化方式：\n\n- 一种是我们维护一个有序的数据结构，让比较和插入的过程更加高效，而不是需要遍历每一个元素判断逐一判断。\n- 另一种思路就是我们是否能寻找到一种直接基于字符串快速计算出编号的方式，并将这个编号映射到一个可以在O(1)时间内基于下标访问的数组中。\n\n以单词为例，英文单词的每个字母只可能是 a-z。\n\n我们用0表示a、1表示b，以此类推，用25表示z，然后将一个单词看成一个26进制的数字即可。\n\n```java\nimport java.util.HashMap;\nimport java.util.Map;\npublic class Main {\n    public static void main(String[] args) {\n        int[] cnt = new int[20000];\n        String doc = \"a b c d\";\n        String[] words = doc.split(\" \");\n        for (String s : words) {\n            int tmp = 0;\n            for (char c: s.toCharArray()) {\n                tmp *= 26;\n                tmp += (c - 'a');\n            }\n            cnt[tmp]++;\n        }\n        String target = \"a\";\n        int hash = 0;\n        for (char c: target.toCharArray()) {\n            hash *= 26;\n            hash += c - 'a';\n        }\n        System.out.println(cnt[hash]);\n    }\n}\n```\n\n这样我们统计N个单词出现数量的时候，整体只需要O(N)的复杂度，相比于原来的需要遍历字典的做法就明显高效的多。\n\n> 这其实就是散列的思想了。\n\n# 优化3\n\n使用散列！\n\n散列函数的本质，就是**将一个更大且可能不连续空间（比如所有的单词），映射到一个空间有限的数组里，从而借用数组基于下标O(1)快速随机访问数组元素的能力**。\n\n但设计一个合理的散列函数是一个非常难的事情。\n\n* 比如对26进制的哈希值再进行一次对大质数取mod的运算，只有这样才能用比较有限的计数数组空间去表示整个哈希表。\n\n取了mod之后，我们很快就会发现，现在可能出现一种情况，把两个不同的单词用26进制表示并取模之后，得到的值很可能是一样的。\n\n这个问题被称之为**哈希碰撞**。\n\n# 如何实现\n\n最后我们考虑一下散列函数到底需要怎么设计。\n\n以JDK（JDK14）的HashMap为例：\n\n* 主要实现在 `java.util` 下的 `HashMap` 中，这是一个最简单的不考虑并发的、基于散列的Map实现。\n\n找到其中用于计算哈希值的hash方法：\n\n```java\nstatic final int hash(Object key) {\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n}\n```\n\n可以发现就是对`key.hashCode()`进行了一次特别的位运算。\n\n**hashcode方法**\n\n在Java中每个对象生成时都会产生一个对应的hashcode。\n\n* 当然数据类型不同，hashcode的计算方式是不一样的，但一定会保证的是两个一样的对象，对应的hashcode也是一样的；\n\n所以在比较两个对象是否相等时，我们可以先比较hashcode是否一致，如果不一致，就不需要继续调用equals，大大降低了比较对象相等的代价。\n\n我们就一起来看看JDK中对String类型的hashcode是怎么计算的，我们进入 `java.lang` 包查看String类型的实现：\n\n```java\npublic int hashCode() {\n    // The hash or hashIsZero fields are subject to a benign data race,\n    // making it crucial to ensure that any observable result of the\n    // calculation in this method stays correct under any possible read of\n    // these fields. Necessary restrictions to allow this to be correct\n    // without explicit memory fences or similar concurrency primitives is\n    // that we can ever only write to one of these two fields for a given\n    // String instance, and that the computation is idempotent and derived\n    // from immutable state\n    int h = hash;\n    if (h == 0 && !hashIsZero) {\n        h = isLatin1() ? StringLatin1.hashCode(value)\n                       : StringUTF16.hashCode(value);\n        if (h == 0) {\n            hashIsZero = true;\n        } else {\n            hash = h;\n        }\n    }\n    return h;\n}\n```\n\nLatin和UTF16是两种字符串的编码格式，实现思路其实差不多，我们来看看`StringUTF16`中hashcode的实现：\n\n```java\npublic static int hashCode(byte[] value) {\n    int h = 0;\n    int length = value.length >> 1;\n    for (int i = 0; i < length; i++) {\n        h = 31 * h + getChar(value, i);\n    }\n    return h;\n}\n```\n\n其实就是对字符串逐位按照下面的方式进行计算，和展开成26进制的想法本质上是相似的。\n\n```\ns[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n```\n\n> 为什么选择了31？\n\n首先在各种哈希计算中，我们比较倾向使用奇素数进行乘法运算，而不是用偶数。\n\n因为用偶数，尤其是2的幂次，进行乘法，相当于直接对原来的数据进行移位运算；这样溢出的时候，部分位的信息就完全丢失了，可能增加哈希冲突的概率。\n\n为什么选择了31这个奇怪的数，这是因为计算机在进行移位运算要比普通乘法运算快得多，而`31*i`可以直接转化为`(i << 5)- i` ，这是一个性能比较好的乘法计算方式，现代的编译器都可以推理并自动完成相关的优化。\n\n> 具体可以参考《Effective Java》中的相关章节。\n\n**h>>>16**\n\n我们现在来看 `^ h >>> 16` 又是一个什么样的作用呢？\n\n> 它的意思是就是将h右移16位并进行异或操作，为什么要这么做呢？\n\n因为那个hash值计算出来这么大，那怎么把它连续地映射到一个小一点的连续数组空间呢？\n\n> 所以需要取模，我们需要将hash值对数组的大小进行一次取模。\n\n我们需要对2的幂次大小的数组进行一次取模计算。\n\n但对二的幂次取模相当于直接截取数字比较低的若干位，这在数组元素较少的时候，相当于只使用了数字比较低位的信息，而放弃了高位的信息，可能会增加冲突的概率。\n\n所以，JDK的代码引入了`^ h >>> 16` 这样的位运算，其实就是把高16位的信息叠加到了低16位，这样我们在取模的时候就可以用到高位的信息了。\n\n**如何处理哈希冲突呢？**\n\nJDK中采用的是开链法。\n\n哈希表内置数组中的每个槽位，存储的是一个链表，链表节点的值存放的就是需要存储的键值对。\n\n如果碰到哈希冲突，也就是两个不同的key映射到了数组中的同一个槽位，我们就将该元素直接放到槽位对应链表的尾部。\n\n# 总结一下\n\n**手写数据结构统计单词的数量正确的思路就是：**\n\n根据全文长度大概预估一下会有多少个单词，开一个数倍于它的数组，再设计一个合理的hash函数，把每个单词映射到数组的某个下标，用这个数组计数统计就好啦。\n\n当然在实际工程中，我们不会为每个场景都单独写一个这样的散列表实现，也不用自己去处理复杂的扩容场景。","slug":"公众号文章/散列表","published":1,"date":"2022-03-13T14:50:44.032Z","updated":"2022-03-13T16:50:23.615Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwix00f5fhji5sj3d5jn","content":"<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢！</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>假设现在有一篇很长的文档，如果希望统计文档中每个单词在文档中出现了多少次，应该怎么做呢？</p>\n<p>很简单！</p>\n<p>我们可以建一个HashMap，以String类型为Key，Int类型为Value；</p>\n<ul>\n<li><p>遍历文档中的每个单词 <code>word</code> ，找到键值对中key为 <code>word</code> 的项，并对相关的value进行自增操作。</p>\n</li>\n<li><p>如果该key&#x3D; <code>word</code> 的项在 HashMap中不存在，我们就插入一个<code>(word,1)</code>的项表示新增。</p>\n</li>\n<li><p>这样每组键值对表示的就是某个单词对应的数量，等整个文档遍历完成，我们就可以得到每个单词的数量了。</p>\n</li>\n</ul>\n<p>简单实现下，代码示例如下：</p>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map map = new HashMap&lt;&gt;();\n        String doc = &quot;yue ban fei yu&quot;;\n        String[] words = doc.split(&quot; &quot;);\n        for (String s : words) &#123;\n            if (!map.containsKey(s)) &#123;\n                map.put(s, 1);\n            &#125; else &#123;\n                map.put(s, map.get(s) + 1);\n            &#125;\n        &#125;\n        System.out.println(map);\n    &#125;\n&#125;\n</code></pre>\n<p>那HashMap是怎么做到高效统计单词对应数量的？我们下面会逐步来研究一下！</p>\n<blockquote>\n<p>首先我们先来看看如果只统计某一个单词的数量？</p>\n</blockquote>\n<p>只需要开一个变量，同样遍历所有单词，遇到和目标单词一样的，才对这个变量进行自增操作；</p>\n<ul>\n<li><p>等遍历完成，我们就可以得到该单词的数量了。</p>\n</li>\n<li><p>我们可以把所有可能出现的单词都列出来，每个单词，单独用一个变量去统计它出现的数量，遍历所有单词，判断当前单词应该被累计到哪个变量中。</p>\n</li>\n</ul>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        int[] cnt = new int[20000];\n        String doc = &quot;a b c d&quot;;\n        String[] words = doc.split(&quot; &quot;);\n        int a = 0;\n        int b = 0;\n        int c = 0;\n        int d = 0;\n        \n        for (String s : words) &#123;\n           if (s == &quot;a&quot;) a++;\n           if (s == &quot;b&quot;) b++;\n           if (s == &quot;c&quot;) c++;\n           if (s == &quot;d&quot;) d++;   \n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>注意：这样的代码显然有两个很大的问题：</p>\n<ol>\n<li>对单词和计数器的映射关系是通过一堆if-else写死的，维护性很差；</li>\n<li>必须已知所有可能出现的单词，如果遇到一个新的单词，就没有办法处理它了。</li>\n</ol>\n<h1 id=\"优化1\"><a href=\"#优化1\" class=\"headerlink\" title=\"优化1\"></a>优化1</h1><p>我们可以开一个数组去维护计数器。</p>\n<blockquote>\n<p>具体做法就是，给每个单词编个号，直接用编号对应下标的数组元素作为它的计数器就好啦。</p>\n</blockquote>\n<p>我们可以建立两个数组：</p>\n<ul>\n<li><p>第一个数组用于存放所有单词，数组下标就是单词编号了，我们称之为字典数组；</p>\n</li>\n<li><p>第二个数组用于存放每个单词对应的计数器，我们称之为计数数组。</p>\n</li>\n</ul>\n<p>每遇到一个新的单词，都遍历一遍字典数组，如果没有出现过，我们就将当前单词插入到字典数组结尾。</p>\n<p>这样做，整体的时间复杂度较高，还是不行。</p>\n<h1 id=\"优化2\"><a href=\"#优化2\" class=\"headerlink\" title=\"优化2\"></a>优化2</h1><p>优化方式：</p>\n<ul>\n<li>一种是我们维护一个有序的数据结构，让比较和插入的过程更加高效，而不是需要遍历每一个元素判断逐一判断。</li>\n<li>另一种思路就是我们是否能寻找到一种直接基于字符串快速计算出编号的方式，并将这个编号映射到一个可以在O(1)时间内基于下标访问的数组中。</li>\n</ul>\n<p>以单词为例，英文单词的每个字母只可能是 a-z。</p>\n<p>我们用0表示a、1表示b，以此类推，用25表示z，然后将一个单词看成一个26进制的数字即可。</p>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        int[] cnt = new int[20000];\n        String doc = &quot;a b c d&quot;;\n        String[] words = doc.split(&quot; &quot;);\n        for (String s : words) &#123;\n            int tmp = 0;\n            for (char c: s.toCharArray()) &#123;\n                tmp *= 26;\n                tmp += (c - &#39;a&#39;);\n            &#125;\n            cnt[tmp]++;\n        &#125;\n        String target = &quot;a&quot;;\n        int hash = 0;\n        for (char c: target.toCharArray()) &#123;\n            hash *= 26;\n            hash += c - &#39;a&#39;;\n        &#125;\n        System.out.println(cnt[hash]);\n    &#125;\n&#125;\n</code></pre>\n<p>这样我们统计N个单词出现数量的时候，整体只需要O(N)的复杂度，相比于原来的需要遍历字典的做法就明显高效的多。</p>\n<blockquote>\n<p>这其实就是散列的思想了。</p>\n</blockquote>\n<h1 id=\"优化3\"><a href=\"#优化3\" class=\"headerlink\" title=\"优化3\"></a>优化3</h1><p>使用散列！</p>\n<p>散列函数的本质，就是<strong>将一个更大且可能不连续空间（比如所有的单词），映射到一个空间有限的数组里，从而借用数组基于下标O(1)快速随机访问数组元素的能力</strong>。</p>\n<p>但设计一个合理的散列函数是一个非常难的事情。</p>\n<ul>\n<li>比如对26进制的哈希值再进行一次对大质数取mod的运算，只有这样才能用比较有限的计数数组空间去表示整个哈希表。</li>\n</ul>\n<p>取了mod之后，我们很快就会发现，现在可能出现一种情况，把两个不同的单词用26进制表示并取模之后，得到的值很可能是一样的。</p>\n<p>这个问题被称之为<strong>哈希碰撞</strong>。</p>\n<h1 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h1><p>最后我们考虑一下散列函数到底需要怎么设计。</p>\n<p>以JDK（JDK14）的HashMap为例：</p>\n<ul>\n<li>主要实现在 <code>java.util</code> 下的 <code>HashMap</code> 中，这是一个最简单的不考虑并发的、基于散列的Map实现。</li>\n</ul>\n<p>找到其中用于计算哈希值的hash方法：</p>\n<pre><code class=\"java\">static final int hash(Object key) &#123;\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n</code></pre>\n<p>可以发现就是对<code>key.hashCode()</code>进行了一次特别的位运算。</p>\n<p><strong>hashcode方法</strong></p>\n<p>在Java中每个对象生成时都会产生一个对应的hashcode。</p>\n<ul>\n<li>当然数据类型不同，hashcode的计算方式是不一样的，但一定会保证的是两个一样的对象，对应的hashcode也是一样的；</li>\n</ul>\n<p>所以在比较两个对象是否相等时，我们可以先比较hashcode是否一致，如果不一致，就不需要继续调用equals，大大降低了比较对象相等的代价。</p>\n<p>我们就一起来看看JDK中对String类型的hashcode是怎么计算的，我们进入 <code>java.lang</code> 包查看String类型的实现：</p>\n<pre><code class=\"java\">public int hashCode() &#123;\n    // The hash or hashIsZero fields are subject to a benign data race,\n    // making it crucial to ensure that any observable result of the\n    // calculation in this method stays correct under any possible read of\n    // these fields. Necessary restrictions to allow this to be correct\n    // without explicit memory fences or similar concurrency primitives is\n    // that we can ever only write to one of these two fields for a given\n    // String instance, and that the computation is idempotent and derived\n    // from immutable state\n    int h = hash;\n    if (h == 0 &amp;&amp; !hashIsZero) &#123;\n        h = isLatin1() ? StringLatin1.hashCode(value)\n                       : StringUTF16.hashCode(value);\n        if (h == 0) &#123;\n            hashIsZero = true;\n        &#125; else &#123;\n            hash = h;\n        &#125;\n    &#125;\n    return h;\n&#125;\n</code></pre>\n<p>Latin和UTF16是两种字符串的编码格式，实现思路其实差不多，我们来看看<code>StringUTF16</code>中hashcode的实现：</p>\n<pre><code class=\"java\">public static int hashCode(byte[] value) &#123;\n    int h = 0;\n    int length = value.length &gt;&gt; 1;\n    for (int i = 0; i &lt; length; i++) &#123;\n        h = 31 * h + getChar(value, i);\n    &#125;\n    return h;\n&#125;\n</code></pre>\n<p>其实就是对字符串逐位按照下面的方式进行计算，和展开成26进制的想法本质上是相似的。</p>\n<pre><code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n</code></pre>\n<blockquote>\n<p>为什么选择了31？</p>\n</blockquote>\n<p>首先在各种哈希计算中，我们比较倾向使用奇素数进行乘法运算，而不是用偶数。</p>\n<p>因为用偶数，尤其是2的幂次，进行乘法，相当于直接对原来的数据进行移位运算；这样溢出的时候，部分位的信息就完全丢失了，可能增加哈希冲突的概率。</p>\n<p>为什么选择了31这个奇怪的数，这是因为计算机在进行移位运算要比普通乘法运算快得多，而<code>31*i</code>可以直接转化为<code>(i &lt;&lt; 5)- i</code> ，这是一个性能比较好的乘法计算方式，现代的编译器都可以推理并自动完成相关的优化。</p>\n<blockquote>\n<p>具体可以参考《Effective Java》中的相关章节。</p>\n</blockquote>\n<p><strong>h&gt;&gt;&gt;16</strong></p>\n<p>我们现在来看 <code>^ h &gt;&gt;&gt; 16</code> 又是一个什么样的作用呢？</p>\n<blockquote>\n<p>它的意思是就是将h右移16位并进行异或操作，为什么要这么做呢？</p>\n</blockquote>\n<p>因为那个hash值计算出来这么大，那怎么把它连续地映射到一个小一点的连续数组空间呢？</p>\n<blockquote>\n<p>所以需要取模，我们需要将hash值对数组的大小进行一次取模。</p>\n</blockquote>\n<p>我们需要对2的幂次大小的数组进行一次取模计算。</p>\n<p>但对二的幂次取模相当于直接截取数字比较低的若干位，这在数组元素较少的时候，相当于只使用了数字比较低位的信息，而放弃了高位的信息，可能会增加冲突的概率。</p>\n<p>所以，JDK的代码引入了<code>^ h &gt;&gt;&gt; 16</code> 这样的位运算，其实就是把高16位的信息叠加到了低16位，这样我们在取模的时候就可以用到高位的信息了。</p>\n<p><strong>如何处理哈希冲突呢？</strong></p>\n<p>JDK中采用的是开链法。</p>\n<p>哈希表内置数组中的每个槽位，存储的是一个链表，链表节点的值存放的就是需要存储的键值对。</p>\n<p>如果碰到哈希冲突，也就是两个不同的key映射到了数组中的同一个槽位，我们就将该元素直接放到槽位对应链表的尾部。</p>\n<h1 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h1><p><strong>手写数据结构统计单词的数量正确的思路就是：</strong></p>\n<p>根据全文长度大概预估一下会有多少个单词，开一个数倍于它的数组，再设计一个合理的hash函数，把每个单词映射到数组的某个下标，用这个数组计数统计就好啦。</p>\n<p>当然在实际工程中，我们不会为每个场景都单独写一个这样的散列表实现，也不用自己去处理复杂的扩容场景。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢！</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7a4cda275e6d468cbdc43ea2157b57c4.png\"></p>\n<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>假设现在有一篇很长的文档，如果希望统计文档中每个单词在文档中出现了多少次，应该怎么做呢？</p>\n<p>很简单！</p>\n<p>我们可以建一个HashMap，以String类型为Key，Int类型为Value；</p>\n<ul>\n<li><p>遍历文档中的每个单词 <code>word</code> ，找到键值对中key为 <code>word</code> 的项，并对相关的value进行自增操作。</p>\n</li>\n<li><p>如果该key&#x3D; <code>word</code> 的项在 HashMap中不存在，我们就插入一个<code>(word,1)</code>的项表示新增。</p>\n</li>\n<li><p>这样每组键值对表示的就是某个单词对应的数量，等整个文档遍历完成，我们就可以得到每个单词的数量了。</p>\n</li>\n</ul>\n<p>简单实现下，代码示例如下：</p>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\npublic class Test &#123;\n    public static void main(String[] args) &#123;\n        Map map = new HashMap&lt;&gt;();\n        String doc = &quot;yue ban fei yu&quot;;\n        String[] words = doc.split(&quot; &quot;);\n        for (String s : words) &#123;\n            if (!map.containsKey(s)) &#123;\n                map.put(s, 1);\n            &#125; else &#123;\n                map.put(s, map.get(s) + 1);\n            &#125;\n        &#125;\n        System.out.println(map);\n    &#125;\n&#125;\n</code></pre>\n<p>那HashMap是怎么做到高效统计单词对应数量的？我们下面会逐步来研究一下！</p>\n<blockquote>\n<p>首先我们先来看看如果只统计某一个单词的数量？</p>\n</blockquote>\n<p>只需要开一个变量，同样遍历所有单词，遇到和目标单词一样的，才对这个变量进行自增操作；</p>\n<ul>\n<li><p>等遍历完成，我们就可以得到该单词的数量了。</p>\n</li>\n<li><p>我们可以把所有可能出现的单词都列出来，每个单词，单独用一个变量去统计它出现的数量，遍历所有单词，判断当前单词应该被累计到哪个变量中。</p>\n</li>\n</ul>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        int[] cnt = new int[20000];\n        String doc = &quot;a b c d&quot;;\n        String[] words = doc.split(&quot; &quot;);\n        int a = 0;\n        int b = 0;\n        int c = 0;\n        int d = 0;\n        \n        for (String s : words) &#123;\n           if (s == &quot;a&quot;) a++;\n           if (s == &quot;b&quot;) b++;\n           if (s == &quot;c&quot;) c++;\n           if (s == &quot;d&quot;) d++;   \n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p>注意：这样的代码显然有两个很大的问题：</p>\n<ol>\n<li>对单词和计数器的映射关系是通过一堆if-else写死的，维护性很差；</li>\n<li>必须已知所有可能出现的单词，如果遇到一个新的单词，就没有办法处理它了。</li>\n</ol>\n<h1 id=\"优化1\"><a href=\"#优化1\" class=\"headerlink\" title=\"优化1\"></a>优化1</h1><p>我们可以开一个数组去维护计数器。</p>\n<blockquote>\n<p>具体做法就是，给每个单词编个号，直接用编号对应下标的数组元素作为它的计数器就好啦。</p>\n</blockquote>\n<p>我们可以建立两个数组：</p>\n<ul>\n<li><p>第一个数组用于存放所有单词，数组下标就是单词编号了，我们称之为字典数组；</p>\n</li>\n<li><p>第二个数组用于存放每个单词对应的计数器，我们称之为计数数组。</p>\n</li>\n</ul>\n<p>每遇到一个新的单词，都遍历一遍字典数组，如果没有出现过，我们就将当前单词插入到字典数组结尾。</p>\n<p>这样做，整体的时间复杂度较高，还是不行。</p>\n<h1 id=\"优化2\"><a href=\"#优化2\" class=\"headerlink\" title=\"优化2\"></a>优化2</h1><p>优化方式：</p>\n<ul>\n<li>一种是我们维护一个有序的数据结构，让比较和插入的过程更加高效，而不是需要遍历每一个元素判断逐一判断。</li>\n<li>另一种思路就是我们是否能寻找到一种直接基于字符串快速计算出编号的方式，并将这个编号映射到一个可以在O(1)时间内基于下标访问的数组中。</li>\n</ul>\n<p>以单词为例，英文单词的每个字母只可能是 a-z。</p>\n<p>我们用0表示a、1表示b，以此类推，用25表示z，然后将一个单词看成一个26进制的数字即可。</p>\n<pre><code class=\"java\">import java.util.HashMap;\nimport java.util.Map;\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        int[] cnt = new int[20000];\n        String doc = &quot;a b c d&quot;;\n        String[] words = doc.split(&quot; &quot;);\n        for (String s : words) &#123;\n            int tmp = 0;\n            for (char c: s.toCharArray()) &#123;\n                tmp *= 26;\n                tmp += (c - &#39;a&#39;);\n            &#125;\n            cnt[tmp]++;\n        &#125;\n        String target = &quot;a&quot;;\n        int hash = 0;\n        for (char c: target.toCharArray()) &#123;\n            hash *= 26;\n            hash += c - &#39;a&#39;;\n        &#125;\n        System.out.println(cnt[hash]);\n    &#125;\n&#125;\n</code></pre>\n<p>这样我们统计N个单词出现数量的时候，整体只需要O(N)的复杂度，相比于原来的需要遍历字典的做法就明显高效的多。</p>\n<blockquote>\n<p>这其实就是散列的思想了。</p>\n</blockquote>\n<h1 id=\"优化3\"><a href=\"#优化3\" class=\"headerlink\" title=\"优化3\"></a>优化3</h1><p>使用散列！</p>\n<p>散列函数的本质，就是<strong>将一个更大且可能不连续空间（比如所有的单词），映射到一个空间有限的数组里，从而借用数组基于下标O(1)快速随机访问数组元素的能力</strong>。</p>\n<p>但设计一个合理的散列函数是一个非常难的事情。</p>\n<ul>\n<li>比如对26进制的哈希值再进行一次对大质数取mod的运算，只有这样才能用比较有限的计数数组空间去表示整个哈希表。</li>\n</ul>\n<p>取了mod之后，我们很快就会发现，现在可能出现一种情况，把两个不同的单词用26进制表示并取模之后，得到的值很可能是一样的。</p>\n<p>这个问题被称之为<strong>哈希碰撞</strong>。</p>\n<h1 id=\"如何实现\"><a href=\"#如何实现\" class=\"headerlink\" title=\"如何实现\"></a>如何实现</h1><p>最后我们考虑一下散列函数到底需要怎么设计。</p>\n<p>以JDK（JDK14）的HashMap为例：</p>\n<ul>\n<li>主要实现在 <code>java.util</code> 下的 <code>HashMap</code> 中，这是一个最简单的不考虑并发的、基于散列的Map实现。</li>\n</ul>\n<p>找到其中用于计算哈希值的hash方法：</p>\n<pre><code class=\"java\">static final int hash(Object key) &#123;\n    int h;\n    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n&#125;\n</code></pre>\n<p>可以发现就是对<code>key.hashCode()</code>进行了一次特别的位运算。</p>\n<p><strong>hashcode方法</strong></p>\n<p>在Java中每个对象生成时都会产生一个对应的hashcode。</p>\n<ul>\n<li>当然数据类型不同，hashcode的计算方式是不一样的，但一定会保证的是两个一样的对象，对应的hashcode也是一样的；</li>\n</ul>\n<p>所以在比较两个对象是否相等时，我们可以先比较hashcode是否一致，如果不一致，就不需要继续调用equals，大大降低了比较对象相等的代价。</p>\n<p>我们就一起来看看JDK中对String类型的hashcode是怎么计算的，我们进入 <code>java.lang</code> 包查看String类型的实现：</p>\n<pre><code class=\"java\">public int hashCode() &#123;\n    // The hash or hashIsZero fields are subject to a benign data race,\n    // making it crucial to ensure that any observable result of the\n    // calculation in this method stays correct under any possible read of\n    // these fields. Necessary restrictions to allow this to be correct\n    // without explicit memory fences or similar concurrency primitives is\n    // that we can ever only write to one of these two fields for a given\n    // String instance, and that the computation is idempotent and derived\n    // from immutable state\n    int h = hash;\n    if (h == 0 &amp;&amp; !hashIsZero) &#123;\n        h = isLatin1() ? StringLatin1.hashCode(value)\n                       : StringUTF16.hashCode(value);\n        if (h == 0) &#123;\n            hashIsZero = true;\n        &#125; else &#123;\n            hash = h;\n        &#125;\n    &#125;\n    return h;\n&#125;\n</code></pre>\n<p>Latin和UTF16是两种字符串的编码格式，实现思路其实差不多，我们来看看<code>StringUTF16</code>中hashcode的实现：</p>\n<pre><code class=\"java\">public static int hashCode(byte[] value) &#123;\n    int h = 0;\n    int length = value.length &gt;&gt; 1;\n    for (int i = 0; i &lt; length; i++) &#123;\n        h = 31 * h + getChar(value, i);\n    &#125;\n    return h;\n&#125;\n</code></pre>\n<p>其实就是对字符串逐位按照下面的方式进行计算，和展开成26进制的想法本质上是相似的。</p>\n<pre><code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]\n</code></pre>\n<blockquote>\n<p>为什么选择了31？</p>\n</blockquote>\n<p>首先在各种哈希计算中，我们比较倾向使用奇素数进行乘法运算，而不是用偶数。</p>\n<p>因为用偶数，尤其是2的幂次，进行乘法，相当于直接对原来的数据进行移位运算；这样溢出的时候，部分位的信息就完全丢失了，可能增加哈希冲突的概率。</p>\n<p>为什么选择了31这个奇怪的数，这是因为计算机在进行移位运算要比普通乘法运算快得多，而<code>31*i</code>可以直接转化为<code>(i &lt;&lt; 5)- i</code> ，这是一个性能比较好的乘法计算方式，现代的编译器都可以推理并自动完成相关的优化。</p>\n<blockquote>\n<p>具体可以参考《Effective Java》中的相关章节。</p>\n</blockquote>\n<p><strong>h&gt;&gt;&gt;16</strong></p>\n<p>我们现在来看 <code>^ h &gt;&gt;&gt; 16</code> 又是一个什么样的作用呢？</p>\n<blockquote>\n<p>它的意思是就是将h右移16位并进行异或操作，为什么要这么做呢？</p>\n</blockquote>\n<p>因为那个hash值计算出来这么大，那怎么把它连续地映射到一个小一点的连续数组空间呢？</p>\n<blockquote>\n<p>所以需要取模，我们需要将hash值对数组的大小进行一次取模。</p>\n</blockquote>\n<p>我们需要对2的幂次大小的数组进行一次取模计算。</p>\n<p>但对二的幂次取模相当于直接截取数字比较低的若干位，这在数组元素较少的时候，相当于只使用了数字比较低位的信息，而放弃了高位的信息，可能会增加冲突的概率。</p>\n<p>所以，JDK的代码引入了<code>^ h &gt;&gt;&gt; 16</code> 这样的位运算，其实就是把高16位的信息叠加到了低16位，这样我们在取模的时候就可以用到高位的信息了。</p>\n<p><strong>如何处理哈希冲突呢？</strong></p>\n<p>JDK中采用的是开链法。</p>\n<p>哈希表内置数组中的每个槽位，存储的是一个链表，链表节点的值存放的就是需要存储的键值对。</p>\n<p>如果碰到哈希冲突，也就是两个不同的key映射到了数组中的同一个槽位，我们就将该元素直接放到槽位对应链表的尾部。</p>\n<h1 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h1><p><strong>手写数据结构统计单词的数量正确的思路就是：</strong></p>\n<p>根据全文长度大概预估一下会有多少个单词，开一个数倍于它的数组，再设计一个合理的hash函数，把每个单词映射到数组的某个下标，用这个数组计数统计就好啦。</p>\n<p>当然在实际工程中，我们不会为每个场景都单独写一个这样的散列表实现，也不用自己去处理复杂的扩容场景。</p>\n"},{"title":"线程安全","_content":"\n文章首发在公众号，之后同步个人网站：https://xiaoflyfish.cn/\n\n**文章较长，可以点赞在看**\n\n我们知道多线程能并发的处理多个任务，有效地提高复杂应用程序的性能，在实际开发中扮演着十分重要的角色\n\n但是使用多线程也带来了很多风险，并且由线程引起的问题往往在测试中难以发现，到了线上就会造成重大的故障和损失\n\n**下面我会结合几个实际案例，帮助大家在工作做规避这些问题**\n\n# 多线程问题\n\n首先介绍下使用的多线程会有哪些问题\n\n使用多线程的问题很大程度上源于多个线程对同一变量的操作权，以及不同线程之间执行顺序的不确定性\n\n《Java并发编程实战》这本书中提到了三种多线程的问题：**安全性问题、活跃性问题和性能问题**\n\n**安全性问题**\n\n例如有一段很简单的扣库存功能操作，如下：\n\n```java\npublic int decrement(){\n return --count;//count初始库存为10\n}\n```\n\n在单线程环境下，这个方法能正确工作，但在多线程环境下，就会导致错误的结果\n\n`--count`看上去是一个操作，但实际上它包含三步（读取-修改-写入）：\n\n- 读取count的值\n- 将值减一\n- 最后把计算结果赋值给count\n\n如下图展示了一种错误的执行过程，当有两个线程1、2同时执行该方法时，它们读取到count的值都是10，最后返回结果都是9；意味着可能有两个人购买了商品，但库存却只减了1，这对于真实的生产环境是不可接受的\n\n![](https://img-blog.csdnimg.cn/3305dbc892374447bd0966c6c5c94975.png)\n\n像上面例子这样由于不恰当的执行时序导致不正确结果的情况，是一种很常见的并发安全问题，被称为**竞态条件**\n\ndecrement()方法这个导致发生竞态条件的代码区被称为**临界区**\n\n避免这种问题，需要保证**读取-修改-写入**这样复合操作的**原子性**\n\n在Java中，有很多方式可以实现，比如使用synchronize内置锁或ReentrantLock显式锁的加锁机制、使用线程安全的原子类、以及采用CAS的方式等\n\n**活跃性问题**\n\n活跃性问题指的是，某个操作因为阻塞或循环，无法继续执行下去\n\n最典型的有三种，分别为死锁、活锁和饥饿\n\n> 死锁\n\n最常见的活跃性问题是死锁\n\n死锁是指多个线程之间相互等待获取对方的锁，又不会释放自己占有的锁，而导致阻塞使得这些线程无法运行下去就是死锁，它往往是不正确的使用加锁机制以及线程间执行顺序的不可预料性引起的\n\n![](https://img-blog.csdnimg.cn/24a8bb7706704f2c99321cbc89f7ae1f.png)\n\n**如何预防死锁**\n\n1.尽量保证加锁顺序是一样的\n\n例如有A,B,C三把锁。\n\n- Thread 1的加锁顺序为A、B、C这样的。\n- Thread 2的加锁顺序为A、C，这样就不会死锁。\n\n如果Thread2的加锁顺序为B、A或者C、A这样顺序就不一致了，就会出现死锁问题。\n\n2.尽量用超时放弃机制\n\nLock接口提供了`tryLock(long time, TimeUnit unit)`方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。可以避免死锁问题\n\n> 活锁\n\n活锁与死锁非常相似，也是程序一直等不到结果，但对比于死锁，活锁是活的，什么意思呢？因为正在运行的线程并没有阻塞，它始终在运行中，却一直得不到结果\n\n> 饥饿\n\n饥饿是指线程需要某些资源时始终得不到，尤其是CPU 资源，就会导致线程一直不能运行而产生的问题。\n\n在 Java 中有线程优先级的概念，Java 中优先级分为 1 到 10，1 最低，10 最高。\n\n如果我们把某个线程的优先级设置为 1，这是最低的优先级，在这种情况下，这个线程就有可能始终分配不到 CPU 资源，而导致长时间无法运行。\n\n**性能问题**\n\n线程本身的创建、以及线程之间的切换都要消耗资源，如果频繁的创建线程或者CPU在线程调度花费的时间远大于线程运行的时间，使用线程反而得不偿失，甚至造成CPU负载过高或者OOM的后果\n\n# 举例说明\n\n## 线程不安全类\n\n### 案例1\n\n**使用线程不安全集合（ArrayList、HashMap等）要进行同步，最好使用线程安全的并发集合**\n\n在多线程环境下，对线程不安全的集合遍历进行操作时，可能会抛出`ConcurrentModificationException`的异常，也就是常说的`fail-fast`机制\n\n下面例子模拟了多个线程同时对ArrayList操作，线程t1遍历list并打印，线程t2向list添加元素\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(0); \nlist.add(1); \nlist.add(2);  //list: [0,1,2]\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -> {\n  for(int i : list){\n    System.out.println(i);\n  }\n});  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -> {\n  for(int i = 3; i < 6; i++){\n    list.add(i);\n  }\n});\n\nt1.start();\nt2.start();\n```\n\n![](https://img-blog.csdnimg.cn/b591e1cbf508404c9d5d884eef466dab.png)\n\n进到抛异常的ArrayList源码中，可以看到遍历ArrayList是通过内部实现的迭代器完成的\n\n调用迭代器的next()方法获取下一个元素时，会先通过`checkForComodification()`方法检查`modCount`和`expectedModCount`是否相等，若不相等则抛出ConcurrentModificationException\n\n![](https://img-blog.csdnimg.cn/7dd1fe757515439ba044dabfc5a31eee.png)\n\n![](https://img-blog.csdnimg.cn/74095ef83baa44de8ef60a5f84aa3742.png)\n\nmodCount是ArrayList的属性，表示集合结构被修改的次数（列表长度发生变化的次数），每次调用add或remove等方法都会使modCount加1\n\nexpectedModCount是迭代器的属性，在迭代器实例创建时被赋与和遍历前modCount相等的值（`expectedModCount=modCount`）\n\n所以当有其他线程添加或删除集合元素时，modCount会增加，然后集合遍历时expectedModCount不等于modCount，就会抛出异常\n\n![](https://img-blog.csdnimg.cn/94d732e037314d3e8b51bc437c8f195b.png)\n\n**使用加锁机制操作线程不安全的集合类**\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(0); \nlist.add(1); \nlist.add(2);\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -> {\n  synchronized (list){   //使用synchronized关键字\n    for(int i : list){\n      System.out.println(i);\n    }\n  }\n});  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -> {\n  synchronized (list){\n    for(int i = 3; i < 6; i++){\n      list.add(i);\n      System.out.println(list);\n    }\n  }\n});  \n\nt1.start();\nt2.start();\n```\n\n如上面代码，用synchronized关键字锁住对list的操作，就不会抛出异常。不过用synchronized相当于把锁住的代码块串行化，性能上是不占优势的\n\n**推荐使用线程安全的并发工具类**\n\nJDK1.5加入了很多线程安全的工具类供使用，如CopyOnWriteArrayList、ConcurrentHashMap等并发容器\n\n日常开发中推荐使用这些工具类来实现多线程编程\n\n### 案例2\n\n**不要将SimpleDateFormat作为全局变量使用**\n\nSimpleDateFormat实际上是一个线程不安全的类，其根本原因是SimpleDateFormat的内部实现对一些共享变量的操作没有进行同步\n\n```java\npublic static final SimpleDateFormat SDF_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\npublic static void main(String[] args) {\n  //两个线程同时调用SimpleDateFormat.parse方法\n  Thread t1 = new Thread(() -> {\n    try {\n      Date date1 = SDF_FORMAT.parse(\"2019-12-09 17:04:32\");\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n  });\n\n  Thread t2 = new Thread(() -> {\n    try {\n      Date date2 = SDF_FORMAT.parse(\"2019-12-09 17:43:32\");\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n  });\n\n  t1.start();\n  t2.start();\n}\n```\n\n![](https://img-blog.csdnimg.cn/cdf9054f21254d9ca6bca6dd862010ea.png)\n\n**建议将SimpleDateFormat作为局部变量使用，或者配合ThreadLocal使用**\n\n最简单的做法是将SimpleDateFormat作为局部变量使用即可\n\n但如果是在for循环中使用，会创建很多实例，可以优化下配合ThreadLocal使用\n\n```java\n//初始化\npublic static final ThreadLocal<SimpleDateFormat> SDF_FORMAT = new ThreadLocal<SimpleDateFormat>(){\n  @Override\n  protected SimpleDateFormat initialValue() {\n    return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n  }\n};\n//调用\nDate date = SDF_FORMAT.get().parse(wedDate);\n```\n\n**推荐使用Java8的LocalDateTime和DateTimeFormatter**\n\nLocalDateTime和DateTimeFormatter是Java 8引入的新特性，它们不仅是线程安全的，而且使用更方便\n\n推荐在实际开发中用LocalDateTime和DateTimeFormatter替代Calendar和SimpleDateFormat\n\n```java\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nLocalDateTime time = LocalDateTime.now();\nSystem.out.println(formatter.format(time));\n```\n\n## 锁的正确释放\n\n假设有这样一段伪代码：\n\n```java\nLock lock = new ReentrantLock();\n...  \ntry{\n  lock.tryLock(timeout, TimeUnit.MILLISECONDS)\n  //业务逻辑\n}\ncatch (Exception e){\n  //错误日志\n  //抛出异常或直接返回\n}\nfinally {\n  //业务逻辑\n  lock.unlock();\n}\n...\n```\n\n这段代码中在finally代码块释放锁之前，执行了一段业务逻辑\n\n假如不巧这段逻辑中依赖服务不可用导致占用锁的线程不能成功释放锁，会造成其他线程因无法获取锁而阻塞，最终线程池被打满的问题\n\n**所以在释放锁之前；finally子句中应该只有对当前线程占有的资源(如锁、IO流等)进行释放的一些处理**\n\n**还有就是获取锁时设置合理的超时时间**\n\n为了避免线程因获取不到锁而一直阻塞，可以设置一个超时时间，当获取锁超时后，线程可以抛出异常或返回一个错误的状态码。其中超时时间的设置也要合理，不应过长，并且应该大于锁住的业务逻辑的执行时间。\n\n## 正确使用线程池\n\n### 案例1\n\n**不要将线程池作为局部变量使用**\n\n```java\npublic void request(List<Id> ids) {\n  for (int i = 0; i < ids.size(); i++) {\n     ExecutorService threadPool = Executors.newSingleThreadExecutor();\n  }\n}\n```\n\n在for循环中创建线程池，那么每次执行该方法时，入参的list长度有多大就会创建多少个线程池，并且方法执行完后也没有及时调用shutdown()方法将线程池销毁\n\n这样的话，随着不断有请求进来，线程池占用的内存会越来越多，就会导致频繁fullGC甚至OOM。每次方法调用都创建线程池是很不合理的，因为这和自己频繁创建、销毁线程没有区别，不仅没有利用线程池的优势，反而还会耗费线程池所需的更多资源\n\n**所以尽量将线程池作为全局变量使用**\n\n### 案例2\n\n**谨慎使用默认的线程池静态方法**\n\n```java\nExecutors.newFixedThreadPool(int);     //创建固定容量大小的线程池\nExecutors.newSingleThreadExecutor();   //创建容量为1的线程池\nExecutors.newCachedThreadPool();       //创建一个线程池，线程池容量大小为Integer.MAX_VALUE\n```\n\n上述三个默认线程池的风险点：\n\nnewFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，使用的阻塞队列是LinkedBlockingQueue。\n\nnewSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue\n\nLinkedBlockingQueue默认容量为`Integer.MAX_VALUE=2147483647`，对于真正的机器来说，可以被认为是无界队列\n\n- newFixedThreadPool和newSingleThreadExecutor在运行的线程数超过corePoolSize时，后来的请求会都被放到阻塞队列中等待，因为阻塞队列设置的过大，后来请求不能快速失败而长时间阻塞，就可能造成请求端的线程池被打满，拖垮整个服务。\n\nnewCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为`Integer.MAX_VALUE`，阻塞队列使用的SynchronousQueue，SynchronousQueue不会保存等待执行的任务\n\n- 所以newCachedThreadPool是来了任务就创建线程运行，而maximumPoolSize相当于无限的设置，使得创建的线程数可能会将机器内存占满。\n\n**所以需要根据自身业务和硬件配置创建自定义线程池**\n\n### 线程数建议\n\n**线程池corePoolSize数量设置建议**：\n\n> 1.CPU密集型应用\n\nCPU密集的意思是任务需要进行大量复杂的运算，几乎没有阻塞，需要CPU长时间高速运行。\n\n一般公式：`corePoolSize=CPU核数+1个线程`。JVM可运行的CPU核数可以通过`Runtime.getRuntime().availableProcessors()`查看。\n\n> 2.IO密集型应用\n\nIO密集型任务会涉及到很多的磁盘读写或网络传输，线程花费更多的时间在IO阻塞上，而不是CPU运算。一般的业务应用都属于IO密集型。\n\n**参考公式：最佳线程数=CPU数/(1-阻塞系数);  阻塞系数=线程等待时间/(线程等待时间+CPU处理时间) 。**\n\nIO密集型任务的CPU处理时间往往远小于线程等待时间，所以阻塞系数一般认为在0.8-0.9之间，以4核单槽CPU为例，corePoolSize可设置为 4/(1-0.9)=40。当然具体的设置还是要根据机器实际运行中的各项指标而定\n\n# 最后\n\n**写文章画图不易，喜欢的话，希望帮忙点赞，转发下哈，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，获得免费电子书籍，必读经典书籍这里全都有\n\n参考书籍：\n\n- Java并发编程实战","source":"_posts/公众号文章/线程安全.md","raw":"---\ntitle: 线程安全\ncategories: \n- 公众号文章\n---\n\n文章首发在公众号，之后同步个人网站：https://xiaoflyfish.cn/\n\n**文章较长，可以点赞在看**\n\n我们知道多线程能并发的处理多个任务，有效地提高复杂应用程序的性能，在实际开发中扮演着十分重要的角色\n\n但是使用多线程也带来了很多风险，并且由线程引起的问题往往在测试中难以发现，到了线上就会造成重大的故障和损失\n\n**下面我会结合几个实际案例，帮助大家在工作做规避这些问题**\n\n# 多线程问题\n\n首先介绍下使用的多线程会有哪些问题\n\n使用多线程的问题很大程度上源于多个线程对同一变量的操作权，以及不同线程之间执行顺序的不确定性\n\n《Java并发编程实战》这本书中提到了三种多线程的问题：**安全性问题、活跃性问题和性能问题**\n\n**安全性问题**\n\n例如有一段很简单的扣库存功能操作，如下：\n\n```java\npublic int decrement(){\n return --count;//count初始库存为10\n}\n```\n\n在单线程环境下，这个方法能正确工作，但在多线程环境下，就会导致错误的结果\n\n`--count`看上去是一个操作，但实际上它包含三步（读取-修改-写入）：\n\n- 读取count的值\n- 将值减一\n- 最后把计算结果赋值给count\n\n如下图展示了一种错误的执行过程，当有两个线程1、2同时执行该方法时，它们读取到count的值都是10，最后返回结果都是9；意味着可能有两个人购买了商品，但库存却只减了1，这对于真实的生产环境是不可接受的\n\n![](https://img-blog.csdnimg.cn/3305dbc892374447bd0966c6c5c94975.png)\n\n像上面例子这样由于不恰当的执行时序导致不正确结果的情况，是一种很常见的并发安全问题，被称为**竞态条件**\n\ndecrement()方法这个导致发生竞态条件的代码区被称为**临界区**\n\n避免这种问题，需要保证**读取-修改-写入**这样复合操作的**原子性**\n\n在Java中，有很多方式可以实现，比如使用synchronize内置锁或ReentrantLock显式锁的加锁机制、使用线程安全的原子类、以及采用CAS的方式等\n\n**活跃性问题**\n\n活跃性问题指的是，某个操作因为阻塞或循环，无法继续执行下去\n\n最典型的有三种，分别为死锁、活锁和饥饿\n\n> 死锁\n\n最常见的活跃性问题是死锁\n\n死锁是指多个线程之间相互等待获取对方的锁，又不会释放自己占有的锁，而导致阻塞使得这些线程无法运行下去就是死锁，它往往是不正确的使用加锁机制以及线程间执行顺序的不可预料性引起的\n\n![](https://img-blog.csdnimg.cn/24a8bb7706704f2c99321cbc89f7ae1f.png)\n\n**如何预防死锁**\n\n1.尽量保证加锁顺序是一样的\n\n例如有A,B,C三把锁。\n\n- Thread 1的加锁顺序为A、B、C这样的。\n- Thread 2的加锁顺序为A、C，这样就不会死锁。\n\n如果Thread2的加锁顺序为B、A或者C、A这样顺序就不一致了，就会出现死锁问题。\n\n2.尽量用超时放弃机制\n\nLock接口提供了`tryLock(long time, TimeUnit unit)`方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。可以避免死锁问题\n\n> 活锁\n\n活锁与死锁非常相似，也是程序一直等不到结果，但对比于死锁，活锁是活的，什么意思呢？因为正在运行的线程并没有阻塞，它始终在运行中，却一直得不到结果\n\n> 饥饿\n\n饥饿是指线程需要某些资源时始终得不到，尤其是CPU 资源，就会导致线程一直不能运行而产生的问题。\n\n在 Java 中有线程优先级的概念，Java 中优先级分为 1 到 10，1 最低，10 最高。\n\n如果我们把某个线程的优先级设置为 1，这是最低的优先级，在这种情况下，这个线程就有可能始终分配不到 CPU 资源，而导致长时间无法运行。\n\n**性能问题**\n\n线程本身的创建、以及线程之间的切换都要消耗资源，如果频繁的创建线程或者CPU在线程调度花费的时间远大于线程运行的时间，使用线程反而得不偿失，甚至造成CPU负载过高或者OOM的后果\n\n# 举例说明\n\n## 线程不安全类\n\n### 案例1\n\n**使用线程不安全集合（ArrayList、HashMap等）要进行同步，最好使用线程安全的并发集合**\n\n在多线程环境下，对线程不安全的集合遍历进行操作时，可能会抛出`ConcurrentModificationException`的异常，也就是常说的`fail-fast`机制\n\n下面例子模拟了多个线程同时对ArrayList操作，线程t1遍历list并打印，线程t2向list添加元素\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(0); \nlist.add(1); \nlist.add(2);  //list: [0,1,2]\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -> {\n  for(int i : list){\n    System.out.println(i);\n  }\n});  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -> {\n  for(int i = 3; i < 6; i++){\n    list.add(i);\n  }\n});\n\nt1.start();\nt2.start();\n```\n\n![](https://img-blog.csdnimg.cn/b591e1cbf508404c9d5d884eef466dab.png)\n\n进到抛异常的ArrayList源码中，可以看到遍历ArrayList是通过内部实现的迭代器完成的\n\n调用迭代器的next()方法获取下一个元素时，会先通过`checkForComodification()`方法检查`modCount`和`expectedModCount`是否相等，若不相等则抛出ConcurrentModificationException\n\n![](https://img-blog.csdnimg.cn/7dd1fe757515439ba044dabfc5a31eee.png)\n\n![](https://img-blog.csdnimg.cn/74095ef83baa44de8ef60a5f84aa3742.png)\n\nmodCount是ArrayList的属性，表示集合结构被修改的次数（列表长度发生变化的次数），每次调用add或remove等方法都会使modCount加1\n\nexpectedModCount是迭代器的属性，在迭代器实例创建时被赋与和遍历前modCount相等的值（`expectedModCount=modCount`）\n\n所以当有其他线程添加或删除集合元素时，modCount会增加，然后集合遍历时expectedModCount不等于modCount，就会抛出异常\n\n![](https://img-blog.csdnimg.cn/94d732e037314d3e8b51bc437c8f195b.png)\n\n**使用加锁机制操作线程不安全的集合类**\n\n```java\nList<Integer> list = new ArrayList<>();\nlist.add(0); \nlist.add(1); \nlist.add(2);\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -> {\n  synchronized (list){   //使用synchronized关键字\n    for(int i : list){\n      System.out.println(i);\n    }\n  }\n});  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -> {\n  synchronized (list){\n    for(int i = 3; i < 6; i++){\n      list.add(i);\n      System.out.println(list);\n    }\n  }\n});  \n\nt1.start();\nt2.start();\n```\n\n如上面代码，用synchronized关键字锁住对list的操作，就不会抛出异常。不过用synchronized相当于把锁住的代码块串行化，性能上是不占优势的\n\n**推荐使用线程安全的并发工具类**\n\nJDK1.5加入了很多线程安全的工具类供使用，如CopyOnWriteArrayList、ConcurrentHashMap等并发容器\n\n日常开发中推荐使用这些工具类来实现多线程编程\n\n### 案例2\n\n**不要将SimpleDateFormat作为全局变量使用**\n\nSimpleDateFormat实际上是一个线程不安全的类，其根本原因是SimpleDateFormat的内部实现对一些共享变量的操作没有进行同步\n\n```java\npublic static final SimpleDateFormat SDF_FORMAT = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\npublic static void main(String[] args) {\n  //两个线程同时调用SimpleDateFormat.parse方法\n  Thread t1 = new Thread(() -> {\n    try {\n      Date date1 = SDF_FORMAT.parse(\"2019-12-09 17:04:32\");\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n  });\n\n  Thread t2 = new Thread(() -> {\n    try {\n      Date date2 = SDF_FORMAT.parse(\"2019-12-09 17:43:32\");\n    } catch (ParseException e) {\n      e.printStackTrace();\n    }\n  });\n\n  t1.start();\n  t2.start();\n}\n```\n\n![](https://img-blog.csdnimg.cn/cdf9054f21254d9ca6bca6dd862010ea.png)\n\n**建议将SimpleDateFormat作为局部变量使用，或者配合ThreadLocal使用**\n\n最简单的做法是将SimpleDateFormat作为局部变量使用即可\n\n但如果是在for循环中使用，会创建很多实例，可以优化下配合ThreadLocal使用\n\n```java\n//初始化\npublic static final ThreadLocal<SimpleDateFormat> SDF_FORMAT = new ThreadLocal<SimpleDateFormat>(){\n  @Override\n  protected SimpleDateFormat initialValue() {\n    return new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n  }\n};\n//调用\nDate date = SDF_FORMAT.get().parse(wedDate);\n```\n\n**推荐使用Java8的LocalDateTime和DateTimeFormatter**\n\nLocalDateTime和DateTimeFormatter是Java 8引入的新特性，它们不仅是线程安全的，而且使用更方便\n\n推荐在实际开发中用LocalDateTime和DateTimeFormatter替代Calendar和SimpleDateFormat\n\n```java\nDateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");\nLocalDateTime time = LocalDateTime.now();\nSystem.out.println(formatter.format(time));\n```\n\n## 锁的正确释放\n\n假设有这样一段伪代码：\n\n```java\nLock lock = new ReentrantLock();\n...  \ntry{\n  lock.tryLock(timeout, TimeUnit.MILLISECONDS)\n  //业务逻辑\n}\ncatch (Exception e){\n  //错误日志\n  //抛出异常或直接返回\n}\nfinally {\n  //业务逻辑\n  lock.unlock();\n}\n...\n```\n\n这段代码中在finally代码块释放锁之前，执行了一段业务逻辑\n\n假如不巧这段逻辑中依赖服务不可用导致占用锁的线程不能成功释放锁，会造成其他线程因无法获取锁而阻塞，最终线程池被打满的问题\n\n**所以在释放锁之前；finally子句中应该只有对当前线程占有的资源(如锁、IO流等)进行释放的一些处理**\n\n**还有就是获取锁时设置合理的超时时间**\n\n为了避免线程因获取不到锁而一直阻塞，可以设置一个超时时间，当获取锁超时后，线程可以抛出异常或返回一个错误的状态码。其中超时时间的设置也要合理，不应过长，并且应该大于锁住的业务逻辑的执行时间。\n\n## 正确使用线程池\n\n### 案例1\n\n**不要将线程池作为局部变量使用**\n\n```java\npublic void request(List<Id> ids) {\n  for (int i = 0; i < ids.size(); i++) {\n     ExecutorService threadPool = Executors.newSingleThreadExecutor();\n  }\n}\n```\n\n在for循环中创建线程池，那么每次执行该方法时，入参的list长度有多大就会创建多少个线程池，并且方法执行完后也没有及时调用shutdown()方法将线程池销毁\n\n这样的话，随着不断有请求进来，线程池占用的内存会越来越多，就会导致频繁fullGC甚至OOM。每次方法调用都创建线程池是很不合理的，因为这和自己频繁创建、销毁线程没有区别，不仅没有利用线程池的优势，反而还会耗费线程池所需的更多资源\n\n**所以尽量将线程池作为全局变量使用**\n\n### 案例2\n\n**谨慎使用默认的线程池静态方法**\n\n```java\nExecutors.newFixedThreadPool(int);     //创建固定容量大小的线程池\nExecutors.newSingleThreadExecutor();   //创建容量为1的线程池\nExecutors.newCachedThreadPool();       //创建一个线程池，线程池容量大小为Integer.MAX_VALUE\n```\n\n上述三个默认线程池的风险点：\n\nnewFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，使用的阻塞队列是LinkedBlockingQueue。\n\nnewSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue\n\nLinkedBlockingQueue默认容量为`Integer.MAX_VALUE=2147483647`，对于真正的机器来说，可以被认为是无界队列\n\n- newFixedThreadPool和newSingleThreadExecutor在运行的线程数超过corePoolSize时，后来的请求会都被放到阻塞队列中等待，因为阻塞队列设置的过大，后来请求不能快速失败而长时间阻塞，就可能造成请求端的线程池被打满，拖垮整个服务。\n\nnewCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为`Integer.MAX_VALUE`，阻塞队列使用的SynchronousQueue，SynchronousQueue不会保存等待执行的任务\n\n- 所以newCachedThreadPool是来了任务就创建线程运行，而maximumPoolSize相当于无限的设置，使得创建的线程数可能会将机器内存占满。\n\n**所以需要根据自身业务和硬件配置创建自定义线程池**\n\n### 线程数建议\n\n**线程池corePoolSize数量设置建议**：\n\n> 1.CPU密集型应用\n\nCPU密集的意思是任务需要进行大量复杂的运算，几乎没有阻塞，需要CPU长时间高速运行。\n\n一般公式：`corePoolSize=CPU核数+1个线程`。JVM可运行的CPU核数可以通过`Runtime.getRuntime().availableProcessors()`查看。\n\n> 2.IO密集型应用\n\nIO密集型任务会涉及到很多的磁盘读写或网络传输，线程花费更多的时间在IO阻塞上，而不是CPU运算。一般的业务应用都属于IO密集型。\n\n**参考公式：最佳线程数=CPU数/(1-阻塞系数);  阻塞系数=线程等待时间/(线程等待时间+CPU处理时间) 。**\n\nIO密集型任务的CPU处理时间往往远小于线程等待时间，所以阻塞系数一般认为在0.8-0.9之间，以4核单槽CPU为例，corePoolSize可设置为 4/(1-0.9)=40。当然具体的设置还是要根据机器实际运行中的各项指标而定\n\n# 最后\n\n**写文章画图不易，喜欢的话，希望帮忙点赞，转发下哈，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，获得免费电子书籍，必读经典书籍这里全都有\n\n参考书籍：\n\n- Java并发编程实战","slug":"公众号文章/线程安全","published":1,"date":"2022-02-04T04:37:43.937Z","updated":"2022-02-04T04:43:29.575Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiy00f8fhjid0l1fzf2","content":"<p>文章首发在公众号，之后同步个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><strong>文章较长，可以点赞在看</strong></p>\n<p>我们知道多线程能并发的处理多个任务，有效地提高复杂应用程序的性能，在实际开发中扮演着十分重要的角色</p>\n<p>但是使用多线程也带来了很多风险，并且由线程引起的问题往往在测试中难以发现，到了线上就会造成重大的故障和损失</p>\n<p><strong>下面我会结合几个实际案例，帮助大家在工作做规避这些问题</strong></p>\n<h1 id=\"多线程问题\"><a href=\"#多线程问题\" class=\"headerlink\" title=\"多线程问题\"></a>多线程问题</h1><p>首先介绍下使用的多线程会有哪些问题</p>\n<p>使用多线程的问题很大程度上源于多个线程对同一变量的操作权，以及不同线程之间执行顺序的不确定性</p>\n<p>《Java并发编程实战》这本书中提到了三种多线程的问题：<strong>安全性问题、活跃性问题和性能问题</strong></p>\n<p><strong>安全性问题</strong></p>\n<p>例如有一段很简单的扣库存功能操作，如下：</p>\n<pre><code class=\"java\">public int decrement()&#123;\n return --count;//count初始库存为10\n&#125;\n</code></pre>\n<p>在单线程环境下，这个方法能正确工作，但在多线程环境下，就会导致错误的结果</p>\n<p><code>--count</code>看上去是一个操作，但实际上它包含三步（读取-修改-写入）：</p>\n<ul>\n<li>读取count的值</li>\n<li>将值减一</li>\n<li>最后把计算结果赋值给count</li>\n</ul>\n<p>如下图展示了一种错误的执行过程，当有两个线程1、2同时执行该方法时，它们读取到count的值都是10，最后返回结果都是9；意味着可能有两个人购买了商品，但库存却只减了1，这对于真实的生产环境是不可接受的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3305dbc892374447bd0966c6c5c94975.png\"></p>\n<p>像上面例子这样由于不恰当的执行时序导致不正确结果的情况，是一种很常见的并发安全问题，被称为<strong>竞态条件</strong></p>\n<p>decrement()方法这个导致发生竞态条件的代码区被称为<strong>临界区</strong></p>\n<p>避免这种问题，需要保证<strong>读取-修改-写入</strong>这样复合操作的<strong>原子性</strong></p>\n<p>在Java中，有很多方式可以实现，比如使用synchronize内置锁或ReentrantLock显式锁的加锁机制、使用线程安全的原子类、以及采用CAS的方式等</p>\n<p><strong>活跃性问题</strong></p>\n<p>活跃性问题指的是，某个操作因为阻塞或循环，无法继续执行下去</p>\n<p>最典型的有三种，分别为死锁、活锁和饥饿</p>\n<blockquote>\n<p>死锁</p>\n</blockquote>\n<p>最常见的活跃性问题是死锁</p>\n<p>死锁是指多个线程之间相互等待获取对方的锁，又不会释放自己占有的锁，而导致阻塞使得这些线程无法运行下去就是死锁，它往往是不正确的使用加锁机制以及线程间执行顺序的不可预料性引起的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/24a8bb7706704f2c99321cbc89f7ae1f.png\"></p>\n<p><strong>如何预防死锁</strong></p>\n<p>1.尽量保证加锁顺序是一样的</p>\n<p>例如有A,B,C三把锁。</p>\n<ul>\n<li>Thread 1的加锁顺序为A、B、C这样的。</li>\n<li>Thread 2的加锁顺序为A、C，这样就不会死锁。</li>\n</ul>\n<p>如果Thread2的加锁顺序为B、A或者C、A这样顺序就不一致了，就会出现死锁问题。</p>\n<p>2.尽量用超时放弃机制</p>\n<p>Lock接口提供了<code>tryLock(long time, TimeUnit unit)</code>方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。可以避免死锁问题</p>\n<blockquote>\n<p>活锁</p>\n</blockquote>\n<p>活锁与死锁非常相似，也是程序一直等不到结果，但对比于死锁，活锁是活的，什么意思呢？因为正在运行的线程并没有阻塞，它始终在运行中，却一直得不到结果</p>\n<blockquote>\n<p>饥饿</p>\n</blockquote>\n<p>饥饿是指线程需要某些资源时始终得不到，尤其是CPU 资源，就会导致线程一直不能运行而产生的问题。</p>\n<p>在 Java 中有线程优先级的概念，Java 中优先级分为 1 到 10，1 最低，10 最高。</p>\n<p>如果我们把某个线程的优先级设置为 1，这是最低的优先级，在这种情况下，这个线程就有可能始终分配不到 CPU 资源，而导致长时间无法运行。</p>\n<p><strong>性能问题</strong></p>\n<p>线程本身的创建、以及线程之间的切换都要消耗资源，如果频繁的创建线程或者CPU在线程调度花费的时间远大于线程运行的时间，使用线程反而得不偿失，甚至造成CPU负载过高或者OOM的后果</p>\n<h1 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h1><h2 id=\"线程不安全类\"><a href=\"#线程不安全类\" class=\"headerlink\" title=\"线程不安全类\"></a>线程不安全类</h2><h3 id=\"案例1\"><a href=\"#案例1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h3><p><strong>使用线程不安全集合（ArrayList、HashMap等）要进行同步，最好使用线程安全的并发集合</strong></p>\n<p>在多线程环境下，对线程不安全的集合遍历进行操作时，可能会抛出<code>ConcurrentModificationException</code>的异常，也就是常说的<code>fail-fast</code>机制</p>\n<p>下面例子模拟了多个线程同时对ArrayList操作，线程t1遍历list并打印，线程t2向list添加元素</p>\n<pre><code class=\"java\">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(0); \nlist.add(1); \nlist.add(2);  //list: [0,1,2]\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -&gt; &#123;\n  for(int i : list)&#123;\n    System.out.println(i);\n  &#125;\n&#125;);  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -&gt; &#123;\n  for(int i = 3; i &lt; 6; i++)&#123;\n    list.add(i);\n  &#125;\n&#125;);\n\nt1.start();\nt2.start();\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b591e1cbf508404c9d5d884eef466dab.png\"></p>\n<p>进到抛异常的ArrayList源码中，可以看到遍历ArrayList是通过内部实现的迭代器完成的</p>\n<p>调用迭代器的next()方法获取下一个元素时，会先通过<code>checkForComodification()</code>方法检查<code>modCount</code>和<code>expectedModCount</code>是否相等，若不相等则抛出ConcurrentModificationException</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7dd1fe757515439ba044dabfc5a31eee.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/74095ef83baa44de8ef60a5f84aa3742.png\"></p>\n<p>modCount是ArrayList的属性，表示集合结构被修改的次数（列表长度发生变化的次数），每次调用add或remove等方法都会使modCount加1</p>\n<p>expectedModCount是迭代器的属性，在迭代器实例创建时被赋与和遍历前modCount相等的值（<code>expectedModCount=modCount</code>）</p>\n<p>所以当有其他线程添加或删除集合元素时，modCount会增加，然后集合遍历时expectedModCount不等于modCount，就会抛出异常</p>\n<p><img src=\"https://img-blog.csdnimg.cn/94d732e037314d3e8b51bc437c8f195b.png\"></p>\n<p><strong>使用加锁机制操作线程不安全的集合类</strong></p>\n<pre><code class=\"java\">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(0); \nlist.add(1); \nlist.add(2);\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -&gt; &#123;\n  synchronized (list)&#123;   //使用synchronized关键字\n    for(int i : list)&#123;\n      System.out.println(i);\n    &#125;\n  &#125;\n&#125;);  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -&gt; &#123;\n  synchronized (list)&#123;\n    for(int i = 3; i &lt; 6; i++)&#123;\n      list.add(i);\n      System.out.println(list);\n    &#125;\n  &#125;\n&#125;);  \n\nt1.start();\nt2.start();\n</code></pre>\n<p>如上面代码，用synchronized关键字锁住对list的操作，就不会抛出异常。不过用synchronized相当于把锁住的代码块串行化，性能上是不占优势的</p>\n<p><strong>推荐使用线程安全的并发工具类</strong></p>\n<p>JDK1.5加入了很多线程安全的工具类供使用，如CopyOnWriteArrayList、ConcurrentHashMap等并发容器</p>\n<p>日常开发中推荐使用这些工具类来实现多线程编程</p>\n<h3 id=\"案例2\"><a href=\"#案例2\" class=\"headerlink\" title=\"案例2\"></a>案例2</h3><p><strong>不要将SimpleDateFormat作为全局变量使用</strong></p>\n<p>SimpleDateFormat实际上是一个线程不安全的类，其根本原因是SimpleDateFormat的内部实现对一些共享变量的操作没有进行同步</p>\n<pre><code class=\"java\">public static final SimpleDateFormat SDF_FORMAT = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n\npublic static void main(String[] args) &#123;\n  //两个线程同时调用SimpleDateFormat.parse方法\n  Thread t1 = new Thread(() -&gt; &#123;\n    try &#123;\n      Date date1 = SDF_FORMAT.parse(&quot;2019-12-09 17:04:32&quot;);\n    &#125; catch (ParseException e) &#123;\n      e.printStackTrace();\n    &#125;\n  &#125;);\n\n  Thread t2 = new Thread(() -&gt; &#123;\n    try &#123;\n      Date date2 = SDF_FORMAT.parse(&quot;2019-12-09 17:43:32&quot;);\n    &#125; catch (ParseException e) &#123;\n      e.printStackTrace();\n    &#125;\n  &#125;);\n\n  t1.start();\n  t2.start();\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/cdf9054f21254d9ca6bca6dd862010ea.png\"></p>\n<p><strong>建议将SimpleDateFormat作为局部变量使用，或者配合ThreadLocal使用</strong></p>\n<p>最简单的做法是将SimpleDateFormat作为局部变量使用即可</p>\n<p>但如果是在for循环中使用，会创建很多实例，可以优化下配合ThreadLocal使用</p>\n<pre><code class=\"java\">//初始化\npublic static final ThreadLocal&lt;SimpleDateFormat&gt; SDF_FORMAT = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;\n  @Override\n  protected SimpleDateFormat initialValue() &#123;\n    return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n  &#125;\n&#125;;\n//调用\nDate date = SDF_FORMAT.get().parse(wedDate);\n</code></pre>\n<p><strong>推荐使用Java8的LocalDateTime和DateTimeFormatter</strong></p>\n<p>LocalDateTime和DateTimeFormatter是Java 8引入的新特性，它们不仅是线程安全的，而且使用更方便</p>\n<p>推荐在实际开发中用LocalDateTime和DateTimeFormatter替代Calendar和SimpleDateFormat</p>\n<pre><code class=\"java\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\nLocalDateTime time = LocalDateTime.now();\nSystem.out.println(formatter.format(time));\n</code></pre>\n<h2 id=\"锁的正确释放\"><a href=\"#锁的正确释放\" class=\"headerlink\" title=\"锁的正确释放\"></a>锁的正确释放</h2><p>假设有这样一段伪代码：</p>\n<pre><code class=\"java\">Lock lock = new ReentrantLock();\n...  \ntry&#123;\n  lock.tryLock(timeout, TimeUnit.MILLISECONDS)\n  //业务逻辑\n&#125;\ncatch (Exception e)&#123;\n  //错误日志\n  //抛出异常或直接返回\n&#125;\nfinally &#123;\n  //业务逻辑\n  lock.unlock();\n&#125;\n...\n</code></pre>\n<p>这段代码中在finally代码块释放锁之前，执行了一段业务逻辑</p>\n<p>假如不巧这段逻辑中依赖服务不可用导致占用锁的线程不能成功释放锁，会造成其他线程因无法获取锁而阻塞，最终线程池被打满的问题</p>\n<p><strong>所以在释放锁之前；finally子句中应该只有对当前线程占有的资源(如锁、IO流等)进行释放的一些处理</strong></p>\n<p><strong>还有就是获取锁时设置合理的超时时间</strong></p>\n<p>为了避免线程因获取不到锁而一直阻塞，可以设置一个超时时间，当获取锁超时后，线程可以抛出异常或返回一个错误的状态码。其中超时时间的设置也要合理，不应过长，并且应该大于锁住的业务逻辑的执行时间。</p>\n<h2 id=\"正确使用线程池\"><a href=\"#正确使用线程池\" class=\"headerlink\" title=\"正确使用线程池\"></a>正确使用线程池</h2><h3 id=\"案例1-1\"><a href=\"#案例1-1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h3><p><strong>不要将线程池作为局部变量使用</strong></p>\n<pre><code class=\"java\">public void request(List&lt;Id&gt; ids) &#123;\n  for (int i = 0; i &lt; ids.size(); i++) &#123;\n     ExecutorService threadPool = Executors.newSingleThreadExecutor();\n  &#125;\n&#125;\n</code></pre>\n<p>在for循环中创建线程池，那么每次执行该方法时，入参的list长度有多大就会创建多少个线程池，并且方法执行完后也没有及时调用shutdown()方法将线程池销毁</p>\n<p>这样的话，随着不断有请求进来，线程池占用的内存会越来越多，就会导致频繁fullGC甚至OOM。每次方法调用都创建线程池是很不合理的，因为这和自己频繁创建、销毁线程没有区别，不仅没有利用线程池的优势，反而还会耗费线程池所需的更多资源</p>\n<p><strong>所以尽量将线程池作为全局变量使用</strong></p>\n<h3 id=\"案例2-1\"><a href=\"#案例2-1\" class=\"headerlink\" title=\"案例2\"></a>案例2</h3><p><strong>谨慎使用默认的线程池静态方法</strong></p>\n<pre><code class=\"java\">Executors.newFixedThreadPool(int);     //创建固定容量大小的线程池\nExecutors.newSingleThreadExecutor();   //创建容量为1的线程池\nExecutors.newCachedThreadPool();       //创建一个线程池，线程池容量大小为Integer.MAX_VALUE\n</code></pre>\n<p>上述三个默认线程池的风险点：</p>\n<p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，使用的阻塞队列是LinkedBlockingQueue。</p>\n<p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue</p>\n<p>LinkedBlockingQueue默认容量为<code>Integer.MAX_VALUE=2147483647</code>，对于真正的机器来说，可以被认为是无界队列</p>\n<ul>\n<li>newFixedThreadPool和newSingleThreadExecutor在运行的线程数超过corePoolSize时，后来的请求会都被放到阻塞队列中等待，因为阻塞队列设置的过大，后来请求不能快速失败而长时间阻塞，就可能造成请求端的线程池被打满，拖垮整个服务。</li>\n</ul>\n<p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为<code>Integer.MAX_VALUE</code>，阻塞队列使用的SynchronousQueue，SynchronousQueue不会保存等待执行的任务</p>\n<ul>\n<li>所以newCachedThreadPool是来了任务就创建线程运行，而maximumPoolSize相当于无限的设置，使得创建的线程数可能会将机器内存占满。</li>\n</ul>\n<p><strong>所以需要根据自身业务和硬件配置创建自定义线程池</strong></p>\n<h3 id=\"线程数建议\"><a href=\"#线程数建议\" class=\"headerlink\" title=\"线程数建议\"></a>线程数建议</h3><p><strong>线程池corePoolSize数量设置建议</strong>：</p>\n<blockquote>\n<p>1.CPU密集型应用</p>\n</blockquote>\n<p>CPU密集的意思是任务需要进行大量复杂的运算，几乎没有阻塞，需要CPU长时间高速运行。</p>\n<p>一般公式：<code>corePoolSize=CPU核数+1个线程</code>。JVM可运行的CPU核数可以通过<code>Runtime.getRuntime().availableProcessors()</code>查看。</p>\n<blockquote>\n<p>2.IO密集型应用</p>\n</blockquote>\n<p>IO密集型任务会涉及到很多的磁盘读写或网络传输，线程花费更多的时间在IO阻塞上，而不是CPU运算。一般的业务应用都属于IO密集型。</p>\n<p><strong>参考公式：最佳线程数&#x3D;CPU数&#x2F;(1-阻塞系数);  阻塞系数&#x3D;线程等待时间&#x2F;(线程等待时间+CPU处理时间) 。</strong></p>\n<p>IO密集型任务的CPU处理时间往往远小于线程等待时间，所以阻塞系数一般认为在0.8-0.9之间，以4核单槽CPU为例，corePoolSize可设置为 4&#x2F;(1-0.9)&#x3D;40。当然具体的设置还是要根据机器实际运行中的各项指标而定</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>写文章画图不易，喜欢的话，希望帮忙点赞，转发下哈，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，获得免费电子书籍，必读经典书籍这里全都有</p>\n<p>参考书籍：</p>\n<ul>\n<li>Java并发编程实战</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>文章首发在公众号，之后同步个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<p><strong>文章较长，可以点赞在看</strong></p>\n<p>我们知道多线程能并发的处理多个任务，有效地提高复杂应用程序的性能，在实际开发中扮演着十分重要的角色</p>\n<p>但是使用多线程也带来了很多风险，并且由线程引起的问题往往在测试中难以发现，到了线上就会造成重大的故障和损失</p>\n<p><strong>下面我会结合几个实际案例，帮助大家在工作做规避这些问题</strong></p>\n<h1 id=\"多线程问题\"><a href=\"#多线程问题\" class=\"headerlink\" title=\"多线程问题\"></a>多线程问题</h1><p>首先介绍下使用的多线程会有哪些问题</p>\n<p>使用多线程的问题很大程度上源于多个线程对同一变量的操作权，以及不同线程之间执行顺序的不确定性</p>\n<p>《Java并发编程实战》这本书中提到了三种多线程的问题：<strong>安全性问题、活跃性问题和性能问题</strong></p>\n<p><strong>安全性问题</strong></p>\n<p>例如有一段很简单的扣库存功能操作，如下：</p>\n<pre><code class=\"java\">public int decrement()&#123;\n return --count;//count初始库存为10\n&#125;\n</code></pre>\n<p>在单线程环境下，这个方法能正确工作，但在多线程环境下，就会导致错误的结果</p>\n<p><code>--count</code>看上去是一个操作，但实际上它包含三步（读取-修改-写入）：</p>\n<ul>\n<li>读取count的值</li>\n<li>将值减一</li>\n<li>最后把计算结果赋值给count</li>\n</ul>\n<p>如下图展示了一种错误的执行过程，当有两个线程1、2同时执行该方法时，它们读取到count的值都是10，最后返回结果都是9；意味着可能有两个人购买了商品，但库存却只减了1，这对于真实的生产环境是不可接受的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3305dbc892374447bd0966c6c5c94975.png\"></p>\n<p>像上面例子这样由于不恰当的执行时序导致不正确结果的情况，是一种很常见的并发安全问题，被称为<strong>竞态条件</strong></p>\n<p>decrement()方法这个导致发生竞态条件的代码区被称为<strong>临界区</strong></p>\n<p>避免这种问题，需要保证<strong>读取-修改-写入</strong>这样复合操作的<strong>原子性</strong></p>\n<p>在Java中，有很多方式可以实现，比如使用synchronize内置锁或ReentrantLock显式锁的加锁机制、使用线程安全的原子类、以及采用CAS的方式等</p>\n<p><strong>活跃性问题</strong></p>\n<p>活跃性问题指的是，某个操作因为阻塞或循环，无法继续执行下去</p>\n<p>最典型的有三种，分别为死锁、活锁和饥饿</p>\n<blockquote>\n<p>死锁</p>\n</blockquote>\n<p>最常见的活跃性问题是死锁</p>\n<p>死锁是指多个线程之间相互等待获取对方的锁，又不会释放自己占有的锁，而导致阻塞使得这些线程无法运行下去就是死锁，它往往是不正确的使用加锁机制以及线程间执行顺序的不可预料性引起的</p>\n<p><img src=\"https://img-blog.csdnimg.cn/24a8bb7706704f2c99321cbc89f7ae1f.png\"></p>\n<p><strong>如何预防死锁</strong></p>\n<p>1.尽量保证加锁顺序是一样的</p>\n<p>例如有A,B,C三把锁。</p>\n<ul>\n<li>Thread 1的加锁顺序为A、B、C这样的。</li>\n<li>Thread 2的加锁顺序为A、C，这样就不会死锁。</li>\n</ul>\n<p>如果Thread2的加锁顺序为B、A或者C、A这样顺序就不一致了，就会出现死锁问题。</p>\n<p>2.尽量用超时放弃机制</p>\n<p>Lock接口提供了<code>tryLock(long time, TimeUnit unit)</code>方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。可以避免死锁问题</p>\n<blockquote>\n<p>活锁</p>\n</blockquote>\n<p>活锁与死锁非常相似，也是程序一直等不到结果，但对比于死锁，活锁是活的，什么意思呢？因为正在运行的线程并没有阻塞，它始终在运行中，却一直得不到结果</p>\n<blockquote>\n<p>饥饿</p>\n</blockquote>\n<p>饥饿是指线程需要某些资源时始终得不到，尤其是CPU 资源，就会导致线程一直不能运行而产生的问题。</p>\n<p>在 Java 中有线程优先级的概念，Java 中优先级分为 1 到 10，1 最低，10 最高。</p>\n<p>如果我们把某个线程的优先级设置为 1，这是最低的优先级，在这种情况下，这个线程就有可能始终分配不到 CPU 资源，而导致长时间无法运行。</p>\n<p><strong>性能问题</strong></p>\n<p>线程本身的创建、以及线程之间的切换都要消耗资源，如果频繁的创建线程或者CPU在线程调度花费的时间远大于线程运行的时间，使用线程反而得不偿失，甚至造成CPU负载过高或者OOM的后果</p>\n<h1 id=\"举例说明\"><a href=\"#举例说明\" class=\"headerlink\" title=\"举例说明\"></a>举例说明</h1><h2 id=\"线程不安全类\"><a href=\"#线程不安全类\" class=\"headerlink\" title=\"线程不安全类\"></a>线程不安全类</h2><h3 id=\"案例1\"><a href=\"#案例1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h3><p><strong>使用线程不安全集合（ArrayList、HashMap等）要进行同步，最好使用线程安全的并发集合</strong></p>\n<p>在多线程环境下，对线程不安全的集合遍历进行操作时，可能会抛出<code>ConcurrentModificationException</code>的异常，也就是常说的<code>fail-fast</code>机制</p>\n<p>下面例子模拟了多个线程同时对ArrayList操作，线程t1遍历list并打印，线程t2向list添加元素</p>\n<pre><code class=\"java\">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(0); \nlist.add(1); \nlist.add(2);  //list: [0,1,2]\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -&gt; &#123;\n  for(int i : list)&#123;\n    System.out.println(i);\n  &#125;\n&#125;);  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -&gt; &#123;\n  for(int i = 3; i &lt; 6; i++)&#123;\n    list.add(i);\n  &#125;\n&#125;);\n\nt1.start();\nt2.start();\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/b591e1cbf508404c9d5d884eef466dab.png\"></p>\n<p>进到抛异常的ArrayList源码中，可以看到遍历ArrayList是通过内部实现的迭代器完成的</p>\n<p>调用迭代器的next()方法获取下一个元素时，会先通过<code>checkForComodification()</code>方法检查<code>modCount</code>和<code>expectedModCount</code>是否相等，若不相等则抛出ConcurrentModificationException</p>\n<p><img src=\"https://img-blog.csdnimg.cn/7dd1fe757515439ba044dabfc5a31eee.png\"></p>\n<p><img src=\"https://img-blog.csdnimg.cn/74095ef83baa44de8ef60a5f84aa3742.png\"></p>\n<p>modCount是ArrayList的属性，表示集合结构被修改的次数（列表长度发生变化的次数），每次调用add或remove等方法都会使modCount加1</p>\n<p>expectedModCount是迭代器的属性，在迭代器实例创建时被赋与和遍历前modCount相等的值（<code>expectedModCount=modCount</code>）</p>\n<p>所以当有其他线程添加或删除集合元素时，modCount会增加，然后集合遍历时expectedModCount不等于modCount，就会抛出异常</p>\n<p><img src=\"https://img-blog.csdnimg.cn/94d732e037314d3e8b51bc437c8f195b.png\"></p>\n<p><strong>使用加锁机制操作线程不安全的集合类</strong></p>\n<pre><code class=\"java\">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(0); \nlist.add(1); \nlist.add(2);\nSystem.out.println(list);\n\n//线程t1遍历打印list\nThread t1 = new Thread(() -&gt; &#123;\n  synchronized (list)&#123;   //使用synchronized关键字\n    for(int i : list)&#123;\n      System.out.println(i);\n    &#125;\n  &#125;\n&#125;);  \n\n//线程t2向list添加元素\nThread t2 = new Thread(() -&gt; &#123;\n  synchronized (list)&#123;\n    for(int i = 3; i &lt; 6; i++)&#123;\n      list.add(i);\n      System.out.println(list);\n    &#125;\n  &#125;\n&#125;);  \n\nt1.start();\nt2.start();\n</code></pre>\n<p>如上面代码，用synchronized关键字锁住对list的操作，就不会抛出异常。不过用synchronized相当于把锁住的代码块串行化，性能上是不占优势的</p>\n<p><strong>推荐使用线程安全的并发工具类</strong></p>\n<p>JDK1.5加入了很多线程安全的工具类供使用，如CopyOnWriteArrayList、ConcurrentHashMap等并发容器</p>\n<p>日常开发中推荐使用这些工具类来实现多线程编程</p>\n<h3 id=\"案例2\"><a href=\"#案例2\" class=\"headerlink\" title=\"案例2\"></a>案例2</h3><p><strong>不要将SimpleDateFormat作为全局变量使用</strong></p>\n<p>SimpleDateFormat实际上是一个线程不安全的类，其根本原因是SimpleDateFormat的内部实现对一些共享变量的操作没有进行同步</p>\n<pre><code class=\"java\">public static final SimpleDateFormat SDF_FORMAT = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n\npublic static void main(String[] args) &#123;\n  //两个线程同时调用SimpleDateFormat.parse方法\n  Thread t1 = new Thread(() -&gt; &#123;\n    try &#123;\n      Date date1 = SDF_FORMAT.parse(&quot;2019-12-09 17:04:32&quot;);\n    &#125; catch (ParseException e) &#123;\n      e.printStackTrace();\n    &#125;\n  &#125;);\n\n  Thread t2 = new Thread(() -&gt; &#123;\n    try &#123;\n      Date date2 = SDF_FORMAT.parse(&quot;2019-12-09 17:43:32&quot;);\n    &#125; catch (ParseException e) &#123;\n      e.printStackTrace();\n    &#125;\n  &#125;);\n\n  t1.start();\n  t2.start();\n&#125;\n</code></pre>\n<p><img src=\"https://img-blog.csdnimg.cn/cdf9054f21254d9ca6bca6dd862010ea.png\"></p>\n<p><strong>建议将SimpleDateFormat作为局部变量使用，或者配合ThreadLocal使用</strong></p>\n<p>最简单的做法是将SimpleDateFormat作为局部变量使用即可</p>\n<p>但如果是在for循环中使用，会创建很多实例，可以优化下配合ThreadLocal使用</p>\n<pre><code class=\"java\">//初始化\npublic static final ThreadLocal&lt;SimpleDateFormat&gt; SDF_FORMAT = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;\n  @Override\n  protected SimpleDateFormat initialValue() &#123;\n    return new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);\n  &#125;\n&#125;;\n//调用\nDate date = SDF_FORMAT.get().parse(wedDate);\n</code></pre>\n<p><strong>推荐使用Java8的LocalDateTime和DateTimeFormatter</strong></p>\n<p>LocalDateTime和DateTimeFormatter是Java 8引入的新特性，它们不仅是线程安全的，而且使用更方便</p>\n<p>推荐在实际开发中用LocalDateTime和DateTimeFormatter替代Calendar和SimpleDateFormat</p>\n<pre><code class=\"java\">DateTimeFormatter formatter = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;);\nLocalDateTime time = LocalDateTime.now();\nSystem.out.println(formatter.format(time));\n</code></pre>\n<h2 id=\"锁的正确释放\"><a href=\"#锁的正确释放\" class=\"headerlink\" title=\"锁的正确释放\"></a>锁的正确释放</h2><p>假设有这样一段伪代码：</p>\n<pre><code class=\"java\">Lock lock = new ReentrantLock();\n...  \ntry&#123;\n  lock.tryLock(timeout, TimeUnit.MILLISECONDS)\n  //业务逻辑\n&#125;\ncatch (Exception e)&#123;\n  //错误日志\n  //抛出异常或直接返回\n&#125;\nfinally &#123;\n  //业务逻辑\n  lock.unlock();\n&#125;\n...\n</code></pre>\n<p>这段代码中在finally代码块释放锁之前，执行了一段业务逻辑</p>\n<p>假如不巧这段逻辑中依赖服务不可用导致占用锁的线程不能成功释放锁，会造成其他线程因无法获取锁而阻塞，最终线程池被打满的问题</p>\n<p><strong>所以在释放锁之前；finally子句中应该只有对当前线程占有的资源(如锁、IO流等)进行释放的一些处理</strong></p>\n<p><strong>还有就是获取锁时设置合理的超时时间</strong></p>\n<p>为了避免线程因获取不到锁而一直阻塞，可以设置一个超时时间，当获取锁超时后，线程可以抛出异常或返回一个错误的状态码。其中超时时间的设置也要合理，不应过长，并且应该大于锁住的业务逻辑的执行时间。</p>\n<h2 id=\"正确使用线程池\"><a href=\"#正确使用线程池\" class=\"headerlink\" title=\"正确使用线程池\"></a>正确使用线程池</h2><h3 id=\"案例1-1\"><a href=\"#案例1-1\" class=\"headerlink\" title=\"案例1\"></a>案例1</h3><p><strong>不要将线程池作为局部变量使用</strong></p>\n<pre><code class=\"java\">public void request(List&lt;Id&gt; ids) &#123;\n  for (int i = 0; i &lt; ids.size(); i++) &#123;\n     ExecutorService threadPool = Executors.newSingleThreadExecutor();\n  &#125;\n&#125;\n</code></pre>\n<p>在for循环中创建线程池，那么每次执行该方法时，入参的list长度有多大就会创建多少个线程池，并且方法执行完后也没有及时调用shutdown()方法将线程池销毁</p>\n<p>这样的话，随着不断有请求进来，线程池占用的内存会越来越多，就会导致频繁fullGC甚至OOM。每次方法调用都创建线程池是很不合理的，因为这和自己频繁创建、销毁线程没有区别，不仅没有利用线程池的优势，反而还会耗费线程池所需的更多资源</p>\n<p><strong>所以尽量将线程池作为全局变量使用</strong></p>\n<h3 id=\"案例2-1\"><a href=\"#案例2-1\" class=\"headerlink\" title=\"案例2\"></a>案例2</h3><p><strong>谨慎使用默认的线程池静态方法</strong></p>\n<pre><code class=\"java\">Executors.newFixedThreadPool(int);     //创建固定容量大小的线程池\nExecutors.newSingleThreadExecutor();   //创建容量为1的线程池\nExecutors.newCachedThreadPool();       //创建一个线程池，线程池容量大小为Integer.MAX_VALUE\n</code></pre>\n<p>上述三个默认线程池的风险点：</p>\n<p>newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，使用的阻塞队列是LinkedBlockingQueue。</p>\n<p>newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue</p>\n<p>LinkedBlockingQueue默认容量为<code>Integer.MAX_VALUE=2147483647</code>，对于真正的机器来说，可以被认为是无界队列</p>\n<ul>\n<li>newFixedThreadPool和newSingleThreadExecutor在运行的线程数超过corePoolSize时，后来的请求会都被放到阻塞队列中等待，因为阻塞队列设置的过大，后来请求不能快速失败而长时间阻塞，就可能造成请求端的线程池被打满，拖垮整个服务。</li>\n</ul>\n<p>newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为<code>Integer.MAX_VALUE</code>，阻塞队列使用的SynchronousQueue，SynchronousQueue不会保存等待执行的任务</p>\n<ul>\n<li>所以newCachedThreadPool是来了任务就创建线程运行，而maximumPoolSize相当于无限的设置，使得创建的线程数可能会将机器内存占满。</li>\n</ul>\n<p><strong>所以需要根据自身业务和硬件配置创建自定义线程池</strong></p>\n<h3 id=\"线程数建议\"><a href=\"#线程数建议\" class=\"headerlink\" title=\"线程数建议\"></a>线程数建议</h3><p><strong>线程池corePoolSize数量设置建议</strong>：</p>\n<blockquote>\n<p>1.CPU密集型应用</p>\n</blockquote>\n<p>CPU密集的意思是任务需要进行大量复杂的运算，几乎没有阻塞，需要CPU长时间高速运行。</p>\n<p>一般公式：<code>corePoolSize=CPU核数+1个线程</code>。JVM可运行的CPU核数可以通过<code>Runtime.getRuntime().availableProcessors()</code>查看。</p>\n<blockquote>\n<p>2.IO密集型应用</p>\n</blockquote>\n<p>IO密集型任务会涉及到很多的磁盘读写或网络传输，线程花费更多的时间在IO阻塞上，而不是CPU运算。一般的业务应用都属于IO密集型。</p>\n<p><strong>参考公式：最佳线程数&#x3D;CPU数&#x2F;(1-阻塞系数);  阻塞系数&#x3D;线程等待时间&#x2F;(线程等待时间+CPU处理时间) 。</strong></p>\n<p>IO密集型任务的CPU处理时间往往远小于线程等待时间，所以阻塞系数一般认为在0.8-0.9之间，以4核单槽CPU为例，corePoolSize可设置为 4&#x2F;(1-0.9)&#x3D;40。当然具体的设置还是要根据机器实际运行中的各项指标而定</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>写文章画图不易，喜欢的话，希望帮忙点赞，转发下哈，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，获得免费电子书籍，必读经典书籍这里全都有</p>\n<p>参考书籍：</p>\n<ul>\n<li>Java并发编程实战</li>\n</ul>\n"},{"title":"缓存一致性","_content":"\n# 前言\n\n一道之前的面试题：\n\n> 如何保证缓存和数据库的一致性？\n\n来自：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect)\n\n* 文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n下面介绍几种方案（大家回答的时候最好根据自己的业务，结合下面的方案）\n\n# 方案分析\n\n**更新缓存策略方式常见的有下面几种：**\n\n1. 先更新缓存，再更新数据库\n2. 先更新数据库，再更新缓存\n3. 先删除缓存，再更新数据库\n4. 先更新数据库，再删除缓存\n\n下面一一介绍！\n\n**方案一：更新缓存，更新数据库**\n\n这种方式可轻易排除，因为如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。\n\n**方案二：更新数据库，更新缓存**\n\n这种缓存更新策略俗称双写，存在问题是：并发更新数据库场景下，会将脏数据刷到缓存\n\n```java\nupdateDB();\nupdateRedis();\n```\n\n举例：如果在两个操作之间数据库和缓存又被后面请求修改，此时再去更新缓存已经是过期数据了。\n\n![](https://img-blog.csdnimg.cn/0e6f449591c94305ad1c0e19392b39dd.png)\n\n**方案三：删除缓存，更新数据库**\n\n存在问题：更新数据库之前，若有查询请求，会将脏数据刷到缓存\n\n```java\ndeleteRedis();\nupdateDB();\n```\n\n举例：如果在两个操作之间发生了数据查询，那么会有旧数据放入缓存。\n\n![](https://img-blog.csdnimg.cn/6568e71251f342cda5a5489f40cc8e7d.png)\n\n该方案会导致请求数据不一致\n\n如果同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n\n- 请求A进行写操作，删除缓存\n- 请求B查询发现缓存不存在\n- 请求B去数据库查询得到旧值\n- 请求B将旧值写入缓存\n- 请求A将新值写入数据库\n\n上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n\n**方案四：更新数据库，删除缓存**\n\n存在问题：在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存\n\n```java\nupdateDB();\ndeleteRedis();\n```\n\n举例：如果在查询数据库和放入缓存这两个操作中间发生了数据更新并且删除缓存，那么会有旧数据放入缓存。\n\n![](https://img-blog.csdnimg.cn/b8afec9a7ed14404a107a3742c95342e.png)\n\n假设有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n\n- 缓存刚好失效\n- 请求A查询数据库，得一个旧值\n- 请求B将新值写入数据库\n- 请求B删除缓存\n- 请求A将查到的旧值写入缓存\n\n如果发生上述情况，确实是会发生脏数据。但是发生上述情况有一个先天性条件，就是写数据库操作比读数据库操作耗时更短\n\n**不过数据库的读操作的速度远快于写操作的**\n\n因此这一情形很难出现。\n\n# 方案对比\n\n**方案1和方案2的共同缺点：**\n\n并发更新数据库场景下，会将脏数据刷到缓存，但一般并发写的场景概率都相对小一些；\n\n线程安全角度，会产生脏数据，比如：\n\n- 线程A更新了数据库\n- 线程B更新了数据库\n- 线程B更新了缓存\n- 线程A更新了缓存\n\n**方案3和方案4的共同缺点：**\n\n不管采用哪种顺序，2种方式都是存在一些问题的：\n\n- 主从延时问题：不管是先删除还是后删除，数据库主从延时可能导致脏数据的产生。\n- 缓存删除失败：如果缓存删除失败，则都会产生脏数据。\n\n问题解决思路：延迟双删，添加重试机制，下面介绍！\n\n**更新缓存还是删除缓存？**\n\n1.更新缓存缓存需要有一定的维护成本，而且会存在并发更新的问题\n\n2.写多读少的情况下，读请求还没有来，缓存以及被更新很多次，没有起到缓存的作用\n\n3.放入缓存的值可能是经过复杂计算的，如果每次更新，都计算写入缓存的值，浪费性能的\n\n删除缓存优点：简单、成本低，容易开发；缺点：会造成一次cache miss\n\n如果更新缓存开销较小并且读多写少，基本不会有写并发的时候可以才用更新缓存，否则通用做法还是删除缓存。\n\n# 总结\n\n| 方案                   | 问题                                                         | 问题出现概率                          | 推荐程度                                                     |\n| :--------------------- | :----------------------------------------------------------- | :------------------------------------ | :----------------------------------------------------------- |\n| 更新缓存 -> 更新数据库 | 为了保证数据准确性，数据必须以数据库更新结果为准，所以该方案绝不可行 | 大                                    | 不推荐                                                       |\n| 更新数据库 -> 更新缓存 | 并发更新数据库场景下，会将脏数据刷到缓存                     | 并发写场景，概率一般                  | 写请求较多时会出现不一致问题，不推荐使用。                   |\n| 删除缓存 -> 更新数据库 | 更新数据库之前，若有查询请求，会将脏数据刷到缓存             | 并发读场景，概率较大                  | 读请求较多时会出现不一致问题，不推荐使用                     |\n| 更新数据库 -> 删除缓存 | 在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存 | 并发读场景&读操作慢于写操作，概率最小 | **读操作比写操作更慢的情况较少，相比于其他方式出错的概率小一些。勉强推荐。** |\n\n# 推荐方案\n\n## 延迟双删\n\n采用更新前后双删除缓存策略\n\n```java\npublic void write(String key,Object data){\n  redis.del(key);\n     db.update(data);\n     Thread.sleep(1000);\n     redis.del(key);\n }\n```\n\n- 先淘汰缓存\n- 再写数据库\n- 休眠1秒，再次淘汰缓存\n\n大家应该评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上即可。\n\n这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n\n**问题及解法：**\n\n1、同步删除，吞吐量降低如何处理\n\n将第二次删除作为异步的，提交一个延迟的执行任务\n\n2、解决删除失败的方式：\n\n添加重试机制，例如：将删除失败的key，写入消息队列；但对业务耦合有些严重；\n\n![](https://img-blog.csdnimg.cn/84cbe8cf3ba0452aa6471278ff19ad8c.png)\n\n**延时工具可以选择：**\n\n最普通的阻塞`Thread.currentThread().sleep(1000);`\n\nJdk调度线程池，quartz定时任务，利用jdk自带的delayQueue，netty的HashWheelTimer，Rabbitmq的延时队列，等等\n\n# 实际场景\n\n我们有个商品中心的场景，是读多写少的服务，并且写数据会发送MQ通知下游拿数据，这样就需要严格保证缓存和数据库的一致性，需要提供高可靠的系统服务能力。\n\n## 写缓存策略\n\n1. 缓存key设置失效时间\n2. 先DB操作，再缓存失效\n3. 写操作都标记key（美团中间件）强制走主库\n4. 接入美团中间件监听binlog（美团中间件）变化的数据在进行兜底，再删除缓存\n\n![](https://img-blog.csdnimg.cn/5824f3a231334f37af2290fb5d341832.png)\n\n## 读缓存策略\n\n1. 先判断是否走主库\n2. 如果走主库，则使用标记（美团中间件）查主库\n3. 如果不是，则查看缓存中是否有数据\n4. 缓存中有数据，则使用缓存数据作为结果\n5. 如果没有，则查DB数据，再写数据到缓存\n\n![](https://img-blog.csdnimg.cn/44a5fb73144d4545b52919127efb5bbb.png)\n\n# 注意\n\n关于缓存过期时间的问题\n\n如果缓存设置了过期时间，那么上述的所有不一致情况都只是暂时的。\n\n但是如果没有设置过期时间，那么不一致问题就只能等到下次更新数据时解决。\n\n所以一定要**设置缓存过期时间**。\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，可以获得免费电子书籍","source":"_posts/公众号文章/缓存一致性.md","raw":"---\ntitle: 缓存一致性\ncategories: \n- 公众号文章\n---\n\n# 前言\n\n一道之前的面试题：\n\n> 如何保证缓存和数据库的一致性？\n\n来自：[社招一年半面经分享(含阿里美团头条京东滴滴)](https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect)\n\n* 文章首发在公众号（月伴飞鱼），之后同步到个人网站：https://xiaoflyfish.cn/\n\n微信搜索：**月伴飞鱼**，交个朋友，进面试交流群\n\n* 公众号后台回复666，可以获得免费电子书籍\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png)\n\n下面介绍几种方案（大家回答的时候最好根据自己的业务，结合下面的方案）\n\n# 方案分析\n\n**更新缓存策略方式常见的有下面几种：**\n\n1. 先更新缓存，再更新数据库\n2. 先更新数据库，再更新缓存\n3. 先删除缓存，再更新数据库\n4. 先更新数据库，再删除缓存\n\n下面一一介绍！\n\n**方案一：更新缓存，更新数据库**\n\n这种方式可轻易排除，因为如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。\n\n**方案二：更新数据库，更新缓存**\n\n这种缓存更新策略俗称双写，存在问题是：并发更新数据库场景下，会将脏数据刷到缓存\n\n```java\nupdateDB();\nupdateRedis();\n```\n\n举例：如果在两个操作之间数据库和缓存又被后面请求修改，此时再去更新缓存已经是过期数据了。\n\n![](https://img-blog.csdnimg.cn/0e6f449591c94305ad1c0e19392b39dd.png)\n\n**方案三：删除缓存，更新数据库**\n\n存在问题：更新数据库之前，若有查询请求，会将脏数据刷到缓存\n\n```java\ndeleteRedis();\nupdateDB();\n```\n\n举例：如果在两个操作之间发生了数据查询，那么会有旧数据放入缓存。\n\n![](https://img-blog.csdnimg.cn/6568e71251f342cda5a5489f40cc8e7d.png)\n\n该方案会导致请求数据不一致\n\n如果同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:\n\n- 请求A进行写操作，删除缓存\n- 请求B查询发现缓存不存在\n- 请求B去数据库查询得到旧值\n- 请求B将旧值写入缓存\n- 请求A将新值写入数据库\n\n上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。\n\n**方案四：更新数据库，删除缓存**\n\n存在问题：在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存\n\n```java\nupdateDB();\ndeleteRedis();\n```\n\n举例：如果在查询数据库和放入缓存这两个操作中间发生了数据更新并且删除缓存，那么会有旧数据放入缓存。\n\n![](https://img-blog.csdnimg.cn/b8afec9a7ed14404a107a3742c95342e.png)\n\n假设有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生\n\n- 缓存刚好失效\n- 请求A查询数据库，得一个旧值\n- 请求B将新值写入数据库\n- 请求B删除缓存\n- 请求A将查到的旧值写入缓存\n\n如果发生上述情况，确实是会发生脏数据。但是发生上述情况有一个先天性条件，就是写数据库操作比读数据库操作耗时更短\n\n**不过数据库的读操作的速度远快于写操作的**\n\n因此这一情形很难出现。\n\n# 方案对比\n\n**方案1和方案2的共同缺点：**\n\n并发更新数据库场景下，会将脏数据刷到缓存，但一般并发写的场景概率都相对小一些；\n\n线程安全角度，会产生脏数据，比如：\n\n- 线程A更新了数据库\n- 线程B更新了数据库\n- 线程B更新了缓存\n- 线程A更新了缓存\n\n**方案3和方案4的共同缺点：**\n\n不管采用哪种顺序，2种方式都是存在一些问题的：\n\n- 主从延时问题：不管是先删除还是后删除，数据库主从延时可能导致脏数据的产生。\n- 缓存删除失败：如果缓存删除失败，则都会产生脏数据。\n\n问题解决思路：延迟双删，添加重试机制，下面介绍！\n\n**更新缓存还是删除缓存？**\n\n1.更新缓存缓存需要有一定的维护成本，而且会存在并发更新的问题\n\n2.写多读少的情况下，读请求还没有来，缓存以及被更新很多次，没有起到缓存的作用\n\n3.放入缓存的值可能是经过复杂计算的，如果每次更新，都计算写入缓存的值，浪费性能的\n\n删除缓存优点：简单、成本低，容易开发；缺点：会造成一次cache miss\n\n如果更新缓存开销较小并且读多写少，基本不会有写并发的时候可以才用更新缓存，否则通用做法还是删除缓存。\n\n# 总结\n\n| 方案                   | 问题                                                         | 问题出现概率                          | 推荐程度                                                     |\n| :--------------------- | :----------------------------------------------------------- | :------------------------------------ | :----------------------------------------------------------- |\n| 更新缓存 -> 更新数据库 | 为了保证数据准确性，数据必须以数据库更新结果为准，所以该方案绝不可行 | 大                                    | 不推荐                                                       |\n| 更新数据库 -> 更新缓存 | 并发更新数据库场景下，会将脏数据刷到缓存                     | 并发写场景，概率一般                  | 写请求较多时会出现不一致问题，不推荐使用。                   |\n| 删除缓存 -> 更新数据库 | 更新数据库之前，若有查询请求，会将脏数据刷到缓存             | 并发读场景，概率较大                  | 读请求较多时会出现不一致问题，不推荐使用                     |\n| 更新数据库 -> 删除缓存 | 在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存 | 并发读场景&读操作慢于写操作，概率最小 | **读操作比写操作更慢的情况较少，相比于其他方式出错的概率小一些。勉强推荐。** |\n\n# 推荐方案\n\n## 延迟双删\n\n采用更新前后双删除缓存策略\n\n```java\npublic void write(String key,Object data){\n  redis.del(key);\n     db.update(data);\n     Thread.sleep(1000);\n     redis.del(key);\n }\n```\n\n- 先淘汰缓存\n- 再写数据库\n- 休眠1秒，再次淘汰缓存\n\n大家应该评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上即可。\n\n这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。\n\n**问题及解法：**\n\n1、同步删除，吞吐量降低如何处理\n\n将第二次删除作为异步的，提交一个延迟的执行任务\n\n2、解决删除失败的方式：\n\n添加重试机制，例如：将删除失败的key，写入消息队列；但对业务耦合有些严重；\n\n![](https://img-blog.csdnimg.cn/84cbe8cf3ba0452aa6471278ff19ad8c.png)\n\n**延时工具可以选择：**\n\n最普通的阻塞`Thread.currentThread().sleep(1000);`\n\nJdk调度线程池，quartz定时任务，利用jdk自带的delayQueue，netty的HashWheelTimer，Rabbitmq的延时队列，等等\n\n# 实际场景\n\n我们有个商品中心的场景，是读多写少的服务，并且写数据会发送MQ通知下游拿数据，这样就需要严格保证缓存和数据库的一致性，需要提供高可靠的系统服务能力。\n\n## 写缓存策略\n\n1. 缓存key设置失效时间\n2. 先DB操作，再缓存失效\n3. 写操作都标记key（美团中间件）强制走主库\n4. 接入美团中间件监听binlog（美团中间件）变化的数据在进行兜底，再删除缓存\n\n![](https://img-blog.csdnimg.cn/5824f3a231334f37af2290fb5d341832.png)\n\n## 读缓存策略\n\n1. 先判断是否走主库\n2. 如果走主库，则使用标记（美团中间件）查主库\n3. 如果不是，则查看缓存中是否有数据\n4. 缓存中有数据，则使用缓存数据作为结果\n5. 如果没有，则查DB数据，再写数据到缓存\n\n![](https://img-blog.csdnimg.cn/44a5fb73144d4545b52919127efb5bbb.png)\n\n# 注意\n\n关于缓存过期时间的问题\n\n如果缓存设置了过期时间，那么上述的所有不一致情况都只是暂时的。\n\n但是如果没有设置过期时间，那么不一致问题就只能等到下次更新数据时解决。\n\n所以一定要**设置缓存过期时间**。\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，可以获得免费电子书籍","slug":"公众号文章/缓存一致性","published":1,"date":"2022-03-01T15:50:22.331Z","updated":"2022-03-01T16:36:03.592Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiy00f9fhji2n747qjt","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>一道之前的面试题：</p>\n<blockquote>\n<p>如何保证缓存和数据库的一致性？</p>\n</blockquote>\n<p>来自：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></p>\n<ul>\n<li>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></li>\n</ul>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>下面介绍几种方案（大家回答的时候最好根据自己的业务，结合下面的方案）</p>\n<h1 id=\"方案分析\"><a href=\"#方案分析\" class=\"headerlink\" title=\"方案分析\"></a>方案分析</h1><p><strong>更新缓存策略方式常见的有下面几种：</strong></p>\n<ol>\n<li>先更新缓存，再更新数据库</li>\n<li>先更新数据库，再更新缓存</li>\n<li>先删除缓存，再更新数据库</li>\n<li>先更新数据库，再删除缓存</li>\n</ol>\n<p>下面一一介绍！</p>\n<p><strong>方案一：更新缓存，更新数据库</strong></p>\n<p>这种方式可轻易排除，因为如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p>\n<p><strong>方案二：更新数据库，更新缓存</strong></p>\n<p>这种缓存更新策略俗称双写，存在问题是：并发更新数据库场景下，会将脏数据刷到缓存</p>\n<pre><code class=\"java\">updateDB();\nupdateRedis();\n</code></pre>\n<p>举例：如果在两个操作之间数据库和缓存又被后面请求修改，此时再去更新缓存已经是过期数据了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0e6f449591c94305ad1c0e19392b39dd.png\"></p>\n<p><strong>方案三：删除缓存，更新数据库</strong></p>\n<p>存在问题：更新数据库之前，若有查询请求，会将脏数据刷到缓存</p>\n<pre><code class=\"java\">deleteRedis();\nupdateDB();\n</code></pre>\n<p>举例：如果在两个操作之间发生了数据查询，那么会有旧数据放入缓存。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6568e71251f342cda5a5489f40cc8e7d.png\"></p>\n<p>该方案会导致请求数据不一致</p>\n<p>如果同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>\n<ul>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求B查询发现缓存不存在</li>\n<li>请求B去数据库查询得到旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>请求A将新值写入数据库</li>\n</ul>\n<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>\n<p><strong>方案四：更新数据库，删除缓存</strong></p>\n<p>存在问题：在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存</p>\n<pre><code class=\"java\">updateDB();\ndeleteRedis();\n</code></pre>\n<p>举例：如果在查询数据库和放入缓存这两个操作中间发生了数据更新并且删除缓存，那么会有旧数据放入缓存。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b8afec9a7ed14404a107a3742c95342e.png\"></p>\n<p>假设有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>\n<ul>\n<li>缓存刚好失效</li>\n<li>请求A查询数据库，得一个旧值</li>\n<li>请求B将新值写入数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存</li>\n</ul>\n<p>如果发生上述情况，确实是会发生脏数据。但是发生上述情况有一个先天性条件，就是写数据库操作比读数据库操作耗时更短</p>\n<p><strong>不过数据库的读操作的速度远快于写操作的</strong></p>\n<p>因此这一情形很难出现。</p>\n<h1 id=\"方案对比\"><a href=\"#方案对比\" class=\"headerlink\" title=\"方案对比\"></a>方案对比</h1><p><strong>方案1和方案2的共同缺点：</strong></p>\n<p>并发更新数据库场景下，会将脏数据刷到缓存，但一般并发写的场景概率都相对小一些；</p>\n<p>线程安全角度，会产生脏数据，比如：</p>\n<ul>\n<li>线程A更新了数据库</li>\n<li>线程B更新了数据库</li>\n<li>线程B更新了缓存</li>\n<li>线程A更新了缓存</li>\n</ul>\n<p><strong>方案3和方案4的共同缺点：</strong></p>\n<p>不管采用哪种顺序，2种方式都是存在一些问题的：</p>\n<ul>\n<li>主从延时问题：不管是先删除还是后删除，数据库主从延时可能导致脏数据的产生。</li>\n<li>缓存删除失败：如果缓存删除失败，则都会产生脏数据。</li>\n</ul>\n<p>问题解决思路：延迟双删，添加重试机制，下面介绍！</p>\n<p><strong>更新缓存还是删除缓存？</strong></p>\n<p>1.更新缓存缓存需要有一定的维护成本，而且会存在并发更新的问题</p>\n<p>2.写多读少的情况下，读请求还没有来，缓存以及被更新很多次，没有起到缓存的作用</p>\n<p>3.放入缓存的值可能是经过复杂计算的，如果每次更新，都计算写入缓存的值，浪费性能的</p>\n<p>删除缓存优点：简单、成本低，容易开发；缺点：会造成一次cache miss</p>\n<p>如果更新缓存开销较小并且读多写少，基本不会有写并发的时候可以才用更新缓存，否则通用做法还是删除缓存。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><table>\n<thead>\n<tr>\n<th align=\"left\">方案</th>\n<th align=\"left\">问题</th>\n<th align=\"left\">问题出现概率</th>\n<th align=\"left\">推荐程度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">更新缓存 -&gt; 更新数据库</td>\n<td align=\"left\">为了保证数据准确性，数据必须以数据库更新结果为准，所以该方案绝不可行</td>\n<td align=\"left\">大</td>\n<td align=\"left\">不推荐</td>\n</tr>\n<tr>\n<td align=\"left\">更新数据库 -&gt; 更新缓存</td>\n<td align=\"left\">并发更新数据库场景下，会将脏数据刷到缓存</td>\n<td align=\"left\">并发写场景，概率一般</td>\n<td align=\"left\">写请求较多时会出现不一致问题，不推荐使用。</td>\n</tr>\n<tr>\n<td align=\"left\">删除缓存 -&gt; 更新数据库</td>\n<td align=\"left\">更新数据库之前，若有查询请求，会将脏数据刷到缓存</td>\n<td align=\"left\">并发读场景，概率较大</td>\n<td align=\"left\">读请求较多时会出现不一致问题，不推荐使用</td>\n</tr>\n<tr>\n<td align=\"left\">更新数据库 -&gt; 删除缓存</td>\n<td align=\"left\">在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存</td>\n<td align=\"left\">并发读场景&amp;读操作慢于写操作，概率最小</td>\n<td align=\"left\"><strong>读操作比写操作更慢的情况较少，相比于其他方式出错的概率小一些。勉强推荐。</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"推荐方案\"><a href=\"#推荐方案\" class=\"headerlink\" title=\"推荐方案\"></a>推荐方案</h1><h2 id=\"延迟双删\"><a href=\"#延迟双删\" class=\"headerlink\" title=\"延迟双删\"></a>延迟双删</h2><p>采用更新前后双删除缓存策略</p>\n<pre><code class=\"java\">public void write(String key,Object data)&#123;\n  redis.del(key);\n     db.update(data);\n     Thread.sleep(1000);\n     redis.del(key);\n &#125;\n</code></pre>\n<ul>\n<li>先淘汰缓存</li>\n<li>再写数据库</li>\n<li>休眠1秒，再次淘汰缓存</li>\n</ul>\n<p>大家应该评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上即可。</p>\n<p>这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>\n<p><strong>问题及解法：</strong></p>\n<p>1、同步删除，吞吐量降低如何处理</p>\n<p>将第二次删除作为异步的，提交一个延迟的执行任务</p>\n<p>2、解决删除失败的方式：</p>\n<p>添加重试机制，例如：将删除失败的key，写入消息队列；但对业务耦合有些严重；</p>\n<p><img src=\"https://img-blog.csdnimg.cn/84cbe8cf3ba0452aa6471278ff19ad8c.png\"></p>\n<p><strong>延时工具可以选择：</strong></p>\n<p>最普通的阻塞<code>Thread.currentThread().sleep(1000);</code></p>\n<p>Jdk调度线程池，quartz定时任务，利用jdk自带的delayQueue，netty的HashWheelTimer，Rabbitmq的延时队列，等等</p>\n<h1 id=\"实际场景\"><a href=\"#实际场景\" class=\"headerlink\" title=\"实际场景\"></a>实际场景</h1><p>我们有个商品中心的场景，是读多写少的服务，并且写数据会发送MQ通知下游拿数据，这样就需要严格保证缓存和数据库的一致性，需要提供高可靠的系统服务能力。</p>\n<h2 id=\"写缓存策略\"><a href=\"#写缓存策略\" class=\"headerlink\" title=\"写缓存策略\"></a>写缓存策略</h2><ol>\n<li>缓存key设置失效时间</li>\n<li>先DB操作，再缓存失效</li>\n<li>写操作都标记key（美团中间件）强制走主库</li>\n<li>接入美团中间件监听binlog（美团中间件）变化的数据在进行兜底，再删除缓存</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/5824f3a231334f37af2290fb5d341832.png\"></p>\n<h2 id=\"读缓存策略\"><a href=\"#读缓存策略\" class=\"headerlink\" title=\"读缓存策略\"></a>读缓存策略</h2><ol>\n<li>先判断是否走主库</li>\n<li>如果走主库，则使用标记（美团中间件）查主库</li>\n<li>如果不是，则查看缓存中是否有数据</li>\n<li>缓存中有数据，则使用缓存数据作为结果</li>\n<li>如果没有，则查DB数据，再写数据到缓存</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/44a5fb73144d4545b52919127efb5bbb.png\"></p>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>关于缓存过期时间的问题</p>\n<p>如果缓存设置了过期时间，那么上述的所有不一致情况都只是暂时的。</p>\n<p>但是如果没有设置过期时间，那么不一致问题就只能等到下次更新数据时解决。</p>\n<p>所以一定要<strong>设置缓存过期时间</strong>。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>一道之前的面试题：</p>\n<blockquote>\n<p>如何保证缓存和数据库的一致性？</p>\n</blockquote>\n<p>来自：<a href=\"https://mp.weixin.qq.com/s?__biz=MzUyOTg1OTkyMA==&mid=2247484910&idx=1&sn=c686a382915e18bfc7bca152aa8590de&scene=21#wechat_redirect\">社招一年半面经分享(含阿里美团头条京东滴滴)</a></p>\n<ul>\n<li>文章首发在公众号（月伴飞鱼），之后同步到个人网站：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></li>\n</ul>\n<p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群</p>\n<ul>\n<li>公众号后台回复666，可以获得免费电子书籍</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/ed97dd67ef6f4df4adde3af262888c6f.png\"></p>\n<p>下面介绍几种方案（大家回答的时候最好根据自己的业务，结合下面的方案）</p>\n<h1 id=\"方案分析\"><a href=\"#方案分析\" class=\"headerlink\" title=\"方案分析\"></a>方案分析</h1><p><strong>更新缓存策略方式常见的有下面几种：</strong></p>\n<ol>\n<li>先更新缓存，再更新数据库</li>\n<li>先更新数据库，再更新缓存</li>\n<li>先删除缓存，再更新数据库</li>\n<li>先更新数据库，再删除缓存</li>\n</ol>\n<p>下面一一介绍！</p>\n<p><strong>方案一：更新缓存，更新数据库</strong></p>\n<p>这种方式可轻易排除，因为如果先更新缓存成功，但是数据库更新失败，则肯定会造成数据不一致。</p>\n<p><strong>方案二：更新数据库，更新缓存</strong></p>\n<p>这种缓存更新策略俗称双写，存在问题是：并发更新数据库场景下，会将脏数据刷到缓存</p>\n<pre><code class=\"java\">updateDB();\nupdateRedis();\n</code></pre>\n<p>举例：如果在两个操作之间数据库和缓存又被后面请求修改，此时再去更新缓存已经是过期数据了。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0e6f449591c94305ad1c0e19392b39dd.png\"></p>\n<p><strong>方案三：删除缓存，更新数据库</strong></p>\n<p>存在问题：更新数据库之前，若有查询请求，会将脏数据刷到缓存</p>\n<pre><code class=\"java\">deleteRedis();\nupdateDB();\n</code></pre>\n<p>举例：如果在两个操作之间发生了数据查询，那么会有旧数据放入缓存。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6568e71251f342cda5a5489f40cc8e7d.png\"></p>\n<p>该方案会导致请求数据不一致</p>\n<p>如果同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:</p>\n<ul>\n<li>请求A进行写操作，删除缓存</li>\n<li>请求B查询发现缓存不存在</li>\n<li>请求B去数据库查询得到旧值</li>\n<li>请求B将旧值写入缓存</li>\n<li>请求A将新值写入数据库</li>\n</ul>\n<p>上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。</p>\n<p><strong>方案四：更新数据库，删除缓存</strong></p>\n<p>存在问题：在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存</p>\n<pre><code class=\"java\">updateDB();\ndeleteRedis();\n</code></pre>\n<p>举例：如果在查询数据库和放入缓存这两个操作中间发生了数据更新并且删除缓存，那么会有旧数据放入缓存。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/b8afec9a7ed14404a107a3742c95342e.png\"></p>\n<p>假设有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生</p>\n<ul>\n<li>缓存刚好失效</li>\n<li>请求A查询数据库，得一个旧值</li>\n<li>请求B将新值写入数据库</li>\n<li>请求B删除缓存</li>\n<li>请求A将查到的旧值写入缓存</li>\n</ul>\n<p>如果发生上述情况，确实是会发生脏数据。但是发生上述情况有一个先天性条件，就是写数据库操作比读数据库操作耗时更短</p>\n<p><strong>不过数据库的读操作的速度远快于写操作的</strong></p>\n<p>因此这一情形很难出现。</p>\n<h1 id=\"方案对比\"><a href=\"#方案对比\" class=\"headerlink\" title=\"方案对比\"></a>方案对比</h1><p><strong>方案1和方案2的共同缺点：</strong></p>\n<p>并发更新数据库场景下，会将脏数据刷到缓存，但一般并发写的场景概率都相对小一些；</p>\n<p>线程安全角度，会产生脏数据，比如：</p>\n<ul>\n<li>线程A更新了数据库</li>\n<li>线程B更新了数据库</li>\n<li>线程B更新了缓存</li>\n<li>线程A更新了缓存</li>\n</ul>\n<p><strong>方案3和方案4的共同缺点：</strong></p>\n<p>不管采用哪种顺序，2种方式都是存在一些问题的：</p>\n<ul>\n<li>主从延时问题：不管是先删除还是后删除，数据库主从延时可能导致脏数据的产生。</li>\n<li>缓存删除失败：如果缓存删除失败，则都会产生脏数据。</li>\n</ul>\n<p>问题解决思路：延迟双删，添加重试机制，下面介绍！</p>\n<p><strong>更新缓存还是删除缓存？</strong></p>\n<p>1.更新缓存缓存需要有一定的维护成本，而且会存在并发更新的问题</p>\n<p>2.写多读少的情况下，读请求还没有来，缓存以及被更新很多次，没有起到缓存的作用</p>\n<p>3.放入缓存的值可能是经过复杂计算的，如果每次更新，都计算写入缓存的值，浪费性能的</p>\n<p>删除缓存优点：简单、成本低，容易开发；缺点：会造成一次cache miss</p>\n<p>如果更新缓存开销较小并且读多写少，基本不会有写并发的时候可以才用更新缓存，否则通用做法还是删除缓存。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><table>\n<thead>\n<tr>\n<th align=\"left\">方案</th>\n<th align=\"left\">问题</th>\n<th align=\"left\">问题出现概率</th>\n<th align=\"left\">推荐程度</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">更新缓存 -&gt; 更新数据库</td>\n<td align=\"left\">为了保证数据准确性，数据必须以数据库更新结果为准，所以该方案绝不可行</td>\n<td align=\"left\">大</td>\n<td align=\"left\">不推荐</td>\n</tr>\n<tr>\n<td align=\"left\">更新数据库 -&gt; 更新缓存</td>\n<td align=\"left\">并发更新数据库场景下，会将脏数据刷到缓存</td>\n<td align=\"left\">并发写场景，概率一般</td>\n<td align=\"left\">写请求较多时会出现不一致问题，不推荐使用。</td>\n</tr>\n<tr>\n<td align=\"left\">删除缓存 -&gt; 更新数据库</td>\n<td align=\"left\">更新数据库之前，若有查询请求，会将脏数据刷到缓存</td>\n<td align=\"left\">并发读场景，概率较大</td>\n<td align=\"left\">读请求较多时会出现不一致问题，不推荐使用</td>\n</tr>\n<tr>\n<td align=\"left\">更新数据库 -&gt; 删除缓存</td>\n<td align=\"left\">在更新数据库之前有查询请求，并且缓存失效了，会查询数据库，然后更新缓存。如果在查询数据库和更新缓存之间进行了数据库更新的操作，那么就会把脏数据刷到缓存</td>\n<td align=\"left\">并发读场景&amp;读操作慢于写操作，概率最小</td>\n<td align=\"left\"><strong>读操作比写操作更慢的情况较少，相比于其他方式出错的概率小一些。勉强推荐。</strong></td>\n</tr>\n</tbody></table>\n<h1 id=\"推荐方案\"><a href=\"#推荐方案\" class=\"headerlink\" title=\"推荐方案\"></a>推荐方案</h1><h2 id=\"延迟双删\"><a href=\"#延迟双删\" class=\"headerlink\" title=\"延迟双删\"></a>延迟双删</h2><p>采用更新前后双删除缓存策略</p>\n<pre><code class=\"java\">public void write(String key,Object data)&#123;\n  redis.del(key);\n     db.update(data);\n     Thread.sleep(1000);\n     redis.del(key);\n &#125;\n</code></pre>\n<ul>\n<li>先淘汰缓存</li>\n<li>再写数据库</li>\n<li>休眠1秒，再次淘汰缓存</li>\n</ul>\n<p>大家应该评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上即可。</p>\n<p>这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。</p>\n<p><strong>问题及解法：</strong></p>\n<p>1、同步删除，吞吐量降低如何处理</p>\n<p>将第二次删除作为异步的，提交一个延迟的执行任务</p>\n<p>2、解决删除失败的方式：</p>\n<p>添加重试机制，例如：将删除失败的key，写入消息队列；但对业务耦合有些严重；</p>\n<p><img src=\"https://img-blog.csdnimg.cn/84cbe8cf3ba0452aa6471278ff19ad8c.png\"></p>\n<p><strong>延时工具可以选择：</strong></p>\n<p>最普通的阻塞<code>Thread.currentThread().sleep(1000);</code></p>\n<p>Jdk调度线程池，quartz定时任务，利用jdk自带的delayQueue，netty的HashWheelTimer，Rabbitmq的延时队列，等等</p>\n<h1 id=\"实际场景\"><a href=\"#实际场景\" class=\"headerlink\" title=\"实际场景\"></a>实际场景</h1><p>我们有个商品中心的场景，是读多写少的服务，并且写数据会发送MQ通知下游拿数据，这样就需要严格保证缓存和数据库的一致性，需要提供高可靠的系统服务能力。</p>\n<h2 id=\"写缓存策略\"><a href=\"#写缓存策略\" class=\"headerlink\" title=\"写缓存策略\"></a>写缓存策略</h2><ol>\n<li>缓存key设置失效时间</li>\n<li>先DB操作，再缓存失效</li>\n<li>写操作都标记key（美团中间件）强制走主库</li>\n<li>接入美团中间件监听binlog（美团中间件）变化的数据在进行兜底，再删除缓存</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/5824f3a231334f37af2290fb5d341832.png\"></p>\n<h2 id=\"读缓存策略\"><a href=\"#读缓存策略\" class=\"headerlink\" title=\"读缓存策略\"></a>读缓存策略</h2><ol>\n<li>先判断是否走主库</li>\n<li>如果走主库，则使用标记（美团中间件）查主库</li>\n<li>如果不是，则查看缓存中是否有数据</li>\n<li>缓存中有数据，则使用缓存数据作为结果</li>\n<li>如果没有，则查DB数据，再写数据到缓存</li>\n</ol>\n<p><img src=\"https://img-blog.csdnimg.cn/44a5fb73144d4545b52919127efb5bbb.png\"></p>\n<h1 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意\"></a>注意</h1><p>关于缓存过期时间的问题</p>\n<p>如果缓存设置了过期时间，那么上述的所有不一致情况都只是暂时的。</p>\n<p>但是如果没有设置过期时间，那么不一致问题就只能等到下次更新数据时解决。</p>\n<p>所以一定要<strong>设置缓存过期时间</strong>。</p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n"},{"title":"网络IO模型","_content":"\n# 前言\n\n文章会同步到个人网站，方便阅读：https://xiaoflyfish.cn/\n\n* 网站最近丰富了很多内容，都是满满的干货！\n\n* 微信搜索：**月伴飞鱼**，交个朋友，进面试交流群！\n\n* 公众号后台回复666，可以获得免费电子书籍！\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png)\n\n# 背景介绍\n\n* 在互联网的时代下，绝大部分数据都是通过网络来进行获取的。\n\n* 在服务端的架构中，绝大部分数据也是通过网络来进行交互的。\n\n而且作为服务端的开发工程师来说，都会进行一系列服务设计、开发以及能力开放，而服务能力开放也是需要通过网络来完成的，因此对网络编程以及网络IO模型都不会太陌生。\n\n由于有很多优秀的框架（比如Netty、HSF、Dubbo、Thrift等）已经把底层网络IO给封装了，通过提供的API能力或者配置就能完成想要的服务能力开发，因此大部分工程师对网络IO模型的底层不够了解。\n\n本文系统的讲解了Linux内核的IO模型、Java网络IO模型以及两者之间的关系！\n\n# 什么是IO\n\n我们都知道在Linux的世界，一切皆文件。\n\n而文件就是一串二进制流，不管Socket、FIFO、管道还是终端，对我们来说，一切都是流。\n\n* 在信息的交换过程中，我们都是对这些流进行数据收发操作，简称为I/O操作。\n\n* 往流中读取数据，系统调用Read，写入数据，系统调用Write。\n\n**通常用户进程的一个完整的IO分为两个阶段：**\n\n磁盘IO：\n\n![](https://img-blog.csdnimg.cn/8053db1cbe10492a84f2e14365350168.png)\n\n网络IO：\n\n![](https://img-blog.csdnimg.cn/53e94417bb104c0192835adaeed92af2.png)\n\n操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能使用指针传递数据，因为Linux使用的**虚拟内存**机制，必须通过系统调用请求内核来完成IO动作。\n\nIO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者！\n\n**为什么需要IO模型**\n\n如果使用**同步**的方式来通信的话，所有的操作都在一个线程内顺序执行完成，这么做缺点是很明显的：\n\n* 因为同步的通信操作会阻塞同一个线程的其他任何操作，只有这个操作完成了之后，后续的操作才可以完成，所以出现了**同步阻塞+多线程**（每个Socket都创建一个线程对应），但是系统内线程数量是有限制的，同时线程切换很浪费时间，适合Socket少的情况。 \n\n> 因该需要出现IO模型。\n\n# Linux的IO模型\n\n在描述Linux IO模型之前，我们先来了解一下Linux系统数据读取的过程：\n\n![](https://img-blog.csdnimg.cn/a428e93aefdf465d9b6f4f4925d91e7f.png)\n\n**以用户请求index.html文件为例子说明**\n\n![](https://img-blog.csdnimg.cn/f887fc0ab5be494db1faf6ca77905e00.png)\n\n## 基本概念\n\n**用户空间和内核空间**\n\n操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。\n\n* 为了保证内核的安全，用户进程不能直接操作内核，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。\n\n**进程切换**\n\n为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。\n\n> 这种行为被称为进程切换。\n\n因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。\n\n**进程的阻塞**\n\n正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。\n\n可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。\n\n> 当进程进入阻塞状态，是不占用CPU资源的。\n\n**文件描述符**\n\n文件描述符（File Descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。\n\n文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。\n\n* 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n\n**缓存IO**\n\n大多数文件系统的默认 IO 操作都是缓存 IO。\n\n其读写过程如下：\n\n- **读操作**：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘、网卡等中读取，然后缓存在操作系统的缓存中；\n- **写操作**：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘、网卡等中由操作系统决定，除非显示地调用了 sync 同步命令。\n\n假设内核空间缓存无需要的数据，用户进程从磁盘或网络读数据分两个阶段：\n\n- **阶段一：**内核程序从磁盘、网卡等读取数据到内核空间缓存区；\n- **阶段二：**用户程序从内核空间缓存拷贝数据到用户空间。\n\n> 缓存 IO 的缺点：\n\n数据在传输过程中需要在应用程序地址空间和内核空间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销非常大。 \n\n## 同步阻塞\n\n用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的网络IO。\n\n* 调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。\n\n这也是最简单的IO模型，在通常FD较少、就绪很快的情况下使用是没有问题的。\n\n![](https://img-blog.csdnimg.cn/767c2050e2ce4f1498129d347bb1b9a3.png)\n\n## 同步非阻塞\n\n非阻塞的系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。\n\n* 进程在返回之后，可以干点别的事情，然后再发起系统调用。\n\n* 重复上面的过程，循环往复的进行系统调用。这个过程通常被称之为轮询。\n\n* 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。\n\n* 需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。\n\n* 这种方式在编程中对Socket设置`O_NONBLOCK`即可。\n\n![](https://img-blog.csdnimg.cn/b033871276f44cefa2e382bddcdbe5e6.png)\n\n## IO多路复用\n\nIO多路复用，这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。\n\n使得一个进程能在一连串的事件上等待。\n\n> IO复用的实现方式目前主要有Select、Poll和Epoll。\n\n![](https://img-blog.csdnimg.cn/fb8cb8b3238a441e9cd8b3496f7124fd.png)\n\n伪代码描述IO多路复用：\n\n```java\nwhile(status == OK) { // 不断轮询\n\tready_fd_list = io_wait(fd_list); //内核缓冲区是否有准备好的数据\n\tfor(fd in ready_fd_list) {\n\t\tdata = read(fd) // 有准备好的数据读取到用户缓冲区\n\t\tprocess(data)\n\t}\n}\n```\n\n## 信号驱动\n\n首先我们允许Socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。\n\n当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。\n\n**流程如下：**\n\n- 开启套接字信号驱动IO功能\n- 系统调用Sigaction执行信号处理函数（非阻塞，立刻返回）\n- 数据就绪，生成Sigio信号，通过信号回调通知应用来读取数据\n\n此种IO方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据\n\n![](https://img-blog.csdnimg.cn/570bbd8ffd0149c788dafcb027d017c2.png)\n\n## 异步非阻塞\n\n**异步IO流程如下所示：**\n\n- 当用户线程调用了`aio_read`系统调用，立刻就可以开始去做其它的事，用户线程不阻塞\n- 内核就开始了IO的第一个阶段：准备数据。当内核一直等到数据准备好了，它就会将数据从内核内核缓冲区，拷贝到用户缓冲区\n- 内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程Read操作完成了\n- 用户线程读取用户缓冲区的数据，完成后续的业务操作\n\n> 相对于同步IO，异步IO不是顺序执行。\n\n用户进程进行`aio_read`系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。\n\n等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。\n\n**对比信号驱动IO，异步IO的主要区别在于：**\n\n* 信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。\n\n异步IO又叫做事件驱动IO，在Unix中，为异步方式访问文件定义了一套库函数，定义了AIO的一系列接口。\n\n* 使用`aio_read`或者`aio_write`发起异步IO操作，使用`aio_error`检查正在运行的IO操作的状态。\n\n目前Linux中AIO的内核实现只对文件IO有效，如果要实现真正的AIO，需要用户自己来实现。\n\n目前有很多开源的异步IO库，例如libevent、libev、libuv。\n\n![](https://img-blog.csdnimg.cn/91e0787545a54b94b96a0f8da9d106fc.png)\n\n# Java网络IO模型\n\n## BIO\n\nBIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的方法，对应Linux内核的同步阻塞IO模型，发送数据和接收数据的过程如下所示：\n\n![](https://img-blog.csdnimg.cn/d7c5dd5b1ae945eea9ed16f5000851c8.png)\n\n**步骤如下：**\n\n- 主线程accept请求\n- 请求到达，创建新的线程来处理这个套接字，完成对客户端的响应\n- 主线程继续accept下一个请求\n\n**服务端处理伪代码如下所示：**\n\n![](https://img-blog.csdnimg.cn/0bd51455f7dd45db8821d041974b1500.png)\n\n这是经典的一个连接对应一个线程的模型，之所以使用多线程，主要原因在于`socket.accept()、socket.read()、socket.write()`三个主要函数都是同步阻塞的。\n\n当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就阻塞，但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。\n\n**其实这也是所有使用多线程的本质：**\n\n> 利用多核，当I/O阻塞时，但CPU空闲的时候，可以利用多线程使用CPU资源。\n\n当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。\n\n随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I/O处理模型。\n\n## NIO\n\nJDK1.4开始引入了NIO类库，主要是使用Selector多路复用器来实现。\n\n> Selector在Linux等主流操作系统上是通过IO复用Epoll实现的。\n\n**NIO的实现流程，类似于Select：**\n\n- 创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式\n- 创建Reactor线程，创建多路复用器(Selector)并启动线程\n- 将ServerSocketChannel注册到Reactor线程的Selector上，监听Accept事件\n- Selector在线程run方法中无线循环轮询准备就绪的Key\n- Selector监听到新的客户端接入，处理新的请求，完成TCP三次握手，建立物理连接\n- 将新的客户端连接注册到Selector上，监听读操作，读取客户端发送的网络消息\n- 客户端发送的数据就绪则读取客户端请求，进行处理\n\n简单处理模型是用一个单线程死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是Select、Poll，2.6之后是Epoll，Windows是IOCP），还会阻塞的等待新事件的到来。\n\n新事件到来的时候，会在Selector上注册标记位，标示可读、可写或者有连接到来，简单处理模型的伪代码如下所示：\n\n![](https://img-blog.csdnimg.cn/da180e8f7f134841bd783159884a8b32.png)\n\nNIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。\n\n除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。\n\n并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。\n\n## AIO\n\nJDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。\n\n* 其底层在Windows上是通过IOCP实现，在Linux上是通过IO复用Epoll来模拟实现的。\n\n在JAVA NIO框架中，Selector它负责代替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操作。\n\n但是在JAVA AIO框架中，由于应用程序不是**轮询**方式，而是订阅-通知方式，所以不再需要Selector（选择器）了，改由Channel通道直接到操作系统注册监听 。\n\n**JAVA AIO框架中，只实现了两种网络IO通道：**\n\n* AsynchronousServerSocketChannel（服务器监听通道）\n\n* AsynchronousSocketChannel（Socket套接字通道）。\n\n**具体过程如下所示：**\n\n- 创建AsynchronousServerSocketChannel，绑定监听端口\n- 调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler，包括上一步，都是非阻塞的\n- 连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler\n- 数据就绪，触发负责处理数据的CompletionHandler的completed方法，继续做下一步处理即可\n- 写入操作类似，也需要传入CompletionHandler\n\n![](https://img-blog.csdnimg.cn/03b858fbe0f244daa6bc97fc8a213509.png)\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，可以获得免费电子书籍","source":"_posts/公众号文章/网络IO模型.md","raw":"---\ntitle: 网络IO模型\ncategories: \n- 公众号文章\n---\n\n# 前言\n\n文章会同步到个人网站，方便阅读：https://xiaoflyfish.cn/\n\n* 网站最近丰富了很多内容，都是满满的干货！\n\n* 微信搜索：**月伴飞鱼**，交个朋友，进面试交流群！\n\n* 公众号后台回复666，可以获得免费电子书籍！\n\n**觉得不错，希望点赞，在看，转发支持一下，谢谢**\n\n![](https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png)\n\n# 背景介绍\n\n* 在互联网的时代下，绝大部分数据都是通过网络来进行获取的。\n\n* 在服务端的架构中，绝大部分数据也是通过网络来进行交互的。\n\n而且作为服务端的开发工程师来说，都会进行一系列服务设计、开发以及能力开放，而服务能力开放也是需要通过网络来完成的，因此对网络编程以及网络IO模型都不会太陌生。\n\n由于有很多优秀的框架（比如Netty、HSF、Dubbo、Thrift等）已经把底层网络IO给封装了，通过提供的API能力或者配置就能完成想要的服务能力开发，因此大部分工程师对网络IO模型的底层不够了解。\n\n本文系统的讲解了Linux内核的IO模型、Java网络IO模型以及两者之间的关系！\n\n# 什么是IO\n\n我们都知道在Linux的世界，一切皆文件。\n\n而文件就是一串二进制流，不管Socket、FIFO、管道还是终端，对我们来说，一切都是流。\n\n* 在信息的交换过程中，我们都是对这些流进行数据收发操作，简称为I/O操作。\n\n* 往流中读取数据，系统调用Read，写入数据，系统调用Write。\n\n**通常用户进程的一个完整的IO分为两个阶段：**\n\n磁盘IO：\n\n![](https://img-blog.csdnimg.cn/8053db1cbe10492a84f2e14365350168.png)\n\n网络IO：\n\n![](https://img-blog.csdnimg.cn/53e94417bb104c0192835adaeed92af2.png)\n\n操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能使用指针传递数据，因为Linux使用的**虚拟内存**机制，必须通过系统调用请求内核来完成IO动作。\n\nIO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者！\n\n**为什么需要IO模型**\n\n如果使用**同步**的方式来通信的话，所有的操作都在一个线程内顺序执行完成，这么做缺点是很明显的：\n\n* 因为同步的通信操作会阻塞同一个线程的其他任何操作，只有这个操作完成了之后，后续的操作才可以完成，所以出现了**同步阻塞+多线程**（每个Socket都创建一个线程对应），但是系统内线程数量是有限制的，同时线程切换很浪费时间，适合Socket少的情况。 \n\n> 因该需要出现IO模型。\n\n# Linux的IO模型\n\n在描述Linux IO模型之前，我们先来了解一下Linux系统数据读取的过程：\n\n![](https://img-blog.csdnimg.cn/a428e93aefdf465d9b6f4f4925d91e7f.png)\n\n**以用户请求index.html文件为例子说明**\n\n![](https://img-blog.csdnimg.cn/f887fc0ab5be494db1faf6ca77905e00.png)\n\n## 基本概念\n\n**用户空间和内核空间**\n\n操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。\n\n* 为了保证内核的安全，用户进程不能直接操作内核，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。\n\n**进程切换**\n\n为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。\n\n> 这种行为被称为进程切换。\n\n因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。\n\n**进程的阻塞**\n\n正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。\n\n可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。\n\n> 当进程进入阻塞状态，是不占用CPU资源的。\n\n**文件描述符**\n\n文件描述符（File Descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。\n\n文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。\n\n* 当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n\n**缓存IO**\n\n大多数文件系统的默认 IO 操作都是缓存 IO。\n\n其读写过程如下：\n\n- **读操作**：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘、网卡等中读取，然后缓存在操作系统的缓存中；\n- **写操作**：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘、网卡等中由操作系统决定，除非显示地调用了 sync 同步命令。\n\n假设内核空间缓存无需要的数据，用户进程从磁盘或网络读数据分两个阶段：\n\n- **阶段一：**内核程序从磁盘、网卡等读取数据到内核空间缓存区；\n- **阶段二：**用户程序从内核空间缓存拷贝数据到用户空间。\n\n> 缓存 IO 的缺点：\n\n数据在传输过程中需要在应用程序地址空间和内核空间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销非常大。 \n\n## 同步阻塞\n\n用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的网络IO。\n\n* 调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。\n\n这也是最简单的IO模型，在通常FD较少、就绪很快的情况下使用是没有问题的。\n\n![](https://img-blog.csdnimg.cn/767c2050e2ce4f1498129d347bb1b9a3.png)\n\n## 同步非阻塞\n\n非阻塞的系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。\n\n* 进程在返回之后，可以干点别的事情，然后再发起系统调用。\n\n* 重复上面的过程，循环往复的进行系统调用。这个过程通常被称之为轮询。\n\n* 轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。\n\n* 需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。\n\n* 这种方式在编程中对Socket设置`O_NONBLOCK`即可。\n\n![](https://img-blog.csdnimg.cn/b033871276f44cefa2e382bddcdbe5e6.png)\n\n## IO多路复用\n\nIO多路复用，这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。\n\n使得一个进程能在一连串的事件上等待。\n\n> IO复用的实现方式目前主要有Select、Poll和Epoll。\n\n![](https://img-blog.csdnimg.cn/fb8cb8b3238a441e9cd8b3496f7124fd.png)\n\n伪代码描述IO多路复用：\n\n```java\nwhile(status == OK) { // 不断轮询\n\tready_fd_list = io_wait(fd_list); //内核缓冲区是否有准备好的数据\n\tfor(fd in ready_fd_list) {\n\t\tdata = read(fd) // 有准备好的数据读取到用户缓冲区\n\t\tprocess(data)\n\t}\n}\n```\n\n## 信号驱动\n\n首先我们允许Socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。\n\n当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。\n\n**流程如下：**\n\n- 开启套接字信号驱动IO功能\n- 系统调用Sigaction执行信号处理函数（非阻塞，立刻返回）\n- 数据就绪，生成Sigio信号，通过信号回调通知应用来读取数据\n\n此种IO方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据\n\n![](https://img-blog.csdnimg.cn/570bbd8ffd0149c788dafcb027d017c2.png)\n\n## 异步非阻塞\n\n**异步IO流程如下所示：**\n\n- 当用户线程调用了`aio_read`系统调用，立刻就可以开始去做其它的事，用户线程不阻塞\n- 内核就开始了IO的第一个阶段：准备数据。当内核一直等到数据准备好了，它就会将数据从内核内核缓冲区，拷贝到用户缓冲区\n- 内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程Read操作完成了\n- 用户线程读取用户缓冲区的数据，完成后续的业务操作\n\n> 相对于同步IO，异步IO不是顺序执行。\n\n用户进程进行`aio_read`系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。\n\n等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。\n\n**对比信号驱动IO，异步IO的主要区别在于：**\n\n* 信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。\n\n异步IO又叫做事件驱动IO，在Unix中，为异步方式访问文件定义了一套库函数，定义了AIO的一系列接口。\n\n* 使用`aio_read`或者`aio_write`发起异步IO操作，使用`aio_error`检查正在运行的IO操作的状态。\n\n目前Linux中AIO的内核实现只对文件IO有效，如果要实现真正的AIO，需要用户自己来实现。\n\n目前有很多开源的异步IO库，例如libevent、libev、libuv。\n\n![](https://img-blog.csdnimg.cn/91e0787545a54b94b96a0f8da9d106fc.png)\n\n# Java网络IO模型\n\n## BIO\n\nBIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的方法，对应Linux内核的同步阻塞IO模型，发送数据和接收数据的过程如下所示：\n\n![](https://img-blog.csdnimg.cn/d7c5dd5b1ae945eea9ed16f5000851c8.png)\n\n**步骤如下：**\n\n- 主线程accept请求\n- 请求到达，创建新的线程来处理这个套接字，完成对客户端的响应\n- 主线程继续accept下一个请求\n\n**服务端处理伪代码如下所示：**\n\n![](https://img-blog.csdnimg.cn/0bd51455f7dd45db8821d041974b1500.png)\n\n这是经典的一个连接对应一个线程的模型，之所以使用多线程，主要原因在于`socket.accept()、socket.read()、socket.write()`三个主要函数都是同步阻塞的。\n\n当一个连接在处理I/O的时候，系统是阻塞的，如果是单线程的话必然就阻塞，但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。\n\n**其实这也是所有使用多线程的本质：**\n\n> 利用多核，当I/O阻塞时，但CPU空闲的时候，可以利用多线程使用CPU资源。\n\n当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。\n\n随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I/O处理模型。\n\n## NIO\n\nJDK1.4开始引入了NIO类库，主要是使用Selector多路复用器来实现。\n\n> Selector在Linux等主流操作系统上是通过IO复用Epoll实现的。\n\n**NIO的实现流程，类似于Select：**\n\n- 创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式\n- 创建Reactor线程，创建多路复用器(Selector)并启动线程\n- 将ServerSocketChannel注册到Reactor线程的Selector上，监听Accept事件\n- Selector在线程run方法中无线循环轮询准备就绪的Key\n- Selector监听到新的客户端接入，处理新的请求，完成TCP三次握手，建立物理连接\n- 将新的客户端连接注册到Selector上，监听读操作，读取客户端发送的网络消息\n- 客户端发送的数据就绪则读取客户端请求，进行处理\n\n简单处理模型是用一个单线程死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是Select、Poll，2.6之后是Epoll，Windows是IOCP），还会阻塞的等待新事件的到来。\n\n新事件到来的时候，会在Selector上注册标记位，标示可读、可写或者有连接到来，简单处理模型的伪代码如下所示：\n\n![](https://img-blog.csdnimg.cn/da180e8f7f134841bd783159884a8b32.png)\n\nNIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。\n\n除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I/O操作都是纯CPU操作，没有必要开启多线程。\n\n并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。\n\n## AIO\n\nJDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。\n\n* 其底层在Windows上是通过IOCP实现，在Linux上是通过IO复用Epoll来模拟实现的。\n\n在JAVA NIO框架中，Selector它负责代替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操作。\n\n但是在JAVA AIO框架中，由于应用程序不是**轮询**方式，而是订阅-通知方式，所以不再需要Selector（选择器）了，改由Channel通道直接到操作系统注册监听 。\n\n**JAVA AIO框架中，只实现了两种网络IO通道：**\n\n* AsynchronousServerSocketChannel（服务器监听通道）\n\n* AsynchronousSocketChannel（Socket套接字通道）。\n\n**具体过程如下所示：**\n\n- 创建AsynchronousServerSocketChannel，绑定监听端口\n- 调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler，包括上一步，都是非阻塞的\n- 连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler\n- 数据就绪，触发负责处理数据的CompletionHandler的completed方法，继续做下一步处理即可\n- 写入操作类似，也需要传入CompletionHandler\n\n![](https://img-blog.csdnimg.cn/03b858fbe0f244daa6bc97fc8a213509.png)\n\n# 最后\n\n**觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢**\n\n微信搜索：月伴飞鱼，交个朋友\n\n公众号后台回复666，可以获得免费电子书籍","slug":"公众号文章/网络IO模型","published":1,"date":"2022-02-20T08:01:23.452Z","updated":"2022-02-20T16:34:43.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwiz00fcfhjidymccf5o","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>文章会同步到个人网站，方便阅读：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<ul>\n<li><p>网站最近丰富了很多内容，都是满满的干货！</p>\n</li>\n<li><p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群！</p>\n</li>\n<li><p>公众号后台回复666，可以获得免费电子书籍！</p>\n</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png\"></p>\n<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><ul>\n<li><p>在互联网的时代下，绝大部分数据都是通过网络来进行获取的。</p>\n</li>\n<li><p>在服务端的架构中，绝大部分数据也是通过网络来进行交互的。</p>\n</li>\n</ul>\n<p>而且作为服务端的开发工程师来说，都会进行一系列服务设计、开发以及能力开放，而服务能力开放也是需要通过网络来完成的，因此对网络编程以及网络IO模型都不会太陌生。</p>\n<p>由于有很多优秀的框架（比如Netty、HSF、Dubbo、Thrift等）已经把底层网络IO给封装了，通过提供的API能力或者配置就能完成想要的服务能力开发，因此大部分工程师对网络IO模型的底层不够了解。</p>\n<p>本文系统的讲解了Linux内核的IO模型、Java网络IO模型以及两者之间的关系！</p>\n<h1 id=\"什么是IO\"><a href=\"#什么是IO\" class=\"headerlink\" title=\"什么是IO\"></a>什么是IO</h1><p>我们都知道在Linux的世界，一切皆文件。</p>\n<p>而文件就是一串二进制流，不管Socket、FIFO、管道还是终端，对我们来说，一切都是流。</p>\n<ul>\n<li><p>在信息的交换过程中，我们都是对这些流进行数据收发操作，简称为I&#x2F;O操作。</p>\n</li>\n<li><p>往流中读取数据，系统调用Read，写入数据，系统调用Write。</p>\n</li>\n</ul>\n<p><strong>通常用户进程的一个完整的IO分为两个阶段：</strong></p>\n<p>磁盘IO：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8053db1cbe10492a84f2e14365350168.png\"></p>\n<p>网络IO：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/53e94417bb104c0192835adaeed92af2.png\"></p>\n<p>操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能使用指针传递数据，因为Linux使用的<strong>虚拟内存</strong>机制，必须通过系统调用请求内核来完成IO动作。</p>\n<p>IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者！</p>\n<p><strong>为什么需要IO模型</strong></p>\n<p>如果使用<strong>同步</strong>的方式来通信的话，所有的操作都在一个线程内顺序执行完成，这么做缺点是很明显的：</p>\n<ul>\n<li>因为同步的通信操作会阻塞同一个线程的其他任何操作，只有这个操作完成了之后，后续的操作才可以完成，所以出现了<strong>同步阻塞+多线程</strong>（每个Socket都创建一个线程对应），但是系统内线程数量是有限制的，同时线程切换很浪费时间，适合Socket少的情况。</li>\n</ul>\n<blockquote>\n<p>因该需要出现IO模型。</p>\n</blockquote>\n<h1 id=\"Linux的IO模型\"><a href=\"#Linux的IO模型\" class=\"headerlink\" title=\"Linux的IO模型\"></a>Linux的IO模型</h1><p>在描述Linux IO模型之前，我们先来了解一下Linux系统数据读取的过程：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a428e93aefdf465d9b6f4f4925d91e7f.png\"></p>\n<p><strong>以用户请求index.html文件为例子说明</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f887fc0ab5be494db1faf6ca77905e00.png\"></p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p><strong>用户空间和内核空间</strong></p>\n<p>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>\n<ul>\n<li>为了保证内核的安全，用户进程不能直接操作内核，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</li>\n</ul>\n<p><strong>进程切换</strong></p>\n<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。</p>\n<blockquote>\n<p>这种行为被称为进程切换。</p>\n</blockquote>\n<p>因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p><strong>进程的阻塞</strong></p>\n<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。</p>\n<p>可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p>\n<blockquote>\n<p>当进程进入阻塞状态，是不占用CPU资源的。</p>\n</blockquote>\n<p><strong>文件描述符</strong></p>\n<p>文件描述符（File Descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>\n<p>文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>\n<ul>\n<li>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</li>\n</ul>\n<p><strong>缓存IO</strong></p>\n<p>大多数文件系统的默认 IO 操作都是缓存 IO。</p>\n<p>其读写过程如下：</p>\n<ul>\n<li><strong>读操作</strong>：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘、网卡等中读取，然后缓存在操作系统的缓存中；</li>\n<li><strong>写操作</strong>：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘、网卡等中由操作系统决定，除非显示地调用了 sync 同步命令。</li>\n</ul>\n<p>假设内核空间缓存无需要的数据，用户进程从磁盘或网络读数据分两个阶段：</p>\n<ul>\n<li><strong>阶段一：</strong>内核程序从磁盘、网卡等读取数据到内核空间缓存区；</li>\n<li><strong>阶段二：</strong>用户程序从内核空间缓存拷贝数据到用户空间。</li>\n</ul>\n<blockquote>\n<p>缓存 IO 的缺点：</p>\n</blockquote>\n<p>数据在传输过程中需要在应用程序地址空间和内核空间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销非常大。 </p>\n<h2 id=\"同步阻塞\"><a href=\"#同步阻塞\" class=\"headerlink\" title=\"同步阻塞\"></a>同步阻塞</h2><p>用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的网络IO。</p>\n<ul>\n<li>调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</li>\n</ul>\n<p>这也是最简单的IO模型，在通常FD较少、就绪很快的情况下使用是没有问题的。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/767c2050e2ce4f1498129d347bb1b9a3.png\"></p>\n<h2 id=\"同步非阻塞\"><a href=\"#同步非阻塞\" class=\"headerlink\" title=\"同步非阻塞\"></a>同步非阻塞</h2><p>非阻塞的系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。</p>\n<ul>\n<li><p>进程在返回之后，可以干点别的事情，然后再发起系统调用。</p>\n</li>\n<li><p>重复上面的过程，循环往复的进行系统调用。这个过程通常被称之为轮询。</p>\n</li>\n<li><p>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。</p>\n</li>\n<li><p>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>\n</li>\n<li><p>这种方式在编程中对Socket设置<code>O_NONBLOCK</code>即可。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/b033871276f44cefa2e382bddcdbe5e6.png\"></p>\n<h2 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h2><p>IO多路复用，这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。</p>\n<p>使得一个进程能在一连串的事件上等待。</p>\n<blockquote>\n<p>IO复用的实现方式目前主要有Select、Poll和Epoll。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/fb8cb8b3238a441e9cd8b3496f7124fd.png\"></p>\n<p>伪代码描述IO多路复用：</p>\n<pre><code class=\"java\">while(status == OK) &#123; // 不断轮询\n    ready_fd_list = io_wait(fd_list); //内核缓冲区是否有准备好的数据\n    for(fd in ready_fd_list) &#123;\n        data = read(fd) // 有准备好的数据读取到用户缓冲区\n        process(data)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"信号驱动\"><a href=\"#信号驱动\" class=\"headerlink\" title=\"信号驱动\"></a>信号驱动</h2><p>首先我们允许Socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。</p>\n<p>当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。</p>\n<p><strong>流程如下：</strong></p>\n<ul>\n<li>开启套接字信号驱动IO功能</li>\n<li>系统调用Sigaction执行信号处理函数（非阻塞，立刻返回）</li>\n<li>数据就绪，生成Sigio信号，通过信号回调通知应用来读取数据</li>\n</ul>\n<p>此种IO方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据</p>\n<p><img src=\"https://img-blog.csdnimg.cn/570bbd8ffd0149c788dafcb027d017c2.png\"></p>\n<h2 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h2><p><strong>异步IO流程如下所示：</strong></p>\n<ul>\n<li>当用户线程调用了<code>aio_read</code>系统调用，立刻就可以开始去做其它的事，用户线程不阻塞</li>\n<li>内核就开始了IO的第一个阶段：准备数据。当内核一直等到数据准备好了，它就会将数据从内核内核缓冲区，拷贝到用户缓冲区</li>\n<li>内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程Read操作完成了</li>\n<li>用户线程读取用户缓冲区的数据，完成后续的业务操作</li>\n</ul>\n<blockquote>\n<p>相对于同步IO，异步IO不是顺序执行。</p>\n</blockquote>\n<p>用户进程进行<code>aio_read</code>系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。</p>\n<p>等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。</p>\n<p><strong>对比信号驱动IO，异步IO的主要区别在于：</strong></p>\n<ul>\n<li>信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。</li>\n</ul>\n<p>异步IO又叫做事件驱动IO，在Unix中，为异步方式访问文件定义了一套库函数，定义了AIO的一系列接口。</p>\n<ul>\n<li>使用<code>aio_read</code>或者<code>aio_write</code>发起异步IO操作，使用<code>aio_error</code>检查正在运行的IO操作的状态。</li>\n</ul>\n<p>目前Linux中AIO的内核实现只对文件IO有效，如果要实现真正的AIO，需要用户自己来实现。</p>\n<p>目前有很多开源的异步IO库，例如libevent、libev、libuv。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/91e0787545a54b94b96a0f8da9d106fc.png\"></p>\n<h1 id=\"Java网络IO模型\"><a href=\"#Java网络IO模型\" class=\"headerlink\" title=\"Java网络IO模型\"></a>Java网络IO模型</h1><h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>BIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的方法，对应Linux内核的同步阻塞IO模型，发送数据和接收数据的过程如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d7c5dd5b1ae945eea9ed16f5000851c8.png\"></p>\n<p><strong>步骤如下：</strong></p>\n<ul>\n<li>主线程accept请求</li>\n<li>请求到达，创建新的线程来处理这个套接字，完成对客户端的响应</li>\n<li>主线程继续accept下一个请求</li>\n</ul>\n<p><strong>服务端处理伪代码如下所示：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0bd51455f7dd45db8821d041974b1500.png\"></p>\n<p>这是经典的一个连接对应一个线程的模型，之所以使用多线程，主要原因在于<code>socket.accept()、socket.read()、socket.write()</code>三个主要函数都是同步阻塞的。</p>\n<p>当一个连接在处理I&#x2F;O的时候，系统是阻塞的，如果是单线程的话必然就阻塞，但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。</p>\n<p><strong>其实这也是所有使用多线程的本质：</strong></p>\n<blockquote>\n<p>利用多核，当I&#x2F;O阻塞时，但CPU空闲的时候，可以利用多线程使用CPU资源。</p>\n</blockquote>\n<p>当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。</p>\n<p>随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I&#x2F;O处理模型。</p>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>JDK1.4开始引入了NIO类库，主要是使用Selector多路复用器来实现。</p>\n<blockquote>\n<p>Selector在Linux等主流操作系统上是通过IO复用Epoll实现的。</p>\n</blockquote>\n<p><strong>NIO的实现流程，类似于Select：</strong></p>\n<ul>\n<li>创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式</li>\n<li>创建Reactor线程，创建多路复用器(Selector)并启动线程</li>\n<li>将ServerSocketChannel注册到Reactor线程的Selector上，监听Accept事件</li>\n<li>Selector在线程run方法中无线循环轮询准备就绪的Key</li>\n<li>Selector监听到新的客户端接入，处理新的请求，完成TCP三次握手，建立物理连接</li>\n<li>将新的客户端连接注册到Selector上，监听读操作，读取客户端发送的网络消息</li>\n<li>客户端发送的数据就绪则读取客户端请求，进行处理</li>\n</ul>\n<p>简单处理模型是用一个单线程死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是Select、Poll，2.6之后是Epoll，Windows是IOCP），还会阻塞的等待新事件的到来。</p>\n<p>新事件到来的时候，会在Selector上注册标记位，标示可读、可写或者有连接到来，简单处理模型的伪代码如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/da180e8f7f134841bd783159884a8b32.png\"></p>\n<p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。</p>\n<p>除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I&#x2F;O操作都是纯CPU操作，没有必要开启多线程。</p>\n<p>并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p>\n<h2 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h2><p>JDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。</p>\n<ul>\n<li>其底层在Windows上是通过IOCP实现，在Linux上是通过IO复用Epoll来模拟实现的。</li>\n</ul>\n<p>在JAVA NIO框架中，Selector它负责代替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操作。</p>\n<p>但是在JAVA AIO框架中，由于应用程序不是<strong>轮询</strong>方式，而是订阅-通知方式，所以不再需要Selector（选择器）了，改由Channel通道直接到操作系统注册监听 。</p>\n<p><strong>JAVA AIO框架中，只实现了两种网络IO通道：</strong></p>\n<ul>\n<li><p>AsynchronousServerSocketChannel（服务器监听通道）</p>\n</li>\n<li><p>AsynchronousSocketChannel（Socket套接字通道）。</p>\n</li>\n</ul>\n<p><strong>具体过程如下所示：</strong></p>\n<ul>\n<li>创建AsynchronousServerSocketChannel，绑定监听端口</li>\n<li>调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler，包括上一步，都是非阻塞的</li>\n<li>连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler</li>\n<li>数据就绪，触发负责处理数据的CompletionHandler的completed方法，继续做下一步处理即可</li>\n<li>写入操作类似，也需要传入CompletionHandler</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/03b858fbe0f244daa6bc97fc8a213509.png\"></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>文章会同步到个人网站，方便阅读：<a href=\"https://xiaoflyfish.cn/\">https://xiaoflyfish.cn/</a></p>\n<ul>\n<li><p>网站最近丰富了很多内容，都是满满的干货！</p>\n</li>\n<li><p>微信搜索：<strong>月伴飞鱼</strong>，交个朋友，进面试交流群！</p>\n</li>\n<li><p>公众号后台回复666，可以获得免费电子书籍！</p>\n</li>\n</ul>\n<p><strong>觉得不错，希望点赞，在看，转发支持一下，谢谢</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/7e2573f7da834e6fa6650992593020f7.png\"></p>\n<h1 id=\"背景介绍\"><a href=\"#背景介绍\" class=\"headerlink\" title=\"背景介绍\"></a>背景介绍</h1><ul>\n<li><p>在互联网的时代下，绝大部分数据都是通过网络来进行获取的。</p>\n</li>\n<li><p>在服务端的架构中，绝大部分数据也是通过网络来进行交互的。</p>\n</li>\n</ul>\n<p>而且作为服务端的开发工程师来说，都会进行一系列服务设计、开发以及能力开放，而服务能力开放也是需要通过网络来完成的，因此对网络编程以及网络IO模型都不会太陌生。</p>\n<p>由于有很多优秀的框架（比如Netty、HSF、Dubbo、Thrift等）已经把底层网络IO给封装了，通过提供的API能力或者配置就能完成想要的服务能力开发，因此大部分工程师对网络IO模型的底层不够了解。</p>\n<p>本文系统的讲解了Linux内核的IO模型、Java网络IO模型以及两者之间的关系！</p>\n<h1 id=\"什么是IO\"><a href=\"#什么是IO\" class=\"headerlink\" title=\"什么是IO\"></a>什么是IO</h1><p>我们都知道在Linux的世界，一切皆文件。</p>\n<p>而文件就是一串二进制流，不管Socket、FIFO、管道还是终端，对我们来说，一切都是流。</p>\n<ul>\n<li><p>在信息的交换过程中，我们都是对这些流进行数据收发操作，简称为I&#x2F;O操作。</p>\n</li>\n<li><p>往流中读取数据，系统调用Read，写入数据，系统调用Write。</p>\n</li>\n</ul>\n<p><strong>通常用户进程的一个完整的IO分为两个阶段：</strong></p>\n<p>磁盘IO：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8053db1cbe10492a84f2e14365350168.png\"></p>\n<p>网络IO：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/53e94417bb104c0192835adaeed92af2.png\"></p>\n<p>操作系统和驱动程序运行在内核空间，应用程序运行在用户空间，两者不能使用指针传递数据，因为Linux使用的<strong>虚拟内存</strong>机制，必须通过系统调用请求内核来完成IO动作。</p>\n<p>IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者！</p>\n<p><strong>为什么需要IO模型</strong></p>\n<p>如果使用<strong>同步</strong>的方式来通信的话，所有的操作都在一个线程内顺序执行完成，这么做缺点是很明显的：</p>\n<ul>\n<li>因为同步的通信操作会阻塞同一个线程的其他任何操作，只有这个操作完成了之后，后续的操作才可以完成，所以出现了<strong>同步阻塞+多线程</strong>（每个Socket都创建一个线程对应），但是系统内线程数量是有限制的，同时线程切换很浪费时间，适合Socket少的情况。</li>\n</ul>\n<blockquote>\n<p>因该需要出现IO模型。</p>\n</blockquote>\n<h1 id=\"Linux的IO模型\"><a href=\"#Linux的IO模型\" class=\"headerlink\" title=\"Linux的IO模型\"></a>Linux的IO模型</h1><p>在描述Linux IO模型之前，我们先来了解一下Linux系统数据读取的过程：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a428e93aefdf465d9b6f4f4925d91e7f.png\"></p>\n<p><strong>以用户请求index.html文件为例子说明</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/f887fc0ab5be494db1faf6ca77905e00.png\"></p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><p><strong>用户空间和内核空间</strong></p>\n<p>操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。</p>\n<ul>\n<li>为了保证内核的安全，用户进程不能直接操作内核，操作系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。</li>\n</ul>\n<p><strong>进程切换</strong></p>\n<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。</p>\n<blockquote>\n<p>这种行为被称为进程切换。</p>\n</blockquote>\n<p>因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>\n<p><strong>进程的阻塞</strong></p>\n<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。</p>\n<p>可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。</p>\n<blockquote>\n<p>当进程进入阻塞状态，是不占用CPU资源的。</p>\n</blockquote>\n<p><strong>文件描述符</strong></p>\n<p>文件描述符（File Descriptor）是计算机科学中的一个术语，是一个用于表述指向文件的引用的抽象化概念。</p>\n<p>文件描述符在形式上是一个非负整数，实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。</p>\n<ul>\n<li>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</li>\n</ul>\n<p><strong>缓存IO</strong></p>\n<p>大多数文件系统的默认 IO 操作都是缓存 IO。</p>\n<p>其读写过程如下：</p>\n<ul>\n<li><strong>读操作</strong>：操作系统检查内核的缓冲区有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回；否则从磁盘、网卡等中读取，然后缓存在操作系统的缓存中；</li>\n<li><strong>写操作</strong>：将数据从用户空间复制到内核空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘、网卡等中由操作系统决定，除非显示地调用了 sync 同步命令。</li>\n</ul>\n<p>假设内核空间缓存无需要的数据，用户进程从磁盘或网络读数据分两个阶段：</p>\n<ul>\n<li><strong>阶段一：</strong>内核程序从磁盘、网卡等读取数据到内核空间缓存区；</li>\n<li><strong>阶段二：</strong>用户程序从内核空间缓存拷贝数据到用户空间。</li>\n</ul>\n<blockquote>\n<p>缓存 IO 的缺点：</p>\n</blockquote>\n<p>数据在传输过程中需要在应用程序地址空间和内核空间进行多次数据拷贝操作，这些数据拷贝操作所带来的CPU以及内存开销非常大。 </p>\n<h2 id=\"同步阻塞\"><a href=\"#同步阻塞\" class=\"headerlink\" title=\"同步阻塞\"></a>同步阻塞</h2><p>用户空间的应用程序执行一个系统调用，这会导致应用程序阻塞，什么也不干，直到数据准备好，并且将数据从内核复制到用户进程，最后进程再处理数据，在等待数据到处理数据的两个阶段，整个进程都被阻塞，不能处理别的网络IO。</p>\n<ul>\n<li>调用应用程序处于一种不再消费 CPU 而只是简单等待响应的状态，因此从处理的角度来看，这是非常有效的。</li>\n</ul>\n<p>这也是最简单的IO模型，在通常FD较少、就绪很快的情况下使用是没有问题的。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/767c2050e2ce4f1498129d347bb1b9a3.png\"></p>\n<h2 id=\"同步非阻塞\"><a href=\"#同步非阻塞\" class=\"headerlink\" title=\"同步非阻塞\"></a>同步非阻塞</h2><p>非阻塞的系统调用调用之后，进程并没有被阻塞，内核马上返回给进程，如果数据还没准备好，此时会返回一个error。</p>\n<ul>\n<li><p>进程在返回之后，可以干点别的事情，然后再发起系统调用。</p>\n</li>\n<li><p>重复上面的过程，循环往复的进行系统调用。这个过程通常被称之为轮询。</p>\n</li>\n<li><p>轮询检查内核数据，直到数据准备好，再拷贝数据到进程，进行数据处理。</p>\n</li>\n<li><p>需要注意，拷贝数据整个过程，进程仍然是属于阻塞的状态。</p>\n</li>\n<li><p>这种方式在编程中对Socket设置<code>O_NONBLOCK</code>即可。</p>\n</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/b033871276f44cefa2e382bddcdbe5e6.png\"></p>\n<h2 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h2><p>IO多路复用，这是一种进程预先告知内核的能力，让内核发现进程指定的一个或多个IO条件就绪了，就通知进程。</p>\n<p>使得一个进程能在一连串的事件上等待。</p>\n<blockquote>\n<p>IO复用的实现方式目前主要有Select、Poll和Epoll。</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/fb8cb8b3238a441e9cd8b3496f7124fd.png\"></p>\n<p>伪代码描述IO多路复用：</p>\n<pre><code class=\"java\">while(status == OK) &#123; // 不断轮询\n    ready_fd_list = io_wait(fd_list); //内核缓冲区是否有准备好的数据\n    for(fd in ready_fd_list) &#123;\n        data = read(fd) // 有准备好的数据读取到用户缓冲区\n        process(data)\n    &#125;\n&#125;\n</code></pre>\n<h2 id=\"信号驱动\"><a href=\"#信号驱动\" class=\"headerlink\" title=\"信号驱动\"></a>信号驱动</h2><p>首先我们允许Socket进行信号驱动IO，并安装一个信号处理函数，进程继续运行并不阻塞。</p>\n<p>当数据准备好时，进程会收到一个SIGIO信号，可以在信号处理函数中调用I&#x2F;O操作函数处理数据。</p>\n<p><strong>流程如下：</strong></p>\n<ul>\n<li>开启套接字信号驱动IO功能</li>\n<li>系统调用Sigaction执行信号处理函数（非阻塞，立刻返回）</li>\n<li>数据就绪，生成Sigio信号，通过信号回调通知应用来读取数据</li>\n</ul>\n<p>此种IO方式存在的一个很大的问题：Linux中信号队列是有限制的，如果超过这个数字问题就无法读取数据</p>\n<p><img src=\"https://img-blog.csdnimg.cn/570bbd8ffd0149c788dafcb027d017c2.png\"></p>\n<h2 id=\"异步非阻塞\"><a href=\"#异步非阻塞\" class=\"headerlink\" title=\"异步非阻塞\"></a>异步非阻塞</h2><p><strong>异步IO流程如下所示：</strong></p>\n<ul>\n<li>当用户线程调用了<code>aio_read</code>系统调用，立刻就可以开始去做其它的事，用户线程不阻塞</li>\n<li>内核就开始了IO的第一个阶段：准备数据。当内核一直等到数据准备好了，它就会将数据从内核内核缓冲区，拷贝到用户缓冲区</li>\n<li>内核会给用户线程发送一个信号，或者回调用户线程注册的回调接口，告诉用户线程Read操作完成了</li>\n<li>用户线程读取用户缓冲区的数据，完成后续的业务操作</li>\n</ul>\n<blockquote>\n<p>相对于同步IO，异步IO不是顺序执行。</p>\n</blockquote>\n<p>用户进程进行<code>aio_read</code>系统调用之后，无论内核数据是否准备好，都会直接返回给用户进程，然后用户态进程可以去做别的事情。</p>\n<p>等到数据准备好了，内核直接复制数据给进程，然后从内核向进程发送通知。</p>\n<p><strong>对比信号驱动IO，异步IO的主要区别在于：</strong></p>\n<ul>\n<li>信号驱动由内核告诉我们何时可以开始一个IO操作(数据在内核缓冲区中)，而异步IO则由内核通知IO操作何时已经完成(数据已经在用户空间中)。</li>\n</ul>\n<p>异步IO又叫做事件驱动IO，在Unix中，为异步方式访问文件定义了一套库函数，定义了AIO的一系列接口。</p>\n<ul>\n<li>使用<code>aio_read</code>或者<code>aio_write</code>发起异步IO操作，使用<code>aio_error</code>检查正在运行的IO操作的状态。</li>\n</ul>\n<p>目前Linux中AIO的内核实现只对文件IO有效，如果要实现真正的AIO，需要用户自己来实现。</p>\n<p>目前有很多开源的异步IO库，例如libevent、libev、libuv。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/91e0787545a54b94b96a0f8da9d106fc.png\"></p>\n<h1 id=\"Java网络IO模型\"><a href=\"#Java网络IO模型\" class=\"headerlink\" title=\"Java网络IO模型\"></a>Java网络IO模型</h1><h2 id=\"BIO\"><a href=\"#BIO\" class=\"headerlink\" title=\"BIO\"></a>BIO</h2><p>BIO是一个典型的网络编程模型，是通常我们实现一个服务端程序的方法，对应Linux内核的同步阻塞IO模型，发送数据和接收数据的过程如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d7c5dd5b1ae945eea9ed16f5000851c8.png\"></p>\n<p><strong>步骤如下：</strong></p>\n<ul>\n<li>主线程accept请求</li>\n<li>请求到达，创建新的线程来处理这个套接字，完成对客户端的响应</li>\n<li>主线程继续accept下一个请求</li>\n</ul>\n<p><strong>服务端处理伪代码如下所示：</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/0bd51455f7dd45db8821d041974b1500.png\"></p>\n<p>这是经典的一个连接对应一个线程的模型，之所以使用多线程，主要原因在于<code>socket.accept()、socket.read()、socket.write()</code>三个主要函数都是同步阻塞的。</p>\n<p>当一个连接在处理I&#x2F;O的时候，系统是阻塞的，如果是单线程的话必然就阻塞，但CPU是被释放出来的，开启多线程，就可以让CPU去处理更多的事情。</p>\n<p><strong>其实这也是所有使用多线程的本质：</strong></p>\n<blockquote>\n<p>利用多核，当I&#x2F;O阻塞时，但CPU空闲的时候，可以利用多线程使用CPU资源。</p>\n</blockquote>\n<p>当面对十万甚至百万级连接的时候，传统的BIO模型是无能为力的。</p>\n<p>随着移动端应用的兴起和各种网络游戏的盛行，百万级长连接日趋普遍，此时，必然需要一种更高效的I&#x2F;O处理模型。</p>\n<h2 id=\"NIO\"><a href=\"#NIO\" class=\"headerlink\" title=\"NIO\"></a>NIO</h2><p>JDK1.4开始引入了NIO类库，主要是使用Selector多路复用器来实现。</p>\n<blockquote>\n<p>Selector在Linux等主流操作系统上是通过IO复用Epoll实现的。</p>\n</blockquote>\n<p><strong>NIO的实现流程，类似于Select：</strong></p>\n<ul>\n<li>创建ServerSocketChannel监听客户端连接并绑定监听端口，设置为非阻塞模式</li>\n<li>创建Reactor线程，创建多路复用器(Selector)并启动线程</li>\n<li>将ServerSocketChannel注册到Reactor线程的Selector上，监听Accept事件</li>\n<li>Selector在线程run方法中无线循环轮询准备就绪的Key</li>\n<li>Selector监听到新的客户端接入，处理新的请求，完成TCP三次握手，建立物理连接</li>\n<li>将新的客户端连接注册到Selector上，监听读操作，读取客户端发送的网络消息</li>\n<li>客户端发送的数据就绪则读取客户端请求，进行处理</li>\n</ul>\n<p>简单处理模型是用一个单线程死循环选择就绪的事件，会执行系统调用（Linux 2.6之前是Select、Poll，2.6之后是Epoll，Windows是IOCP），还会阻塞的等待新事件的到来。</p>\n<p>新事件到来的时候，会在Selector上注册标记位，标示可读、可写或者有连接到来，简单处理模型的伪代码如下所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/da180e8f7f134841bd783159884a8b32.png\"></p>\n<p>NIO由原来的阻塞读写（占用线程）变成了单线程轮询事件，找到可以进行读写的网络描述符进行读写。</p>\n<p>除了事件的轮询是阻塞的（没有可干的事情必须要阻塞），剩余的I&#x2F;O操作都是纯CPU操作，没有必要开启多线程。</p>\n<p>并且由于线程的节约，连接数大的时候因为线程切换带来的问题也随之解决，进而为处理海量连接提供了可能。</p>\n<h2 id=\"AIO\"><a href=\"#AIO\" class=\"headerlink\" title=\"AIO\"></a>AIO</h2><p>JDK1.7引入NIO2.0，提供了异步文件通道和异步套接字通道的实现。</p>\n<ul>\n<li>其底层在Windows上是通过IOCP实现，在Linux上是通过IO复用Epoll来模拟实现的。</li>\n</ul>\n<p>在JAVA NIO框架中，Selector它负责代替应用查询中所有已注册的通道到操作系统中进行IO事件轮询、管理当前注册的通道集合，定位发生事件的通道等操作。</p>\n<p>但是在JAVA AIO框架中，由于应用程序不是<strong>轮询</strong>方式，而是订阅-通知方式，所以不再需要Selector（选择器）了，改由Channel通道直接到操作系统注册监听 。</p>\n<p><strong>JAVA AIO框架中，只实现了两种网络IO通道：</strong></p>\n<ul>\n<li><p>AsynchronousServerSocketChannel（服务器监听通道）</p>\n</li>\n<li><p>AsynchronousSocketChannel（Socket套接字通道）。</p>\n</li>\n</ul>\n<p><strong>具体过程如下所示：</strong></p>\n<ul>\n<li>创建AsynchronousServerSocketChannel，绑定监听端口</li>\n<li>调用AsynchronousServerSocketChannel的accpet方法，传入自己实现的CompletionHandler，包括上一步，都是非阻塞的</li>\n<li>连接传入，回调CompletionHandler的completed方法，在里面，调用AsynchronousSocketChannel的read方法，传入负责处理数据的CompletionHandler</li>\n<li>数据就绪，触发负责处理数据的CompletionHandler的completed方法，继续做下一步处理即可</li>\n<li>写入操作类似，也需要传入CompletionHandler</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/03b858fbe0f244daa6bc97fc8a213509.png\"></p>\n<h1 id=\"最后\"><a href=\"#最后\" class=\"headerlink\" title=\"最后\"></a>最后</h1><p><strong>觉得有收获，希望帮忙点赞，转发下哈，谢谢，谢谢</strong></p>\n<p>微信搜索：月伴飞鱼，交个朋友</p>\n<p>公众号后台回复666，可以获得免费电子书籍</p>\n"},{"title":"HTTP","_content":"\n**请求方法**\n\nHTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。\n\nHTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。\n\n| 序 号 | 方法    | 描述                                                         |\n| ----- | ------- | ------------------------------------------------------------ |\n| 1     | GET     | 请求指定的页面信息，并返回实体主体。                         |\n| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |\n| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |\n| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |\n| 5     | DELETE  | 请求服务器删除指定的页面。                                   |\n| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |\n| 7     | OPTIONS | 允许客户端查看服务器的性能。                                 |\n| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |\n| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |\n\n**GET请求和POST请求的区别**\n\n1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到body中，在url 中不可见。\n2. 请求的url有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如IE浏览器对 URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应，因为GET请求的参数是添加到URL中，所以GET请求的URL的长度限制需要将请求参数长度也考虑进去。而POST请求不用考虑请求参数的长度。\n3. GET请求产生一个数据包; POST请求产生2个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为GET没有请求体，所以就发送一个数据包，而POST包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。\n4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。\n5. GET是幂等的，而POST不是(幂等表示执行相同的操作，结果也是相同的)\n6. GET是获取数据，POST是修改数据\n\n# 状态码\n\n**状态码由3位数字组成，第一位定义响应的类别**\n\n1XX：指示信息，表示请求以接收，继续处理\n\n2XX：成功，表示请求已经被成功接收、理解、接受\n\n- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。\n- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。\n\n- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。\n\n3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。\n\n* 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。\n* 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。\n\n301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。\n\n* 304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。\n\n4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。\n\n* 400 Bad Request表示客户端请求的报文有错误。\n\n* 401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。\n\n* 403 Forbidden表示服务器禁止访问资源，并不是客户端的请求出错。\n\n* 404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。\n\n5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。\n\n* 501 Not Implemented 表示客户端请求的功能还不支持。\n\n* 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。\n\n* 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。\n\n* 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。\n\n**301和302的区别**\n\n* 301重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。\n\n* 301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。\n\n* 302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。\n\n# HTTP1.1\n\n**长连接**\n\nHTTP 1.1支持长连接\n\nHTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。\n\nHTTP 1.1则支持持久连接Persistent Connection，并且默认使用，在同一个TCP的连接中可以传送多个HTTP请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头\n\nHTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为Close时，客户端通知服务器返回本次请求结果后关闭连接。\n\n**管道网络传输**\n\nHTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。\n\n即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**\n\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。\n\n但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。\n\n**Host字段**\n\n在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。\n\nHTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。\n\n此外，服务器应该接受以绝对路径标记的资源请求。\n\n**100Status**\n\nHTTP/1.1加入了一个新的状态码100。\n\n客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；\n\n如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。\n\n100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。\n\n**Chunked Transfer Coding**\n\nHTTP/1.1将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。\n\n这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。\n\n**Cache**\n\nHTTP/1.1在1.0的基础上加入了一些Cache的新特性，当缓存对象的Age超过Expire时变为Stable对象，Cache不需要直接抛弃Stable对象，而是与源服务器进行重新激活。\n\n# HTTP2.0\n\n**HTTP2.0和HTTP1.X相比的新特性**\n\n- 新的二进制格式，`HTTP1.x`的解析是基于文本\n- 多路复用，即连接共享，即每一个request都是是用作连接共享机制的，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面\n\n- header压缩，`HTTP1.x`的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小\n- 服务端推送\n\nHTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。\n\n举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。\n\n**数据流**\n\nHTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。\n\n因此，必须要对数据包做标记，指出它属于哪个回应。\n\n每个请求或回应的所有数据包，称为一个数据流（Stream）。\n\n每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数\n\n客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。\n\n**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别**\n\n- HTTP/1.1的Pipeling为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；\n- HTTP2.0多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行\n\n# HTTP3.0\n\n**使用UDP协议**\n\nHTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。\n\n所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。\n\n- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了\n- HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。\n\n这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**\n\n# HTTPS\n\n**HTTP与HTTPS的区别**\n\nHTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全\n\n- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO，谷歌、百度优先索引HTTPS网页\n- HTTPS需要用到SSL证书，而HTTP不用\n\n- HTTPS标准端口443，HTTP标准端口80\n- HTTPS基于传输层，HTTP基于应用层\n\n- HTTPS在浏览器显示绿色安全锁，HTTP没有显示\n\n**工作原理**\n\nHTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现\n\nHTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：\n\n<img src=\"https://img-blog.csdnimg.cn/65281a9a92e14718a0aee46a6e514338.png\" style=\"zoom:25%;\" />\n\n* Client发起一个HTTPS的请求\n* Server把事先配置好的公钥证书返回给客户端。\n* Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书），如果验证通过则继续，不通过则显示警告信息。\n* Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。\n* Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。\n* Server使用对称密钥加密明文内容A，发送给Client。\n* Client使用对称密钥解密响应的密文，得到明文内容A。\n* Client再次发起HTTPS的请求，使用对称密钥加密请求的明文内容B，然后Server使用对称密钥解密密文，得到明文内容B。\n\n# 数字证书\n\n客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\n> 这就存在些问题，如何保证公钥不被篡改和信任度？\n\n所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。\n\n通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。\n\n<img src=\"https://img-blog.csdnimg.cn/08d1910ce2fe42c0a7a0ed678cb074c6.png\" style=\"zoom:25%;\" />\n\n# 请求报文\n\n**请求头**\n\nHTTP 请求报文由3部分组成(请求行+请求头+请求体)\n\n<img src=\"https://img-blog.csdnimg.cn/af3039bf68e54adfbe68b60b7ede321d.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/ca2ecaf13042486da3fc5b36667ddb75.png\" style=\"zoom:25%;\" />\n\n**常见的HTTP报文头属性**\n\n- Accpet\n  - 告诉服务端，客户端接收什么类型的响应\n- Referer\n  - 表示这是请求是从哪个URL进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的Referer就是：[www.baidu.com](www.baidu.com)\n- Cache-Control\n  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置\n- Accept-Encoding\n  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)\n    - 例如:`Accept-Encoding:gzip, deflate`(这两种都是压缩格式)\n- Host\n  - 指定要请求的资源所在的主机和端口\n- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称\n- Connection\n\n　　决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。\n\n* 持久连接，事务完成后不关闭网络连接 ：` Connection: keep-alive`\n\n- 非持久连接，事务完成后关闭网络连接： `Connection: close`　\n\n# 响应报文\n\n响应报文与请求报文一样，由三个部分组成(响应行，响应头，响应体)\n\n<img src=\"https://img-blog.csdnimg.cn/1da807fe2185485f85c2a5f40696bd57.png\" style=\"zoom:45%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/b32b3cd8c34f4cc08f1e54bb53b3e6bf.png\" style=\"zoom:25%;\" />\n\n**HTTP响应报文属性**\n\n- Cache-Control\n  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存\n- ETag\n  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变\n- Location\n  - 在重定向中或者创建新资源时使用\n- Set-Cookie\n  - 服务端可以设置客户端的cookie\n\n**在浏览器地址栏键入URL**\n\n1. DNS解析：浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名对应的IP地址，DNS缓存从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、域名服务器缓存、顶级域名服务器缓存。\n\n* 从哪个缓存找到对应的IP直接返回，不再查询后面的缓存。\n\n2. TCP连接：结合三次握手\n\n3. 发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求发送给服务器\n\n4. 服务器处理请求并返回HTTP报文：服务器对浏览器请求做出响应，把对应的带有HTML文本的HTTP响应报文发送给浏览器\n\n5. 浏览器解析渲染页面\n\n6. 连接结束：浏览器释放TCP连接，该步骤即四次挥手。\n\n第5步和第6步可以认为是同时发生的，哪一步在前没有特别的要求\n\n<img src=\"https://img-blog.csdnimg.cn/994915d1718445bb803d0e9b9241cc95.png\" style=\"zoom:25%;\" />\n\n# Cookie和Session\n\nSession 是**基于Cookie 实现**的另一种记录服务端和客户端会话状态的机制。\n\n* Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。\n\nSession 的**认证过程**：\n\n1. 客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID\n2. 客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名\n3. 当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的 Session，如果有对应的 Session 则通过，继续执行请求，否则就中断\n\n**Cookie和Session的区别**\n\n1. 安全性，因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态\n2. 适用性，Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据\n3. 有效期，Cookie 可以设置任意时间有效，而 Session 一般失效时间短","source":"_posts/图解TCP IP/HTTP.md","raw":"---\ntitle: HTTP\ncategories: \n- 图解TCP IP\n---\n\n**请求方法**\n\nHTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。\n\nHTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。\n\n| 序 号 | 方法    | 描述                                                         |\n| ----- | ------- | ------------------------------------------------------------ |\n| 1     | GET     | 请求指定的页面信息，并返回实体主体。                         |\n| 2     | HEAD    | 类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头 |\n| 3     | POST    | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和/或已有资源的修改。 |\n| 4     | PUT     | 从客户端向服务器传送的数据取代指定的文档的内容。             |\n| 5     | DELETE  | 请求服务器删除指定的页面。                                   |\n| 6     | CONNECT | HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。    |\n| 7     | OPTIONS | 允许客户端查看服务器的性能。                                 |\n| 8     | TRACE   | 回显服务器收到的请求，主要用于测试或诊断。                   |\n| 9     | PATCH   | 是对 PUT 方法的补充，用来对已知资源进行局部更新 。           |\n\n**GET请求和POST请求的区别**\n\n1. GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到body中，在url 中不可见。\n2. 请求的url有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如IE浏览器对 URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应，因为GET请求的参数是添加到URL中，所以GET请求的URL的长度限制需要将请求参数长度也考虑进去。而POST请求不用考虑请求参数的长度。\n3. GET请求产生一个数据包; POST请求产生2个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为GET没有请求体，所以就发送一个数据包，而POST包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。\n4. GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。\n5. GET是幂等的，而POST不是(幂等表示执行相同的操作，结果也是相同的)\n6. GET是获取数据，POST是修改数据\n\n# 状态码\n\n**状态码由3位数字组成，第一位定义响应的类别**\n\n1XX：指示信息，表示请求以接收，继续处理\n\n2XX：成功，表示请求已经被成功接收、理解、接受\n\n- 200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。\n- 204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。\n\n- 206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。\n\n3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是**重定向**。\n\n* 301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。\n* 302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。\n\n301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。\n\n* 304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。\n\n4XX：状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。\n\n* 400 Bad Request表示客户端请求的报文有错误。\n\n* 401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。\n\n* 403 Forbidden表示服务器禁止访问资源，并不是客户端的请求出错。\n\n* 404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。\n\n5XX：状态码表示客户端请求报文正确，但是**服务器处理时内部发生了错误**，属于服务器端的错误码。\n\n* 501 Not Implemented 表示客户端请求的功能还不支持。\n\n* 502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。\n\n* 503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。\n\n* 504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。\n\n**301和302的区别**\n\n* 301重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。\n\n* 301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。\n\n* 302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。\n\n# HTTP1.1\n\n**长连接**\n\nHTTP 1.1支持长连接\n\nHTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。\n\nHTTP 1.1则支持持久连接Persistent Connection，并且默认使用，在同一个TCP的连接中可以传送多个HTTP请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头\n\nHTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为Close时，客户端通知服务器返回本次请求结果后关闭连接。\n\n**管道网络传输**\n\nHTTP/1.1 采用了长连接的方式，这使得管道网络传输成为了可能。\n\n即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**\n\n举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。\n\n但是服务器还是按照**顺序**，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。\n\n**Host字段**\n\n在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。\n\nHTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。\n\n此外，服务器应该接受以绝对路径标记的资源请求。\n\n**100Status**\n\nHTTP/1.1加入了一个新的状态码100。\n\n客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；\n\n如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。\n\n100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。\n\n**Chunked Transfer Coding**\n\nHTTP/1.1将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。\n\n这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。\n\n**Cache**\n\nHTTP/1.1在1.0的基础上加入了一些Cache的新特性，当缓存对象的Age超过Expire时变为Stable对象，Cache不需要直接抛弃Stable对象，而是与源服务器进行重新激活。\n\n# HTTP2.0\n\n**HTTP2.0和HTTP1.X相比的新特性**\n\n- 新的二进制格式，`HTTP1.x`的解析是基于文本\n- 多路复用，即连接共享，即每一个request都是是用作连接共享机制的，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面\n\n- header压缩，`HTTP1.x`的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小\n- 服务端推送\n\nHTTP/2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以**主动**向客户端发送消息。\n\n举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，**减少延时的等待**，也就是服务器推送。\n\n**数据流**\n\nHTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。\n\n因此，必须要对数据包做标记，指出它属于哪个回应。\n\n每个请求或回应的所有数据包，称为一个数据流（Stream）。\n\n每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数\n\n客户端还可以**指定数据流的优先级**。优先级高的请求，服务器就先响应该请求。\n\n**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别**\n\n- HTTP/1.1的Pipeling为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；\n- HTTP2.0多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行\n\n# HTTP3.0\n\n**使用UDP协议**\n\nHTTP/2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。\n\n所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。\n\n- HTTP/1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了\n- HTTP/2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。\n\n这都是基于 TCP 传输层的问题，所以 **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP！**\n\n# HTTPS\n\n**HTTP与HTTPS的区别**\n\nHTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全\n\n- HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO，谷歌、百度优先索引HTTPS网页\n- HTTPS需要用到SSL证书，而HTTP不用\n\n- HTTPS标准端口443，HTTP标准端口80\n- HTTPS基于传输层，HTTP基于应用层\n\n- HTTPS在浏览器显示绿色安全锁，HTTP没有显示\n\n**工作原理**\n\nHTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现\n\nHTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：\n\n<img src=\"https://img-blog.csdnimg.cn/65281a9a92e14718a0aee46a6e514338.png\" style=\"zoom:25%;\" />\n\n* Client发起一个HTTPS的请求\n* Server把事先配置好的公钥证书返回给客户端。\n* Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书），如果验证通过则继续，不通过则显示警告信息。\n* Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。\n* Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。\n* Server使用对称密钥加密明文内容A，发送给Client。\n* Client使用对称密钥解密响应的密文，得到明文内容A。\n* Client再次发起HTTPS的请求，使用对称密钥加密请求的明文内容B，然后Server使用对称密钥解密密文，得到明文内容B。\n\n# 数字证书\n\n客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。\n\n> 这就存在些问题，如何保证公钥不被篡改和信任度？\n\n所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将**服务器公钥放在数字证书**（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。\n\n通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。\n\n<img src=\"https://img-blog.csdnimg.cn/08d1910ce2fe42c0a7a0ed678cb074c6.png\" style=\"zoom:25%;\" />\n\n# 请求报文\n\n**请求头**\n\nHTTP 请求报文由3部分组成(请求行+请求头+请求体)\n\n<img src=\"https://img-blog.csdnimg.cn/af3039bf68e54adfbe68b60b7ede321d.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/ca2ecaf13042486da3fc5b36667ddb75.png\" style=\"zoom:25%;\" />\n\n**常见的HTTP报文头属性**\n\n- Accpet\n  - 告诉服务端，客户端接收什么类型的响应\n- Referer\n  - 表示这是请求是从哪个URL进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的Referer就是：[www.baidu.com](www.baidu.com)\n- Cache-Control\n  - 对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置\n- Accept-Encoding\n  - 这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)\n    - 例如:`Accept-Encoding:gzip, deflate`(这两种都是压缩格式)\n- Host\n  - 指定要请求的资源所在的主机和端口\n- User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称\n- Connection\n\n　　决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。\n\n* 持久连接，事务完成后不关闭网络连接 ：` Connection: keep-alive`\n\n- 非持久连接，事务完成后关闭网络连接： `Connection: close`　\n\n# 响应报文\n\n响应报文与请求报文一样，由三个部分组成(响应行，响应头，响应体)\n\n<img src=\"https://img-blog.csdnimg.cn/1da807fe2185485f85c2a5f40696bd57.png\" style=\"zoom:45%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/b32b3cd8c34f4cc08f1e54bb53b3e6bf.png\" style=\"zoom:25%;\" />\n\n**HTTP响应报文属性**\n\n- Cache-Control\n  - 响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存\n- ETag\n  - 表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变\n- Location\n  - 在重定向中或者创建新资源时使用\n- Set-Cookie\n  - 服务端可以设置客户端的cookie\n\n**在浏览器地址栏键入URL**\n\n1. DNS解析：浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名对应的IP地址，DNS缓存从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、域名服务器缓存、顶级域名服务器缓存。\n\n* 从哪个缓存找到对应的IP直接返回，不再查询后面的缓存。\n\n2. TCP连接：结合三次握手\n\n3. 发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求发送给服务器\n\n4. 服务器处理请求并返回HTTP报文：服务器对浏览器请求做出响应，把对应的带有HTML文本的HTTP响应报文发送给浏览器\n\n5. 浏览器解析渲染页面\n\n6. 连接结束：浏览器释放TCP连接，该步骤即四次挥手。\n\n第5步和第6步可以认为是同时发生的，哪一步在前没有特别的要求\n\n<img src=\"https://img-blog.csdnimg.cn/994915d1718445bb803d0e9b9241cc95.png\" style=\"zoom:25%;\" />\n\n# Cookie和Session\n\nSession 是**基于Cookie 实现**的另一种记录服务端和客户端会话状态的机制。\n\n* Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。\n\nSession 的**认证过程**：\n\n1. 客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID\n2. 客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名\n3. 当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的 Session，如果有对应的 Session 则通过，继续执行请求，否则就中断\n\n**Cookie和Session的区别**\n\n1. 安全性，因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态\n2. 适用性，Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据\n3. 有效期，Cookie 可以设置任意时间有效，而 Session 一般失效时间短","slug":"图解TCP IP/HTTP","published":1,"date":"2022-02-01T14:56:47.075Z","updated":"2022-02-08T02:51:15.739Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj500fpfhji71tned4h","content":"<p><strong>请求方法</strong></p>\n<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>\n<table>\n<thead>\n<tr>\n<th>序 号</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n<tr>\n<td>9</td>\n<td>PATCH</td>\n<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>\n</tr>\n</tbody></table>\n<p><strong>GET请求和POST请求的区别</strong></p>\n<ol>\n<li>GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到body中，在url 中不可见。</li>\n<li>请求的url有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如IE浏览器对 URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应，因为GET请求的参数是添加到URL中，所以GET请求的URL的长度限制需要将请求参数长度也考虑进去。而POST请求不用考虑请求参数的长度。</li>\n<li>GET请求产生一个数据包; POST请求产生2个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为GET没有请求体，所以就发送一个数据包，而POST包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。</li>\n<li>GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>\n<li>GET是幂等的，而POST不是(幂等表示执行相同的操作，结果也是相同的)</li>\n<li>GET是获取数据，POST是修改数据</li>\n</ol>\n<h1 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h1><p><strong>状态码由3位数字组成，第一位定义响应的类别</strong></p>\n<p>1XX：指示信息，表示请求以接收，继续处理</p>\n<p>2XX：成功，表示请求已经被成功接收、理解、接受</p>\n<ul>\n<li><p>200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</p>\n</li>\n<li><p>204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>\n</li>\n<li><p>206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p>\n</li>\n</ul>\n<p>3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>\n<ul>\n<li>301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。</li>\n<li>302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。</li>\n</ul>\n<p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>\n<ul>\n<li>304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</li>\n</ul>\n<p>4XX：状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>\n<ul>\n<li><p>400 Bad Request表示客户端请求的报文有错误。</p>\n</li>\n<li><p>401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>\n</li>\n<li><p>403 Forbidden表示服务器禁止访问资源，并不是客户端的请求出错。</p>\n</li>\n<li><p>404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>\n</li>\n</ul>\n<p>5XX：状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>\n<ul>\n<li><p>501 Not Implemented 表示客户端请求的功能还不支持。</p>\n</li>\n<li><p>502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p>\n</li>\n<li><p>503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。</p>\n</li>\n<li><p>504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</p>\n</li>\n</ul>\n<p><strong>301和302的区别</strong></p>\n<ul>\n<li><p>301重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。</p>\n</li>\n<li><p>301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。</p>\n</li>\n<li><p>302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。</p>\n</li>\n</ul>\n<h1 id=\"HTTP1-1\"><a href=\"#HTTP1-1\" class=\"headerlink\" title=\"HTTP1.1\"></a>HTTP1.1</h1><p><strong>长连接</strong></p>\n<p>HTTP 1.1支持长连接</p>\n<p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p>\n<p>HTTP 1.1则支持持久连接Persistent Connection，并且默认使用，在同一个TCP的连接中可以传送多个HTTP请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头</p>\n<p>HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为Close时，客户端通知服务器返回本次请求结果后关闭连接。</p>\n<p><strong>管道网络传输</strong></p>\n<p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道网络传输成为了可能。</p>\n<p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p>\n<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p>\n<p>但是服务器还是按照<strong>顺序</strong>，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。</p>\n<p><strong>Host字段</strong></p>\n<p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。</p>\n<p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>\n<p>此外，服务器应该接受以绝对路径标记的资源请求。</p>\n<p><strong>100Status</strong></p>\n<p>HTTP&#x2F;1.1加入了一个新的状态码100。</p>\n<p>客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；</p>\n<p>如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。</p>\n<p>100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p>\n<p><strong>Chunked Transfer Coding</strong></p>\n<p>HTTP&#x2F;1.1将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。</p>\n<p>这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。</p>\n<p><strong>Cache</strong></p>\n<p>HTTP&#x2F;1.1在1.0的基础上加入了一些Cache的新特性，当缓存对象的Age超过Expire时变为Stable对象，Cache不需要直接抛弃Stable对象，而是与源服务器进行重新激活。</p>\n<h1 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h1><p><strong>HTTP2.0和HTTP1.X相比的新特性</strong></p>\n<ul>\n<li><p>新的二进制格式，<code>HTTP1.x</code>的解析是基于文本</p>\n</li>\n<li><p>多路复用，即连接共享，即每一个request都是是用作连接共享机制的，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面</p>\n</li>\n<li><p>header压缩，<code>HTTP1.x</code>的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小</p>\n</li>\n<li><p>服务端推送</p>\n</li>\n</ul>\n<p>HTTP&#x2F;2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p>\n<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送。</p>\n<p><strong>数据流</strong></p>\n<p>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。</p>\n<p>因此，必须要对数据包做标记，指出它属于哪个回应。</p>\n<p>每个请求或回应的所有数据包，称为一个数据流（Stream）。</p>\n<p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>\n<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p>\n<p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别</strong></p>\n<ul>\n<li>HTTP&#x2F;1.1的Pipeling为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；</li>\n<li>HTTP2.0多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行</li>\n</ul>\n<h1 id=\"HTTP3-0\"><a href=\"#HTTP3-0\" class=\"headerlink\" title=\"HTTP3.0\"></a>HTTP3.0</h1><p><strong>使用UDP协议</strong></p>\n<p>HTTP&#x2F;2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</p>\n<p>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>\n<ul>\n<li>HTTP&#x2F;1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>\n<li>HTTP&#x2F;2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>\n</ul>\n<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>\n<h1 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h1><p><strong>HTTP与HTTPS的区别</strong></p>\n<p>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</p>\n<ul>\n<li><p>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO，谷歌、百度优先索引HTTPS网页</p>\n</li>\n<li><p>HTTPS需要用到SSL证书，而HTTP不用</p>\n</li>\n<li><p>HTTPS标准端口443，HTTP标准端口80</p>\n</li>\n<li><p>HTTPS基于传输层，HTTP基于应用层</p>\n</li>\n<li><p>HTTPS在浏览器显示绿色安全锁，HTTP没有显示</p>\n</li>\n</ul>\n<p><strong>工作原理</strong></p>\n<p>HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现</p>\n<p>HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：</p>\n<img src=\"https://img-blog.csdnimg.cn/65281a9a92e14718a0aee46a6e514338.png\" style=\"zoom:25%;\" />\n\n<ul>\n<li>Client发起一个HTTPS的请求</li>\n<li>Server把事先配置好的公钥证书返回给客户端。</li>\n<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书），如果验证通过则继续，不通过则显示警告信息。</li>\n<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li>\n<li>Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li>\n<li>Server使用对称密钥加密明文内容A，发送给Client。</li>\n<li>Client使用对称密钥解密响应的密文，得到明文内容A。</li>\n<li>Client再次发起HTTPS的请求，使用对称密钥加密请求的明文内容B，然后Server使用对称密钥解密密文，得到明文内容B。</li>\n</ul>\n<h1 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h1><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>\n<blockquote>\n<p>这就存在些问题，如何保证公钥不被篡改和信任度？</p>\n</blockquote>\n<p>所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>\n<p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p>\n<img src=\"https://img-blog.csdnimg.cn/08d1910ce2fe42c0a7a0ed678cb074c6.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"请求报文\"><a href=\"#请求报文\" class=\"headerlink\" title=\"请求报文\"></a>请求报文</h1><p><strong>请求头</strong></p>\n<p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p>\n<img src=\"https://img-blog.csdnimg.cn/af3039bf68e54adfbe68b60b7ede321d.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/ca2ecaf13042486da3fc5b36667ddb75.png\" style=\"zoom:25%;\" />\n\n<p><strong>常见的HTTP报文头属性</strong></p>\n<ul>\n<li>Accpet<ul>\n<li>告诉服务端，客户端接收什么类型的响应</li>\n</ul>\n</li>\n<li>Referer<ul>\n<li>表示这是请求是从哪个URL进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的Referer就是：<a href=\"www.baidu.com\">www.baidu.com</a></li>\n</ul>\n</li>\n<li>Cache-Control<ul>\n<li>对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置</li>\n</ul>\n</li>\n<li>Accept-Encoding<ul>\n<li>这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)<ul>\n<li>例如:<code>Accept-Encoding:gzip, deflate</code>(这两种都是压缩格式)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Host<ul>\n<li>指定要请求的资源所在的主机和端口</li>\n</ul>\n</li>\n<li>User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称</li>\n<li>Connection</li>\n</ul>\n<p>　　决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。</p>\n<ul>\n<li>持久连接，事务完成后不关闭网络连接 ：<code> Connection: keep-alive</code></li>\n</ul>\n<ul>\n<li>非持久连接，事务完成后关闭网络连接： <code>Connection: close</code></li>\n</ul>\n<p>　</p>\n<h1 id=\"响应报文\"><a href=\"#响应报文\" class=\"headerlink\" title=\"响应报文\"></a>响应报文</h1><p>响应报文与请求报文一样，由三个部分组成(响应行，响应头，响应体)</p>\n<img src=\"https://img-blog.csdnimg.cn/1da807fe2185485f85c2a5f40696bd57.png\" style=\"zoom:45%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/b32b3cd8c34f4cc08f1e54bb53b3e6bf.png\" style=\"zoom:25%;\" />\n\n<p><strong>HTTP响应报文属性</strong></p>\n<ul>\n<li>Cache-Control<ul>\n<li>响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存</li>\n</ul>\n</li>\n<li>ETag<ul>\n<li>表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变</li>\n</ul>\n</li>\n<li>Location<ul>\n<li>在重定向中或者创建新资源时使用</li>\n</ul>\n</li>\n<li>Set-Cookie<ul>\n<li>服务端可以设置客户端的cookie</li>\n</ul>\n</li>\n</ul>\n<p><strong>在浏览器地址栏键入URL</strong></p>\n<ol>\n<li>DNS解析：浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名对应的IP地址，DNS缓存从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、域名服务器缓存、顶级域名服务器缓存。</li>\n</ol>\n<ul>\n<li>从哪个缓存找到对应的IP直接返回，不再查询后面的缓存。</li>\n</ul>\n<ol start=\"2\">\n<li><p>TCP连接：结合三次握手</p>\n</li>\n<li><p>发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求发送给服务器</p>\n</li>\n<li><p>服务器处理请求并返回HTTP报文：服务器对浏览器请求做出响应，把对应的带有HTML文本的HTTP响应报文发送给浏览器</p>\n</li>\n<li><p>浏览器解析渲染页面</p>\n</li>\n<li><p>连接结束：浏览器释放TCP连接，该步骤即四次挥手。</p>\n</li>\n</ol>\n<p>第5步和第6步可以认为是同时发生的，哪一步在前没有特别的要求</p>\n<img src=\"https://img-blog.csdnimg.cn/994915d1718445bb803d0e9b9241cc95.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"Cookie和Session\"><a href=\"#Cookie和Session\" class=\"headerlink\" title=\"Cookie和Session\"></a>Cookie和Session</h1><p>Session 是<strong>基于Cookie 实现</strong>的另一种记录服务端和客户端会话状态的机制。</p>\n<ul>\n<li>Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。</li>\n</ul>\n<p>Session 的<strong>认证过程</strong>：</p>\n<ol>\n<li>客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID</li>\n<li>客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名</li>\n<li>当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的 Session，如果有对应的 Session 则通过，继续执行请求，否则就中断</li>\n</ol>\n<p><strong>Cookie和Session的区别</strong></p>\n<ol>\n<li>安全性，因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态</li>\n<li>适用性，Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据</li>\n<li>有效期，Cookie 可以设置任意时间有效，而 Session 一般失效时间短</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>请求方法</strong></p>\n<p>HTTP1.0 定义了三种请求方法： GET, POST 和 HEAD方法。</p>\n<p>HTTP1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE 和 CONNECT 方法。</p>\n<table>\n<thead>\n<tr>\n<th>序 号</th>\n<th>方法</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>GET</td>\n<td>请求指定的页面信息，并返回实体主体。</td>\n</tr>\n<tr>\n<td>2</td>\n<td>HEAD</td>\n<td>类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头</td>\n</tr>\n<tr>\n<td>3</td>\n<td>POST</td>\n<td>向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。POST 请求可能会导致新的资源的建立和&#x2F;或已有资源的修改。</td>\n</tr>\n<tr>\n<td>4</td>\n<td>PUT</td>\n<td>从客户端向服务器传送的数据取代指定的文档的内容。</td>\n</tr>\n<tr>\n<td>5</td>\n<td>DELETE</td>\n<td>请求服务器删除指定的页面。</td>\n</tr>\n<tr>\n<td>6</td>\n<td>CONNECT</td>\n<td>HTTP&#x2F;1.1 协议中预留给能够将连接改为管道方式的代理服务器。</td>\n</tr>\n<tr>\n<td>7</td>\n<td>OPTIONS</td>\n<td>允许客户端查看服务器的性能。</td>\n</tr>\n<tr>\n<td>8</td>\n<td>TRACE</td>\n<td>回显服务器收到的请求，主要用于测试或诊断。</td>\n</tr>\n<tr>\n<td>9</td>\n<td>PATCH</td>\n<td>是对 PUT 方法的补充，用来对已知资源进行局部更新 。</td>\n</tr>\n</tbody></table>\n<p><strong>GET请求和POST请求的区别</strong></p>\n<ol>\n<li>GET 请求的请求参数是添加到 head 中，可以在 url 中可以看到；POST 请求的请求参数是添加到body中，在url 中不可见。</li>\n<li>请求的url有长度限制，这个限制由浏览器和 web 服务器决定和设置的，例如IE浏览器对 URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应，因为GET请求的参数是添加到URL中，所以GET请求的URL的长度限制需要将请求参数长度也考虑进去。而POST请求不用考虑请求参数的长度。</li>\n<li>GET请求产生一个数据包; POST请求产生2个数据包，在火狐浏览器中，产生一个数据包，这个区别点在于浏览器的请求机制，先发送请求头，再发送请求体，因为GET没有请求体，所以就发送一个数据包，而POST包含请求体，所以发送两次数据包，但是由于火狐机制不同，所以发送一个数据包。</li>\n<li>GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>\n<li>GET是幂等的，而POST不是(幂等表示执行相同的操作，结果也是相同的)</li>\n<li>GET是获取数据，POST是修改数据</li>\n</ol>\n<h1 id=\"状态码\"><a href=\"#状态码\" class=\"headerlink\" title=\"状态码\"></a>状态码</h1><p><strong>状态码由3位数字组成，第一位定义响应的类别</strong></p>\n<p>1XX：指示信息，表示请求以接收，继续处理</p>\n<p>2XX：成功，表示请求已经被成功接收、理解、接受</p>\n<ul>\n<li><p>200 OK 是最常见的成功状态码，表示一切正常。如果是非 HEAD 请求，服务器返回的响应头都会有 body 数据。</p>\n</li>\n<li><p>204 No Content 也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。</p>\n</li>\n<li><p>206 Partial Content 是应用于 HTTP 分块下载或断电续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。</p>\n</li>\n</ul>\n<p>3XX：状态码表示客户端请求的资源发送了变动，需要客户端用新的 URL 重新发送请求获取资源，也就是<strong>重定向</strong>。</p>\n<ul>\n<li>301 Moved Permanently 表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问，搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址。</li>\n<li>302 Moved Permanently 表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问，搜索引擎会抓取新的内容而保存旧的网址。</li>\n</ul>\n<p>301 和 302 都会在响应头里使用字段 Location，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。</p>\n<ul>\n<li>304 Not Modified不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，用于缓存控制。</li>\n</ul>\n<p>4XX：状态码表示客户端发送的<strong>报文有误</strong>，服务器无法处理，也就是错误码的含义。</p>\n<ul>\n<li><p>400 Bad Request表示客户端请求的报文有错误。</p>\n</li>\n<li><p>401 Unauthorized：缺失或错误的认证，这个状态代码必须和WWW-Authenticate报头域一起使用。</p>\n</li>\n<li><p>403 Forbidden表示服务器禁止访问资源，并不是客户端的请求出错。</p>\n</li>\n<li><p>404 Not Found表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。</p>\n</li>\n</ul>\n<p>5XX：状态码表示客户端请求报文正确，但是<strong>服务器处理时内部发生了错误</strong>，属于服务器端的错误码。</p>\n<ul>\n<li><p>501 Not Implemented 表示客户端请求的功能还不支持。</p>\n</li>\n<li><p>502 Bad Gateway 通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。</p>\n</li>\n<li><p>503 Service Unavailable 表示服务器当前很忙，暂时无法响应服务器。</p>\n</li>\n<li><p>504 Gateway Timeout：网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。</p>\n</li>\n</ul>\n<p><strong>301和302的区别</strong></p>\n<ul>\n<li><p>301重定向，指页面永久性转移，表示为资源或页面永久性地转移到了另一个位置。</p>\n</li>\n<li><p>301是HTTP协议中的一种状态码，当用户或搜索引擎向服务器发出浏览请求时，服务器返回的HTTP数据流中头信息中包含状态码 301 ，表示该资源已经永久改变了位置。</p>\n</li>\n<li><p>302重定向是页面暂时性转移，搜索引擎会抓取新的内容而保存旧的网址并认为新的网址只是暂时的。</p>\n</li>\n</ul>\n<h1 id=\"HTTP1-1\"><a href=\"#HTTP1-1\" class=\"headerlink\" title=\"HTTP1.1\"></a>HTTP1.1</h1><p><strong>长连接</strong></p>\n<p>HTTP 1.1支持长连接</p>\n<p>HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。</p>\n<p>HTTP 1.1则支持持久连接Persistent Connection，并且默认使用，在同一个TCP的连接中可以传送多个HTTP请求和响应，多个请求和响应可以重叠，多个请求和响应可以同时进行，更加多的请求头和响应头</p>\n<p>HTTP 1.1的持续连接，也需要增加新的请求头来帮助实现，例如，Connection请求头的值为Keep-Alive时，客户端通知服务器返回本次请求结果后保持连接；Connection请求头的值为Close时，客户端通知服务器返回本次请求结果后关闭连接。</p>\n<p><strong>管道网络传输</strong></p>\n<p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道网络传输成为了可能。</p>\n<p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以<strong>减少整体的响应时间。</strong></p>\n<p>举例来说，客户端需要请求两个资源。以前的做法是，在同一个TCP连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求，管道机制则是允许浏览器同时发出 A 请求和 B 请求。</p>\n<p>但是服务器还是按照<strong>顺序</strong>，先回应 A 请求，完成后再回应 B 请求，要是 前面的回应特别慢，后面就会有许多请求排队等着。</p>\n<p><strong>Host字段</strong></p>\n<p>在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名，但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。</p>\n<p>HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。</p>\n<p>此外，服务器应该接受以绝对路径标记的资源请求。</p>\n<p><strong>100Status</strong></p>\n<p>HTTP&#x2F;1.1加入了一个新的状态码100。</p>\n<p>客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；</p>\n<p>如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。</p>\n<p>100状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p>\n<p><strong>Chunked Transfer Coding</strong></p>\n<p>HTTP&#x2F;1.1将发送方将消息分割成若干个任意大小的数据块，每个数据块在发送时都会附上块的长度，最后用一个零长度的块作为消息结束的标志。</p>\n<p>这种方法允许发送方只缓冲消息的一个片段，避免缓冲整个消息带来的过载。</p>\n<p><strong>Cache</strong></p>\n<p>HTTP&#x2F;1.1在1.0的基础上加入了一些Cache的新特性，当缓存对象的Age超过Expire时变为Stable对象，Cache不需要直接抛弃Stable对象，而是与源服务器进行重新激活。</p>\n<h1 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h1><p><strong>HTTP2.0和HTTP1.X相比的新特性</strong></p>\n<ul>\n<li><p>新的二进制格式，<code>HTTP1.x</code>的解析是基于文本</p>\n</li>\n<li><p>多路复用，即连接共享，即每一个request都是是用作连接共享机制的，一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面</p>\n</li>\n<li><p>header压缩，<code>HTTP1.x</code>的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小</p>\n</li>\n<li><p>服务端推送</p>\n</li>\n</ul>\n<p>HTTP&#x2F;2 还在一定程度上改善了传统的请求 - 应答工作模式，服务不再是被动地响应，也可以<strong>主动</strong>向客户端发送消息。</p>\n<p>举例来说，在浏览器刚请求 HTML 的时候，就提前把可能会用到的 JS、CSS 文件等静态资源主动发给客户端，<strong>减少延时的等待</strong>，也就是服务器推送。</p>\n<p><strong>数据流</strong></p>\n<p>HTTP&#x2F;2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。</p>\n<p>因此，必须要对数据包做标记，指出它属于哪个回应。</p>\n<p>每个请求或回应的所有数据包，称为一个数据流（Stream）。</p>\n<p>每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数， 服务器发出的数据流编号为偶数</p>\n<p>客户端还可以<strong>指定数据流的优先级</strong>。优先级高的请求，服务器就先响应该请求。</p>\n<p><strong>HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别</strong></p>\n<ul>\n<li>HTTP&#x2F;1.1的Pipeling为若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法；</li>\n<li>HTTP2.0多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行</li>\n</ul>\n<h1 id=\"HTTP3-0\"><a href=\"#HTTP3-0\" class=\"headerlink\" title=\"HTTP3.0\"></a>HTTP3.0</h1><p><strong>使用UDP协议</strong></p>\n<p>HTTP&#x2F;2 主要的问题在于：多个 HTTP 请求在复用一个 TCP 连接，下层的 TCP 协议是不知道有多少个 HTTP 请求的。</p>\n<p>所以一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p>\n<ul>\n<li>HTTP&#x2F;1.1 中的管道传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了</li>\n<li>HTTP&#x2F;2 多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。</li>\n</ul>\n<p>这都是基于 TCP 传输层的问题，所以 <strong>HTTP&#x2F;3 把 HTTP 下层的 TCP 协议改成了 UDP！</strong></p>\n<h1 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h1><p><strong>HTTP与HTTPS的区别</strong></p>\n<p>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全</p>\n<ul>\n<li><p>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO，谷歌、百度优先索引HTTPS网页</p>\n</li>\n<li><p>HTTPS需要用到SSL证书，而HTTP不用</p>\n</li>\n<li><p>HTTPS标准端口443，HTTP标准端口80</p>\n</li>\n<li><p>HTTPS基于传输层，HTTP基于应用层</p>\n</li>\n<li><p>HTTPS在浏览器显示绿色安全锁，HTTP没有显示</p>\n</li>\n</ul>\n<p><strong>工作原理</strong></p>\n<p>HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现</p>\n<p>HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：</p>\n<img src=\"https://img-blog.csdnimg.cn/65281a9a92e14718a0aee46a6e514338.png\" style=\"zoom:25%;\" />\n\n<ul>\n<li>Client发起一个HTTPS的请求</li>\n<li>Server把事先配置好的公钥证书返回给客户端。</li>\n<li>Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书），如果验证通过则继续，不通过则显示警告信息。</li>\n<li>Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。</li>\n<li>Server使用自己的私钥解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。</li>\n<li>Server使用对称密钥加密明文内容A，发送给Client。</li>\n<li>Client使用对称密钥解密响应的密文，得到明文内容A。</li>\n<li>Client再次发起HTTPS的请求，使用对称密钥加密请求的明文内容B，然后Server使用对称密钥解密密文，得到明文内容B。</li>\n</ul>\n<h1 id=\"数字证书\"><a href=\"#数字证书\" class=\"headerlink\" title=\"数字证书\"></a>数字证书</h1><p>客户端先向服务器端索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密。</p>\n<blockquote>\n<p>这就存在些问题，如何保证公钥不被篡改和信任度？</p>\n</blockquote>\n<p>所以这里就需要借助第三方权威机构 CA （数字证书认证机构），将<strong>服务器公钥放在数字证书</strong>（由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>\n<p>通过数字证书的方式保证服务器公钥的身份，解决冒充的风险。</p>\n<img src=\"https://img-blog.csdnimg.cn/08d1910ce2fe42c0a7a0ed678cb074c6.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"请求报文\"><a href=\"#请求报文\" class=\"headerlink\" title=\"请求报文\"></a>请求报文</h1><p><strong>请求头</strong></p>\n<p>HTTP 请求报文由3部分组成(请求行+请求头+请求体)</p>\n<img src=\"https://img-blog.csdnimg.cn/af3039bf68e54adfbe68b60b7ede321d.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/ca2ecaf13042486da3fc5b36667ddb75.png\" style=\"zoom:25%;\" />\n\n<p><strong>常见的HTTP报文头属性</strong></p>\n<ul>\n<li>Accpet<ul>\n<li>告诉服务端，客户端接收什么类型的响应</li>\n</ul>\n</li>\n<li>Referer<ul>\n<li>表示这是请求是从哪个URL进来的,比如想在网上购物，但是不知道选择哪家电商平台，你就去问度娘，说哪家电商的东西便宜啊，然后一堆东西弹出在你面前，第一给就是某宝，当你从这里进入某宝的时候，这个请求报文的Referer就是：<a href=\"www.baidu.com\">www.baidu.com</a></li>\n</ul>\n</li>\n<li>Cache-Control<ul>\n<li>对缓存进行控制，如一个请求希望响应的内容在客户端缓存一年，或不被缓可以通过这个报文头设置</li>\n</ul>\n</li>\n<li>Accept-Encoding<ul>\n<li>这个属性是用来告诉服务器能接受什么编码格式，包括字符编码,压缩形式(一般都是压缩形式)<ul>\n<li>例如:<code>Accept-Encoding:gzip, deflate</code>(这两种都是压缩格式)</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Host<ul>\n<li>指定要请求的资源所在的主机和端口</li>\n</ul>\n</li>\n<li>User-Agent：告诉服务器，客户端使用的操作系统、浏览器版本和名称</li>\n<li>Connection</li>\n</ul>\n<p>　　决定当前事务（三次握手和四次挥手）完成后，是否关闭网络连接。</p>\n<ul>\n<li>持久连接，事务完成后不关闭网络连接 ：<code> Connection: keep-alive</code></li>\n</ul>\n<ul>\n<li>非持久连接，事务完成后关闭网络连接： <code>Connection: close</code></li>\n</ul>\n<p>　</p>\n<h1 id=\"响应报文\"><a href=\"#响应报文\" class=\"headerlink\" title=\"响应报文\"></a>响应报文</h1><p>响应报文与请求报文一样，由三个部分组成(响应行，响应头，响应体)</p>\n<img src=\"https://img-blog.csdnimg.cn/1da807fe2185485f85c2a5f40696bd57.png\" style=\"zoom:45%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/b32b3cd8c34f4cc08f1e54bb53b3e6bf.png\" style=\"zoom:25%;\" />\n\n<p><strong>HTTP响应报文属性</strong></p>\n<ul>\n<li>Cache-Control<ul>\n<li>响应输出到客户端后，服务端通过该属性告诉客户端该怎么控制响应内容的缓存</li>\n</ul>\n</li>\n<li>ETag<ul>\n<li>表示你请求资源的版本，如果该资源发生啦变化，那么这个属性也会跟着变</li>\n</ul>\n</li>\n<li>Location<ul>\n<li>在重定向中或者创建新资源时使用</li>\n</ul>\n</li>\n<li>Set-Cookie<ul>\n<li>服务端可以设置客户端的cookie</li>\n</ul>\n</li>\n</ul>\n<p><strong>在浏览器地址栏键入URL</strong></p>\n<ol>\n<li>DNS解析：浏览器会依据URL逐层查询DNS服务器缓存，解析URL中的域名对应的IP地址，DNS缓存从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、域名服务器缓存、顶级域名服务器缓存。</li>\n</ol>\n<ul>\n<li>从哪个缓存找到对应的IP直接返回，不再查询后面的缓存。</li>\n</ul>\n<ol start=\"2\">\n<li><p>TCP连接：结合三次握手</p>\n</li>\n<li><p>发送HTTP请求：浏览器发出读取文件的HTTP请求，该请求发送给服务器</p>\n</li>\n<li><p>服务器处理请求并返回HTTP报文：服务器对浏览器请求做出响应，把对应的带有HTML文本的HTTP响应报文发送给浏览器</p>\n</li>\n<li><p>浏览器解析渲染页面</p>\n</li>\n<li><p>连接结束：浏览器释放TCP连接，该步骤即四次挥手。</p>\n</li>\n</ol>\n<p>第5步和第6步可以认为是同时发生的，哪一步在前没有特别的要求</p>\n<img src=\"https://img-blog.csdnimg.cn/994915d1718445bb803d0e9b9241cc95.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"Cookie和Session\"><a href=\"#Cookie和Session\" class=\"headerlink\" title=\"Cookie和Session\"></a>Cookie和Session</h1><p>Session 是<strong>基于Cookie 实现</strong>的另一种记录服务端和客户端会话状态的机制。</p>\n<ul>\n<li>Session 是存储在服务端，而 SessionId 会被存储在客户端的 Cookie 中。</li>\n</ul>\n<p>Session 的<strong>认证过程</strong>：</p>\n<ol>\n<li>客户端第一次发送请求到服务端，服务端根据信息创建对应的 Session，并在响应头返回 SessionID</li>\n<li>客户端接收到服务端返回的 SessionID 后，会将此信息存储在 Cookie 上，同时会记录这个 SessionID 属于哪个域名</li>\n<li>当客户端再次访问服务端时，请求会自动判断该域名下是否存在 Cookie 信息，如果有则发送给服务端，服务端会从 Cookie 中拿到 SessionID，再根据 SessionID 找到对应的 Session，如果有对应的 Session 则通过，继续执行请求，否则就中断</li>\n</ol>\n<p><strong>Cookie和Session的区别</strong></p>\n<ol>\n<li>安全性，因为 Cookie 可以通过客户端修改，而 Session 只能在服务端设置，所以安全性比 Cookie 高，一般会用于验证用户登录状态</li>\n<li>适用性，Cookie 只能存储字符串数据，而 Session 可以存储任意类型数据</li>\n<li>有效期，Cookie 可以设置任意时间有效，而 Session 一般失效时间短</li>\n</ol>\n"},{"title":"TCP IP基础知识","_content":"\n# TCP和IP模型\n\nOSI模型注重通信协议必要的功能；TCP/IP更强调在计算机上实现协议应该开发哪种程序。\n\n**TCP/IP划分了四层网络模型**\n\n- 第一层：应用层，主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等\n- 第二层：传输层，主要是有**可靠传输**的TCP协议，特别**高效**的UDP协议。主要负责传输应用层的数据包。\n- 第三层：网络层，主要是IP协议。主要负责寻址（找到目标设备的位置）\n- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。\n\n<img src=\"https://img-blog.csdnimg.cn/2c306962843a4ea59c890f3dd727202a.png\" style=\"zoom:25%;\" />\n\n**四层网络协议的作用**\n\n- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。\n- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。\n- 层层加密和解密后，应用层最终拿到了需要的数据。\n\n**举个例子：**\n\n我们需要发送一个**index.html**。\n\n* 两台电脑在应用层都使用HTTP协议（即都使用浏览器）。\n\n* 在传输层，TCP协议会将HTTP协议发送的数据看作一个数据包，并在这个数据包前面加上TCP包的一部分信息（部首）\n\n* 在网络层，IP协议会将TCP协议要发送的数据看作一个数据包，同样的在这个数据包前端加上IP协议的部首\n\n* 在数据链路层，对应的协议也会在IP数据包前端加上以太网的部首。\n\n<img src=\"https://img-blog.csdnimg.cn/270ea156a87d470c938049611cfae9ad.png\" style=\"zoom:50%;\" />\n\n* 源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。\n\n* 数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的IP数据包，再将IP数据包传给上层的网络层。\n\n* 数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。\n\n<img src=\"https://img-blog.csdnimg.cn/b3a1a77662fa4d2a9052033792e2bc64.png\" style=\"zoom:50%;\" />\n\n**TCP/IP协议族**\n\n从字面意义上来讲，TCP/IP是指**传输层**的TCP协议和**网络层**的IP协议。\n\n实际上，TCP/IP只是利用 IP 进行通信时所必须用到的协议群的统称。\n\n具体来说，在网络层是IP/ICMP协议、在传输层是TCP/UDP协议、在应用层是SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。\n\n# 网络层\n\n**MAC地址**\n\nMAC称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。\n\nMAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。\n\n> MAC地址对应于OSI参考模型的第二层数据链路层，工作在数据链路层的交换机维护着计算机MAC地址和自身端口的数据库，交换机根据收到的数据帧中的目的MAC地址字段来转发数据帧。\n\nMAC地址更像是身份证，是一个唯一的标识。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。\n\n## IP地址\n\n常见的IP地址分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；\n\nIP地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机\n\n* 本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。\n\nIP地址对应于OSI参考模型的第三层网络层，工作在网络层的路由器根据目标IP和源IP来判断是否属于同一网段，如果是不同网段，则转发数据包。\n\n**IP地址格式和表示**\n\nIP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）\n\n* 每一段8位二进制，中间使用英文的标点符号`.`隔开\n\n由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。\n\nIP地址的这种表示法叫做**点分十进制表示法**。\n\n* 举个栗子：`210.21.196.6`就是一个IP地址的表示。\n\n计算机的IP地址由两部分组成，一部分为网络标识，一部分为主机标识，同一网段内的计算机网络部分相同，主机部分不能同时重复出现。\n\n* **路由器**连接不同网段，负责不同网段之间的数据转发，**交换机**连接的是同一网段的计算机。\n\n通过设置网络地址和主机地址，在互相连接的整个网络中保证每台主机的IP地址不会互相重叠，即IP地址具有了唯一性。\n\n**IP地址分类**\n\nIP地址分A、B、C、D、E五类，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。\n\n<img src=\"https://img-blog.csdnimg.cn/2c725f4c914a4d46ac9e625d3532a036.png\" style=\"zoom:30%;\" />\n\n**公有IP地址和私有IP地址**\n\n![](https://img-blog.csdnimg.cn/06628445eb4444b3a31ec25e89098934.png)\n\n平时我们看到的数据中心里，办公室、家里或学校的IP地址，一般都是私有IP地址段。因为这些地址允许组织内部的IT人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有IP地址段和我学校的可以是一样的。\n\n* 这就像每个小区有自己的楼编号和门牌号，你们小区可以叫6栋，我们小区也叫6栋，没有任何问题。\n\n* 但是一旦出了小区，就需要使用公有IP地址。就像人民路888号，是国家统一分配的，不能两个小区都叫人民路888号。\n\n公有IP地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的IT人员给你一个IP地址就行。\n\n但是假如你要做一个类似网易163这样的网站，就需要有公有IP地址，这样全世界的人才能访问。\n\n* 表格中的`192.168.0.x`是最常用的私有IP地址。\n\n* 你家里有Wi-Fi，对应就会有一个IP地址。一般你家里地上网设备不会超过256个。\n\n不需要将十进制转换为二进制32位，就能明显看出192.168.0是网络号，后面是主机号。\n\n而整个网络里面的第一个地址192.168.0.1，往往就是你这个私有网络的出口地址。\n\n例如，你家里的电脑连接Wi-Fi，Wi-Fi路由器的地址就是192.168.0.1，而192.168.0.255就是广播地址。\n\n* 一旦发送这个地址，整个192.168.0网络里面的所有机器都能收到。\n\n**动态主机配置协议（DHCP）**\n\n配置了IP之后一般不能变的，配置一个服务端的机器还可以，但是如果是客户端的机器呢？我抱着一台笔记本电脑在公司里走来走去，或者白天来晚上走，每次使用都要配置IP地址，那可怎么办？\n\n* 还有人事、行政等非技术人员，如果公司所有的电脑都需要IT人员配置，肯定忙不过来啊。\n\n因此，我们需要有一个自动配置的协议，也就是**动态主机配置协议（Dynamic Host Configuration Protocol）**，简称**DHCP**。\n\n* 有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的IP地址。\n\n* 每一台新接入的机器都通过DHCP协议，来这个共享的IP地址里申请，然后自动配置好就可以了。\n\n* 等人走了，或者用完了，还回去，这样其他的机器也能用。\n\n所以说，**如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修。DHCP的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。**\n\n一个广播的网络里面接入了N台机器，我怎么知道每个MAC地址是谁呢？这就是**ARP协议**，也就是已知IP地址，求MAC地址的协议。\n\n<img src=\"https://img-blog.csdnimg.cn/36995f9f91204a4580d24cd8cdfb2cf1.png\" style=\"zoom:25%;\" />\n\n为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP的MAC地址缓存过一段时间就会过期。\n\n**ICMP协议**\n\nping的操作是基于ICMP协议工作的。\n\n* **ICMP**全称**Internet Control Message Protocol**，就是**互联网控制报文协议**。\n\n网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。\n\n* 当遇到问题的时候，总不能死个不明不白，要传出消息来，报告情况，这样才可以调整传输策略。\n\n这就相当于我们经常看到的电视剧里，古代行军的时候，为将为帅者需要通过侦察兵、哨探或传令兵等人肉的方式来掌握情况，控制整个战局。\n\nICMP报文是封装在IP包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。\n\n<img src=\"https://img-blog.csdnimg.cn/a104b3fd98b04fb18b0657c297e817c0.png\" style=\"zoom:25%;\" />\n\n**ARP协议**\n\nARP即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。\n\n**ARP协议的工作过程**\n\n* 首先，每个主机都会有自己的ARP缓存区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系\n\n当源主机要发送数据时，首先检测ARP列表中是否对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包\n\n当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果存在，则覆盖然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址\n\n源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据，如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。\n\n## 子网掩码\n\n**子网掩码的概念及作用**\n\n通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。\n\n* 子网掩码和IP地址做与运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。\n\n子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。\n\n**子网掩码的组成**\n\n同IP地址一样，子网掩码是由长度为32位二进制数组成的一个地址。\n\n子网掩码32位与IP地址32位相对应，IP地址如果某位是网络地址，则子网掩码为1，否则为0。\n\n* 举个栗子：如：`11111111.11111111.11111111.00000000`\n\n> 左边连续的1的个数代表网络号的长度，（使用时必须是连续的，理论上也可以不连续），右边连续的0的个数代表主机号的长度。\n\n**为什么要使用子网掩码**\n\n两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。\n\n* 如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。\n\n> 可以这么简单的理解：A主机要与B主机通信，A和B各自的IP地址与A主机的子网掩码进行And与运算，看得出的结果：\n>\n> 1、结果如果相同，则说明这两台主机是处于同一个网段，这样A可以通过ARP广播发现B的MAC地址，B也可以发现A的MAC地址来实现正常通信。\n>\n> 2、如果结果不同，ARP广播会在本地网关终结，这时候A会把发给B的数据包先发给本地网关，网关再根据B主机的IP地址来查询路由表，再将数据包继续传递转发，最终送达到目的地B。\n\n------\n\n> 计算机的网关（Gateway）就是到其他网段的出口，也就是路由器接口IP地址。\n>\n> 路由器接口使用的IP地址可以是本网段中任何一个地址，不过通常使用该网段的第一个可用的地址或最后一个可用的地址，这是为了尽可能避免和本网段中的主机地址冲突。\n\n在如下拓扑图示例中，A与B，C与D，都可以直接相互通信（都是属于各自同一网段，不用经过路由器）\n\n但是A与C，A与D，B与C，B与D它们之间不属于同一网段，所以它们通信是要经过本地网关，然后路由器根据对方IP地址，在路由表中查找恰好有匹配到对方IP地址的直连路由，于是从另一边网关接口转发出去实现互连\n\n<img src=\"https://img-blog.csdnimg.cn/a3a6f3542c5e4bca810d056157362b5c.png\" style=\"zoom:50%;\" />\n\n**子网掩码和IP地址的关系**\n\n* 子网掩码是用来判断任意两台主机的IP地址是否属于同一网络的依据\n\n* 拿双方主机的IP地址和自己主机的子网掩码做与运算，如结果为同一网络，就可以直接通信\n\n**如何根据IP地址和子网掩码，计算网络地址：**\n\n* 将IP地址与子网掩码转换成二进制数。\n\n* 将二进制形式的 IP 地址与子网掩码做与运算。\n\n* 将得出的结果转化为十进制，便得到网络地址。\n\n<img src=\"https://img-blog.csdnimg.cn/f243e18a4e134ce388aa8f85ecdf2a2d.png\" style=\"zoom:50%;\" />\n\n## 网关\n\n**怎么在宿舍上网？**\n\n还记得咱们在宿舍的时候买了台交换机，几台机器组了一个局域网打游戏吗？\n\n* 可惜啊，只能打局域网的游戏，不能上网啊！盼啊盼啊，终于盼到大二，允许宿舍开通网络了。\n\n学校给每个宿舍的网口分配了一个IP地址。\n\n* 这个IP是校园网的IP，完全由网管部门控制。宿舍网的IP地址多为192.168.1.x。校园网的IP地址，假设是10.10.x.x。\n\n这个时候，你要在宿舍上网，有两个办法：\n\n* 第一个办法，让你们宿舍长再买一个网卡。这个时候，你们宿舍长的电脑里就有两张网卡。一张网卡的线插到你们宿舍的交换机上，另一张网卡的线插到校园网的网口。而且，这张新的网卡的IP地址要按照学校网管部门分配的配置，不然上不了网。**这种情况下，如果你们宿舍的人要上网，就需要一直开着宿舍长的电脑。**\n\n* 第二个办法，你们共同出钱买个家庭路由器。家庭路由器会有内网网口和外网网口。把外网网口的线插到校园网的网口上，将这个外网网口配置成和网管部的一样。内网网口连上你们宿舍的所有的电脑。**这种情况下，如果你们宿舍的人要上网，就需要一直开着路由器。**\n\n> 这两种方法其实是一样的。只不过第一种方式，让你的宿舍长的电脑，变成一个有多个口的路由器而已。\n\n而你买的家庭路由器，里面也跑着程序，和你宿舍长电脑里的功能一样，只不过是一个嵌入式的系统。\n\n* 当你的宿舍长能够上网之后，接下来，就是其他人的电脑怎么上网的问题。这就需要配置你们的**网卡。**\n\n* 当然DHCP是可以默认配置的。在进行网卡配置的时候，除了IP地址，还需要配置一个Gateway**的东西，这个就是**网关。\n\n网关实质上是一个网络通向其他网络的IP地址。\n\n* 比如有网络A和网络B，网络A的IP地址范围为`192.168.1.1~192. 168.1.254`，子网掩码为`255.255.255.0`；\n\n* 网络B的IP地址范围为`192.168.2.1~192.168.2.254`，子网掩码为`255.255.255.0`。\n\n在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(`255.255.255.0`)判定两个网络中的主机处在不同的网络里。\n\n* 而要实现这两个网络之间的通信，则必须通过网关。\n\n如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。\n\n**所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。**\n\n> 那么这个IP地址是哪台机器的IP地址呢？\n\n网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。\n\n* **如果是同一个网段**，例如，你访问你旁边的兄弟的电脑，那就没网关什么事情，直接将源地址和目标地址放入IP头中，然后通过ARP获得MAC地址，将源MAC和目的MAC放入MAC头中，发出去就可以了。\n\n* **如果不是同一网段**，例如，你要访问你们校园网里面的BBS，该怎么办？\n\n这就需要发往默认网关Gateway。Gateway的地址一定是和源IP地址是一个网段的。\n\n**如何发往默认网关呢？**\n\n网关不是和源IP地址是一个网段的么？\n\n* 这个过程就和发往同一个网段的其他机器是一样的：将源地址和目标IP地址放入IP头中，通过ARP获得网关的MAC地址，将源MAC和网关的MAC放入MAC头中，发送出去。\n\n* 网关所在的端口，例如`192.168.1.1/24`将网络包收进来，然后接下来怎么做，就完全看网关的了。\n\n**网关往往是一个路由器，是一个三层转发的设备。**\n\n* 三层设备？就是把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。\n\n在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源IP同网段的。\n\n很多情况下，人们把网关就叫做路由器。其实不完全准确，而另一种比喻更加恰当：**路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。**\n\n任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下MAC头和IP头，看看，根据自己的路由算法，选择另一只手，加上IP头和MAC头，然后扔出去。\n\n**静态路由是什么？**\n\n大致可以分为两类，一个是**静态路由**，一个是**动态路由**。\n\n* **静态路由，其实就是在路由器上，配置一条一条规则。**\n\n这些规则包括：想访问BBS站（它肯定有个网段），从2号口出去，下一跳是IP2；\n\n想访问教学视频站（它也有个自己的网段），从3号口出去，下一跳是IP3，然后保存在路由器里。\n\n* 每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳IPX。\n\nMAC地址是一个局域网内才有效的地址。因而，MAC地址只要过网关，就必定会改变，因为已经换了局域网。\n\n* 两者主要的区别在于IP地址是否改变。不改变IP地址的网关，我们称为**转发网关；改变IP地址的网关，我们称为NAT网关**。\n\n现在大家每家都有家用路由器，家里的网段都是`192.168.1.x`，所以你肯定访问不了你邻居家的这个私网的IP地址的。\n\n* 所以，当我们家里的包发出去的时候，都被家用路由器NAT成为了运营商的地址了。\n\n很多办公室访问外网的时候，也是被NAT过的，因为不可能办公室里面的IP也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口IP地址。\n\n**路由协议**\n\n家里的网段是私有网段，出去的包需要NAT成公网的IP地址，因而路由器是一个NAT路由器。\n\n两个运营商都要为这个网关配置一个公网的IP地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。\n\n<img src=\"https://img-blog.csdnimg.cn/b1175b1f0f4f45c7b4a51a70aa817557.png\" style=\"zoom:25%;\" />\n\n## DNS\n\nDNS通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。\n\n* **通俗的讲**，我们更习惯于记住一个网站的名字，www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2\n\n**工作原理**\n\n将主机域名转换为ip地址，属于应用层协议，使用UDP传输。\n\n<img src=\"https://img-blog.csdnimg.cn/76f522fa8e764b3c84be4bd6d18638bc.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/63167cd00b9046fd85c5ccb580cd7c31.png\" style=\"zoom:50%;\" />\n\n* 第一步，客户端向本地DNS服务器发送解析请求\n\n* 第二步，本地DNS如有相应记录会直接返回结果给客户端，如没有就向DNS根服务器发送请求\n\n* 第三步,DSN根服务器接收到请求，返回给本地服务器一个所查询域的主域名服务器的地址\n\n* 第四步，本地dns服务器再向返回的主域名服务器地址发送查询请求\n\n* 第五步，主域名服务器如有记录就返回结果，没有的话返回相关的下级域名服务器地址\n\n* 第六步，本地DNS服务器继续向接收到的地址进行查询请求\n\n* 第七步，下级域名服务器有相应记录，返回结果\n\n* 第八步，本地dns服务器将收到的返回地址发给客户端，同时写入自己的缓存，以便下次查询\n\nDNS域名查询实际上就是个不断递归查询的过程，直到查找到相应结果，需要注意的时，当找不到相应记录，会返回空结果，而不是超时信息\n","source":"_posts/图解TCP IP/TCP IP基础知识.md","raw":"---\ntitle: TCP IP基础知识\ncategories: \n- 图解TCP IP\n---\n\n# TCP和IP模型\n\nOSI模型注重通信协议必要的功能；TCP/IP更强调在计算机上实现协议应该开发哪种程序。\n\n**TCP/IP划分了四层网络模型**\n\n- 第一层：应用层，主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等\n- 第二层：传输层，主要是有**可靠传输**的TCP协议，特别**高效**的UDP协议。主要负责传输应用层的数据包。\n- 第三层：网络层，主要是IP协议。主要负责寻址（找到目标设备的位置）\n- 第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。\n\n<img src=\"https://img-blog.csdnimg.cn/2c306962843a4ea59c890f3dd727202a.png\" style=\"zoom:25%;\" />\n\n**四层网络协议的作用**\n\n- 发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。\n- 接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。\n- 层层加密和解密后，应用层最终拿到了需要的数据。\n\n**举个例子：**\n\n我们需要发送一个**index.html**。\n\n* 两台电脑在应用层都使用HTTP协议（即都使用浏览器）。\n\n* 在传输层，TCP协议会将HTTP协议发送的数据看作一个数据包，并在这个数据包前面加上TCP包的一部分信息（部首）\n\n* 在网络层，IP协议会将TCP协议要发送的数据看作一个数据包，同样的在这个数据包前端加上IP协议的部首\n\n* 在数据链路层，对应的协议也会在IP数据包前端加上以太网的部首。\n\n<img src=\"https://img-blog.csdnimg.cn/270ea156a87d470c938049611cfae9ad.png\" style=\"zoom:50%;\" />\n\n* 源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。\n\n* 数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的IP数据包，再将IP数据包传给上层的网络层。\n\n* 数据链路层>网络层>传输层>应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的**index.html**。\n\n<img src=\"https://img-blog.csdnimg.cn/b3a1a77662fa4d2a9052033792e2bc64.png\" style=\"zoom:50%;\" />\n\n**TCP/IP协议族**\n\n从字面意义上来讲，TCP/IP是指**传输层**的TCP协议和**网络层**的IP协议。\n\n实际上，TCP/IP只是利用 IP 进行通信时所必须用到的协议群的统称。\n\n具体来说，在网络层是IP/ICMP协议、在传输层是TCP/UDP协议、在应用层是SMTP、FTP、以及 HTTP 等。他们都属于 TCP/IP 协议。\n\n# 网络层\n\n**MAC地址**\n\nMAC称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。\n\nMAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。\n\n> MAC地址对应于OSI参考模型的第二层数据链路层，工作在数据链路层的交换机维护着计算机MAC地址和自身端口的数据库，交换机根据收到的数据帧中的目的MAC地址字段来转发数据帧。\n\nMAC地址更像是身份证，是一个唯一的标识。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。\n\n## IP地址\n\n常见的IP地址分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；\n\nIP地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机\n\n* 本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。\n\nIP地址对应于OSI参考模型的第三层网络层，工作在网络层的路由器根据目标IP和源IP来判断是否属于同一网段，如果是不同网段，则转发数据包。\n\n**IP地址格式和表示**\n\nIP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）\n\n* 每一段8位二进制，中间使用英文的标点符号`.`隔开\n\n由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。\n\nIP地址的这种表示法叫做**点分十进制表示法**。\n\n* 举个栗子：`210.21.196.6`就是一个IP地址的表示。\n\n计算机的IP地址由两部分组成，一部分为网络标识，一部分为主机标识，同一网段内的计算机网络部分相同，主机部分不能同时重复出现。\n\n* **路由器**连接不同网段，负责不同网段之间的数据转发，**交换机**连接的是同一网段的计算机。\n\n通过设置网络地址和主机地址，在互相连接的整个网络中保证每台主机的IP地址不会互相重叠，即IP地址具有了唯一性。\n\n**IP地址分类**\n\nIP地址分A、B、C、D、E五类，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。\n\n<img src=\"https://img-blog.csdnimg.cn/2c725f4c914a4d46ac9e625d3532a036.png\" style=\"zoom:30%;\" />\n\n**公有IP地址和私有IP地址**\n\n![](https://img-blog.csdnimg.cn/06628445eb4444b3a31ec25e89098934.png)\n\n平时我们看到的数据中心里，办公室、家里或学校的IP地址，一般都是私有IP地址段。因为这些地址允许组织内部的IT人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有IP地址段和我学校的可以是一样的。\n\n* 这就像每个小区有自己的楼编号和门牌号，你们小区可以叫6栋，我们小区也叫6栋，没有任何问题。\n\n* 但是一旦出了小区，就需要使用公有IP地址。就像人民路888号，是国家统一分配的，不能两个小区都叫人民路888号。\n\n公有IP地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的IT人员给你一个IP地址就行。\n\n但是假如你要做一个类似网易163这样的网站，就需要有公有IP地址，这样全世界的人才能访问。\n\n* 表格中的`192.168.0.x`是最常用的私有IP地址。\n\n* 你家里有Wi-Fi，对应就会有一个IP地址。一般你家里地上网设备不会超过256个。\n\n不需要将十进制转换为二进制32位，就能明显看出192.168.0是网络号，后面是主机号。\n\n而整个网络里面的第一个地址192.168.0.1，往往就是你这个私有网络的出口地址。\n\n例如，你家里的电脑连接Wi-Fi，Wi-Fi路由器的地址就是192.168.0.1，而192.168.0.255就是广播地址。\n\n* 一旦发送这个地址，整个192.168.0网络里面的所有机器都能收到。\n\n**动态主机配置协议（DHCP）**\n\n配置了IP之后一般不能变的，配置一个服务端的机器还可以，但是如果是客户端的机器呢？我抱着一台笔记本电脑在公司里走来走去，或者白天来晚上走，每次使用都要配置IP地址，那可怎么办？\n\n* 还有人事、行政等非技术人员，如果公司所有的电脑都需要IT人员配置，肯定忙不过来啊。\n\n因此，我们需要有一个自动配置的协议，也就是**动态主机配置协议（Dynamic Host Configuration Protocol）**，简称**DHCP**。\n\n* 有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的IP地址。\n\n* 每一台新接入的机器都通过DHCP协议，来这个共享的IP地址里申请，然后自动配置好就可以了。\n\n* 等人走了，或者用完了，还回去，这样其他的机器也能用。\n\n所以说，**如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修。DHCP的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。**\n\n一个广播的网络里面接入了N台机器，我怎么知道每个MAC地址是谁呢？这就是**ARP协议**，也就是已知IP地址，求MAC地址的协议。\n\n<img src=\"https://img-blog.csdnimg.cn/36995f9f91204a4580d24cd8cdfb2cf1.png\" style=\"zoom:25%;\" />\n\n为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP的MAC地址缓存过一段时间就会过期。\n\n**ICMP协议**\n\nping的操作是基于ICMP协议工作的。\n\n* **ICMP**全称**Internet Control Message Protocol**，就是**互联网控制报文协议**。\n\n网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。\n\n* 当遇到问题的时候，总不能死个不明不白，要传出消息来，报告情况，这样才可以调整传输策略。\n\n这就相当于我们经常看到的电视剧里，古代行军的时候，为将为帅者需要通过侦察兵、哨探或传令兵等人肉的方式来掌握情况，控制整个战局。\n\nICMP报文是封装在IP包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。\n\n<img src=\"https://img-blog.csdnimg.cn/a104b3fd98b04fb18b0657c297e817c0.png\" style=\"zoom:25%;\" />\n\n**ARP协议**\n\nARP即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。\n\n**ARP协议的工作过程**\n\n* 首先，每个主机都会有自己的ARP缓存区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系\n\n当源主机要发送数据时，首先检测ARP列表中是否对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包\n\n当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果存在，则覆盖然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址\n\n源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据，如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。\n\n## 子网掩码\n\n**子网掩码的概念及作用**\n\n通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。\n\n* 子网掩码和IP地址做与运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。\n\n子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。\n\n**子网掩码的组成**\n\n同IP地址一样，子网掩码是由长度为32位二进制数组成的一个地址。\n\n子网掩码32位与IP地址32位相对应，IP地址如果某位是网络地址，则子网掩码为1，否则为0。\n\n* 举个栗子：如：`11111111.11111111.11111111.00000000`\n\n> 左边连续的1的个数代表网络号的长度，（使用时必须是连续的，理论上也可以不连续），右边连续的0的个数代表主机号的长度。\n\n**为什么要使用子网掩码**\n\n两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。\n\n* 如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。\n\n> 可以这么简单的理解：A主机要与B主机通信，A和B各自的IP地址与A主机的子网掩码进行And与运算，看得出的结果：\n>\n> 1、结果如果相同，则说明这两台主机是处于同一个网段，这样A可以通过ARP广播发现B的MAC地址，B也可以发现A的MAC地址来实现正常通信。\n>\n> 2、如果结果不同，ARP广播会在本地网关终结，这时候A会把发给B的数据包先发给本地网关，网关再根据B主机的IP地址来查询路由表，再将数据包继续传递转发，最终送达到目的地B。\n\n------\n\n> 计算机的网关（Gateway）就是到其他网段的出口，也就是路由器接口IP地址。\n>\n> 路由器接口使用的IP地址可以是本网段中任何一个地址，不过通常使用该网段的第一个可用的地址或最后一个可用的地址，这是为了尽可能避免和本网段中的主机地址冲突。\n\n在如下拓扑图示例中，A与B，C与D，都可以直接相互通信（都是属于各自同一网段，不用经过路由器）\n\n但是A与C，A与D，B与C，B与D它们之间不属于同一网段，所以它们通信是要经过本地网关，然后路由器根据对方IP地址，在路由表中查找恰好有匹配到对方IP地址的直连路由，于是从另一边网关接口转发出去实现互连\n\n<img src=\"https://img-blog.csdnimg.cn/a3a6f3542c5e4bca810d056157362b5c.png\" style=\"zoom:50%;\" />\n\n**子网掩码和IP地址的关系**\n\n* 子网掩码是用来判断任意两台主机的IP地址是否属于同一网络的依据\n\n* 拿双方主机的IP地址和自己主机的子网掩码做与运算，如结果为同一网络，就可以直接通信\n\n**如何根据IP地址和子网掩码，计算网络地址：**\n\n* 将IP地址与子网掩码转换成二进制数。\n\n* 将二进制形式的 IP 地址与子网掩码做与运算。\n\n* 将得出的结果转化为十进制，便得到网络地址。\n\n<img src=\"https://img-blog.csdnimg.cn/f243e18a4e134ce388aa8f85ecdf2a2d.png\" style=\"zoom:50%;\" />\n\n## 网关\n\n**怎么在宿舍上网？**\n\n还记得咱们在宿舍的时候买了台交换机，几台机器组了一个局域网打游戏吗？\n\n* 可惜啊，只能打局域网的游戏，不能上网啊！盼啊盼啊，终于盼到大二，允许宿舍开通网络了。\n\n学校给每个宿舍的网口分配了一个IP地址。\n\n* 这个IP是校园网的IP，完全由网管部门控制。宿舍网的IP地址多为192.168.1.x。校园网的IP地址，假设是10.10.x.x。\n\n这个时候，你要在宿舍上网，有两个办法：\n\n* 第一个办法，让你们宿舍长再买一个网卡。这个时候，你们宿舍长的电脑里就有两张网卡。一张网卡的线插到你们宿舍的交换机上，另一张网卡的线插到校园网的网口。而且，这张新的网卡的IP地址要按照学校网管部门分配的配置，不然上不了网。**这种情况下，如果你们宿舍的人要上网，就需要一直开着宿舍长的电脑。**\n\n* 第二个办法，你们共同出钱买个家庭路由器。家庭路由器会有内网网口和外网网口。把外网网口的线插到校园网的网口上，将这个外网网口配置成和网管部的一样。内网网口连上你们宿舍的所有的电脑。**这种情况下，如果你们宿舍的人要上网，就需要一直开着路由器。**\n\n> 这两种方法其实是一样的。只不过第一种方式，让你的宿舍长的电脑，变成一个有多个口的路由器而已。\n\n而你买的家庭路由器，里面也跑着程序，和你宿舍长电脑里的功能一样，只不过是一个嵌入式的系统。\n\n* 当你的宿舍长能够上网之后，接下来，就是其他人的电脑怎么上网的问题。这就需要配置你们的**网卡。**\n\n* 当然DHCP是可以默认配置的。在进行网卡配置的时候，除了IP地址，还需要配置一个Gateway**的东西，这个就是**网关。\n\n网关实质上是一个网络通向其他网络的IP地址。\n\n* 比如有网络A和网络B，网络A的IP地址范围为`192.168.1.1~192. 168.1.254`，子网掩码为`255.255.255.0`；\n\n* 网络B的IP地址范围为`192.168.2.1~192.168.2.254`，子网掩码为`255.255.255.0`。\n\n在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP/IP协议也会根据子网掩码(`255.255.255.0`)判定两个网络中的主机处在不同的网络里。\n\n* 而要实现这两个网络之间的通信，则必须通过网关。\n\n如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。\n\n**所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。**\n\n> 那么这个IP地址是哪台机器的IP地址呢？\n\n网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。\n\n* **如果是同一个网段**，例如，你访问你旁边的兄弟的电脑，那就没网关什么事情，直接将源地址和目标地址放入IP头中，然后通过ARP获得MAC地址，将源MAC和目的MAC放入MAC头中，发出去就可以了。\n\n* **如果不是同一网段**，例如，你要访问你们校园网里面的BBS，该怎么办？\n\n这就需要发往默认网关Gateway。Gateway的地址一定是和源IP地址是一个网段的。\n\n**如何发往默认网关呢？**\n\n网关不是和源IP地址是一个网段的么？\n\n* 这个过程就和发往同一个网段的其他机器是一样的：将源地址和目标IP地址放入IP头中，通过ARP获得网关的MAC地址，将源MAC和网关的MAC放入MAC头中，发送出去。\n\n* 网关所在的端口，例如`192.168.1.1/24`将网络包收进来，然后接下来怎么做，就完全看网关的了。\n\n**网关往往是一个路由器，是一个三层转发的设备。**\n\n* 三层设备？就是把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。\n\n在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源IP同网段的。\n\n很多情况下，人们把网关就叫做路由器。其实不完全准确，而另一种比喻更加恰当：**路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。**\n\n任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下MAC头和IP头，看看，根据自己的路由算法，选择另一只手，加上IP头和MAC头，然后扔出去。\n\n**静态路由是什么？**\n\n大致可以分为两类，一个是**静态路由**，一个是**动态路由**。\n\n* **静态路由，其实就是在路由器上，配置一条一条规则。**\n\n这些规则包括：想访问BBS站（它肯定有个网段），从2号口出去，下一跳是IP2；\n\n想访问教学视频站（它也有个自己的网段），从3号口出去，下一跳是IP3，然后保存在路由器里。\n\n* 每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳IPX。\n\nMAC地址是一个局域网内才有效的地址。因而，MAC地址只要过网关，就必定会改变，因为已经换了局域网。\n\n* 两者主要的区别在于IP地址是否改变。不改变IP地址的网关，我们称为**转发网关；改变IP地址的网关，我们称为NAT网关**。\n\n现在大家每家都有家用路由器，家里的网段都是`192.168.1.x`，所以你肯定访问不了你邻居家的这个私网的IP地址的。\n\n* 所以，当我们家里的包发出去的时候，都被家用路由器NAT成为了运营商的地址了。\n\n很多办公室访问外网的时候，也是被NAT过的，因为不可能办公室里面的IP也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口IP地址。\n\n**路由协议**\n\n家里的网段是私有网段，出去的包需要NAT成公网的IP地址，因而路由器是一个NAT路由器。\n\n两个运营商都要为这个网关配置一个公网的IP地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。\n\n<img src=\"https://img-blog.csdnimg.cn/b1175b1f0f4f45c7b4a51a70aa817557.png\" style=\"zoom:25%;\" />\n\n## DNS\n\nDNS通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。\n\n* **通俗的讲**，我们更习惯于记住一个网站的名字，www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2\n\n**工作原理**\n\n将主机域名转换为ip地址，属于应用层协议，使用UDP传输。\n\n<img src=\"https://img-blog.csdnimg.cn/76f522fa8e764b3c84be4bd6d18638bc.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/63167cd00b9046fd85c5ccb580cd7c31.png\" style=\"zoom:50%;\" />\n\n* 第一步，客户端向本地DNS服务器发送解析请求\n\n* 第二步，本地DNS如有相应记录会直接返回结果给客户端，如没有就向DNS根服务器发送请求\n\n* 第三步,DSN根服务器接收到请求，返回给本地服务器一个所查询域的主域名服务器的地址\n\n* 第四步，本地dns服务器再向返回的主域名服务器地址发送查询请求\n\n* 第五步，主域名服务器如有记录就返回结果，没有的话返回相关的下级域名服务器地址\n\n* 第六步，本地DNS服务器继续向接收到的地址进行查询请求\n\n* 第七步，下级域名服务器有相应记录，返回结果\n\n* 第八步，本地dns服务器将收到的返回地址发给客户端，同时写入自己的缓存，以便下次查询\n\nDNS域名查询实际上就是个不断递归查询的过程，直到查找到相应结果，需要注意的时，当找不到相应记录，会返回空结果，而不是超时信息\n","slug":"图解TCP IP/TCP IP基础知识","published":1,"date":"2022-02-09T01:42:59.476Z","updated":"2022-02-10T02:20:26.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj500fsfhjiew68cdzl","content":"<h1 id=\"TCP和IP模型\"><a href=\"#TCP和IP模型\" class=\"headerlink\" title=\"TCP和IP模型\"></a>TCP和IP模型</h1><p>OSI模型注重通信协议必要的功能；TCP&#x2F;IP更强调在计算机上实现协议应该开发哪种程序。</p>\n<p><strong>TCP&#x2F;IP划分了四层网络模型</strong></p>\n<ul>\n<li>第一层：应用层，主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等</li>\n<li>第二层：传输层，主要是有<strong>可靠传输</strong>的TCP协议，特别<strong>高效</strong>的UDP协议。主要负责传输应用层的数据包。</li>\n<li>第三层：网络层，主要是IP协议。主要负责寻址（找到目标设备的位置）</li>\n<li>第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/2c306962843a4ea59c890f3dd727202a.png\" style=\"zoom:25%;\" />\n\n<p><strong>四层网络协议的作用</strong></p>\n<ul>\n<li>发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。</li>\n<li>接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。</li>\n<li>层层加密和解密后，应用层最终拿到了需要的数据。</li>\n</ul>\n<p><strong>举个例子：</strong></p>\n<p>我们需要发送一个<strong>index.html</strong>。</p>\n<ul>\n<li><p>两台电脑在应用层都使用HTTP协议（即都使用浏览器）。</p>\n</li>\n<li><p>在传输层，TCP协议会将HTTP协议发送的数据看作一个数据包，并在这个数据包前面加上TCP包的一部分信息（部首）</p>\n</li>\n<li><p>在网络层，IP协议会将TCP协议要发送的数据看作一个数据包，同样的在这个数据包前端加上IP协议的部首</p>\n</li>\n<li><p>在数据链路层，对应的协议也会在IP数据包前端加上以太网的部首。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/270ea156a87d470c938049611cfae9ad.png\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。</p>\n</li>\n<li><p>数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的IP数据包，再将IP数据包传给上层的网络层。</p>\n</li>\n<li><p>数据链路层&gt;网络层&gt;传输层&gt;应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的<strong>index.html</strong>。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/b3a1a77662fa4d2a9052033792e2bc64.png\" style=\"zoom:50%;\" />\n\n<p><strong>TCP&#x2F;IP协议族</strong></p>\n<p>从字面意义上来讲，TCP&#x2F;IP是指<strong>传输层</strong>的TCP协议和<strong>网络层</strong>的IP协议。</p>\n<p>实际上，TCP&#x2F;IP只是利用 IP 进行通信时所必须用到的协议群的统称。</p>\n<p>具体来说，在网络层是IP&#x2F;ICMP协议、在传输层是TCP&#x2F;UDP协议、在应用层是SMTP、FTP、以及 HTTP 等。他们都属于 TCP&#x2F;IP 协议。</p>\n<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><p><strong>MAC地址</strong></p>\n<p>MAC称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。</p>\n<p>MAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。</p>\n<blockquote>\n<p>MAC地址对应于OSI参考模型的第二层数据链路层，工作在数据链路层的交换机维护着计算机MAC地址和自身端口的数据库，交换机根据收到的数据帧中的目的MAC地址字段来转发数据帧。</p>\n</blockquote>\n<p>MAC地址更像是身份证，是一个唯一的标识。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。</p>\n<h2 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h2><p>常见的IP地址分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；</p>\n<p>IP地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机</p>\n<ul>\n<li>本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。</li>\n</ul>\n<p>IP地址对应于OSI参考模型的第三层网络层，工作在网络层的路由器根据目标IP和源IP来判断是否属于同一网段，如果是不同网段，则转发数据包。</p>\n<p><strong>IP地址格式和表示</strong></p>\n<p>IP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）</p>\n<ul>\n<li>每一段8位二进制，中间使用英文的标点符号<code>.</code>隔开</li>\n</ul>\n<p>由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。</p>\n<p>IP地址的这种表示法叫做<strong>点分十进制表示法</strong>。</p>\n<ul>\n<li>举个栗子：<code>210.21.196.6</code>就是一个IP地址的表示。</li>\n</ul>\n<p>计算机的IP地址由两部分组成，一部分为网络标识，一部分为主机标识，同一网段内的计算机网络部分相同，主机部分不能同时重复出现。</p>\n<ul>\n<li><strong>路由器</strong>连接不同网段，负责不同网段之间的数据转发，<strong>交换机</strong>连接的是同一网段的计算机。</li>\n</ul>\n<p>通过设置网络地址和主机地址，在互相连接的整个网络中保证每台主机的IP地址不会互相重叠，即IP地址具有了唯一性。</p>\n<p><strong>IP地址分类</strong></p>\n<p>IP地址分A、B、C、D、E五类，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。</p>\n<img src=\"https://img-blog.csdnimg.cn/2c725f4c914a4d46ac9e625d3532a036.png\" style=\"zoom:30%;\" />\n\n<p><strong>公有IP地址和私有IP地址</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/06628445eb4444b3a31ec25e89098934.png\"></p>\n<p>平时我们看到的数据中心里，办公室、家里或学校的IP地址，一般都是私有IP地址段。因为这些地址允许组织内部的IT人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有IP地址段和我学校的可以是一样的。</p>\n<ul>\n<li><p>这就像每个小区有自己的楼编号和门牌号，你们小区可以叫6栋，我们小区也叫6栋，没有任何问题。</p>\n</li>\n<li><p>但是一旦出了小区，就需要使用公有IP地址。就像人民路888号，是国家统一分配的，不能两个小区都叫人民路888号。</p>\n</li>\n</ul>\n<p>公有IP地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的IT人员给你一个IP地址就行。</p>\n<p>但是假如你要做一个类似网易163这样的网站，就需要有公有IP地址，这样全世界的人才能访问。</p>\n<ul>\n<li><p>表格中的<code>192.168.0.x</code>是最常用的私有IP地址。</p>\n</li>\n<li><p>你家里有Wi-Fi，对应就会有一个IP地址。一般你家里地上网设备不会超过256个。</p>\n</li>\n</ul>\n<p>不需要将十进制转换为二进制32位，就能明显看出192.168.0是网络号，后面是主机号。</p>\n<p>而整个网络里面的第一个地址192.168.0.1，往往就是你这个私有网络的出口地址。</p>\n<p>例如，你家里的电脑连接Wi-Fi，Wi-Fi路由器的地址就是192.168.0.1，而192.168.0.255就是广播地址。</p>\n<ul>\n<li>一旦发送这个地址，整个192.168.0网络里面的所有机器都能收到。</li>\n</ul>\n<p><strong>动态主机配置协议（DHCP）</strong></p>\n<p>配置了IP之后一般不能变的，配置一个服务端的机器还可以，但是如果是客户端的机器呢？我抱着一台笔记本电脑在公司里走来走去，或者白天来晚上走，每次使用都要配置IP地址，那可怎么办？</p>\n<ul>\n<li>还有人事、行政等非技术人员，如果公司所有的电脑都需要IT人员配置，肯定忙不过来啊。</li>\n</ul>\n<p>因此，我们需要有一个自动配置的协议，也就是<strong>动态主机配置协议（Dynamic Host Configuration Protocol）</strong>，简称<strong>DHCP</strong>。</p>\n<ul>\n<li><p>有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的IP地址。</p>\n</li>\n<li><p>每一台新接入的机器都通过DHCP协议，来这个共享的IP地址里申请，然后自动配置好就可以了。</p>\n</li>\n<li><p>等人走了，或者用完了，还回去，这样其他的机器也能用。</p>\n</li>\n</ul>\n<p>所以说，<strong>如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修。DHCP的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。</strong></p>\n<p>一个广播的网络里面接入了N台机器，我怎么知道每个MAC地址是谁呢？这就是<strong>ARP协议</strong>，也就是已知IP地址，求MAC地址的协议。</p>\n<img src=\"https://img-blog.csdnimg.cn/36995f9f91204a4580d24cd8cdfb2cf1.png\" style=\"zoom:25%;\" />\n\n<p>为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP的MAC地址缓存过一段时间就会过期。</p>\n<p><strong>ICMP协议</strong></p>\n<p>ping的操作是基于ICMP协议工作的。</p>\n<ul>\n<li><strong>ICMP</strong>全称<strong>Internet Control Message Protocol</strong>，就是<strong>互联网控制报文协议</strong>。</li>\n</ul>\n<p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。</p>\n<ul>\n<li>当遇到问题的时候，总不能死个不明不白，要传出消息来，报告情况，这样才可以调整传输策略。</li>\n</ul>\n<p>这就相当于我们经常看到的电视剧里，古代行军的时候，为将为帅者需要通过侦察兵、哨探或传令兵等人肉的方式来掌握情况，控制整个战局。</p>\n<p>ICMP报文是封装在IP包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。</p>\n<img src=\"https://img-blog.csdnimg.cn/a104b3fd98b04fb18b0657c297e817c0.png\" style=\"zoom:25%;\" />\n\n<p><strong>ARP协议</strong></p>\n<p>ARP即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。</p>\n<p><strong>ARP协议的工作过程</strong></p>\n<ul>\n<li>首先，每个主机都会有自己的ARP缓存区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系</li>\n</ul>\n<p>当源主机要发送数据时，首先检测ARP列表中是否对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包</p>\n<p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果存在，则覆盖然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址</p>\n<p>源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据，如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>\n<h2 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h2><p><strong>子网掩码的概念及作用</strong></p>\n<p>通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。</p>\n<ul>\n<li>子网掩码和IP地址做与运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。</li>\n</ul>\n<p>子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。</p>\n<p><strong>子网掩码的组成</strong></p>\n<p>同IP地址一样，子网掩码是由长度为32位二进制数组成的一个地址。</p>\n<p>子网掩码32位与IP地址32位相对应，IP地址如果某位是网络地址，则子网掩码为1，否则为0。</p>\n<ul>\n<li>举个栗子：如：<code>11111111.11111111.11111111.00000000</code></li>\n</ul>\n<blockquote>\n<p>左边连续的1的个数代表网络号的长度，（使用时必须是连续的，理论上也可以不连续），右边连续的0的个数代表主机号的长度。</p>\n</blockquote>\n<p><strong>为什么要使用子网掩码</strong></p>\n<p>两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。</p>\n<ul>\n<li>如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。</li>\n</ul>\n<blockquote>\n<p>可以这么简单的理解：A主机要与B主机通信，A和B各自的IP地址与A主机的子网掩码进行And与运算，看得出的结果：</p>\n<p>1、结果如果相同，则说明这两台主机是处于同一个网段，这样A可以通过ARP广播发现B的MAC地址，B也可以发现A的MAC地址来实现正常通信。</p>\n<p>2、如果结果不同，ARP广播会在本地网关终结，这时候A会把发给B的数据包先发给本地网关，网关再根据B主机的IP地址来查询路由表，再将数据包继续传递转发，最终送达到目的地B。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>计算机的网关（Gateway）就是到其他网段的出口，也就是路由器接口IP地址。</p>\n<p>路由器接口使用的IP地址可以是本网段中任何一个地址，不过通常使用该网段的第一个可用的地址或最后一个可用的地址，这是为了尽可能避免和本网段中的主机地址冲突。</p>\n</blockquote>\n<p>在如下拓扑图示例中，A与B，C与D，都可以直接相互通信（都是属于各自同一网段，不用经过路由器）</p>\n<p>但是A与C，A与D，B与C，B与D它们之间不属于同一网段，所以它们通信是要经过本地网关，然后路由器根据对方IP地址，在路由表中查找恰好有匹配到对方IP地址的直连路由，于是从另一边网关接口转发出去实现互连</p>\n<img src=\"https://img-blog.csdnimg.cn/a3a6f3542c5e4bca810d056157362b5c.png\" style=\"zoom:50%;\" />\n\n<p><strong>子网掩码和IP地址的关系</strong></p>\n<ul>\n<li><p>子网掩码是用来判断任意两台主机的IP地址是否属于同一网络的依据</p>\n</li>\n<li><p>拿双方主机的IP地址和自己主机的子网掩码做与运算，如结果为同一网络，就可以直接通信</p>\n</li>\n</ul>\n<p><strong>如何根据IP地址和子网掩码，计算网络地址：</strong></p>\n<ul>\n<li><p>将IP地址与子网掩码转换成二进制数。</p>\n</li>\n<li><p>将二进制形式的 IP 地址与子网掩码做与运算。</p>\n</li>\n<li><p>将得出的结果转化为十进制，便得到网络地址。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/f243e18a4e134ce388aa8f85ecdf2a2d.png\" style=\"zoom:50%;\" />\n\n<h2 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h2><p><strong>怎么在宿舍上网？</strong></p>\n<p>还记得咱们在宿舍的时候买了台交换机，几台机器组了一个局域网打游戏吗？</p>\n<ul>\n<li>可惜啊，只能打局域网的游戏，不能上网啊！盼啊盼啊，终于盼到大二，允许宿舍开通网络了。</li>\n</ul>\n<p>学校给每个宿舍的网口分配了一个IP地址。</p>\n<ul>\n<li>这个IP是校园网的IP，完全由网管部门控制。宿舍网的IP地址多为192.168.1.x。校园网的IP地址，假设是10.10.x.x。</li>\n</ul>\n<p>这个时候，你要在宿舍上网，有两个办法：</p>\n<ul>\n<li><p>第一个办法，让你们宿舍长再买一个网卡。这个时候，你们宿舍长的电脑里就有两张网卡。一张网卡的线插到你们宿舍的交换机上，另一张网卡的线插到校园网的网口。而且，这张新的网卡的IP地址要按照学校网管部门分配的配置，不然上不了网。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着宿舍长的电脑。</strong></p>\n</li>\n<li><p>第二个办法，你们共同出钱买个家庭路由器。家庭路由器会有内网网口和外网网口。把外网网口的线插到校园网的网口上，将这个外网网口配置成和网管部的一样。内网网口连上你们宿舍的所有的电脑。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着路由器。</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>这两种方法其实是一样的。只不过第一种方式，让你的宿舍长的电脑，变成一个有多个口的路由器而已。</p>\n</blockquote>\n<p>而你买的家庭路由器，里面也跑着程序，和你宿舍长电脑里的功能一样，只不过是一个嵌入式的系统。</p>\n<ul>\n<li><p>当你的宿舍长能够上网之后，接下来，就是其他人的电脑怎么上网的问题。这就需要配置你们的<strong>网卡。</strong></p>\n</li>\n<li><p>当然DHCP是可以默认配置的。在进行网卡配置的时候，除了IP地址，还需要配置一个Gateway<strong>的东西，这个就是</strong>网关。</p>\n</li>\n</ul>\n<p>网关实质上是一个网络通向其他网络的IP地址。</p>\n<ul>\n<li><p>比如有网络A和网络B，网络A的IP地址范围为<code>192.168.1.1~192. 168.1.254</code>，子网掩码为<code>255.255.255.0</code>；</p>\n</li>\n<li><p>网络B的IP地址范围为<code>192.168.2.1~192.168.2.254</code>，子网掩码为<code>255.255.255.0</code>。</p>\n</li>\n</ul>\n<p>在没有路由器的情况下，两个网络之间是不能进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(<code>255.255.255.0</code>)判定两个网络中的主机处在不同的网络里。</p>\n<ul>\n<li>而要实现这两个网络之间的通信，则必须通过网关。</li>\n</ul>\n<p>如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。</p>\n<p><strong>所以说，只有设置好网关的IP地址，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。</strong></p>\n<blockquote>\n<p>那么这个IP地址是哪台机器的IP地址呢？</p>\n</blockquote>\n<p>网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。</p>\n<ul>\n<li><p><strong>如果是同一个网段</strong>，例如，你访问你旁边的兄弟的电脑，那就没网关什么事情，直接将源地址和目标地址放入IP头中，然后通过ARP获得MAC地址，将源MAC和目的MAC放入MAC头中，发出去就可以了。</p>\n</li>\n<li><p><strong>如果不是同一网段</strong>，例如，你要访问你们校园网里面的BBS，该怎么办？</p>\n</li>\n</ul>\n<p>这就需要发往默认网关Gateway。Gateway的地址一定是和源IP地址是一个网段的。</p>\n<p><strong>如何发往默认网关呢？</strong></p>\n<p>网关不是和源IP地址是一个网段的么？</p>\n<ul>\n<li><p>这个过程就和发往同一个网段的其他机器是一样的：将源地址和目标IP地址放入IP头中，通过ARP获得网关的MAC地址，将源MAC和网关的MAC放入MAC头中，发送出去。</p>\n</li>\n<li><p>网关所在的端口，例如<code>192.168.1.1/24</code>将网络包收进来，然后接下来怎么做，就完全看网关的了。</p>\n</li>\n</ul>\n<p><strong>网关往往是一个路由器，是一个三层转发的设备。</strong></p>\n<ul>\n<li>三层设备？就是把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。</li>\n</ul>\n<p>在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源IP同网段的。</p>\n<p>很多情况下，人们把网关就叫做路由器。其实不完全准确，而另一种比喻更加恰当：<strong>路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。</strong></p>\n<p>任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下MAC头和IP头，看看，根据自己的路由算法，选择另一只手，加上IP头和MAC头，然后扔出去。</p>\n<p><strong>静态路由是什么？</strong></p>\n<p>大致可以分为两类，一个是<strong>静态路由</strong>，一个是<strong>动态路由</strong>。</p>\n<ul>\n<li><strong>静态路由，其实就是在路由器上，配置一条一条规则。</strong></li>\n</ul>\n<p>这些规则包括：想访问BBS站（它肯定有个网段），从2号口出去，下一跳是IP2；</p>\n<p>想访问教学视频站（它也有个自己的网段），从3号口出去，下一跳是IP3，然后保存在路由器里。</p>\n<ul>\n<li>每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳IPX。</li>\n</ul>\n<p>MAC地址是一个局域网内才有效的地址。因而，MAC地址只要过网关，就必定会改变，因为已经换了局域网。</p>\n<ul>\n<li>两者主要的区别在于IP地址是否改变。不改变IP地址的网关，我们称为<strong>转发网关；改变IP地址的网关，我们称为NAT网关</strong>。</li>\n</ul>\n<p>现在大家每家都有家用路由器，家里的网段都是<code>192.168.1.x</code>，所以你肯定访问不了你邻居家的这个私网的IP地址的。</p>\n<ul>\n<li>所以，当我们家里的包发出去的时候，都被家用路由器NAT成为了运营商的地址了。</li>\n</ul>\n<p>很多办公室访问外网的时候，也是被NAT过的，因为不可能办公室里面的IP也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口IP地址。</p>\n<p><strong>路由协议</strong></p>\n<p>家里的网段是私有网段，出去的包需要NAT成公网的IP地址，因而路由器是一个NAT路由器。</p>\n<p>两个运营商都要为这个网关配置一个公网的IP地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。</p>\n<img src=\"https://img-blog.csdnimg.cn/b1175b1f0f4f45c7b4a51a70aa817557.png\" style=\"zoom:25%;\" />\n\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>\n<ul>\n<li><strong>通俗的讲</strong>，我们更习惯于记住一个网站的名字，<a href=\"http://www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2\">www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2</a></li>\n</ul>\n<p><strong>工作原理</strong></p>\n<p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。</p>\n<img src=\"https://img-blog.csdnimg.cn/76f522fa8e764b3c84be4bd6d18638bc.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/63167cd00b9046fd85c5ccb580cd7c31.png\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>第一步，客户端向本地DNS服务器发送解析请求</p>\n</li>\n<li><p>第二步，本地DNS如有相应记录会直接返回结果给客户端，如没有就向DNS根服务器发送请求</p>\n</li>\n<li><p>第三步,DSN根服务器接收到请求，返回给本地服务器一个所查询域的主域名服务器的地址</p>\n</li>\n<li><p>第四步，本地dns服务器再向返回的主域名服务器地址发送查询请求</p>\n</li>\n<li><p>第五步，主域名服务器如有记录就返回结果，没有的话返回相关的下级域名服务器地址</p>\n</li>\n<li><p>第六步，本地DNS服务器继续向接收到的地址进行查询请求</p>\n</li>\n<li><p>第七步，下级域名服务器有相应记录，返回结果</p>\n</li>\n<li><p>第八步，本地dns服务器将收到的返回地址发给客户端，同时写入自己的缓存，以便下次查询</p>\n</li>\n</ul>\n<p>DNS域名查询实际上就是个不断递归查询的过程，直到查找到相应结果，需要注意的时，当找不到相应记录，会返回空结果，而不是超时信息</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TCP和IP模型\"><a href=\"#TCP和IP模型\" class=\"headerlink\" title=\"TCP和IP模型\"></a>TCP和IP模型</h1><p>OSI模型注重通信协议必要的功能；TCP&#x2F;IP更强调在计算机上实现协议应该开发哪种程序。</p>\n<p><strong>TCP&#x2F;IP划分了四层网络模型</strong></p>\n<ul>\n<li>第一层：应用层，主要有负责web浏览器的HTTP协议， 文件传输的FTP协议，负责电子邮件的SMTP协议，负责域名系统的DNS等</li>\n<li>第二层：传输层，主要是有<strong>可靠传输</strong>的TCP协议，特别<strong>高效</strong>的UDP协议。主要负责传输应用层的数据包。</li>\n<li>第三层：网络层，主要是IP协议。主要负责寻址（找到目标设备的位置）</li>\n<li>第四层：数据链路层，主要是负责转换数字信号和物理二进制信号。</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/2c306962843a4ea59c890f3dd727202a.png\" style=\"zoom:25%;\" />\n\n<p><strong>四层网络协议的作用</strong></p>\n<ul>\n<li>发送端是由上至下，把上层来的数据在头部加上各层协议的数据（部首）再下发给下层。</li>\n<li>接受端则由下而上，把从下层接受到的数据进行解密和去掉头部的部首后再发送给上层。</li>\n<li>层层加密和解密后，应用层最终拿到了需要的数据。</li>\n</ul>\n<p><strong>举个例子：</strong></p>\n<p>我们需要发送一个<strong>index.html</strong>。</p>\n<ul>\n<li><p>两台电脑在应用层都使用HTTP协议（即都使用浏览器）。</p>\n</li>\n<li><p>在传输层，TCP协议会将HTTP协议发送的数据看作一个数据包，并在这个数据包前面加上TCP包的一部分信息（部首）</p>\n</li>\n<li><p>在网络层，IP协议会将TCP协议要发送的数据看作一个数据包，同样的在这个数据包前端加上IP协议的部首</p>\n</li>\n<li><p>在数据链路层，对应的协议也会在IP数据包前端加上以太网的部首。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/270ea156a87d470c938049611cfae9ad.png\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>源设备和目标设备通过网线连接，就可以通过物理层的二进制传输数据。</p>\n</li>\n<li><p>数据链路层，会使用对应的协议找到物理层的二进制数据，解码得到以太网的部首信息和对应的IP数据包，再将IP数据包传给上层的网络层。</p>\n</li>\n<li><p>数据链路层&gt;网络层&gt;传输层&gt;应用层，一层层的解码，最后就可以在浏览器中得到目标设备传送过来的<strong>index.html</strong>。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/b3a1a77662fa4d2a9052033792e2bc64.png\" style=\"zoom:50%;\" />\n\n<p><strong>TCP&#x2F;IP协议族</strong></p>\n<p>从字面意义上来讲，TCP&#x2F;IP是指<strong>传输层</strong>的TCP协议和<strong>网络层</strong>的IP协议。</p>\n<p>实际上，TCP&#x2F;IP只是利用 IP 进行通信时所必须用到的协议群的统称。</p>\n<p>具体来说，在网络层是IP&#x2F;ICMP协议、在传输层是TCP&#x2F;UDP协议、在应用层是SMTP、FTP、以及 HTTP 等。他们都属于 TCP&#x2F;IP 协议。</p>\n<h1 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h1><p><strong>MAC地址</strong></p>\n<p>MAC称为物理地址，也叫硬件地址，用来定义网络设备的位置，MAC地址是网卡出厂时设定的，是固定的（但可以通过在设备管理器中或注册表等方式修改，同一网段内的MAC地址必须唯一）。</p>\n<p>MAC地址采用十六进制数表示，长度是6个字节（48位），分为前24位和后24位。</p>\n<blockquote>\n<p>MAC地址对应于OSI参考模型的第二层数据链路层，工作在数据链路层的交换机维护着计算机MAC地址和自身端口的数据库，交换机根据收到的数据帧中的目的MAC地址字段来转发数据帧。</p>\n</blockquote>\n<p>MAC地址更像是身份证，是一个唯一的标识。它的唯一性设计是为了组网的时候，不同的网卡放在一个网络里面的时候，可以不用担心冲突。从硬件角度，保证不同的网卡有不同的标识。</p>\n<h2 id=\"IP地址\"><a href=\"#IP地址\" class=\"headerlink\" title=\"IP地址\"></a>IP地址</h2><p>常见的IP地址分为IPv4与IPv6两大类，当前广泛应用的是IPv4，目前IPv4几乎耗尽，下一阶段必然会进行版本升级到IPv6；</p>\n<p>IP地址是以网络号和主机号来标示网络上的主机的，我们把网络号相同的主机称之为本地网络，网络号不相同的主机称之为远程网络主机</p>\n<ul>\n<li>本地网络中的主机可以直接相互通信；远程网络中的主机要相互通信必须通过本地网关（Gateway）来传递转发数据。</li>\n</ul>\n<p>IP地址对应于OSI参考模型的第三层网络层，工作在网络层的路由器根据目标IP和源IP来判断是否属于同一网段，如果是不同网段，则转发数据包。</p>\n<p><strong>IP地址格式和表示</strong></p>\n<p>IP地址(IPv4)由32位二进制数组成，分为4段（4个字节），每一段为8位二进制数（1个字节）</p>\n<ul>\n<li>每一段8位二进制，中间使用英文的标点符号<code>.</code>隔开</li>\n</ul>\n<p>由于二进制数太长，为了便于记忆和识别，把每一段8位二进制数转成十进制，大小为0至255。</p>\n<p>IP地址的这种表示法叫做<strong>点分十进制表示法</strong>。</p>\n<ul>\n<li>举个栗子：<code>210.21.196.6</code>就是一个IP地址的表示。</li>\n</ul>\n<p>计算机的IP地址由两部分组成，一部分为网络标识，一部分为主机标识，同一网段内的计算机网络部分相同，主机部分不能同时重复出现。</p>\n<ul>\n<li><strong>路由器</strong>连接不同网段，负责不同网段之间的数据转发，<strong>交换机</strong>连接的是同一网段的计算机。</li>\n</ul>\n<p>通过设置网络地址和主机地址，在互相连接的整个网络中保证每台主机的IP地址不会互相重叠，即IP地址具有了唯一性。</p>\n<p><strong>IP地址分类</strong></p>\n<p>IP地址分A、B、C、D、E五类，其中A、B、C这三类是比较常用的IP地址，D、E类为特殊地址。</p>\n<img src=\"https://img-blog.csdnimg.cn/2c725f4c914a4d46ac9e625d3532a036.png\" style=\"zoom:30%;\" />\n\n<p><strong>公有IP地址和私有IP地址</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/06628445eb4444b3a31ec25e89098934.png\"></p>\n<p>平时我们看到的数据中心里，办公室、家里或学校的IP地址，一般都是私有IP地址段。因为这些地址允许组织内部的IT人员自己管理、自己分配，而且可以重复。因此，你学校的某个私有IP地址段和我学校的可以是一样的。</p>\n<ul>\n<li><p>这就像每个小区有自己的楼编号和门牌号，你们小区可以叫6栋，我们小区也叫6栋，没有任何问题。</p>\n</li>\n<li><p>但是一旦出了小区，就需要使用公有IP地址。就像人民路888号，是国家统一分配的，不能两个小区都叫人民路888号。</p>\n</li>\n</ul>\n<p>公有IP地址有个组织统一分配，你需要去买。如果你搭建一个网站，给你学校的人使用，让你们学校的IT人员给你一个IP地址就行。</p>\n<p>但是假如你要做一个类似网易163这样的网站，就需要有公有IP地址，这样全世界的人才能访问。</p>\n<ul>\n<li><p>表格中的<code>192.168.0.x</code>是最常用的私有IP地址。</p>\n</li>\n<li><p>你家里有Wi-Fi，对应就会有一个IP地址。一般你家里地上网设备不会超过256个。</p>\n</li>\n</ul>\n<p>不需要将十进制转换为二进制32位，就能明显看出192.168.0是网络号，后面是主机号。</p>\n<p>而整个网络里面的第一个地址192.168.0.1，往往就是你这个私有网络的出口地址。</p>\n<p>例如，你家里的电脑连接Wi-Fi，Wi-Fi路由器的地址就是192.168.0.1，而192.168.0.255就是广播地址。</p>\n<ul>\n<li>一旦发送这个地址，整个192.168.0网络里面的所有机器都能收到。</li>\n</ul>\n<p><strong>动态主机配置协议（DHCP）</strong></p>\n<p>配置了IP之后一般不能变的，配置一个服务端的机器还可以，但是如果是客户端的机器呢？我抱着一台笔记本电脑在公司里走来走去，或者白天来晚上走，每次使用都要配置IP地址，那可怎么办？</p>\n<ul>\n<li>还有人事、行政等非技术人员，如果公司所有的电脑都需要IT人员配置，肯定忙不过来啊。</li>\n</ul>\n<p>因此，我们需要有一个自动配置的协议，也就是<strong>动态主机配置协议（Dynamic Host Configuration Protocol）</strong>，简称<strong>DHCP</strong>。</p>\n<ul>\n<li><p>有了这个协议，网络管理员就轻松多了。他只需要配置一段共享的IP地址。</p>\n</li>\n<li><p>每一台新接入的机器都通过DHCP协议，来这个共享的IP地址里申请，然后自动配置好就可以了。</p>\n</li>\n<li><p>等人走了，或者用完了，还回去，这样其他的机器也能用。</p>\n</li>\n</ul>\n<p>所以说，<strong>如果是数据中心里面的服务器，IP一旦配置好，基本不会变，这就相当于买房自己装修。DHCP的方式就相当于租房。你不用装修，都是帮你配置好的。你暂时用一下，用完退租就可以了。</strong></p>\n<p>一个广播的网络里面接入了N台机器，我怎么知道每个MAC地址是谁呢？这就是<strong>ARP协议</strong>，也就是已知IP地址，求MAC地址的协议。</p>\n<img src=\"https://img-blog.csdnimg.cn/36995f9f91204a4580d24cd8cdfb2cf1.png\" style=\"zoom:25%;\" />\n\n<p>为了避免每次都用ARP请求，机器本地也会进行ARP缓存。当然机器会不断地上线下线，IP也可能会变，所以ARP的MAC地址缓存过一段时间就会过期。</p>\n<p><strong>ICMP协议</strong></p>\n<p>ping的操作是基于ICMP协议工作的。</p>\n<ul>\n<li><strong>ICMP</strong>全称<strong>Internet Control Message Protocol</strong>，就是<strong>互联网控制报文协议</strong>。</li>\n</ul>\n<p>网络包在异常复杂的网络环境中传输时，常常会遇到各种各样的问题。</p>\n<ul>\n<li>当遇到问题的时候，总不能死个不明不白，要传出消息来，报告情况，这样才可以调整传输策略。</li>\n</ul>\n<p>这就相当于我们经常看到的电视剧里，古代行军的时候，为将为帅者需要通过侦察兵、哨探或传令兵等人肉的方式来掌握情况，控制整个战局。</p>\n<p>ICMP报文是封装在IP包里面的。因为传输指令的时候，肯定需要源地址和目标地址。它本身非常简单。</p>\n<img src=\"https://img-blog.csdnimg.cn/a104b3fd98b04fb18b0657c297e817c0.png\" style=\"zoom:25%;\" />\n\n<p><strong>ARP协议</strong></p>\n<p>ARP即地址解析协议， 用于实现从 IP 地址到 MAC 地址的映射，即询问目标IP对应的MAC地址。</p>\n<p><strong>ARP协议的工作过程</strong></p>\n<ul>\n<li>首先，每个主机都会有自己的ARP缓存区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系</li>\n</ul>\n<p>当源主机要发送数据时，首先检测ARP列表中是否对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包</p>\n<p>当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果存在，则覆盖然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址</p>\n<p>源主机收到ARP响应包后，将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据，如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。</p>\n<h2 id=\"子网掩码\"><a href=\"#子网掩码\" class=\"headerlink\" title=\"子网掩码\"></a>子网掩码</h2><p><strong>子网掩码的概念及作用</strong></p>\n<p>通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作。</p>\n<ul>\n<li>子网掩码和IP地址做与运算，分离出IP地址中的网络地址和主机地址，用于判断该IP地址是在本地网络上，还是在远程网络网上。</li>\n</ul>\n<p>子网掩码还用于将网络进一步划分为若干子网，以避免主机过多而拥堵或过少而IP浪费。</p>\n<p><strong>子网掩码的组成</strong></p>\n<p>同IP地址一样，子网掩码是由长度为32位二进制数组成的一个地址。</p>\n<p>子网掩码32位与IP地址32位相对应，IP地址如果某位是网络地址，则子网掩码为1，否则为0。</p>\n<ul>\n<li>举个栗子：如：<code>11111111.11111111.11111111.00000000</code></li>\n</ul>\n<blockquote>\n<p>左边连续的1的个数代表网络号的长度，（使用时必须是连续的，理论上也可以不连续），右边连续的0的个数代表主机号的长度。</p>\n</blockquote>\n<p><strong>为什么要使用子网掩码</strong></p>\n<p>两台主机要通信，首先要判断是否处于同一网段，即网络地址是否相同。</p>\n<ul>\n<li>如果相同，那么可以把数据包直接发送到目标主机，否则就需要路由网关将数据包转发送到目的地。</li>\n</ul>\n<blockquote>\n<p>可以这么简单的理解：A主机要与B主机通信，A和B各自的IP地址与A主机的子网掩码进行And与运算，看得出的结果：</p>\n<p>1、结果如果相同，则说明这两台主机是处于同一个网段，这样A可以通过ARP广播发现B的MAC地址，B也可以发现A的MAC地址来实现正常通信。</p>\n<p>2、如果结果不同，ARP广播会在本地网关终结，这时候A会把发给B的数据包先发给本地网关，网关再根据B主机的IP地址来查询路由表，再将数据包继续传递转发，最终送达到目的地B。</p>\n</blockquote>\n<hr>\n<blockquote>\n<p>计算机的网关（Gateway）就是到其他网段的出口，也就是路由器接口IP地址。</p>\n<p>路由器接口使用的IP地址可以是本网段中任何一个地址，不过通常使用该网段的第一个可用的地址或最后一个可用的地址，这是为了尽可能避免和本网段中的主机地址冲突。</p>\n</blockquote>\n<p>在如下拓扑图示例中，A与B，C与D，都可以直接相互通信（都是属于各自同一网段，不用经过路由器）</p>\n<p>但是A与C，A与D，B与C，B与D它们之间不属于同一网段，所以它们通信是要经过本地网关，然后路由器根据对方IP地址，在路由表中查找恰好有匹配到对方IP地址的直连路由，于是从另一边网关接口转发出去实现互连</p>\n<img src=\"https://img-blog.csdnimg.cn/a3a6f3542c5e4bca810d056157362b5c.png\" style=\"zoom:50%;\" />\n\n<p><strong>子网掩码和IP地址的关系</strong></p>\n<ul>\n<li><p>子网掩码是用来判断任意两台主机的IP地址是否属于同一网络的依据</p>\n</li>\n<li><p>拿双方主机的IP地址和自己主机的子网掩码做与运算，如结果为同一网络，就可以直接通信</p>\n</li>\n</ul>\n<p><strong>如何根据IP地址和子网掩码，计算网络地址：</strong></p>\n<ul>\n<li><p>将IP地址与子网掩码转换成二进制数。</p>\n</li>\n<li><p>将二进制形式的 IP 地址与子网掩码做与运算。</p>\n</li>\n<li><p>将得出的结果转化为十进制，便得到网络地址。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/f243e18a4e134ce388aa8f85ecdf2a2d.png\" style=\"zoom:50%;\" />\n\n<h2 id=\"网关\"><a href=\"#网关\" class=\"headerlink\" title=\"网关\"></a>网关</h2><p><strong>怎么在宿舍上网？</strong></p>\n<p>还记得咱们在宿舍的时候买了台交换机，几台机器组了一个局域网打游戏吗？</p>\n<ul>\n<li>可惜啊，只能打局域网的游戏，不能上网啊！盼啊盼啊，终于盼到大二，允许宿舍开通网络了。</li>\n</ul>\n<p>学校给每个宿舍的网口分配了一个IP地址。</p>\n<ul>\n<li>这个IP是校园网的IP，完全由网管部门控制。宿舍网的IP地址多为192.168.1.x。校园网的IP地址，假设是10.10.x.x。</li>\n</ul>\n<p>这个时候，你要在宿舍上网，有两个办法：</p>\n<ul>\n<li><p>第一个办法，让你们宿舍长再买一个网卡。这个时候，你们宿舍长的电脑里就有两张网卡。一张网卡的线插到你们宿舍的交换机上，另一张网卡的线插到校园网的网口。而且，这张新的网卡的IP地址要按照学校网管部门分配的配置，不然上不了网。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着宿舍长的电脑。</strong></p>\n</li>\n<li><p>第二个办法，你们共同出钱买个家庭路由器。家庭路由器会有内网网口和外网网口。把外网网口的线插到校园网的网口上，将这个外网网口配置成和网管部的一样。内网网口连上你们宿舍的所有的电脑。<strong>这种情况下，如果你们宿舍的人要上网，就需要一直开着路由器。</strong></p>\n</li>\n</ul>\n<blockquote>\n<p>这两种方法其实是一样的。只不过第一种方式，让你的宿舍长的电脑，变成一个有多个口的路由器而已。</p>\n</blockquote>\n<p>而你买的家庭路由器，里面也跑着程序，和你宿舍长电脑里的功能一样，只不过是一个嵌入式的系统。</p>\n<ul>\n<li><p>当你的宿舍长能够上网之后，接下来，就是其他人的电脑怎么上网的问题。这就需要配置你们的<strong>网卡。</strong></p>\n</li>\n<li><p>当然DHCP是可以默认配置的。在进行网卡配置的时候，除了IP地址，还需要配置一个Gateway<strong>的东西，这个就是</strong>网关。</p>\n</li>\n</ul>\n<p>网关实质上是一个网络通向其他网络的IP地址。</p>\n<ul>\n<li><p>比如有网络A和网络B，网络A的IP地址范围为<code>192.168.1.1~192. 168.1.254</code>，子网掩码为<code>255.255.255.0</code>；</p>\n</li>\n<li><p>网络B的IP地址范围为<code>192.168.2.1~192.168.2.254</code>，子网掩码为<code>255.255.255.0</code>。</p>\n</li>\n</ul>\n<p>在没有路由器的情况下，两个网络之间是不能进行TCP&#x2F;IP通信的，即使是两个网络连接在同一台交换机(或集线器)上，TCP&#x2F;IP协议也会根据子网掩码(<code>255.255.255.0</code>)判定两个网络中的主机处在不同的网络里。</p>\n<ul>\n<li>而要实现这两个网络之间的通信，则必须通过网关。</li>\n</ul>\n<p>如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。</p>\n<p><strong>所以说，只有设置好网关的IP地址，TCP&#x2F;IP协议才能实现不同网络之间的相互通信。</strong></p>\n<blockquote>\n<p>那么这个IP地址是哪台机器的IP地址呢？</p>\n</blockquote>\n<p>网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器(实质上相当于一台路由器)、代理服务器(也相当于一台路由器)。</p>\n<ul>\n<li><p><strong>如果是同一个网段</strong>，例如，你访问你旁边的兄弟的电脑，那就没网关什么事情，直接将源地址和目标地址放入IP头中，然后通过ARP获得MAC地址，将源MAC和目的MAC放入MAC头中，发出去就可以了。</p>\n</li>\n<li><p><strong>如果不是同一网段</strong>，例如，你要访问你们校园网里面的BBS，该怎么办？</p>\n</li>\n</ul>\n<p>这就需要发往默认网关Gateway。Gateway的地址一定是和源IP地址是一个网段的。</p>\n<p><strong>如何发往默认网关呢？</strong></p>\n<p>网关不是和源IP地址是一个网段的么？</p>\n<ul>\n<li><p>这个过程就和发往同一个网段的其他机器是一样的：将源地址和目标IP地址放入IP头中，通过ARP获得网关的MAC地址，将源MAC和网关的MAC放入MAC头中，发送出去。</p>\n</li>\n<li><p>网关所在的端口，例如<code>192.168.1.1/24</code>将网络包收进来，然后接下来怎么做，就完全看网关的了。</p>\n</li>\n</ul>\n<p><strong>网关往往是一个路由器，是一个三层转发的设备。</strong></p>\n<ul>\n<li>三层设备？就是把MAC头和IP头都取下来，然后根据里面的内容，看看接下来把包往哪里转发的设备。</li>\n</ul>\n<p>在你的宿舍里面，网关就是你宿舍长的电脑。一个路由器往往有多个网口，如果是一台服务器做这个事情，则就有多个网卡，其中一个网卡是和源IP同网段的。</p>\n<p>很多情况下，人们把网关就叫做路由器。其实不完全准确，而另一种比喻更加恰当：<strong>路由器是一台设备，它有五个网口或者网卡，相当于有五只手，分别连着五个局域网。每只手的IP地址都和局域网的IP地址相同的网段，每只手都是它握住的那个局域网的网关。</strong></p>\n<p>任何一个想发往其他局域网的包，都会到达其中一只手，被拿进来，拿下MAC头和IP头，看看，根据自己的路由算法，选择另一只手，加上IP头和MAC头，然后扔出去。</p>\n<p><strong>静态路由是什么？</strong></p>\n<p>大致可以分为两类，一个是<strong>静态路由</strong>，一个是<strong>动态路由</strong>。</p>\n<ul>\n<li><strong>静态路由，其实就是在路由器上，配置一条一条规则。</strong></li>\n</ul>\n<p>这些规则包括：想访问BBS站（它肯定有个网段），从2号口出去，下一跳是IP2；</p>\n<p>想访问教学视频站（它也有个自己的网段），从3号口出去，下一跳是IP3，然后保存在路由器里。</p>\n<ul>\n<li>每当要选择从哪只手抛出去的时候，就一条一条的匹配规则，找到符合的规则，就按规则中设置的那样，从某个口抛出去，找下一跳IPX。</li>\n</ul>\n<p>MAC地址是一个局域网内才有效的地址。因而，MAC地址只要过网关，就必定会改变，因为已经换了局域网。</p>\n<ul>\n<li>两者主要的区别在于IP地址是否改变。不改变IP地址的网关，我们称为<strong>转发网关；改变IP地址的网关，我们称为NAT网关</strong>。</li>\n</ul>\n<p>现在大家每家都有家用路由器，家里的网段都是<code>192.168.1.x</code>，所以你肯定访问不了你邻居家的这个私网的IP地址的。</p>\n<ul>\n<li>所以，当我们家里的包发出去的时候，都被家用路由器NAT成为了运营商的地址了。</li>\n</ul>\n<p>很多办公室访问外网的时候，也是被NAT过的，因为不可能办公室里面的IP也是公网可见的，公网地址实在是太贵了，所以一般就是整个办公室共用一个到两个出口IP地址。</p>\n<p><strong>路由协议</strong></p>\n<p>家里的网段是私有网段，出去的包需要NAT成公网的IP地址，因而路由器是一个NAT路由器。</p>\n<p>两个运营商都要为这个网关配置一个公网的IP地址。如果你去查看你们家路由器里的网段，基本就是我图中画的样子。</p>\n<img src=\"https://img-blog.csdnimg.cn/b1175b1f0f4f45c7b4a51a70aa817557.png\" style=\"zoom:25%;\" />\n\n<h2 id=\"DNS\"><a href=\"#DNS\" class=\"headerlink\" title=\"DNS\"></a>DNS</h2><p>DNS通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>\n<ul>\n<li><strong>通俗的讲</strong>，我们更习惯于记住一个网站的名字，<a href=\"http://www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2\">www.baidu.com，而不是记住它的ip地址，比如：167.23.10.2</a></li>\n</ul>\n<p><strong>工作原理</strong></p>\n<p>将主机域名转换为ip地址，属于应用层协议，使用UDP传输。</p>\n<img src=\"https://img-blog.csdnimg.cn/76f522fa8e764b3c84be4bd6d18638bc.png\" style=\"zoom:50%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/63167cd00b9046fd85c5ccb580cd7c31.png\" style=\"zoom:50%;\" />\n\n<ul>\n<li><p>第一步，客户端向本地DNS服务器发送解析请求</p>\n</li>\n<li><p>第二步，本地DNS如有相应记录会直接返回结果给客户端，如没有就向DNS根服务器发送请求</p>\n</li>\n<li><p>第三步,DSN根服务器接收到请求，返回给本地服务器一个所查询域的主域名服务器的地址</p>\n</li>\n<li><p>第四步，本地dns服务器再向返回的主域名服务器地址发送查询请求</p>\n</li>\n<li><p>第五步，主域名服务器如有记录就返回结果，没有的话返回相关的下级域名服务器地址</p>\n</li>\n<li><p>第六步，本地DNS服务器继续向接收到的地址进行查询请求</p>\n</li>\n<li><p>第七步，下级域名服务器有相应记录，返回结果</p>\n</li>\n<li><p>第八步，本地dns服务器将收到的返回地址发给客户端，同时写入自己的缓存，以便下次查询</p>\n</li>\n</ul>\n<p>DNS域名查询实际上就是个不断递归查询的过程，直到查找到相应结果，需要注意的时，当找不到相应记录，会返回空结果，而不是超时信息</p>\n"},{"title":"TCP和UDP","_content":"\n# TCP\n\nTCP是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。\n\n**双工/单工**\n\n在任何一个时刻，如果数据只能单向发送，就是单工。\n\n如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。\n\n如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。\n\nTCP 是一个双工协议，数据任何时候都可以双向传输。\n\n这就意味着客户端和服务端可以平等地发送、接收信息。\n\n**TCP协议的主要特点**\n\n-  TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。 \n\n-  每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的； \n\n-  TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达； \n\n-  TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存； \n\n-  面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，接收方的TCP可能只用收到的4个数据块字节流交付给上层的应用程序 \n\n**TCP的可靠性原理**\n\n可靠传输有如下两个特点:\n\n1. 传输信道无差错,保证传输数据正确; \n2. 不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据; \n\n首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。\n\n其次，TCP采用了连续ARQ协议（回退N(Go-back-N)；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。\n\n最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。\n\n**报文段**\n\nTCP虽面向字节流，但传送的数据单元为报文段\n\n报文段 = 首部 + 数据2部分\n\nTCP的全部功能体现在它首部中各字段的作用\n\n> 1. 首部前20个字符固定、后面有4n个字节是根据需而增加的选项\n> 2. 故 TCP首部最小长度 = 20字节\n\n<img src=\"https://img-blog.csdnimg.cn/34ef681324ee4834a03a1a894c9ebd36.png\" style=\"zoom:50%;\" />\n\n**端口**：\n\n源端口号和目地端口各占16位两个字节，也就是端口的范围是`2^16=65535`\n\n另外1024以下是系统保留的，从1024-65535是用户使用的端口范围\n\n**seq序号**：占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。\n\n例如：一段报文的序号字段值是107，携带的数据是100个字段，下一个报文段序号从107+100=207开始。\n\n**ack确认号**：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。\n\n例如：B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1=500），B期望收到A下一个数据序号是501，B发送给A的确认报文段中把ack确认号置为501。\n\n**数据偏移**：头部有可选字段，长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远。\n\n**保留**：保留今后使用的，被标为1。\n\n**控制位**：由8个标志位组成。每个标志位表示一个控制功能。\n\n其中主要的6个：\n\n* **URG紧急指针标志**，为1表示紧急指针有效，为0忽略紧急指针。\n\n* **ACK确认序号标志**，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。\n\n* **PSH标志**，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。\n\n* **RST重置连接标志**，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。\n\n* **SYN同步序号**，同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。。\n\n* **FIN终止标志**，用于释放连接，为1时表示发送方没有发送了。\n\n**窗口**：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。\n\n**校验和**：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。\n\n**紧急指针**：只有控制位中的URG为1时才有效，指出本报文段中的紧急数据的字节数。\n\n**选项**：其长度可变，定义其他的可选参数。\n\n## 粘包与拆包\n\nTCP是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP协议也没有字段说明发送数据包的大小。\n\n而且TCP不保证接受方应用程序收到的数据块和发送应用程序发送的数据块具有对应的大小关系\n\n比如发送方应用程序交给发送方`TCP` 10个数据块，接受方TCP可能只用了4个数据块就完整的把接受到的字节流交给了上层应用程序。\n\nTCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题\n\n**TCP粘包/拆包解决策略**\n\n由于TCP无法理解上一层的业务数据特点，所以TCP是无法保证发送的数据包不发生粘包和拆包，这个问题只能通过上层的协议栈设计来解决，解决思路有一下几种：\n\n- 消息定长：每个发送的数据包大小固定，比如100字节，不足100字节的用空格补充，接受方取数据的时候根据这个长度来读取数据\n\n- 消息末尾增加换行符来表示一条完整的消息：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。\n\n- 将消息分为消息头和消息尾两部分，消息头指定数据长度，根据消息长度来读取完整的消息，例如UDP协议是这么设计的，用两个字节来表示消息长度，所以UDP不存在粘包和拆包问题。\n\n## 三次握手\n\n<img src=\"https://img-blog.csdnimg.cn/acbb8bc0f2b24d0dbc7a1dd2f6e212be.png\" style=\"zoom:50%;\" />\n\n**第一次握手**：\n\n客户端将TCP报文标志位`SYN`置为1，随机产生一个序号值`seq=J`，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入`SYN_SENT`状态，等待服务器端确认。\n\n**第二次握手**：\n\n服务器端收到数据包后由标志位`SYN=1`知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，`ack=J+1`，随机产生一个序号值`seq=K`，并将该数据包发送给客户端以确认连接请求，服务器端进入`SYN_RCVD`状态。\n\n**第三次握手**：\n\n客户端收到确认后，检查ack是否为`J+1`，ACK是否为1，如果正确则将标志位ACK置为1，`ack=K+1`，并将该数据包发送给服务器端，服务器端检查ack是否为`K+1`，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入`ESTABLISHED`状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。\n\n**上面写的ack和ACK，不是同一个概念：**\n\n- 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，`ack=seq+1`。\n\n- 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。\n\n**TCP为什么三次握手而不是两次握手**\n\n- 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤\n\n- 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认\n\n**《计算机网络》中是这样说的：**\n\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n\n> 在书中同时举了一个例子，如下：\n\n假如`client`发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达`server`，本来这是一个早已失效的报文段，但`server`收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。\n\n于是就向client发出确认报文段，同意建立连接，假设不采用**三次握手**，那么只要server发出确认，新的连接就建立了，由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。\n\n但server却以为新的连接已经建立，并一直等待`client`发来数据，这样，server的很多资源就白白浪费掉了。\n\n采用**三次握手**的办法可以防止上述现象发生，例如刚才那种情况，client不会向`server`的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接。\n\n**什么是半连接队列**\n\n服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD`状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。\n\n当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\n\n补充一点关于**SYN-ACK 重传次数**的问题：\n\n服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。\n\n**三次握手过程中可以携带数据吗**\n\n其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。\n\n假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。\n\n而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据没啥毛病。\n\n## 四次挥手\n\n<img src=\"https://img-blog.csdnimg.cn/faa54ef4df1749139f4ee2dd5d002562.png\" style=\"zoom:50%;\" />\n\n挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：\n\n- 第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入`FIN_WAIT_1`状态，这表示Client端没有数据要发送给Server端了。\n\n- 第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入`FIN_WAIT_2`状态，Server端告诉Client端，我确认并同意你的关闭请求。\n\n- 第三次挥手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入`LAST_ACK`状态。\n\n- 第四次挥手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入`TIME_WAIT`状态，Server端收到Client端的ACK报文段以后，就关闭连接，此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。\n\n**为什么连接的时候是三次握手，关闭的时候却是四次握手？**\n\n建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。\n\n由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。\n\n这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。\n\n当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。\n\n**为什么TIME_WAIT要等待2MSL？**\n\nMSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。\n\n有以下两个原因：\n\n-  第一点：保证TCP协议的全双工连接能够可靠关闭：\n   由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于`CLOESD`状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入`CLOSED`状态，而要保持`TIME_WAIT`，当再次收到FIN的时候，能够保证对方收到ACK，最后正确关闭连接。 \n-  第二点：保证这次连接的重复数据段从网络中消失\n   如果Client端发送最后的ACK直接进入`CLOSED`状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱，所以TCP连接需要在`TIME_WAIT`状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。 \n\n## 流量控制\n\n**RTT和RTO**\n\nRTT：发送一个数据包到收到对应的ACK，所花费的时间\n\nRTO：重传时间间隔（TCP在发送一个数据包后会启动一个重传定时器，RTO即定时器的重传时间）\n\n开始预先算一个定时器时间，如果回复ACK，重传定时器就自动失效，即不需要重传；如果没有回复ACK，RTO定时器时间就到了，重传。\n\nRTO是本次发送当前数据包所预估的超时时间，RTO不是固定写死的配置，是经过RTT计算出来的。\n\n**滑动窗口**\n\nTCP的滑动窗口主要有两个作用：\n\n1. 保证TCP的可靠性\n\n2. 保证TCP的流控特性\n\nTCP报文头有个字段叫Window，用于接收方通知发送方自己还有多少缓存区可以接收数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来，这便是流量控制。\n\n发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。\n\n发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。\n\n不同的滑动窗口协议窗口大小一般不同。\n\n发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧\n\n<img src=\"https://img-blog.csdnimg.cn/524ceb06725142e5b2c4a3211020a06e.png\" style=\"zoom:50%;\" />\n\n滑动窗口由四部分组成每个字节的数据都有唯一顺序的编码，随着时间发展，未确认部分与可以发送数据包编码部分向右移动，形式滑动窗口\n\n1. `绿色`：发送成功并已经ACK确认的数据\n2. `黄色`：发送成功等待ACK确认的数据(占用滑动窗口大小)\n3. `紫色`：滑动窗口剩余大小可以发送的字节数量(滑动窗口可用大小)\n4. `灰色`：后续数据编码\n\n接收窗口的大小就是滑动窗口的最大值，数据传输过程中滑动窗口的可用大小是动态变化的。\n\n但是还有这么一点，滑动窗口的设计仅仅是考虑到了处理方的处理能力，但是没有考虑到道路的通畅问题\n\n就好像服务端可以处理100M数据，但是传输的数据99M都堵在路上了，这不就是导致道路阻塞了么？这就需要另外一个设计**拥塞避免**\n\n**流量控制的目的**\n\n如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。\n\n为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。\n\n流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。\n\n**如何实现流量控制**\n\n由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。\n\n主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。\n\n![](https://img-blog.csdnimg.cn/5faa3ef1f5a242d3a2a5f38a377611b9.png)\n\n**流量控制引发的死锁**\n\n当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。\n\n但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。\n\n为了避免流量控制引发的死锁，TCP使用了**持续计时器**。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。\n\n## 拥塞控制\n\n**为什么要进行拥塞控制**\n\n假设网络已经出现拥塞，如果不处理拥塞，那么延时增加，出现更多丢包，触发发送方重传数据，加剧拥塞情况，继续恶性循环直至网络瘫痪。\n\n拥塞控制与流量控制的适应场景和目的均不同。\n\n拥塞发生前，可避免流量过快增长拖垮网络；拥塞发生时，唯一的选择就是降低流量。\n\n主要使用4种算法完成拥塞控制：\n\n1. 慢启动\n2. 拥塞避免\n3. 快重传算法\n4. 快速恢复算法\n\n算法1、2适用于拥塞发生前，算法3适用于拥塞发生时，算法4适用于拥塞解决后（相当于拥塞发生前）。\n\n**rwnd与cwnd**\n\n`rwnd`（Receiver Window，接收者窗口）与`cwnd`（Congestion Window，拥塞窗口）：\n\n- rwnd是用于流量控制的窗口大小，主要取决于接收方的处理速度，由接收方通知发送方被动调整。\n\n- cwnd是用于拥塞处理的窗口大小，取决于网络状况，由发送方探查网络主动调整。\n\n同时考虑流量控制与拥塞处理，则发送方窗口的大小不超过`min{rwnd, cwnd}`。\n\n**慢启动算法**\n\n慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。\n\n这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。\n\n一个传输轮次所经历的时间其实就是往返时间RTT，而且每经过一个传输轮次，拥塞窗口cwnd就加倍。\n\n为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。\n\n> ssthresh的用法如下：\n\n-  cwnd<ssthresh时，使用慢开始算法。 \n\n-  当cwnd>ssthresh时，改用拥塞避免算法。 \n\n-  当cwnd=ssthresh时，慢开始与拥塞避免算法任意 \n\n注意，这里的慢并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要慢得多。\n\n**拥塞避免算法**\n\n让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。\n\n这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多\n\n无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。\n\n然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。\n\n这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n\n**整个拥塞控制的流程：**\n\n假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。\n\n当cwnd=12=ssthresh时，改为执行拥塞避免算法\n\n注意：拥塞避免并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞。\n\n![](https://img-blog.csdnimg.cn/d7b6db2a7cf64645a98325c7be12c3d6.png)\n\n**快重传算法**\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。\n\n快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期\n\n**快恢复算法**\n\n快重传配合使用的还有快恢复算法，有以下两个要点：\n\n-  当发送方连续收到三个重复确认时，就把ssthresh门限减半（为了预防网络发生拥塞）。 \n\n-  但是接下去并不执行慢开始算法 \n\n考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。\n\n所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。\n\n<img src=\"https://img-blog.csdnimg.cn/a80c340fb68d4d4c8151a91b805851a9.png\" style=\"zoom:50%;\" />\n\n## Socket\n\n即套接字，是应用层 与 `TCP/IP` 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）\n\n<img src=\"https://img-blog.csdnimg.cn/b9e355824efb43a7a6da3435add24dd8.png\" style=\"zoom:50%;\" />\n\n`Socket`不是一种协议，而是一个编程调用接口（`API`），属于传输层（主要解决数据如何在网络中传输）\n\n对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信\n\n# UDP\n\n**UDP协议特点**\n\n-  UDP是无连接的传输层协议； \n\n-  UDP使用尽最大努力交付，不保证可靠交付； \n\n-  UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界； \n\n-  UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率； \n\n-  UDP支持一对一　一对多　多对多的交互通信； \n\n-  UDP的首部开销小，只有８字节 \n\n**TCP和UDP的区别**\n\n- TCP是可靠传输，UDP是不可靠传输;\n\n- TCP面向连接，UDP无连接;\n\n- TCP传输数据有序，UDP不保证数据的有序性;\n\n- TCP不保存数据边界，UDP保留数据边界;\n\n- TCP传输速度相对UDP较慢;\n\n- TCP有流量控制和拥塞控制，UDP没有;\n\n- TCP是重量级协议，UDP是轻量级协议;\n\n- TCP首部较长20字节，UDP首部较短８字节;\n\n**基于TCP和UDP的常用协议**\n\nHTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。\n\nTFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议\n\n当我发送的UDP包到达目标机器后，发现MAC地址匹配，于是就取下来，将剩下的包传给处理IP层的代码。\n\n把IP头取下来，发现目标IP匹配，接下来呢？这里面的数据包是给谁呢？\n\n发送的时候，我知道我发的是一个UDP的包，收到的那台机器咋知道的呢？\n\n所以在IP头里面有个8位协议，这里会存放，数据里面到底是TCP还是UDP，当然这里是UDP。\n\n于是，如果我们知道UDP头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？\n\n处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？\n\n无论应用程序写的使用TCP传数据，还是UDP传数据，都要监听一个端口。\n\n正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？\n\n所以，按理说，无论是TCP还是UDP包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。\n\n**报文段**\n\nUDP的报文段共有2个字段：数据字段 + 首部字段\n\n<img src=\"https://img-blog.csdnimg.cn/f700d8237cd24158946981d95d51882b.png\" style=\"zoom:50%;\" />\n\n**UDP报文中每个字段的含义如下：**\n\n- 源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口，接收端的应用程序利用这个字段的值作为发送响应的目的地址，这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中，如果不写入端口号，则把这个字段设置为 0，这样，接收端的应用程序就不能发送响应了。\n- 目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。\n- 长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度，因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。\n- 校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。","source":"_posts/图解TCP IP/TCP和UDP.md","raw":"---\ntitle: TCP和UDP\ncategories: \n- 图解TCP IP\n---\n\n# TCP\n\nTCP是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。\n\n**双工/单工**\n\n在任何一个时刻，如果数据只能单向发送，就是单工。\n\n如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。\n\n如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。\n\nTCP 是一个双工协议，数据任何时候都可以双向传输。\n\n这就意味着客户端和服务端可以平等地发送、接收信息。\n\n**TCP协议的主要特点**\n\n-  TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。 \n\n-  每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的； \n\n-  TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达； \n\n-  TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存； \n\n-  面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，接收方的TCP可能只用收到的4个数据块字节流交付给上层的应用程序 \n\n**TCP的可靠性原理**\n\n可靠传输有如下两个特点:\n\n1. 传输信道无差错,保证传输数据正确; \n2. 不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据; \n\n首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。\n\n其次，TCP采用了连续ARQ协议（回退N(Go-back-N)；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。\n\n最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。\n\n**报文段**\n\nTCP虽面向字节流，但传送的数据单元为报文段\n\n报文段 = 首部 + 数据2部分\n\nTCP的全部功能体现在它首部中各字段的作用\n\n> 1. 首部前20个字符固定、后面有4n个字节是根据需而增加的选项\n> 2. 故 TCP首部最小长度 = 20字节\n\n<img src=\"https://img-blog.csdnimg.cn/34ef681324ee4834a03a1a894c9ebd36.png\" style=\"zoom:50%;\" />\n\n**端口**：\n\n源端口号和目地端口各占16位两个字节，也就是端口的范围是`2^16=65535`\n\n另外1024以下是系统保留的，从1024-65535是用户使用的端口范围\n\n**seq序号**：占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。\n\n例如：一段报文的序号字段值是107，携带的数据是100个字段，下一个报文段序号从107+100=207开始。\n\n**ack确认号**：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。\n\n例如：B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1=500），B期望收到A下一个数据序号是501，B发送给A的确认报文段中把ack确认号置为501。\n\n**数据偏移**：头部有可选字段，长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远。\n\n**保留**：保留今后使用的，被标为1。\n\n**控制位**：由8个标志位组成。每个标志位表示一个控制功能。\n\n其中主要的6个：\n\n* **URG紧急指针标志**，为1表示紧急指针有效，为0忽略紧急指针。\n\n* **ACK确认序号标志**，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。\n\n* **PSH标志**，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。\n\n* **RST重置连接标志**，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。\n\n* **SYN同步序号**，同步序号，用于建立连接过程，在连接请求中，SYN=1和ACK=0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN=1和ACK=1。。\n\n* **FIN终止标志**，用于释放连接，为1时表示发送方没有发送了。\n\n**窗口**：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。\n\n**校验和**：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。\n\n**紧急指针**：只有控制位中的URG为1时才有效，指出本报文段中的紧急数据的字节数。\n\n**选项**：其长度可变，定义其他的可选参数。\n\n## 粘包与拆包\n\nTCP是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP协议也没有字段说明发送数据包的大小。\n\n而且TCP不保证接受方应用程序收到的数据块和发送应用程序发送的数据块具有对应的大小关系\n\n比如发送方应用程序交给发送方`TCP` 10个数据块，接受方TCP可能只用了4个数据块就完整的把接受到的字节流交给了上层应用程序。\n\nTCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题\n\n**TCP粘包/拆包解决策略**\n\n由于TCP无法理解上一层的业务数据特点，所以TCP是无法保证发送的数据包不发生粘包和拆包，这个问题只能通过上层的协议栈设计来解决，解决思路有一下几种：\n\n- 消息定长：每个发送的数据包大小固定，比如100字节，不足100字节的用空格补充，接受方取数据的时候根据这个长度来读取数据\n\n- 消息末尾增加换行符来表示一条完整的消息：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。\n\n- 将消息分为消息头和消息尾两部分，消息头指定数据长度，根据消息长度来读取完整的消息，例如UDP协议是这么设计的，用两个字节来表示消息长度，所以UDP不存在粘包和拆包问题。\n\n## 三次握手\n\n<img src=\"https://img-blog.csdnimg.cn/acbb8bc0f2b24d0dbc7a1dd2f6e212be.png\" style=\"zoom:50%;\" />\n\n**第一次握手**：\n\n客户端将TCP报文标志位`SYN`置为1，随机产生一个序号值`seq=J`，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入`SYN_SENT`状态，等待服务器端确认。\n\n**第二次握手**：\n\n服务器端收到数据包后由标志位`SYN=1`知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，`ack=J+1`，随机产生一个序号值`seq=K`，并将该数据包发送给客户端以确认连接请求，服务器端进入`SYN_RCVD`状态。\n\n**第三次握手**：\n\n客户端收到确认后，检查ack是否为`J+1`，ACK是否为1，如果正确则将标志位ACK置为1，`ack=K+1`，并将该数据包发送给服务器端，服务器端检查ack是否为`K+1`，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入`ESTABLISHED`状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。\n\n**上面写的ack和ACK，不是同一个概念：**\n\n- 小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，`ack=seq+1`。\n\n- 大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。\n\n**TCP为什么三次握手而不是两次握手**\n\n- 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤\n\n- 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认\n\n**《计算机网络》中是这样说的：**\n\n为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。\n\n> 在书中同时举了一个例子，如下：\n\n假如`client`发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达`server`，本来这是一个早已失效的报文段，但`server`收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。\n\n于是就向client发出确认报文段，同意建立连接，假设不采用**三次握手**，那么只要server发出确认，新的连接就建立了，由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。\n\n但server却以为新的连接已经建立，并一直等待`client`发来数据，这样，server的很多资源就白白浪费掉了。\n\n采用**三次握手**的办法可以防止上述现象发生，例如刚才那种情况，client不会向`server`的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接。\n\n**什么是半连接队列**\n\n服务器第一次收到客户端的 SYN 之后，就会处于 `SYN_RCVD`状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为**半连接队列**。\n\n当然还有一个**全连接队列**，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。\n\n补充一点关于**SYN-ACK 重传次数**的问题：\n\n服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。\n\n**三次握手过程中可以携带数据吗**\n\n其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。\n\n假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。\n\n而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据没啥毛病。\n\n## 四次挥手\n\n<img src=\"https://img-blog.csdnimg.cn/faa54ef4df1749139f4ee2dd5d002562.png\" style=\"zoom:50%;\" />\n\n挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：\n\n- 第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入`FIN_WAIT_1`状态，这表示Client端没有数据要发送给Server端了。\n\n- 第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入`FIN_WAIT_2`状态，Server端告诉Client端，我确认并同意你的关闭请求。\n\n- 第三次挥手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入`LAST_ACK`状态。\n\n- 第四次挥手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入`TIME_WAIT`状态，Server端收到Client端的ACK报文段以后，就关闭连接，此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。\n\n**为什么连接的时候是三次握手，关闭的时候却是四次握手？**\n\n建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。\n\n由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。\n\n这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。\n\n当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。\n\n**为什么TIME_WAIT要等待2MSL？**\n\nMSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。\n\n有以下两个原因：\n\n-  第一点：保证TCP协议的全双工连接能够可靠关闭：\n   由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于`CLOESD`状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入`CLOSED`状态，而要保持`TIME_WAIT`，当再次收到FIN的时候，能够保证对方收到ACK，最后正确关闭连接。 \n-  第二点：保证这次连接的重复数据段从网络中消失\n   如果Client端发送最后的ACK直接进入`CLOSED`状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱，所以TCP连接需要在`TIME_WAIT`状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。 \n\n## 流量控制\n\n**RTT和RTO**\n\nRTT：发送一个数据包到收到对应的ACK，所花费的时间\n\nRTO：重传时间间隔（TCP在发送一个数据包后会启动一个重传定时器，RTO即定时器的重传时间）\n\n开始预先算一个定时器时间，如果回复ACK，重传定时器就自动失效，即不需要重传；如果没有回复ACK，RTO定时器时间就到了，重传。\n\nRTO是本次发送当前数据包所预估的超时时间，RTO不是固定写死的配置，是经过RTT计算出来的。\n\n**滑动窗口**\n\nTCP的滑动窗口主要有两个作用：\n\n1. 保证TCP的可靠性\n\n2. 保证TCP的流控特性\n\nTCP报文头有个字段叫Window，用于接收方通知发送方自己还有多少缓存区可以接收数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来，这便是流量控制。\n\n发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。\n\n发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。\n\n不同的滑动窗口协议窗口大小一般不同。\n\n发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧\n\n<img src=\"https://img-blog.csdnimg.cn/524ceb06725142e5b2c4a3211020a06e.png\" style=\"zoom:50%;\" />\n\n滑动窗口由四部分组成每个字节的数据都有唯一顺序的编码，随着时间发展，未确认部分与可以发送数据包编码部分向右移动，形式滑动窗口\n\n1. `绿色`：发送成功并已经ACK确认的数据\n2. `黄色`：发送成功等待ACK确认的数据(占用滑动窗口大小)\n3. `紫色`：滑动窗口剩余大小可以发送的字节数量(滑动窗口可用大小)\n4. `灰色`：后续数据编码\n\n接收窗口的大小就是滑动窗口的最大值，数据传输过程中滑动窗口的可用大小是动态变化的。\n\n但是还有这么一点，滑动窗口的设计仅仅是考虑到了处理方的处理能力，但是没有考虑到道路的通畅问题\n\n就好像服务端可以处理100M数据，但是传输的数据99M都堵在路上了，这不就是导致道路阻塞了么？这就需要另外一个设计**拥塞避免**\n\n**流量控制的目的**\n\n如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。\n\n为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。\n\n流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。\n\n**如何实现流量控制**\n\n由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。\n\n主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。\n\n![](https://img-blog.csdnimg.cn/5faa3ef1f5a242d3a2a5f38a377611b9.png)\n\n**流量控制引发的死锁**\n\n当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。\n\n但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。\n\n为了避免流量控制引发的死锁，TCP使用了**持续计时器**。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。\n\n## 拥塞控制\n\n**为什么要进行拥塞控制**\n\n假设网络已经出现拥塞，如果不处理拥塞，那么延时增加，出现更多丢包，触发发送方重传数据，加剧拥塞情况，继续恶性循环直至网络瘫痪。\n\n拥塞控制与流量控制的适应场景和目的均不同。\n\n拥塞发生前，可避免流量过快增长拖垮网络；拥塞发生时，唯一的选择就是降低流量。\n\n主要使用4种算法完成拥塞控制：\n\n1. 慢启动\n2. 拥塞避免\n3. 快重传算法\n4. 快速恢复算法\n\n算法1、2适用于拥塞发生前，算法3适用于拥塞发生时，算法4适用于拥塞解决后（相当于拥塞发生前）。\n\n**rwnd与cwnd**\n\n`rwnd`（Receiver Window，接收者窗口）与`cwnd`（Congestion Window，拥塞窗口）：\n\n- rwnd是用于流量控制的窗口大小，主要取决于接收方的处理速度，由接收方通知发送方被动调整。\n\n- cwnd是用于拥塞处理的窗口大小，取决于网络状况，由发送方探查网络主动调整。\n\n同时考虑流量控制与拥塞处理，则发送方窗口的大小不超过`min{rwnd, cwnd}`。\n\n**慢启动算法**\n\n慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。\n\n这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。\n\n一个传输轮次所经历的时间其实就是往返时间RTT，而且每经过一个传输轮次，拥塞窗口cwnd就加倍。\n\n为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。\n\n> ssthresh的用法如下：\n\n-  cwnd<ssthresh时，使用慢开始算法。 \n\n-  当cwnd>ssthresh时，改用拥塞避免算法。 \n\n-  当cwnd=ssthresh时，慢开始与拥塞避免算法任意 \n\n注意，这里的慢并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd=1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要慢得多。\n\n**拥塞避免算法**\n\n让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。\n\n这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多\n\n无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。\n\n然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。\n\n这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。\n\n**整个拥塞控制的流程：**\n\n假定cwnd=24时，网络出现超时（拥塞），则更新后的ssthresh=12，cwnd重新设置为1，并执行慢开始算法。\n\n当cwnd=12=ssthresh时，改为执行拥塞避免算法\n\n注意：拥塞避免并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞。\n\n![](https://img-blog.csdnimg.cn/d7b6db2a7cf64645a98325c7be12c3d6.png)\n\n**快重传算法**\n\n快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。\n\n快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期\n\n**快恢复算法**\n\n快重传配合使用的还有快恢复算法，有以下两个要点：\n\n-  当发送方连续收到三个重复确认时，就把ssthresh门限减半（为了预防网络发生拥塞）。 \n\n-  但是接下去并不执行慢开始算法 \n\n考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。\n\n所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。\n\n<img src=\"https://img-blog.csdnimg.cn/a80c340fb68d4d4c8151a91b805851a9.png\" style=\"zoom:50%;\" />\n\n## Socket\n\n即套接字，是应用层 与 `TCP/IP` 协议族通信的中间软件抽象层，表现为一个封装了 TCP / IP协议族 的编程接口（API）\n\n<img src=\"https://img-blog.csdnimg.cn/b9e355824efb43a7a6da3435add24dd8.png\" style=\"zoom:50%;\" />\n\n`Socket`不是一种协议，而是一个编程调用接口（`API`），属于传输层（主要解决数据如何在网络中传输）\n\n对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信\n\n# UDP\n\n**UDP协议特点**\n\n-  UDP是无连接的传输层协议； \n\n-  UDP使用尽最大努力交付，不保证可靠交付； \n\n-  UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界； \n\n-  UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率； \n\n-  UDP支持一对一　一对多　多对多的交互通信； \n\n-  UDP的首部开销小，只有８字节 \n\n**TCP和UDP的区别**\n\n- TCP是可靠传输，UDP是不可靠传输;\n\n- TCP面向连接，UDP无连接;\n\n- TCP传输数据有序，UDP不保证数据的有序性;\n\n- TCP不保存数据边界，UDP保留数据边界;\n\n- TCP传输速度相对UDP较慢;\n\n- TCP有流量控制和拥塞控制，UDP没有;\n\n- TCP是重量级协议，UDP是轻量级协议;\n\n- TCP首部较长20字节，UDP首部较短８字节;\n\n**基于TCP和UDP的常用协议**\n\nHTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。\n\nTFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议\n\n当我发送的UDP包到达目标机器后，发现MAC地址匹配，于是就取下来，将剩下的包传给处理IP层的代码。\n\n把IP头取下来，发现目标IP匹配，接下来呢？这里面的数据包是给谁呢？\n\n发送的时候，我知道我发的是一个UDP的包，收到的那台机器咋知道的呢？\n\n所以在IP头里面有个8位协议，这里会存放，数据里面到底是TCP还是UDP，当然这里是UDP。\n\n于是，如果我们知道UDP头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？\n\n处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？\n\n无论应用程序写的使用TCP传数据，还是UDP传数据，都要监听一个端口。\n\n正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？\n\n所以，按理说，无论是TCP还是UDP包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。\n\n**报文段**\n\nUDP的报文段共有2个字段：数据字段 + 首部字段\n\n<img src=\"https://img-blog.csdnimg.cn/f700d8237cd24158946981d95d51882b.png\" style=\"zoom:50%;\" />\n\n**UDP报文中每个字段的含义如下：**\n\n- 源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口，接收端的应用程序利用这个字段的值作为发送响应的目的地址，这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中，如果不写入端口号，则把这个字段设置为 0，这样，接收端的应用程序就不能发送响应了。\n- 目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。\n- 长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度，因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。\n- 校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。","slug":"图解TCP IP/TCP和UDP","published":1,"date":"2022-02-02T02:35:23.652Z","updated":"2022-02-08T02:51:43.913Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj600ftfhjieggd0ouo","content":"<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p>TCP是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。</p>\n<p><strong>双工&#x2F;单工</strong></p>\n<p>在任何一个时刻，如果数据只能单向发送，就是单工。</p>\n<p>如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。</p>\n<p>如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。</p>\n<p>TCP 是一个双工协议，数据任何时候都可以双向传输。</p>\n<p>这就意味着客户端和服务端可以平等地发送、接收信息。</p>\n<p><strong>TCP协议的主要特点</strong></p>\n<ul>\n<li><p>TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。 </p>\n</li>\n<li><p>每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的； </p>\n</li>\n<li><p>TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达； </p>\n</li>\n<li><p>TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存； </p>\n</li>\n<li><p>面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，接收方的TCP可能只用收到的4个数据块字节流交付给上层的应用程序</p>\n</li>\n</ul>\n<p><strong>TCP的可靠性原理</strong></p>\n<p>可靠传输有如下两个特点:</p>\n<ol>\n<li>传输信道无差错,保证传输数据正确; </li>\n<li>不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;</li>\n</ol>\n<p>首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。</p>\n<p>其次，TCP采用了连续ARQ协议（回退N(Go-back-N)；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。</p>\n<p>最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。</p>\n<p><strong>报文段</strong></p>\n<p>TCP虽面向字节流，但传送的数据单元为报文段</p>\n<p>报文段 &#x3D; 首部 + 数据2部分</p>\n<p>TCP的全部功能体现在它首部中各字段的作用</p>\n<blockquote>\n<ol>\n<li>首部前20个字符固定、后面有4n个字节是根据需而增加的选项</li>\n<li>故 TCP首部最小长度 &#x3D; 20字节</li>\n</ol>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/34ef681324ee4834a03a1a894c9ebd36.png\" style=\"zoom:50%;\" />\n\n<p><strong>端口</strong>：</p>\n<p>源端口号和目地端口各占16位两个字节，也就是端口的范围是<code>2^16=65535</code></p>\n<p>另外1024以下是系统保留的，从1024-65535是用户使用的端口范围</p>\n<p><strong>seq序号</strong>：占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。</p>\n<p>例如：一段报文的序号字段值是107，携带的数据是100个字段，下一个报文段序号从107+100&#x3D;207开始。</p>\n<p><strong>ack确认号</strong>：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。</p>\n<p>例如：B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1&#x3D;500），B期望收到A下一个数据序号是501，B发送给A的确认报文段中把ack确认号置为501。</p>\n<p><strong>数据偏移</strong>：头部有可选字段，长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远。</p>\n<p><strong>保留</strong>：保留今后使用的，被标为1。</p>\n<p><strong>控制位</strong>：由8个标志位组成。每个标志位表示一个控制功能。</p>\n<p>其中主要的6个：</p>\n<ul>\n<li><p><strong>URG紧急指针标志</strong>，为1表示紧急指针有效，为0忽略紧急指针。</p>\n</li>\n<li><p><strong>ACK确认序号标志</strong>，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。</p>\n</li>\n<li><p><strong>PSH标志</strong>，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。</p>\n</li>\n<li><p><strong>RST重置连接标志</strong>，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。</p>\n</li>\n<li><p><strong>SYN同步序号</strong>，同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。。</p>\n</li>\n<li><p><strong>FIN终止标志</strong>，用于释放连接，为1时表示发送方没有发送了。</p>\n</li>\n</ul>\n<p><strong>窗口</strong>：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。</p>\n<p><strong>校验和</strong>：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。</p>\n<p><strong>紧急指针</strong>：只有控制位中的URG为1时才有效，指出本报文段中的紧急数据的字节数。</p>\n<p><strong>选项</strong>：其长度可变，定义其他的可选参数。</p>\n<h2 id=\"粘包与拆包\"><a href=\"#粘包与拆包\" class=\"headerlink\" title=\"粘包与拆包\"></a>粘包与拆包</h2><p>TCP是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP协议也没有字段说明发送数据包的大小。</p>\n<p>而且TCP不保证接受方应用程序收到的数据块和发送应用程序发送的数据块具有对应的大小关系</p>\n<p>比如发送方应用程序交给发送方<code>TCP</code> 10个数据块，接受方TCP可能只用了4个数据块就完整的把接受到的字节流交给了上层应用程序。</p>\n<p>TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题</p>\n<p><strong>TCP粘包&#x2F;拆包解决策略</strong></p>\n<p>由于TCP无法理解上一层的业务数据特点，所以TCP是无法保证发送的数据包不发生粘包和拆包，这个问题只能通过上层的协议栈设计来解决，解决思路有一下几种：</p>\n<ul>\n<li><p>消息定长：每个发送的数据包大小固定，比如100字节，不足100字节的用空格补充，接受方取数据的时候根据这个长度来读取数据</p>\n</li>\n<li><p>消息末尾增加换行符来表示一条完整的消息：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。</p>\n</li>\n<li><p>将消息分为消息头和消息尾两部分，消息头指定数据长度，根据消息长度来读取完整的消息，例如UDP协议是这么设计的，用两个字节来表示消息长度，所以UDP不存在粘包和拆包问题。</p>\n</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><img src=\"https://img-blog.csdnimg.cn/acbb8bc0f2b24d0dbc7a1dd2f6e212be.png\" style=\"zoom:50%;\" />\n\n<p><strong>第一次握手</strong>：</p>\n<p>客户端将TCP报文标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p>\n<p><strong>第二次握手</strong>：</p>\n<p>服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个序号值<code>seq=K</code>，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</p>\n<p><strong>第三次握手</strong>：</p>\n<p>客户端收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>\n<p><strong>上面写的ack和ACK，不是同一个概念：</strong></p>\n<ul>\n<li><p>小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，<code>ack=seq+1</code>。</p>\n</li>\n<li><p>大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。</p>\n</li>\n</ul>\n<p><strong>TCP为什么三次握手而不是两次握手</strong></p>\n<ul>\n<li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>\n</li>\n<li><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p>\n</li>\n</ul>\n<p><strong>《计算机网络》中是这样说的：</strong></p>\n<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>\n<blockquote>\n<p>在书中同时举了一个例子，如下：</p>\n</blockquote>\n<p>假如<code>client</code>发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达<code>server</code>，本来这是一个早已失效的报文段，但<code>server</code>收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。</p>\n<p>于是就向client发出确认报文段，同意建立连接，假设不采用<strong>三次握手</strong>，那么只要server发出确认，新的连接就建立了，由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。</p>\n<p>但server却以为新的连接已经建立，并一直等待<code>client</code>发来数据，这样，server的很多资源就白白浪费掉了。</p>\n<p>采用<strong>三次握手</strong>的办法可以防止上述现象发生，例如刚才那种情况，client不会向<code>server</code>的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接。</p>\n<p><strong>什么是半连接队列</strong></p>\n<p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code>状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p>\n<p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>\n<p>补充一点关于<strong>SYN-ACK 重传次数</strong>的问题：</p>\n<p>服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>\n<p><strong>三次握手过程中可以携带数据吗</strong></p>\n<p>其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>\n<p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>\n<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据没啥毛病。</p>\n<h2 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h2><img src=\"https://img-blog.csdnimg.cn/faa54ef4df1749139f4ee2dd5d002562.png\" style=\"zoom:50%;\" />\n\n<p>挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：</p>\n<ul>\n<li><p>第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入<code>FIN_WAIT_1</code>状态，这表示Client端没有数据要发送给Server端了。</p>\n</li>\n<li><p>第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入<code>FIN_WAIT_2</code>状态，Server端告诉Client端，我确认并同意你的关闭请求。</p>\n</li>\n<li><p>第三次挥手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入<code>LAST_ACK</code>状态。</p>\n</li>\n<li><p>第四次挥手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入<code>TIME_WAIT</code>状态，Server端收到Client端的ACK报文段以后，就关闭连接，此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</p>\n</li>\n</ul>\n<p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p>\n<p>建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。</p>\n<p>由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。</p>\n<p>这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。</p>\n<p>当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>\n<p><strong>为什么TIME_WAIT要等待2MSL？</strong></p>\n<p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p>\n<p>有以下两个原因：</p>\n<ul>\n<li>第一点：保证TCP协议的全双工连接能够可靠关闭：<br>由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于<code>CLOESD</code>状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入<code>CLOSED</code>状态，而要保持<code>TIME_WAIT</code>，当再次收到FIN的时候，能够保证对方收到ACK，最后正确关闭连接。 </li>\n<li>第二点：保证这次连接的重复数据段从网络中消失<br>如果Client端发送最后的ACK直接进入<code>CLOSED</code>状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱，所以TCP连接需要在<code>TIME_WAIT</code>状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。</li>\n</ul>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><p><strong>RTT和RTO</strong></p>\n<p>RTT：发送一个数据包到收到对应的ACK，所花费的时间</p>\n<p>RTO：重传时间间隔（TCP在发送一个数据包后会启动一个重传定时器，RTO即定时器的重传时间）</p>\n<p>开始预先算一个定时器时间，如果回复ACK，重传定时器就自动失效，即不需要重传；如果没有回复ACK，RTO定时器时间就到了，重传。</p>\n<p>RTO是本次发送当前数据包所预估的超时时间，RTO不是固定写死的配置，是经过RTT计算出来的。</p>\n<p><strong>滑动窗口</strong></p>\n<p>TCP的滑动窗口主要有两个作用：</p>\n<ol>\n<li><p>保证TCP的可靠性</p>\n</li>\n<li><p>保证TCP的流控特性</p>\n</li>\n</ol>\n<p>TCP报文头有个字段叫Window，用于接收方通知发送方自己还有多少缓存区可以接收数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来，这便是流量控制。</p>\n<p>发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。</p>\n<p>发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。</p>\n<p>不同的滑动窗口协议窗口大小一般不同。</p>\n<p>发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧</p>\n<img src=\"https://img-blog.csdnimg.cn/524ceb06725142e5b2c4a3211020a06e.png\" style=\"zoom:50%;\" />\n\n<p>滑动窗口由四部分组成每个字节的数据都有唯一顺序的编码，随着时间发展，未确认部分与可以发送数据包编码部分向右移动，形式滑动窗口</p>\n<ol>\n<li><code>绿色</code>：发送成功并已经ACK确认的数据</li>\n<li><code>黄色</code>：发送成功等待ACK确认的数据(占用滑动窗口大小)</li>\n<li><code>紫色</code>：滑动窗口剩余大小可以发送的字节数量(滑动窗口可用大小)</li>\n<li><code>灰色</code>：后续数据编码</li>\n</ol>\n<p>接收窗口的大小就是滑动窗口的最大值，数据传输过程中滑动窗口的可用大小是动态变化的。</p>\n<p>但是还有这么一点，滑动窗口的设计仅仅是考虑到了处理方的处理能力，但是没有考虑到道路的通畅问题</p>\n<p>就好像服务端可以处理100M数据，但是传输的数据99M都堵在路上了，这不就是导致道路阻塞了么？这就需要另外一个设计<strong>拥塞避免</strong></p>\n<p><strong>流量控制的目的</strong></p>\n<p>如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。</p>\n<p>为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。</p>\n<p>流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p>\n<p><strong>如何实现流量控制</strong></p>\n<p>由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。</p>\n<p>主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5faa3ef1f5a242d3a2a5f38a377611b9.png\"></p>\n<p><strong>流量控制引发的死锁</strong></p>\n<p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。</p>\n<p>但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p>\n<p>为了避免流量控制引发的死锁，TCP使用了<strong>持续计时器</strong>。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p><strong>为什么要进行拥塞控制</strong></p>\n<p>假设网络已经出现拥塞，如果不处理拥塞，那么延时增加，出现更多丢包，触发发送方重传数据，加剧拥塞情况，继续恶性循环直至网络瘫痪。</p>\n<p>拥塞控制与流量控制的适应场景和目的均不同。</p>\n<p>拥塞发生前，可避免流量过快增长拖垮网络；拥塞发生时，唯一的选择就是降低流量。</p>\n<p>主要使用4种算法完成拥塞控制：</p>\n<ol>\n<li>慢启动</li>\n<li>拥塞避免</li>\n<li>快重传算法</li>\n<li>快速恢复算法</li>\n</ol>\n<p>算法1、2适用于拥塞发生前，算法3适用于拥塞发生时，算法4适用于拥塞解决后（相当于拥塞发生前）。</p>\n<p><strong>rwnd与cwnd</strong></p>\n<p><code>rwnd</code>（Receiver Window，接收者窗口）与<code>cwnd</code>（Congestion Window，拥塞窗口）：</p>\n<ul>\n<li><p>rwnd是用于流量控制的窗口大小，主要取决于接收方的处理速度，由接收方通知发送方被动调整。</p>\n</li>\n<li><p>cwnd是用于拥塞处理的窗口大小，取决于网络状况，由发送方探查网络主动调整。</p>\n</li>\n</ul>\n<p>同时考虑流量控制与拥塞处理，则发送方窗口的大小不超过<code>min&#123;rwnd, cwnd&#125;</code>。</p>\n<p><strong>慢启动算法</strong></p>\n<p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>\n<p>这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。</p>\n<p>一个传输轮次所经历的时间其实就是往返时间RTT，而且每经过一个传输轮次，拥塞窗口cwnd就加倍。</p>\n<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。</p>\n<blockquote>\n<p>ssthresh的用法如下：</p>\n</blockquote>\n<ul>\n<li><p>cwnd&lt;ssthresh时，使用慢开始算法。 </p>\n</li>\n<li><p>当cwnd&gt;ssthresh时，改用拥塞避免算法。 </p>\n</li>\n<li><p>当cwnd&#x3D;ssthresh时，慢开始与拥塞避免算法任意</p>\n</li>\n</ul>\n<p>注意，这里的慢并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要慢得多。</p>\n<p><strong>拥塞避免算法</strong></p>\n<p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>\n<p>这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多</p>\n<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。</p>\n<p>然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p>\n<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>\n<p><strong>整个拥塞控制的流程：</strong></p>\n<p>假定cwnd&#x3D;24时，网络出现超时（拥塞），则更新后的ssthresh&#x3D;12，cwnd重新设置为1，并执行慢开始算法。</p>\n<p>当cwnd&#x3D;12&#x3D;ssthresh时，改为执行拥塞避免算法</p>\n<p>注意：拥塞避免并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d7b6db2a7cf64645a98325c7be12c3d6.png\"></p>\n<p><strong>快重传算法</strong></p>\n<p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。</p>\n<p>快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</p>\n<p><strong>快恢复算法</strong></p>\n<p>快重传配合使用的还有快恢复算法，有以下两个要点：</p>\n<ul>\n<li><p>当发送方连续收到三个重复确认时，就把ssthresh门限减半（为了预防网络发生拥塞）。 </p>\n</li>\n<li><p>但是接下去并不执行慢开始算法</p>\n</li>\n</ul>\n<p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。</p>\n<p>所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。</p>\n<img src=\"https://img-blog.csdnimg.cn/a80c340fb68d4d4c8151a91b805851a9.png\" style=\"zoom:50%;\" />\n\n<h2 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h2><p>即套接字，是应用层 与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，表现为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）</p>\n<img src=\"https://img-blog.csdnimg.cn/b9e355824efb43a7a6da3435add24dd8.png\" style=\"zoom:50%;\" />\n\n<p><code>Socket</code>不是一种协议，而是一个编程调用接口（<code>API</code>），属于传输层（主要解决数据如何在网络中传输）</p>\n<p>对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信</p>\n<h1 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h1><p><strong>UDP协议特点</strong></p>\n<ul>\n<li><p>UDP是无连接的传输层协议； </p>\n</li>\n<li><p>UDP使用尽最大努力交付，不保证可靠交付； </p>\n</li>\n<li><p>UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界； </p>\n</li>\n<li><p>UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率； </p>\n</li>\n<li><p>UDP支持一对一　一对多　多对多的交互通信； </p>\n</li>\n<li><p>UDP的首部开销小，只有８字节</p>\n</li>\n</ul>\n<p><strong>TCP和UDP的区别</strong></p>\n<ul>\n<li><p>TCP是可靠传输，UDP是不可靠传输;</p>\n</li>\n<li><p>TCP面向连接，UDP无连接;</p>\n</li>\n<li><p>TCP传输数据有序，UDP不保证数据的有序性;</p>\n</li>\n<li><p>TCP不保存数据边界，UDP保留数据边界;</p>\n</li>\n<li><p>TCP传输速度相对UDP较慢;</p>\n</li>\n<li><p>TCP有流量控制和拥塞控制，UDP没有;</p>\n</li>\n<li><p>TCP是重量级协议，UDP是轻量级协议;</p>\n</li>\n<li><p>TCP首部较长20字节，UDP首部较短８字节;</p>\n</li>\n</ul>\n<p><strong>基于TCP和UDP的常用协议</strong></p>\n<p>HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。</p>\n<p>TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议</p>\n<p>当我发送的UDP包到达目标机器后，发现MAC地址匹配，于是就取下来，将剩下的包传给处理IP层的代码。</p>\n<p>把IP头取下来，发现目标IP匹配，接下来呢？这里面的数据包是给谁呢？</p>\n<p>发送的时候，我知道我发的是一个UDP的包，收到的那台机器咋知道的呢？</p>\n<p>所以在IP头里面有个8位协议，这里会存放，数据里面到底是TCP还是UDP，当然这里是UDP。</p>\n<p>于是，如果我们知道UDP头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？</p>\n<p>处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？</p>\n<p>无论应用程序写的使用TCP传数据，还是UDP传数据，都要监听一个端口。</p>\n<p>正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？</p>\n<p>所以，按理说，无论是TCP还是UDP包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。</p>\n<p><strong>报文段</strong></p>\n<p>UDP的报文段共有2个字段：数据字段 + 首部字段</p>\n<img src=\"https://img-blog.csdnimg.cn/f700d8237cd24158946981d95d51882b.png\" style=\"zoom:50%;\" />\n\n<p><strong>UDP报文中每个字段的含义如下：</strong></p>\n<ul>\n<li>源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口，接收端的应用程序利用这个字段的值作为发送响应的目的地址，这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中，如果不写入端口号，则把这个字段设置为 0，这样，接收端的应用程序就不能发送响应了。</li>\n<li>目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。</li>\n<li>长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度，因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。</li>\n<li>校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"TCP\"><a href=\"#TCP\" class=\"headerlink\" title=\"TCP\"></a>TCP</h1><p>TCP是一个传输层协议，提供可靠传输，支持全双工，是一个连接导向的协议。</p>\n<p><strong>双工&#x2F;单工</strong></p>\n<p>在任何一个时刻，如果数据只能单向发送，就是单工。</p>\n<p>如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫作半双工；半双工需要至少 1 条线路。</p>\n<p>如果任何时刻数据都可以双向收发，这就是全双工，全双工需要大于 1 条线路。</p>\n<p>TCP 是一个双工协议，数据任何时候都可以双向传输。</p>\n<p>这就意味着客户端和服务端可以平等地发送、接收信息。</p>\n<p><strong>TCP协议的主要特点</strong></p>\n<ul>\n<li><p>TCP是面向连接的运输层协议；所谓面向连接就是双方传输数据之前，必须先建立一条通道，例如三次握手就是建议通道的一个过程，而四次挥手则是结束销毁通道的一个其中过程。 </p>\n</li>\n<li><p>每一条TCP连接只能有两个端点（即两个套接字），只能是点对点的； </p>\n</li>\n<li><p>TCP提供可靠的传输服务。传送的数据无差错、不丢失、不重复、按序到达； </p>\n</li>\n<li><p>TCP提供全双工通信。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存； </p>\n</li>\n<li><p>面向字节流。虽然应用程序与TCP交互是一次一个大小不等的数据块，但TCP把这些数据看成一连串无结构的字节流，它不保证接收方收到的数据块和发送方发送的数据块具有对应大小关系，例如，发送方应用程序交给发送方的TCP10个数据块，接收方的TCP可能只用收到的4个数据块字节流交付给上层的应用程序</p>\n</li>\n</ul>\n<p><strong>TCP的可靠性原理</strong></p>\n<p>可靠传输有如下两个特点:</p>\n<ol>\n<li>传输信道无差错,保证传输数据正确; </li>\n<li>不管发送方以多快的速度发送数据,接收方总是来得及处理收到的数据;</li>\n</ol>\n<p>首先，采用三次握手来建立TCP连接，四次握手来释放TCP连接，从而保证建立的传输信道是可靠的。</p>\n<p>其次，TCP采用了连续ARQ协议（回退N(Go-back-N)；超时自动重传）来保证数据传输的正确性，使用滑动窗口协议来保证接方能够及时处理所接收到的数据，进行流量控制。</p>\n<p>最后，TCP使用慢开始、拥塞避免、快重传和快恢复来进行拥塞控制，避免网络拥塞。</p>\n<p><strong>报文段</strong></p>\n<p>TCP虽面向字节流，但传送的数据单元为报文段</p>\n<p>报文段 &#x3D; 首部 + 数据2部分</p>\n<p>TCP的全部功能体现在它首部中各字段的作用</p>\n<blockquote>\n<ol>\n<li>首部前20个字符固定、后面有4n个字节是根据需而增加的选项</li>\n<li>故 TCP首部最小长度 &#x3D; 20字节</li>\n</ol>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/34ef681324ee4834a03a1a894c9ebd36.png\" style=\"zoom:50%;\" />\n\n<p><strong>端口</strong>：</p>\n<p>源端口号和目地端口各占16位两个字节，也就是端口的范围是<code>2^16=65535</code></p>\n<p>另外1024以下是系统保留的，从1024-65535是用户使用的端口范围</p>\n<p><strong>seq序号</strong>：占4字节，TCP连接中传送的字节流中的每个字节都按顺序编号。</p>\n<p>例如：一段报文的序号字段值是107，携带的数据是100个字段，下一个报文段序号从107+100&#x3D;207开始。</p>\n<p><strong>ack确认号</strong>：4个字节，是期望收到对方下一个报文段的第一个数据字节的序号。</p>\n<p>例如：B收到A发送的报文，其序号字段是301，数据长度是200字节，表明B正确收到A发送的到序号500为止的数据（301+200-1&#x3D;500），B期望收到A下一个数据序号是501，B发送给A的确认报文段中把ack确认号置为501。</p>\n<p><strong>数据偏移</strong>：头部有可选字段，长度不固定，指出TCP报文段的数据起始处距离报文段的起始处有多远。</p>\n<p><strong>保留</strong>：保留今后使用的，被标为1。</p>\n<p><strong>控制位</strong>：由8个标志位组成。每个标志位表示一个控制功能。</p>\n<p>其中主要的6个：</p>\n<ul>\n<li><p><strong>URG紧急指针标志</strong>，为1表示紧急指针有效，为0忽略紧急指针。</p>\n</li>\n<li><p><strong>ACK确认序号标志</strong>，为1表示确认号有效，为0表示报文不含确认信息，忽略确认号字段，上面的确认号是否有效就是通过该标识控制的。</p>\n</li>\n<li><p><strong>PSH标志</strong>，为1表示带有push标志的数据，指示接收方在接收到该报文段以后，应尽快将该报文段交给应用程序，而不是在缓冲区排队。</p>\n</li>\n<li><p><strong>RST重置连接标志</strong>，重置因为主机崩溃或其他原因而出现错误的连接，或用于拒绝非法的报文段或非法的连接。</p>\n</li>\n<li><p><strong>SYN同步序号</strong>，同步序号，用于建立连接过程，在连接请求中，SYN&#x3D;1和ACK&#x3D;0表示该数据段没有使用捎带的确认域，而连接应答捎带一个确认，即SYN&#x3D;1和ACK&#x3D;1。。</p>\n</li>\n<li><p><strong>FIN终止标志</strong>，用于释放连接，为1时表示发送方没有发送了。</p>\n</li>\n</ul>\n<p><strong>窗口</strong>：滑动窗口大小，用来告知发送端接收端缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。</p>\n<p><strong>校验和</strong>：奇偶校验，此校验和是对整个的TCP报文段（包括TCP头部和TCP数据），以16位进行计算所得，由发送端计算和存储，接收端进行验证。</p>\n<p><strong>紧急指针</strong>：只有控制位中的URG为1时才有效，指出本报文段中的紧急数据的字节数。</p>\n<p><strong>选项</strong>：其长度可变，定义其他的可选参数。</p>\n<h2 id=\"粘包与拆包\"><a href=\"#粘包与拆包\" class=\"headerlink\" title=\"粘包与拆包\"></a>粘包与拆包</h2><p>TCP是面向字节流的协议，把上层应用层的数据看成字节流，所以它发送的不是固定大小的数据包，TCP协议也没有字段说明发送数据包的大小。</p>\n<p>而且TCP不保证接受方应用程序收到的数据块和发送应用程序发送的数据块具有对应的大小关系</p>\n<p>比如发送方应用程序交给发送方<code>TCP</code> 10个数据块，接受方TCP可能只用了4个数据块就完整的把接受到的字节流交给了上层应用程序。</p>\n<p>TCP底层并不了解上层业务数据的具体含义，它会根据TCP缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被TCP拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的TCP粘包和拆包问题</p>\n<p><strong>TCP粘包&#x2F;拆包解决策略</strong></p>\n<p>由于TCP无法理解上一层的业务数据特点，所以TCP是无法保证发送的数据包不发生粘包和拆包，这个问题只能通过上层的协议栈设计来解决，解决思路有一下几种：</p>\n<ul>\n<li><p>消息定长：每个发送的数据包大小固定，比如100字节，不足100字节的用空格补充，接受方取数据的时候根据这个长度来读取数据</p>\n</li>\n<li><p>消息末尾增加换行符来表示一条完整的消息：接收方读取的时候根据换行符来判断是否是一条完整的消息，如果消息的内容也包含换行符，那么这种方式就不合适了。</p>\n</li>\n<li><p>将消息分为消息头和消息尾两部分，消息头指定数据长度，根据消息长度来读取完整的消息，例如UDP协议是这么设计的，用两个字节来表示消息长度，所以UDP不存在粘包和拆包问题。</p>\n</li>\n</ul>\n<h2 id=\"三次握手\"><a href=\"#三次握手\" class=\"headerlink\" title=\"三次握手\"></a>三次握手</h2><img src=\"https://img-blog.csdnimg.cn/acbb8bc0f2b24d0dbc7a1dd2f6e212be.png\" style=\"zoom:50%;\" />\n\n<p><strong>第一次握手</strong>：</p>\n<p>客户端将TCP报文标志位<code>SYN</code>置为1，随机产生一个序号值<code>seq=J</code>，保存在TCP首部的序列号字段里，指明客户端打算连接的服务器的端口，并将该数据包发送给服务器端，发送完毕后，客户端进入<code>SYN_SENT</code>状态，等待服务器端确认。</p>\n<p><strong>第二次握手</strong>：</p>\n<p>服务器端收到数据包后由标志位<code>SYN=1</code>知道客户端请求建立连接，服务器端将TCP报文标志位SYN和ACK都置为1，<code>ack=J+1</code>，随机产生一个序号值<code>seq=K</code>，并将该数据包发送给客户端以确认连接请求，服务器端进入<code>SYN_RCVD</code>状态。</p>\n<p><strong>第三次握手</strong>：</p>\n<p>客户端收到确认后，检查ack是否为<code>J+1</code>，ACK是否为1，如果正确则将标志位ACK置为1，<code>ack=K+1</code>，并将该数据包发送给服务器端，服务器端检查ack是否为<code>K+1</code>，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入<code>ESTABLISHED</code>状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>\n<p><strong>上面写的ack和ACK，不是同一个概念：</strong></p>\n<ul>\n<li><p>小写的ack代表的是头部的确认号Acknowledge number， 缩写ack，是对上一个包的序号进行确认的号，<code>ack=seq+1</code>。</p>\n</li>\n<li><p>大写的ACK，则是我们上面说的TCP首部的标志位，用于标志的TCP包是否对上一个包进行了确认操作，如果确认了，则把ACK标志位设置成1。</p>\n</li>\n</ul>\n<p><strong>TCP为什么三次握手而不是两次握手</strong></p>\n<ul>\n<li><p>为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤</p>\n</li>\n<li><p>如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认</p>\n</li>\n</ul>\n<p><strong>《计算机网络》中是这样说的：</strong></p>\n<p>为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p>\n<blockquote>\n<p>在书中同时举了一个例子，如下：</p>\n</blockquote>\n<p>假如<code>client</code>发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达<code>server</code>，本来这是一个早已失效的报文段，但<code>server</code>收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。</p>\n<p>于是就向client发出确认报文段，同意建立连接，假设不采用<strong>三次握手</strong>，那么只要server发出确认，新的连接就建立了，由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。</p>\n<p>但server却以为新的连接已经建立，并一直等待<code>client</code>发来数据，这样，server的很多资源就白白浪费掉了。</p>\n<p>采用<strong>三次握手</strong>的办法可以防止上述现象发生，例如刚才那种情况，client不会向<code>server</code>的确认发出确认，server由于收不到确认，就知道client并没有要求建立连接。</p>\n<p><strong>什么是半连接队列</strong></p>\n<p>服务器第一次收到客户端的 SYN 之后，就会处于 <code>SYN_RCVD</code>状态，此时双方还没有完全建立其连接，服务器会把此种状态下请求连接放在一个队列里，我们把这种队列称之为<strong>半连接队列</strong>。</p>\n<p>当然还有一个<strong>全连接队列</strong>，就是已经完成三次握手，建立起连接的就会放在全连接队列中。如果队列满了就有可能会出现丢包现象。</p>\n<p>补充一点关于<strong>SYN-ACK 重传次数</strong>的问题：</p>\n<p>服务器发送完SYN－ACK包，如果未收到客户确认包，服务器进行首次重传，等待一段时间仍未收到客户确认包，进行第二次重传，如果重传次数超过系统规定的最大重传次数，系统将该连接信息从半连接队列中删除。</p>\n<p><strong>三次握手过程中可以携带数据吗</strong></p>\n<p>其实第三次握手的时候，是可以携带数据的，也就是说，第一次、第二次握手不可以携带数据，而第三次握手是可以携带数据的。</p>\n<p>假如第一次握手可以携带数据的话，如果有人要恶意攻击服务器，那他每次都在第一次握手中的 SYN 报文中放入大量的数据，因为攻击者根本就不理服务器的接收、发送能力是否正常，然后疯狂着重复发 SYN 报文的话，这会让服务器花费很多时间、内存空间来接收这些报文。也就是说，第一次握手可以放数据的话，其中一个简单的原因就是会让服务器更加容易受到攻击了。</p>\n<p>而对于第三次的话，此时客户端已经处于 established 状态，也就是说，对于客户端来说，他已经建立起连接了，并且也已经知道服务器的接收、发送能力是正常的了，所以能携带数据没啥毛病。</p>\n<h2 id=\"四次挥手\"><a href=\"#四次挥手\" class=\"headerlink\" title=\"四次挥手\"></a>四次挥手</h2><img src=\"https://img-blog.csdnimg.cn/faa54ef4df1749139f4ee2dd5d002562.png\" style=\"zoom:50%;\" />\n\n<p>挥手请求可以是Client端，也可以是Server端发起的，我们假设是Client端发起：</p>\n<ul>\n<li><p>第一次挥手： Client端发起挥手请求，向Server端发送标志位是FIN报文段，设置序列号seq，此时，Client端进入<code>FIN_WAIT_1</code>状态，这表示Client端没有数据要发送给Server端了。</p>\n</li>\n<li><p>第二次挥手：Server端收到了Client端发送的FIN报文段，向Client端返回一个标志位是ACK的报文段，ack设为seq加1，Client端进入<code>FIN_WAIT_2</code>状态，Server端告诉Client端，我确认并同意你的关闭请求。</p>\n</li>\n<li><p>第三次挥手： Server端向Client端发送标志位是FIN的报文段，请求关闭连接，同时Client端进入<code>LAST_ACK</code>状态。</p>\n</li>\n<li><p>第四次挥手 ： Client端收到Server端发送的FIN报文段，向Server端发送标志位是ACK的报文段，然后Client端进入<code>TIME_WAIT</code>状态，Server端收到Client端的ACK报文段以后，就关闭连接，此时，Client端等待2MSL的时间后依然没有收到回复，则证明Server端已正常关闭，那好，Client端也可以关闭连接了。</p>\n</li>\n</ul>\n<p><strong>为什么连接的时候是三次握手，关闭的时候却是四次握手？</strong></p>\n<p>建立连接时因为当Server端收到Client端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。所以建立连接只需要三次握手。</p>\n<p>由于TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议，TCP是全双工模式。</p>\n<p>这就意味着，关闭连接时，当Client端发出FIN报文段时，只是表示Client端告诉Server端数据已经发送完毕了。当Server端收到FIN报文并返回ACK报文段，表示它已经知道Client端没有数据发送了，但是Server端还是可以发送数据到Client端的，所以Server很可能并不会立即关闭SOCKET，直到Server端把数据也发送完毕。</p>\n<p>当Server端也发送了FIN报文段时，这个时候就表示Server端也没有数据要发送了，就会告诉Client端，我也没有数据要发送了，之后彼此就会愉快的中断这次TCP连接。</p>\n<p><strong>为什么TIME_WAIT要等待2MSL？</strong></p>\n<p>MSL：报文段最大生存时间，它是任何报文段被丢弃前在网络内的最长时间。</p>\n<p>有以下两个原因：</p>\n<ul>\n<li>第一点：保证TCP协议的全双工连接能够可靠关闭：<br>由于IP协议的不可靠性或者是其它网络原因，导致了Server端没有收到Client端的ACK报文，那么Server端就会在超时之后重新发送FIN，如果此时Client端的连接已经关闭处于<code>CLOESD</code>状态，那么重发的FIN就找不到对应的连接了，从而导致连接错乱，所以，Client端发送完最后的ACK不能直接进入<code>CLOSED</code>状态，而要保持<code>TIME_WAIT</code>，当再次收到FIN的时候，能够保证对方收到ACK，最后正确关闭连接。 </li>\n<li>第二点：保证这次连接的重复数据段从网络中消失<br>如果Client端发送最后的ACK直接进入<code>CLOSED</code>状态，然后又再向Server端发起一个新连接，这时不能保证新连接的与刚关闭的连接的端口号是不同的，也就是新连接和老连接的端口号可能一样了，那么就可能出现问题：如果前一次的连接某些数据滞留在网络中，这些延迟数据在建立新连接后到达Client端，由于新老连接的端口号和IP都一样，TCP协议就认为延迟数据是属于新连接的，新连接就会接收到脏数据，这样就会导致数据包混乱，所以TCP连接需要在<code>TIME_WAIT</code>状态等待2倍MSL，才能保证本次连接的所有数据在网络中消失。</li>\n</ul>\n<h2 id=\"流量控制\"><a href=\"#流量控制\" class=\"headerlink\" title=\"流量控制\"></a>流量控制</h2><p><strong>RTT和RTO</strong></p>\n<p>RTT：发送一个数据包到收到对应的ACK，所花费的时间</p>\n<p>RTO：重传时间间隔（TCP在发送一个数据包后会启动一个重传定时器，RTO即定时器的重传时间）</p>\n<p>开始预先算一个定时器时间，如果回复ACK，重传定时器就自动失效，即不需要重传；如果没有回复ACK，RTO定时器时间就到了，重传。</p>\n<p>RTO是本次发送当前数据包所预估的超时时间，RTO不是固定写死的配置，是经过RTT计算出来的。</p>\n<p><strong>滑动窗口</strong></p>\n<p>TCP的滑动窗口主要有两个作用：</p>\n<ol>\n<li><p>保证TCP的可靠性</p>\n</li>\n<li><p>保证TCP的流控特性</p>\n</li>\n</ol>\n<p>TCP报文头有个字段叫Window，用于接收方通知发送方自己还有多少缓存区可以接收数据，发送方根据接收方的处理能力来发送数据，不会导致接收方处理不过来，这便是流量控制。</p>\n<p>发送方都维持了一个连续的允许发送的帧的序号，称为发送窗口；同时，接收方也维持了一个连续的允许接收的帧的序号，称为接收窗口。</p>\n<p>发送窗口和接收窗口的序号的上下界不一定要一样，甚至大小也可以不同。</p>\n<p>不同的滑动窗口协议窗口大小一般不同。</p>\n<p>发送方窗口内的序列号代表了那些已经被发送，但是还没有被确认的帧，或者是那些可以被发送的帧</p>\n<img src=\"https://img-blog.csdnimg.cn/524ceb06725142e5b2c4a3211020a06e.png\" style=\"zoom:50%;\" />\n\n<p>滑动窗口由四部分组成每个字节的数据都有唯一顺序的编码，随着时间发展，未确认部分与可以发送数据包编码部分向右移动，形式滑动窗口</p>\n<ol>\n<li><code>绿色</code>：发送成功并已经ACK确认的数据</li>\n<li><code>黄色</code>：发送成功等待ACK确认的数据(占用滑动窗口大小)</li>\n<li><code>紫色</code>：滑动窗口剩余大小可以发送的字节数量(滑动窗口可用大小)</li>\n<li><code>灰色</code>：后续数据编码</li>\n</ol>\n<p>接收窗口的大小就是滑动窗口的最大值，数据传输过程中滑动窗口的可用大小是动态变化的。</p>\n<p>但是还有这么一点，滑动窗口的设计仅仅是考虑到了处理方的处理能力，但是没有考虑到道路的通畅问题</p>\n<p>就好像服务端可以处理100M数据，但是传输的数据99M都堵在路上了，这不就是导致道路阻塞了么？这就需要另外一个设计<strong>拥塞避免</strong></p>\n<p><strong>流量控制的目的</strong></p>\n<p>如果发送者发送数据过快，接收者来不及接收，那么就会有分组丢失。</p>\n<p>为了避免分组丢失，控制发送者的发送速度，使得接收者来得及接收，这就是流量控制。</p>\n<p>流量控制根本目的是防止分组丢失，它是构成TCP可靠性的一方面。</p>\n<p><strong>如何实现流量控制</strong></p>\n<p>由滑动窗口协议（连续ARQ协议）实现。滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制。</p>\n<p>主要的方式就是接收方返回的 ACK 中会包含自己的接收窗口的大小，并且利用大小来控制发送方的数据发送。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/5faa3ef1f5a242d3a2a5f38a377611b9.png\"></p>\n<p><strong>流量控制引发的死锁</strong></p>\n<p>当发送者收到了一个窗口为0的应答，发送者便停止发送，等待接收者的下一个应答。</p>\n<p>但是如果这个窗口不为0的应答在传输过程丢失，发送者一直等待下去，而接收者以为发送者已经收到该应答，等待接收新数据，这样双方就相互等待，从而产生死锁。</p>\n<p>为了避免流量控制引发的死锁，TCP使用了<strong>持续计时器</strong>。每当发送者收到一个零窗口的应答后就启动该计时器。时间一到便主动发送报文询问接收者的窗口大小。若接收者仍然返回零窗口，则重置该计时器继续等待；若窗口不为0，则表示应答报文丢失了，此时重置发送窗口后开始发送，这样就避免了死锁的产生。</p>\n<h2 id=\"拥塞控制\"><a href=\"#拥塞控制\" class=\"headerlink\" title=\"拥塞控制\"></a>拥塞控制</h2><p><strong>为什么要进行拥塞控制</strong></p>\n<p>假设网络已经出现拥塞，如果不处理拥塞，那么延时增加，出现更多丢包，触发发送方重传数据，加剧拥塞情况，继续恶性循环直至网络瘫痪。</p>\n<p>拥塞控制与流量控制的适应场景和目的均不同。</p>\n<p>拥塞发生前，可避免流量过快增长拖垮网络；拥塞发生时，唯一的选择就是降低流量。</p>\n<p>主要使用4种算法完成拥塞控制：</p>\n<ol>\n<li>慢启动</li>\n<li>拥塞避免</li>\n<li>快重传算法</li>\n<li>快速恢复算法</li>\n</ol>\n<p>算法1、2适用于拥塞发生前，算法3适用于拥塞发生时，算法4适用于拥塞解决后（相当于拥塞发生前）。</p>\n<p><strong>rwnd与cwnd</strong></p>\n<p><code>rwnd</code>（Receiver Window，接收者窗口）与<code>cwnd</code>（Congestion Window，拥塞窗口）：</p>\n<ul>\n<li><p>rwnd是用于流量控制的窗口大小，主要取决于接收方的处理速度，由接收方通知发送方被动调整。</p>\n</li>\n<li><p>cwnd是用于拥塞处理的窗口大小，取决于网络状况，由发送方探查网络主动调整。</p>\n</li>\n</ul>\n<p>同时考虑流量控制与拥塞处理，则发送方窗口的大小不超过<code>min&#123;rwnd, cwnd&#125;</code>。</p>\n<p><strong>慢启动算法</strong></p>\n<p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>\n<p>这里用报文段的个数作为拥塞窗口的大小举例说明慢开始算法，实际的拥塞窗口大小是以字节为单位的。</p>\n<p>一个传输轮次所经历的时间其实就是往返时间RTT，而且每经过一个传输轮次，拥塞窗口cwnd就加倍。</p>\n<p>为了防止cwnd增长过大引起网络拥塞，还需设置一个慢开始门限ssthresh状态变量。</p>\n<blockquote>\n<p>ssthresh的用法如下：</p>\n</blockquote>\n<ul>\n<li><p>cwnd&lt;ssthresh时，使用慢开始算法。 </p>\n</li>\n<li><p>当cwnd&gt;ssthresh时，改用拥塞避免算法。 </p>\n</li>\n<li><p>当cwnd&#x3D;ssthresh时，慢开始与拥塞避免算法任意</p>\n</li>\n</ul>\n<p>注意，这里的慢并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，然后逐渐增大，这当然比按照大的cwnd一下子把许多报文段突然注入到网络中要慢得多。</p>\n<p><strong>拥塞避免算法</strong></p>\n<p>让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>\n<p>这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多</p>\n<p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有按时收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限ssthresh设置为出现拥塞时的发送窗口大小的一半（但不能小于2）。</p>\n<p>然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。</p>\n<p>这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>\n<p><strong>整个拥塞控制的流程：</strong></p>\n<p>假定cwnd&#x3D;24时，网络出现超时（拥塞），则更新后的ssthresh&#x3D;12，cwnd重新设置为1，并执行慢开始算法。</p>\n<p>当cwnd&#x3D;12&#x3D;ssthresh时，改为执行拥塞避免算法</p>\n<p>注意：拥塞避免并非完全能够避免了阻塞，而是使网络比较不容易出现拥塞。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/d7b6db2a7cf64645a98325c7be12c3d6.png\"></p>\n<p><strong>快重传算法</strong></p>\n<p>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方，可提高网络吞吐量约20%）而不要等到自己发送数据时捎带确认。</p>\n<p>快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期</p>\n<p><strong>快恢复算法</strong></p>\n<p>快重传配合使用的还有快恢复算法，有以下两个要点：</p>\n<ul>\n<li><p>当发送方连续收到三个重复确认时，就把ssthresh门限减半（为了预防网络发生拥塞）。 </p>\n</li>\n<li><p>但是接下去并不执行慢开始算法</p>\n</li>\n</ul>\n<p>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。</p>\n<p>所以此时不执行慢开始算法，而是将cwnd设置为ssthresh减半后的值，然后执行拥塞避免算法，使cwnd缓慢增大。</p>\n<img src=\"https://img-blog.csdnimg.cn/a80c340fb68d4d4c8151a91b805851a9.png\" style=\"zoom:50%;\" />\n\n<h2 id=\"Socket\"><a href=\"#Socket\" class=\"headerlink\" title=\"Socket\"></a>Socket</h2><p>即套接字，是应用层 与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，表现为一个封装了 TCP &#x2F; IP协议族 的编程接口（API）</p>\n<img src=\"https://img-blog.csdnimg.cn/b9e355824efb43a7a6da3435add24dd8.png\" style=\"zoom:50%;\" />\n\n<p><code>Socket</code>不是一种协议，而是一个编程调用接口（<code>API</code>），属于传输层（主要解决数据如何在网络中传输）</p>\n<p>对用户来说，只需调用Socket去组织数据，以符合指定的协议，即可通信</p>\n<h1 id=\"UDP\"><a href=\"#UDP\" class=\"headerlink\" title=\"UDP\"></a>UDP</h1><p><strong>UDP协议特点</strong></p>\n<ul>\n<li><p>UDP是无连接的传输层协议； </p>\n</li>\n<li><p>UDP使用尽最大努力交付，不保证可靠交付； </p>\n</li>\n<li><p>UDP是面向报文的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界； </p>\n</li>\n<li><p>UDP没有拥塞控制，因此即使网络出现拥塞也不会降低发送速率； </p>\n</li>\n<li><p>UDP支持一对一　一对多　多对多的交互通信； </p>\n</li>\n<li><p>UDP的首部开销小，只有８字节</p>\n</li>\n</ul>\n<p><strong>TCP和UDP的区别</strong></p>\n<ul>\n<li><p>TCP是可靠传输，UDP是不可靠传输;</p>\n</li>\n<li><p>TCP面向连接，UDP无连接;</p>\n</li>\n<li><p>TCP传输数据有序，UDP不保证数据的有序性;</p>\n</li>\n<li><p>TCP不保存数据边界，UDP保留数据边界;</p>\n</li>\n<li><p>TCP传输速度相对UDP较慢;</p>\n</li>\n<li><p>TCP有流量控制和拥塞控制，UDP没有;</p>\n</li>\n<li><p>TCP是重量级协议，UDP是轻量级协议;</p>\n</li>\n<li><p>TCP首部较长20字节，UDP首部较短８字节;</p>\n</li>\n</ul>\n<p><strong>基于TCP和UDP的常用协议</strong></p>\n<p>HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。</p>\n<p>TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议</p>\n<p>当我发送的UDP包到达目标机器后，发现MAC地址匹配，于是就取下来，将剩下的包传给处理IP层的代码。</p>\n<p>把IP头取下来，发现目标IP匹配，接下来呢？这里面的数据包是给谁呢？</p>\n<p>发送的时候，我知道我发的是一个UDP的包，收到的那台机器咋知道的呢？</p>\n<p>所以在IP头里面有个8位协议，这里会存放，数据里面到底是TCP还是UDP，当然这里是UDP。</p>\n<p>于是，如果我们知道UDP头的格式，就能从数据里面，将它解析出来。解析出来以后呢？数据给谁处理呢？</p>\n<p>处理完传输层的事情，内核的事情基本就干完了，里面的数据应该交给应用程序自己去处理，可是一台机器上跑着这么多的应用程序，应该给谁呢？</p>\n<p>无论应用程序写的使用TCP传数据，还是UDP传数据，都要监听一个端口。</p>\n<p>正是这个端口，用来区分应用程序，要不说端口不能冲突呢。两个应用监听一个端口，到时候包给谁呀？</p>\n<p>所以，按理说，无论是TCP还是UDP包头里面应该有端口号，根据端口号，将数据交给相应的应用程序。</p>\n<p><strong>报文段</strong></p>\n<p>UDP的报文段共有2个字段：数据字段 + 首部字段</p>\n<img src=\"https://img-blog.csdnimg.cn/f700d8237cd24158946981d95d51882b.png\" style=\"zoom:50%;\" />\n\n<p><strong>UDP报文中每个字段的含义如下：</strong></p>\n<ul>\n<li>源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口，接收端的应用程序利用这个字段的值作为发送响应的目的地址，这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中，如果不写入端口号，则把这个字段设置为 0，这样，接收端的应用程序就不能发送响应了。</li>\n<li>目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。</li>\n<li>长度：该字段占据 16 位，表示 UDP 数据报长度，包含 UDP 报文头和 UDP 数据长度，因为 UDP 报文头长度是 8 个字节，所以这个值最小为 8。</li>\n<li>校验值：该字段占据 16 位，可以检验数据在传输过程中是否被损坏。</li>\n</ul>\n"},{"title":"网络基础知识","_content":"\n# 协议\n\n**协议定义：**\n\n计算机与计算机之间通过网络实现通信事先达成的一种约定。\n\n这种约定使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。\n\n反之，如果使用的协议不同，就无法通信。\n\n> （举例人与人之间对话，汉语和英语当作协议，聊天当作通信，说话的内容当作数据，只会汉语和只会英语的人就无法通信）\n\n![](https://img-blog.csdnimg.cn/5b46d323da8645e18eb9ae23055815f9.png)\n\n**分组交换：**\n\n将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。\n\n这里所说的包，就如同我们平常在邮局里见到的邮包。\n\n> 分组交换就是将大数据分装为一个个这样的邮包交给对方。\n\n# OSI七层模型\n\n<img src=\"https://img-blog.csdnimg.cn/cec1f2d82bc54785a4ed03241da45f6c.png\" style=\"zoom:25%;\" />\n\n| 层级 | 分层名称   | 功能                                     |\n| ---- | ---------- | ---------------------------------------- |\n| 7    | 应用层     | 针对特定应用的协议                       |\n| 6    | 表示层     | 设备固有数据格式和网络标准数据格式的转换 |\n| 5    | 会话层     | 通信管理                                 |\n| 4    | 传输层     | 管理两个节点之间的数据传输               |\n| 3    | 网络层     | 地址管理和路由选择                       |\n| 2    | 数据链路层 | 互连设备之间传送和识别数据帧             |\n| 1    | 物理层     | 比特流与电子信号之间的切换               |\n\n**7层通信实例：**\n\n假设主机A的用户A要给主机B的用户B发送一封电子邮件，邮件内容为早上好：\n\n<img src=\"https://img-blog.csdnimg.cn/b01ed91b7a8e4f0bad03c3fa84f90254.png\" style=\"zoom:25%;\" />\n\n发送方从第7层、第6层到第1层由上至下按照顺序传输数据，而接收端则从第1层、第2层到第7层由下至上向每个上一级分层传输数据。\n\n* 每个分层上，在处理由上一层传过来的数据时可以附上当前分层的协议所必须的首部信息。\n\n* 然后接收端对收到的数据进行数据首部与内容的分离，再转发给上一分层，并最终将发送端的数据恢复为原装。\n\n* 应用层：目标地址为B，发件人为用户A，邮件内容为早上好\n\n* 表示层：将数据（即邮件内容早上好）从主机特有的格式转换为网络标准传输格式\n\n* 会话层：决定采用哪个连接发送。假设用户A新建了5封电子邮件准备发给B，这5封邮件的发送顺序可以有很多种。可以每发一封邮件时建立一次连接，随后断开；还可以建立一次连接连续发送5次；还可以同时建立5个连接，同时发送。决定采用何种连接方式是会话层的主要责任。\n\n* 传输层：确立连接与断开连接重发。例子中的数据早上好可能因为某些原因导致数据被破坏，或者网络异常导致只有部分数据到达目的地址；用户B最后只收到早上这部分数据。此时用户A就需要重发，保证数据传输的可靠性就是传输层的一个重要作用。然而将数据传输给对端的处理是由网络层完成的。\n\n* 网络层：在网络与网络互相互连接的环境中，将数据从发送端主机发送到接收端主机。\n* 数据链路层：在通过（物理的）传输介质互连的设备间进行数据处理。\n* 物理层：将数据的0、1转换为电压和脉冲光传输给物理的传输介质，相互直连的设备之间使用MAC地址（采用MAC地址是为了识别连接到同一传输介质上的设备）进行传输。\n\n> 网络层与数据链路层都是基于目标地址将数据发送给接收端的，但网络层负责将整个数据发送给最终目标地址，而数据链路层只负责发送一个分段内的数据。\n\n**物理层**\n\n首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。\n\n* 物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。\n\n主要作用是传输比特流（`0101`二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。\n\n* 这层数据叫做比特。**网卡工作在这层**。\n\n> 集线器\n\n这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。\n\n* 它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。\n\n这种组网的方法，对一个宿舍来说没有问题，但是一旦机器数目增多，问题就出现了。\n\n* 因为Hub是广播的，不管某个接口是否需要，所有的Bit都会被发送出去，然后让主机来判断是不是需要。\n\n因为每个口都只连接一台电脑，这台电脑又不怎么换IP和MAC地址，只要记住这台电脑的MAC地址，如果目标MAC地址不是这台电脑的，这个口就不用转发了。\n\n> 怎么知道目标MAC地址是否就是连接某个口的电脑的MAC地址呢？\n\n这就需要一个能把MAC头拿下来，检查一下目标MAC地址，然后根据策略转发的设备，这个设备显然是个二层设备，我们称为**交换机**。\n\n> 交换机怎么知道每个口的电脑的MAC地址呢？这需要交换机会学习。\n\n一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候，一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。\n\n但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1是来自一个明确的口。\n\n以后有包的目的地址是MAC1的，直接发送到这个口就可以了。\n\n* 当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。\n\n* 当然，每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为**转发表**，是有一个过期时间的。\n\n有了交换机，一般来说，你接个几十台、上百台机器打游戏，应该没啥问题。你可以组个战队了。能上网了，就可以玩网游了。\n\n**数据链路层**\n\n在传输比特流的过程中，会产生错传、数据传输不完整的可能。\n\n* 数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。\n\n本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。\n\n* 该层负责物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。\n\n常见的协议有 `HDLC、PPP、SLIP`等\n\n数据链路层会将`0、1`序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）\n\n**网络层**\n\n随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。\n\n* 网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。\n\n网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。\n\n* 由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。\n\n此层的数据称之为数据包。本层需要关注的协议`TCP/IP`协议中的IP协议。\n\n网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 `IP、ICMP` 两个协议组成。\n\n网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。\n\n![](https://img-blog.csdnimg.cn/74f18ce814a84f34bfe492b76dfe6619.png)\n\n**传输层**\n\n随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（`Segement`）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。\n\n* 传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。\n\n传输层需要关注的协议有TCP/IP协议中的`TCP`协议和`UDP`协议。\n\n**会话层**\n\n自动收发包，自动寻址。\n\n* 会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 `ADSP、RPC` 等\n\n**表示层**\n\nLinux给WIndows发包，不同系统语法不一致，如exe不能在`Linux`下执行，shell不能在Windows不能直接运行。于是需要表示层。\n\n* 解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。\n\n它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有`ASCII、SSL/TLS` 等\n\n**应用层**\n\n规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。\n\n* 应用层旨在更**方便应用从网络中接收的数据**，重点关注`TCP/IP`协议中的HTTP协议\n\n**注意：**\n\n* 四层传输层数据被称作**段**（Segments）；\n\n* 三层网络层数据被称做**包**（Packages）；\n\n* 二层数据链路层时数据被称为**帧**（Frames）；\n\n* 一层物理层时数据被称为**比特流**（Bits）。\n\n# 网络设备\n\n| 设备             | 作用                             |\n| ---------------- | -------------------------------- |\n| 网卡             | 使计算机连网的设备               |\n| 中继器           | 从物理层上延长网络的设备         |\n| 网桥/2层交换机   | 从数据链路层上延长网络的设备     |\n| 路由器/3层交换机 | 通过网络层转化分组数据的设备     |\n| 4~7层交换机      | 处理传输层以上各层网络传输的设备 |\n| 网关             | 转换协议的设备                   |\n\n**交换机**\n\n> 交换机可以接入多台电脑\n\n每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑\n\n* 交换机就可以识别数据头部的 MAC 地址来区分不同的电脑\n\n* 交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去\n\n交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**\n\n**路由器**\n\n> 交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多\n\n但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项\n\n* 于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来\n\n局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接\n\n不同区域的局域网互联使用**路由器**\n\n> 那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？\n\n* 路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**\n\n它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发\n\n# 传输方式\n\n面向有连接：发送数据之前，需要在收发主机之间连接一条通信线路。类似于平常打电话。\n\n面向无连接：发送端可于任何时候自由发送数据，接收端不知道自己会在何时从哪里收到数据。所以接收端需要时常确认是否收到了数据。类似于人们去邮局寄包裹。\n\n> 电路交换：\n\n电路交换中交换机负责数据的中转处理。\n\n计算机之间发送数据时需要通过交换机与目标主机建立通信电路。**连接电路称为建立连接**。如果某条电路只是用来连接两台计算机的通信线路，这两台计算机是可以独占线路进行数据传输的；如果一条电路上连接了多台计算机，其他计算机只能等待独占电路的计算机收发信息完毕后才有机会使用电路。如果并发用户数超过交换机之间的通信线路数，通信无法实现。\n\n> 分组交换：\n\n让连接到通信线路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。\n\n这样所有的计算机就可以一齐收发数据，提高通信线路的利用率。\n\n<img src=\"https://img-blog.csdnimg.cn/23805b7f155446dd809b0af481a6e741.png\" style=\"zoom:25%;\" />\n\n> 分组交换过程：\n\n发送端计算机将数据分组发送给交换机（路由器），路由器收到这些分组数据以后缓存到自己的缓冲区，然后转发给目标表计算机。\n\n<img src=\"https://img-blog.csdnimg.cn/039bf48508074f499a2eaa06fe8588a0.png\" style=\"zoom:25%;\" />\n\n电路交换中，计算机间传输速度不变；分组交换中，由于网络拥堵，通信线路的速度可能有所不同。\n\n路由器的缓存饱和或溢出时，甚至出现分组数据丢失、无法发送到对端。\n\n**单薄、广播、多播、任播**\n\n<img src=\"https://img-blog.csdnimg.cn/b0442a9776144c22a93d0fc08d37d79b.png\" style=\"zoom:25%;\" />\n\n多播：与广播类似，也是将消息发给多个接收主机。但广播不需要限定接收端，而多播需要限定某一组主机作为接收端。\n\n任播：在特定的多台主机中选出一台作为接收端。任播与多播类似，都是面向特定的一群主机。但任播会从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。被选中的那台特定主机会返回一个单薄信号，随后发送端主机会只跟这台主机进行通信。","source":"_posts/图解TCP IP/网络基础知识.md","raw":"---\ntitle: 网络基础知识\ncategories: \n- 图解TCP IP\n---\n\n# 协议\n\n**协议定义：**\n\n计算机与计算机之间通过网络实现通信事先达成的一种约定。\n\n这种约定使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。\n\n反之，如果使用的协议不同，就无法通信。\n\n> （举例人与人之间对话，汉语和英语当作协议，聊天当作通信，说话的内容当作数据，只会汉语和只会英语的人就无法通信）\n\n![](https://img-blog.csdnimg.cn/5b46d323da8645e18eb9ae23055815f9.png)\n\n**分组交换：**\n\n将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。\n\n这里所说的包，就如同我们平常在邮局里见到的邮包。\n\n> 分组交换就是将大数据分装为一个个这样的邮包交给对方。\n\n# OSI七层模型\n\n<img src=\"https://img-blog.csdnimg.cn/cec1f2d82bc54785a4ed03241da45f6c.png\" style=\"zoom:25%;\" />\n\n| 层级 | 分层名称   | 功能                                     |\n| ---- | ---------- | ---------------------------------------- |\n| 7    | 应用层     | 针对特定应用的协议                       |\n| 6    | 表示层     | 设备固有数据格式和网络标准数据格式的转换 |\n| 5    | 会话层     | 通信管理                                 |\n| 4    | 传输层     | 管理两个节点之间的数据传输               |\n| 3    | 网络层     | 地址管理和路由选择                       |\n| 2    | 数据链路层 | 互连设备之间传送和识别数据帧             |\n| 1    | 物理层     | 比特流与电子信号之间的切换               |\n\n**7层通信实例：**\n\n假设主机A的用户A要给主机B的用户B发送一封电子邮件，邮件内容为早上好：\n\n<img src=\"https://img-blog.csdnimg.cn/b01ed91b7a8e4f0bad03c3fa84f90254.png\" style=\"zoom:25%;\" />\n\n发送方从第7层、第6层到第1层由上至下按照顺序传输数据，而接收端则从第1层、第2层到第7层由下至上向每个上一级分层传输数据。\n\n* 每个分层上，在处理由上一层传过来的数据时可以附上当前分层的协议所必须的首部信息。\n\n* 然后接收端对收到的数据进行数据首部与内容的分离，再转发给上一分层，并最终将发送端的数据恢复为原装。\n\n* 应用层：目标地址为B，发件人为用户A，邮件内容为早上好\n\n* 表示层：将数据（即邮件内容早上好）从主机特有的格式转换为网络标准传输格式\n\n* 会话层：决定采用哪个连接发送。假设用户A新建了5封电子邮件准备发给B，这5封邮件的发送顺序可以有很多种。可以每发一封邮件时建立一次连接，随后断开；还可以建立一次连接连续发送5次；还可以同时建立5个连接，同时发送。决定采用何种连接方式是会话层的主要责任。\n\n* 传输层：确立连接与断开连接重发。例子中的数据早上好可能因为某些原因导致数据被破坏，或者网络异常导致只有部分数据到达目的地址；用户B最后只收到早上这部分数据。此时用户A就需要重发，保证数据传输的可靠性就是传输层的一个重要作用。然而将数据传输给对端的处理是由网络层完成的。\n\n* 网络层：在网络与网络互相互连接的环境中，将数据从发送端主机发送到接收端主机。\n* 数据链路层：在通过（物理的）传输介质互连的设备间进行数据处理。\n* 物理层：将数据的0、1转换为电压和脉冲光传输给物理的传输介质，相互直连的设备之间使用MAC地址（采用MAC地址是为了识别连接到同一传输介质上的设备）进行传输。\n\n> 网络层与数据链路层都是基于目标地址将数据发送给接收端的，但网络层负责将整个数据发送给最终目标地址，而数据链路层只负责发送一个分段内的数据。\n\n**物理层**\n\n首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。\n\n* 物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。\n\n主要作用是传输比特流（`0101`二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。\n\n* 这层数据叫做比特。**网卡工作在这层**。\n\n> 集线器\n\n这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。\n\n* 它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。\n\n这种组网的方法，对一个宿舍来说没有问题，但是一旦机器数目增多，问题就出现了。\n\n* 因为Hub是广播的，不管某个接口是否需要，所有的Bit都会被发送出去，然后让主机来判断是不是需要。\n\n因为每个口都只连接一台电脑，这台电脑又不怎么换IP和MAC地址，只要记住这台电脑的MAC地址，如果目标MAC地址不是这台电脑的，这个口就不用转发了。\n\n> 怎么知道目标MAC地址是否就是连接某个口的电脑的MAC地址呢？\n\n这就需要一个能把MAC头拿下来，检查一下目标MAC地址，然后根据策略转发的设备，这个设备显然是个二层设备，我们称为**交换机**。\n\n> 交换机怎么知道每个口的电脑的MAC地址呢？这需要交换机会学习。\n\n一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候，一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。\n\n但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1是来自一个明确的口。\n\n以后有包的目的地址是MAC1的，直接发送到这个口就可以了。\n\n* 当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。\n\n* 当然，每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为**转发表**，是有一个过期时间的。\n\n有了交换机，一般来说，你接个几十台、上百台机器打游戏，应该没啥问题。你可以组个战队了。能上网了，就可以玩网游了。\n\n**数据链路层**\n\n在传输比特流的过程中，会产生错传、数据传输不完整的可能。\n\n* 数据链路层定义了**如何格式化数据进行传输**，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。\n\n本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。\n\n* 该层负责物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。\n\n常见的协议有 `HDLC、PPP、SLIP`等\n\n数据链路层会将`0、1`序列划分为具有意义的数据帧传送给对端（**数据帧的生成与接收**）\n\n**网络层**\n\n随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。\n\n* 网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。\n\n网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。\n\n* 由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。\n\n此层的数据称之为数据包。本层需要关注的协议`TCP/IP`协议中的IP协议。\n\n网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责**寻址和路由选择**。主要由 `IP、ICMP` 两个协议组成。\n\n网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。\n\n![](https://img-blog.csdnimg.cn/74f18ce814a84f34bfe492b76dfe6619.png)\n\n**传输层**\n\n随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（`Segement`）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。\n\n* 传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了**传输质量**的问题。\n\n传输层需要关注的协议有TCP/IP协议中的`TCP`协议和`UDP`协议。\n\n**会话层**\n\n自动收发包，自动寻址。\n\n* 会话层作用是**负责建立和断开通信连接**，何时建立，断开连接以及保持多久的连接。常见的协议有 `ADSP、RPC` 等\n\n**表示层**\n\nLinux给WIndows发包，不同系统语法不一致，如exe不能在`Linux`下执行，shell不能在Windows不能直接运行。于是需要表示层。\n\n* 解决**不同系统之间通信语法问题**，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。\n\n它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有`ASCII、SSL/TLS` 等\n\n**应用层**\n\n规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。\n\n* 应用层旨在更**方便应用从网络中接收的数据**，重点关注`TCP/IP`协议中的HTTP协议\n\n**注意：**\n\n* 四层传输层数据被称作**段**（Segments）；\n\n* 三层网络层数据被称做**包**（Packages）；\n\n* 二层数据链路层时数据被称为**帧**（Frames）；\n\n* 一层物理层时数据被称为**比特流**（Bits）。\n\n# 网络设备\n\n| 设备             | 作用                             |\n| ---------------- | -------------------------------- |\n| 网卡             | 使计算机连网的设备               |\n| 中继器           | 从物理层上延长网络的设备         |\n| 网桥/2层交换机   | 从数据链路层上延长网络的设备     |\n| 路由器/3层交换机 | 通过网络层转化分组数据的设备     |\n| 4~7层交换机      | 处理传输层以上各层网络传输的设备 |\n| 网关             | 转换协议的设备                   |\n\n**交换机**\n\n> 交换机可以接入多台电脑\n\n每个电脑网卡的 **MAC 地址**都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑\n\n* 交换机就可以识别数据头部的 MAC 地址来区分不同的电脑\n\n* 交换机除了能识别不同的电脑，还需要找到电脑连接的**交换机端口**，才能顺利的把数据从相应端口发送出去\n\n交换机通过**自学机制**，把学习到的设备 MAC 地址和交换机端口号添加到 **MAC 地址表**，并根据 MAC 地址表进行数据**转发**\n\n**路由器**\n\n> 交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多\n\n但是交换机的**容量和性能有限**，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项\n\n* 于是就有了三层网络设备**路由器**，路由器可以把全世界的网络连接起来\n\n局域网内的网络连接可以使用**交换机**，例如一个公司内的网络或者一个校园内的网络通过交换机连接\n\n不同区域的局域网互联使用**路由器**\n\n> 那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？\n\n* 路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址**网络号不同**\n\n它通过识别目的 IP 地址的**网络号**，再根据**路由表**进行数据转发\n\n# 传输方式\n\n面向有连接：发送数据之前，需要在收发主机之间连接一条通信线路。类似于平常打电话。\n\n面向无连接：发送端可于任何时候自由发送数据，接收端不知道自己会在何时从哪里收到数据。所以接收端需要时常确认是否收到了数据。类似于人们去邮局寄包裹。\n\n> 电路交换：\n\n电路交换中交换机负责数据的中转处理。\n\n计算机之间发送数据时需要通过交换机与目标主机建立通信电路。**连接电路称为建立连接**。如果某条电路只是用来连接两台计算机的通信线路，这两台计算机是可以独占线路进行数据传输的；如果一条电路上连接了多台计算机，其他计算机只能等待独占电路的计算机收发信息完毕后才有机会使用电路。如果并发用户数超过交换机之间的通信线路数，通信无法实现。\n\n> 分组交换：\n\n让连接到通信线路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。\n\n这样所有的计算机就可以一齐收发数据，提高通信线路的利用率。\n\n<img src=\"https://img-blog.csdnimg.cn/23805b7f155446dd809b0af481a6e741.png\" style=\"zoom:25%;\" />\n\n> 分组交换过程：\n\n发送端计算机将数据分组发送给交换机（路由器），路由器收到这些分组数据以后缓存到自己的缓冲区，然后转发给目标表计算机。\n\n<img src=\"https://img-blog.csdnimg.cn/039bf48508074f499a2eaa06fe8588a0.png\" style=\"zoom:25%;\" />\n\n电路交换中，计算机间传输速度不变；分组交换中，由于网络拥堵，通信线路的速度可能有所不同。\n\n路由器的缓存饱和或溢出时，甚至出现分组数据丢失、无法发送到对端。\n\n**单薄、广播、多播、任播**\n\n<img src=\"https://img-blog.csdnimg.cn/b0442a9776144c22a93d0fc08d37d79b.png\" style=\"zoom:25%;\" />\n\n多播：与广播类似，也是将消息发给多个接收主机。但广播不需要限定接收端，而多播需要限定某一组主机作为接收端。\n\n任播：在特定的多台主机中选出一台作为接收端。任播与多播类似，都是面向特定的一群主机。但任播会从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。被选中的那台特定主机会返回一个单薄信号，随后发送端主机会只跟这台主机进行通信。","slug":"图解TCP IP/网络基础知识","published":1,"date":"2022-02-08T06:11:41.474Z","updated":"2022-02-08T06:54:07.392Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj700fwfhjiaz4u3na1","content":"<h1 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h1><p><strong>协议定义：</strong></p>\n<p>计算机与计算机之间通过网络实现通信事先达成的一种约定。</p>\n<p>这种约定使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。</p>\n<p>反之，如果使用的协议不同，就无法通信。</p>\n<blockquote>\n<p>（举例人与人之间对话，汉语和英语当作协议，聊天当作通信，说话的内容当作数据，只会汉语和只会英语的人就无法通信）</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/5b46d323da8645e18eb9ae23055815f9.png\"></p>\n<p><strong>分组交换：</strong></p>\n<p>将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。</p>\n<p>这里所说的包，就如同我们平常在邮局里见到的邮包。</p>\n<blockquote>\n<p>分组交换就是将大数据分装为一个个这样的邮包交给对方。</p>\n</blockquote>\n<h1 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h1><img src=\"https://img-blog.csdnimg.cn/cec1f2d82bc54785a4ed03241da45f6c.png\" style=\"zoom:25%;\" />\n\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>分层名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7</td>\n<td>应用层</td>\n<td>针对特定应用的协议</td>\n</tr>\n<tr>\n<td>6</td>\n<td>表示层</td>\n<td>设备固有数据格式和网络标准数据格式的转换</td>\n</tr>\n<tr>\n<td>5</td>\n<td>会话层</td>\n<td>通信管理</td>\n</tr>\n<tr>\n<td>4</td>\n<td>传输层</td>\n<td>管理两个节点之间的数据传输</td>\n</tr>\n<tr>\n<td>3</td>\n<td>网络层</td>\n<td>地址管理和路由选择</td>\n</tr>\n<tr>\n<td>2</td>\n<td>数据链路层</td>\n<td>互连设备之间传送和识别数据帧</td>\n</tr>\n<tr>\n<td>1</td>\n<td>物理层</td>\n<td>比特流与电子信号之间的切换</td>\n</tr>\n</tbody></table>\n<p><strong>7层通信实例：</strong></p>\n<p>假设主机A的用户A要给主机B的用户B发送一封电子邮件，邮件内容为早上好：</p>\n<img src=\"https://img-blog.csdnimg.cn/b01ed91b7a8e4f0bad03c3fa84f90254.png\" style=\"zoom:25%;\" />\n\n<p>发送方从第7层、第6层到第1层由上至下按照顺序传输数据，而接收端则从第1层、第2层到第7层由下至上向每个上一级分层传输数据。</p>\n<ul>\n<li><p>每个分层上，在处理由上一层传过来的数据时可以附上当前分层的协议所必须的首部信息。</p>\n</li>\n<li><p>然后接收端对收到的数据进行数据首部与内容的分离，再转发给上一分层，并最终将发送端的数据恢复为原装。</p>\n</li>\n<li><p>应用层：目标地址为B，发件人为用户A，邮件内容为早上好</p>\n</li>\n<li><p>表示层：将数据（即邮件内容早上好）从主机特有的格式转换为网络标准传输格式</p>\n</li>\n<li><p>会话层：决定采用哪个连接发送。假设用户A新建了5封电子邮件准备发给B，这5封邮件的发送顺序可以有很多种。可以每发一封邮件时建立一次连接，随后断开；还可以建立一次连接连续发送5次；还可以同时建立5个连接，同时发送。决定采用何种连接方式是会话层的主要责任。</p>\n</li>\n<li><p>传输层：确立连接与断开连接重发。例子中的数据早上好可能因为某些原因导致数据被破坏，或者网络异常导致只有部分数据到达目的地址；用户B最后只收到早上这部分数据。此时用户A就需要重发，保证数据传输的可靠性就是传输层的一个重要作用。然而将数据传输给对端的处理是由网络层完成的。</p>\n</li>\n<li><p>网络层：在网络与网络互相互连接的环境中，将数据从发送端主机发送到接收端主机。</p>\n</li>\n<li><p>数据链路层：在通过（物理的）传输介质互连的设备间进行数据处理。</p>\n</li>\n<li><p>物理层：将数据的0、1转换为电压和脉冲光传输给物理的传输介质，相互直连的设备之间使用MAC地址（采用MAC地址是为了识别连接到同一传输介质上的设备）进行传输。</p>\n</li>\n</ul>\n<blockquote>\n<p>网络层与数据链路层都是基于目标地址将数据发送给接收端的，但网络层负责将整个数据发送给最终目标地址，而数据链路层只负责发送一个分段内的数据。</p>\n</blockquote>\n<p><strong>物理层</strong></p>\n<p>首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。</p>\n<ul>\n<li>物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。</li>\n</ul>\n<p>主要作用是传输比特流（<code>0101</code>二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。</p>\n<ul>\n<li>这层数据叫做比特。<strong>网卡工作在这层</strong>。</li>\n</ul>\n<blockquote>\n<p>集线器</p>\n</blockquote>\n<p>这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。</p>\n<ul>\n<li>它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</li>\n</ul>\n<p>这种组网的方法，对一个宿舍来说没有问题，但是一旦机器数目增多，问题就出现了。</p>\n<ul>\n<li>因为Hub是广播的，不管某个接口是否需要，所有的Bit都会被发送出去，然后让主机来判断是不是需要。</li>\n</ul>\n<p>因为每个口都只连接一台电脑，这台电脑又不怎么换IP和MAC地址，只要记住这台电脑的MAC地址，如果目标MAC地址不是这台电脑的，这个口就不用转发了。</p>\n<blockquote>\n<p>怎么知道目标MAC地址是否就是连接某个口的电脑的MAC地址呢？</p>\n</blockquote>\n<p>这就需要一个能把MAC头拿下来，检查一下目标MAC地址，然后根据策略转发的设备，这个设备显然是个二层设备，我们称为<strong>交换机</strong>。</p>\n<blockquote>\n<p>交换机怎么知道每个口的电脑的MAC地址呢？这需要交换机会学习。</p>\n</blockquote>\n<p>一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候，一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。</p>\n<p>但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1是来自一个明确的口。</p>\n<p>以后有包的目的地址是MAC1的，直接发送到这个口就可以了。</p>\n<ul>\n<li><p>当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。</p>\n</li>\n<li><p>当然，每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为<strong>转发表</strong>，是有一个过期时间的。</p>\n</li>\n</ul>\n<p>有了交换机，一般来说，你接个几十台、上百台机器打游戏，应该没啥问题。你可以组个战队了。能上网了，就可以玩网游了。</p>\n<p><strong>数据链路层</strong></p>\n<p>在传输比特流的过程中，会产生错传、数据传输不完整的可能。</p>\n<ul>\n<li>数据链路层定义了<strong>如何格式化数据进行传输</strong>，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。</li>\n</ul>\n<p>本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。</p>\n<ul>\n<li>该层负责物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。</li>\n</ul>\n<p>常见的协议有 <code>HDLC、PPP、SLIP</code>等</p>\n<p>数据链路层会将<code>0、1</code>序列划分为具有意义的数据帧传送给对端（<strong>数据帧的生成与接收</strong>）</p>\n<p><strong>网络层</strong></p>\n<p>随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。</p>\n<ul>\n<li>网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。</li>\n</ul>\n<p>网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。</p>\n<ul>\n<li>由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。</li>\n</ul>\n<p>此层的数据称之为数据包。本层需要关注的协议<code>TCP/IP</code>协议中的IP协议。</p>\n<p>网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责<strong>寻址和路由选择</strong>。主要由 <code>IP、ICMP</code> 两个协议组成。</p>\n<p>网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/74f18ce814a84f34bfe492b76dfe6619.png\"></p>\n<p><strong>传输层</strong></p>\n<p>随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（<code>Segement</code>）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。</p>\n<ul>\n<li>传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了<strong>传输质量</strong>的问题。</li>\n</ul>\n<p>传输层需要关注的协议有TCP&#x2F;IP协议中的<code>TCP</code>协议和<code>UDP</code>协议。</p>\n<p><strong>会话层</strong></p>\n<p>自动收发包，自动寻址。</p>\n<ul>\n<li>会话层作用是<strong>负责建立和断开通信连接</strong>，何时建立，断开连接以及保持多久的连接。常见的协议有 <code>ADSP、RPC</code> 等</li>\n</ul>\n<p><strong>表示层</strong></p>\n<p>Linux给WIndows发包，不同系统语法不一致，如exe不能在<code>Linux</code>下执行，shell不能在Windows不能直接运行。于是需要表示层。</p>\n<ul>\n<li>解决<strong>不同系统之间通信语法问题</strong>，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。</li>\n</ul>\n<p>它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有<code>ASCII、SSL/TLS</code> 等</p>\n<p><strong>应用层</strong></p>\n<p>规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。</p>\n<ul>\n<li>应用层旨在更<strong>方便应用从网络中接收的数据</strong>，重点关注<code>TCP/IP</code>协议中的HTTP协议</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>四层传输层数据被称作<strong>段</strong>（Segments）；</p>\n</li>\n<li><p>三层网络层数据被称做<strong>包</strong>（Packages）；</p>\n</li>\n<li><p>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</p>\n</li>\n<li><p>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</p>\n</li>\n</ul>\n<h1 id=\"网络设备\"><a href=\"#网络设备\" class=\"headerlink\" title=\"网络设备\"></a>网络设备</h1><table>\n<thead>\n<tr>\n<th>设备</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网卡</td>\n<td>使计算机连网的设备</td>\n</tr>\n<tr>\n<td>中继器</td>\n<td>从物理层上延长网络的设备</td>\n</tr>\n<tr>\n<td>网桥&#x2F;2层交换机</td>\n<td>从数据链路层上延长网络的设备</td>\n</tr>\n<tr>\n<td>路由器&#x2F;3层交换机</td>\n<td>通过网络层转化分组数据的设备</td>\n</tr>\n<tr>\n<td>4~7层交换机</td>\n<td>处理传输层以上各层网络传输的设备</td>\n</tr>\n<tr>\n<td>网关</td>\n<td>转换协议的设备</td>\n</tr>\n</tbody></table>\n<p><strong>交换机</strong></p>\n<blockquote>\n<p>交换机可以接入多台电脑</p>\n</blockquote>\n<p>每个电脑网卡的 <strong>MAC 地址</strong>都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑</p>\n<ul>\n<li><p>交换机就可以识别数据头部的 MAC 地址来区分不同的电脑</p>\n</li>\n<li><p>交换机除了能识别不同的电脑，还需要找到电脑连接的<strong>交换机端口</strong>，才能顺利的把数据从相应端口发送出去</p>\n</li>\n</ul>\n<p>交换机通过<strong>自学机制</strong>，把学习到的设备 MAC 地址和交换机端口号添加到 <strong>MAC 地址表</strong>，并根据 MAC 地址表进行数据<strong>转发</strong></p>\n<p><strong>路由器</strong></p>\n<blockquote>\n<p>交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多</p>\n</blockquote>\n<p>但是交换机的<strong>容量和性能有限</strong>，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项</p>\n<ul>\n<li>于是就有了三层网络设备<strong>路由器</strong>，路由器可以把全世界的网络连接起来</li>\n</ul>\n<p>局域网内的网络连接可以使用<strong>交换机</strong>，例如一个公司内的网络或者一个校园内的网络通过交换机连接</p>\n<p>不同区域的局域网互联使用<strong>路由器</strong></p>\n<blockquote>\n<p>那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？</p>\n</blockquote>\n<ul>\n<li>路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址<strong>网络号不同</strong></li>\n</ul>\n<p>它通过识别目的 IP 地址的<strong>网络号</strong>，再根据<strong>路由表</strong>进行数据转发</p>\n<h1 id=\"传输方式\"><a href=\"#传输方式\" class=\"headerlink\" title=\"传输方式\"></a>传输方式</h1><p>面向有连接：发送数据之前，需要在收发主机之间连接一条通信线路。类似于平常打电话。</p>\n<p>面向无连接：发送端可于任何时候自由发送数据，接收端不知道自己会在何时从哪里收到数据。所以接收端需要时常确认是否收到了数据。类似于人们去邮局寄包裹。</p>\n<blockquote>\n<p>电路交换：</p>\n</blockquote>\n<p>电路交换中交换机负责数据的中转处理。</p>\n<p>计算机之间发送数据时需要通过交换机与目标主机建立通信电路。<strong>连接电路称为建立连接</strong>。如果某条电路只是用来连接两台计算机的通信线路，这两台计算机是可以独占线路进行数据传输的；如果一条电路上连接了多台计算机，其他计算机只能等待独占电路的计算机收发信息完毕后才有机会使用电路。如果并发用户数超过交换机之间的通信线路数，通信无法实现。</p>\n<blockquote>\n<p>分组交换：</p>\n</blockquote>\n<p>让连接到通信线路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。</p>\n<p>这样所有的计算机就可以一齐收发数据，提高通信线路的利用率。</p>\n<img src=\"https://img-blog.csdnimg.cn/23805b7f155446dd809b0af481a6e741.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>分组交换过程：</p>\n</blockquote>\n<p>发送端计算机将数据分组发送给交换机（路由器），路由器收到这些分组数据以后缓存到自己的缓冲区，然后转发给目标表计算机。</p>\n<img src=\"https://img-blog.csdnimg.cn/039bf48508074f499a2eaa06fe8588a0.png\" style=\"zoom:25%;\" />\n\n<p>电路交换中，计算机间传输速度不变；分组交换中，由于网络拥堵，通信线路的速度可能有所不同。</p>\n<p>路由器的缓存饱和或溢出时，甚至出现分组数据丢失、无法发送到对端。</p>\n<p><strong>单薄、广播、多播、任播</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/b0442a9776144c22a93d0fc08d37d79b.png\" style=\"zoom:25%;\" />\n\n<p>多播：与广播类似，也是将消息发给多个接收主机。但广播不需要限定接收端，而多播需要限定某一组主机作为接收端。</p>\n<p>任播：在特定的多台主机中选出一台作为接收端。任播与多播类似，都是面向特定的一群主机。但任播会从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。被选中的那台特定主机会返回一个单薄信号，随后发送端主机会只跟这台主机进行通信。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h1><p><strong>协议定义：</strong></p>\n<p>计算机与计算机之间通过网络实现通信事先达成的一种约定。</p>\n<p>这种约定使那些由不同厂商的设备、不同的CPU以及不同的操作系统组成的计算机之间，只要遵循相同的协议就能够实现通信。</p>\n<p>反之，如果使用的协议不同，就无法通信。</p>\n<blockquote>\n<p>（举例人与人之间对话，汉语和英语当作协议，聊天当作通信，说话的内容当作数据，只会汉语和只会英语的人就无法通信）</p>\n</blockquote>\n<p><img src=\"https://img-blog.csdnimg.cn/5b46d323da8645e18eb9ae23055815f9.png\"></p>\n<p><strong>分组交换：</strong></p>\n<p>将大数据分割为一个个叫做包（Packet）的较小单位进行传输的方法。</p>\n<p>这里所说的包，就如同我们平常在邮局里见到的邮包。</p>\n<blockquote>\n<p>分组交换就是将大数据分装为一个个这样的邮包交给对方。</p>\n</blockquote>\n<h1 id=\"OSI七层模型\"><a href=\"#OSI七层模型\" class=\"headerlink\" title=\"OSI七层模型\"></a>OSI七层模型</h1><img src=\"https://img-blog.csdnimg.cn/cec1f2d82bc54785a4ed03241da45f6c.png\" style=\"zoom:25%;\" />\n\n<table>\n<thead>\n<tr>\n<th>层级</th>\n<th>分层名称</th>\n<th>功能</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>7</td>\n<td>应用层</td>\n<td>针对特定应用的协议</td>\n</tr>\n<tr>\n<td>6</td>\n<td>表示层</td>\n<td>设备固有数据格式和网络标准数据格式的转换</td>\n</tr>\n<tr>\n<td>5</td>\n<td>会话层</td>\n<td>通信管理</td>\n</tr>\n<tr>\n<td>4</td>\n<td>传输层</td>\n<td>管理两个节点之间的数据传输</td>\n</tr>\n<tr>\n<td>3</td>\n<td>网络层</td>\n<td>地址管理和路由选择</td>\n</tr>\n<tr>\n<td>2</td>\n<td>数据链路层</td>\n<td>互连设备之间传送和识别数据帧</td>\n</tr>\n<tr>\n<td>1</td>\n<td>物理层</td>\n<td>比特流与电子信号之间的切换</td>\n</tr>\n</tbody></table>\n<p><strong>7层通信实例：</strong></p>\n<p>假设主机A的用户A要给主机B的用户B发送一封电子邮件，邮件内容为早上好：</p>\n<img src=\"https://img-blog.csdnimg.cn/b01ed91b7a8e4f0bad03c3fa84f90254.png\" style=\"zoom:25%;\" />\n\n<p>发送方从第7层、第6层到第1层由上至下按照顺序传输数据，而接收端则从第1层、第2层到第7层由下至上向每个上一级分层传输数据。</p>\n<ul>\n<li><p>每个分层上，在处理由上一层传过来的数据时可以附上当前分层的协议所必须的首部信息。</p>\n</li>\n<li><p>然后接收端对收到的数据进行数据首部与内容的分离，再转发给上一分层，并最终将发送端的数据恢复为原装。</p>\n</li>\n<li><p>应用层：目标地址为B，发件人为用户A，邮件内容为早上好</p>\n</li>\n<li><p>表示层：将数据（即邮件内容早上好）从主机特有的格式转换为网络标准传输格式</p>\n</li>\n<li><p>会话层：决定采用哪个连接发送。假设用户A新建了5封电子邮件准备发给B，这5封邮件的发送顺序可以有很多种。可以每发一封邮件时建立一次连接，随后断开；还可以建立一次连接连续发送5次；还可以同时建立5个连接，同时发送。决定采用何种连接方式是会话层的主要责任。</p>\n</li>\n<li><p>传输层：确立连接与断开连接重发。例子中的数据早上好可能因为某些原因导致数据被破坏，或者网络异常导致只有部分数据到达目的地址；用户B最后只收到早上这部分数据。此时用户A就需要重发，保证数据传输的可靠性就是传输层的一个重要作用。然而将数据传输给对端的处理是由网络层完成的。</p>\n</li>\n<li><p>网络层：在网络与网络互相互连接的环境中，将数据从发送端主机发送到接收端主机。</p>\n</li>\n<li><p>数据链路层：在通过（物理的）传输介质互连的设备间进行数据处理。</p>\n</li>\n<li><p>物理层：将数据的0、1转换为电压和脉冲光传输给物理的传输介质，相互直连的设备之间使用MAC地址（采用MAC地址是为了识别连接到同一传输介质上的设备）进行传输。</p>\n</li>\n</ul>\n<blockquote>\n<p>网络层与数据链路层都是基于目标地址将数据发送给接收端的，但网络层负责将整个数据发送给最终目标地址，而数据链路层只负责发送一个分段内的数据。</p>\n</blockquote>\n<p><strong>物理层</strong></p>\n<p>首先解决两台物理机之间的通信需求，具体就是机器A往机器B发送比特流，机器B能收到比特流。</p>\n<ul>\n<li>物理层主要定义了物理设备的标准，如网线的类型，光纤的接口类型，各种传输介质的传输速率。</li>\n</ul>\n<p>主要作用是传输比特流（<code>0101</code>二进制数据），将比特流转化为电流强弱传输，到达目的后再转化为比特流，即常说的数模转化和模数转换。</p>\n<ul>\n<li>这层数据叫做比特。<strong>网卡工作在这层</strong>。</li>\n</ul>\n<blockquote>\n<p>集线器</p>\n</blockquote>\n<p>这种设备有多个口，可以将宿舍里的多台电脑连接起来。但是，和交换机不同，集线器没有大脑，它完全在物理层工作。</p>\n<ul>\n<li>它会将自己收到的每一个字节，都复制到其他端口上去。这是第一层物理层联通的方案。</li>\n</ul>\n<p>这种组网的方法，对一个宿舍来说没有问题，但是一旦机器数目增多，问题就出现了。</p>\n<ul>\n<li>因为Hub是广播的，不管某个接口是否需要，所有的Bit都会被发送出去，然后让主机来判断是不是需要。</li>\n</ul>\n<p>因为每个口都只连接一台电脑，这台电脑又不怎么换IP和MAC地址，只要记住这台电脑的MAC地址，如果目标MAC地址不是这台电脑的，这个口就不用转发了。</p>\n<blockquote>\n<p>怎么知道目标MAC地址是否就是连接某个口的电脑的MAC地址呢？</p>\n</blockquote>\n<p>这就需要一个能把MAC头拿下来，检查一下目标MAC地址，然后根据策略转发的设备，这个设备显然是个二层设备，我们称为<strong>交换机</strong>。</p>\n<blockquote>\n<p>交换机怎么知道每个口的电脑的MAC地址呢？这需要交换机会学习。</p>\n</blockquote>\n<p>一台MAC1电脑将一个包发送给另一台MAC2电脑，当这个包到达交换机的时候，一开始交换机也不知道MAC2的电脑在哪个口，所以没办法，它只能将包转发给除了来的那个口之外的其他所有的口。</p>\n<p>但是，这个时候，交换机会干一件非常聪明的事情，就是交换机会记住，MAC1是来自一个明确的口。</p>\n<p>以后有包的目的地址是MAC1的，直接发送到这个口就可以了。</p>\n<ul>\n<li><p>当交换机作为一个关卡一样，过了一段时间之后，就有了整个网络的一个结构了，这个时候，基本上不用广播了，全部可以准确转发。</p>\n</li>\n<li><p>当然，每个机器的IP地址会变，所在的口也会变，因而交换机上的学习的结果，我们称为<strong>转发表</strong>，是有一个过期时间的。</p>\n</li>\n</ul>\n<p>有了交换机，一般来说，你接个几十台、上百台机器打游戏，应该没啥问题。你可以组个战队了。能上网了，就可以玩网游了。</p>\n<p><strong>数据链路层</strong></p>\n<p>在传输比特流的过程中，会产生错传、数据传输不完整的可能。</p>\n<ul>\n<li>数据链路层定义了<strong>如何格式化数据进行传输</strong>，以及如何控制对物理介质的访问。通常提供错误检测和纠正，以确保数据传输的准确性。</li>\n</ul>\n<p>本层将比特数据组成帧，交换机工作在这层，对帧解码，并根据帧中包含的信息把数据发送到正确的接收方。</p>\n<ul>\n<li>该层负责物理层面上互连的节点之间的通信传输。例如与1个以太网相连的两个节点间的通讯。</li>\n</ul>\n<p>常见的协议有 <code>HDLC、PPP、SLIP</code>等</p>\n<p>数据链路层会将<code>0、1</code>序列划分为具有意义的数据帧传送给对端（<strong>数据帧的生成与接收</strong>）</p>\n<p><strong>网络层</strong></p>\n<p>随着网络节点的不断增加，点对点通讯需要通过多个节点，如何找到目标节点，如何选择最佳路径成为首要需求。</p>\n<ul>\n<li>网络层主要功能是将网络地址转化为对应的物理地址，并决定如何将数据从发送方路由到接收方。</li>\n</ul>\n<p>网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A到另一个网络中节点B的最佳路径。</p>\n<ul>\n<li>由于网络层处理并智能指导数据传送，路由器连接网络隔断，所以路由器属于网络层。</li>\n</ul>\n<p>此层的数据称之为数据包。本层需要关注的协议<code>TCP/IP</code>协议中的IP协议。</p>\n<p>网络层负责将数据传输到目标地址。目标地址可以使多个网络通过路由器连接而成的某一个地址。因此这一层主要负责<strong>寻址和路由选择</strong>。主要由 <code>IP、ICMP</code> 两个协议组成。</p>\n<p>网络层将数据从发送端的主机发送到接收端的主机，两台主机间可能会存在很多数据链路，但网络层就是负责找出一条相对顺畅的通路将数据传递过去。传输的地址使用的是IP地址。IP地址通过不断转发到更近的IP地址，最终可以到达目标地址。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/74f18ce814a84f34bfe492b76dfe6619.png\"></p>\n<p><strong>传输层</strong></p>\n<p>随着网络通信需求的进一步扩大，通信过程中需要发送大量的数据，如海量文件传输，可能需要很长时间，网络在通信的过程中会中断很多次，此时为了保证传输大量文件时的准确性，需要对发送出去的数据进行切分，切割为一个一个的段落（<code>Segement</code>）发送，其中一个段落丢失是否重传，段落是否按顺序到达，是传输层需要考虑的问题。</p>\n<ul>\n<li>传输层解决了主机间的数据传输，数据间的传输可以是不同网络，并且传输层解决了<strong>传输质量</strong>的问题。</li>\n</ul>\n<p>传输层需要关注的协议有TCP&#x2F;IP协议中的<code>TCP</code>协议和<code>UDP</code>协议。</p>\n<p><strong>会话层</strong></p>\n<p>自动收发包，自动寻址。</p>\n<ul>\n<li>会话层作用是<strong>负责建立和断开通信连接</strong>，何时建立，断开连接以及保持多久的连接。常见的协议有 <code>ADSP、RPC</code> 等</li>\n</ul>\n<p><strong>表示层</strong></p>\n<p>Linux给WIndows发包，不同系统语法不一致，如exe不能在<code>Linux</code>下执行，shell不能在Windows不能直接运行。于是需要表示层。</p>\n<ul>\n<li>解决<strong>不同系统之间通信语法问题</strong>，在表示层数据将按照网络能理解的方案进行格式化，格式化因所使用网络的不同而不同。</li>\n</ul>\n<p>它主要负责数据格式的转换。具体来说，就是讲设备固有的数据格式转换为网络标准格式。常见的协议有<code>ASCII、SSL/TLS</code> 等</p>\n<p><strong>应用层</strong></p>\n<p>规定发送方和接收方必须使用一个固定长度的消息头，消息头必须使用某种固定的组成，消息头中必须记录消息体的长度等信息，方便接收方正确解析发送方发送的数据。</p>\n<ul>\n<li>应用层旨在更<strong>方便应用从网络中接收的数据</strong>，重点关注<code>TCP/IP</code>协议中的HTTP协议</li>\n</ul>\n<p><strong>注意：</strong></p>\n<ul>\n<li><p>四层传输层数据被称作<strong>段</strong>（Segments）；</p>\n</li>\n<li><p>三层网络层数据被称做<strong>包</strong>（Packages）；</p>\n</li>\n<li><p>二层数据链路层时数据被称为<strong>帧</strong>（Frames）；</p>\n</li>\n<li><p>一层物理层时数据被称为<strong>比特流</strong>（Bits）。</p>\n</li>\n</ul>\n<h1 id=\"网络设备\"><a href=\"#网络设备\" class=\"headerlink\" title=\"网络设备\"></a>网络设备</h1><table>\n<thead>\n<tr>\n<th>设备</th>\n<th>作用</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网卡</td>\n<td>使计算机连网的设备</td>\n</tr>\n<tr>\n<td>中继器</td>\n<td>从物理层上延长网络的设备</td>\n</tr>\n<tr>\n<td>网桥&#x2F;2层交换机</td>\n<td>从数据链路层上延长网络的设备</td>\n</tr>\n<tr>\n<td>路由器&#x2F;3层交换机</td>\n<td>通过网络层转化分组数据的设备</td>\n</tr>\n<tr>\n<td>4~7层交换机</td>\n<td>处理传输层以上各层网络传输的设备</td>\n</tr>\n<tr>\n<td>网关</td>\n<td>转换协议的设备</td>\n</tr>\n</tbody></table>\n<p><strong>交换机</strong></p>\n<blockquote>\n<p>交换机可以接入多台电脑</p>\n</blockquote>\n<p>每个电脑网卡的 <strong>MAC 地址</strong>都是不一样的，电脑发送数据时，数据头部携带网卡的 MAC 地址，用 MAC 地址标识来不同的电脑</p>\n<ul>\n<li><p>交换机就可以识别数据头部的 MAC 地址来区分不同的电脑</p>\n</li>\n<li><p>交换机除了能识别不同的电脑，还需要找到电脑连接的<strong>交换机端口</strong>，才能顺利的把数据从相应端口发送出去</p>\n</li>\n</ul>\n<p>交换机通过<strong>自学机制</strong>，把学习到的设备 MAC 地址和交换机端口号添加到 <strong>MAC 地址表</strong>，并根据 MAC 地址表进行数据<strong>转发</strong></p>\n<p><strong>路由器</strong></p>\n<blockquote>\n<p>交换机需要记录的 MAC 地址表也越来越多，需要的交换机也越来越多</p>\n</blockquote>\n<p>但是交换机的<strong>容量和性能有限</strong>，MAC 地址表无法记录全世界电脑的 MAC 地址和对应的端口号，MAC 地址表太大也无法快速查找到对应的 MAC 地址表项</p>\n<ul>\n<li>于是就有了三层网络设备<strong>路由器</strong>，路由器可以把全世界的网络连接起来</li>\n</ul>\n<p>局域网内的网络连接可以使用<strong>交换机</strong>，例如一个公司内的网络或者一个校园内的网络通过交换机连接</p>\n<p>不同区域的局域网互联使用<strong>路由器</strong></p>\n<blockquote>\n<p>那么如何区分不同的网络区域呢？又是如何跨网络区域进行数据转发的呢？</p>\n</blockquote>\n<ul>\n<li>路由器有多个端口，分别连接不同的网络区域，不同网络区域的 IP 地址<strong>网络号不同</strong></li>\n</ul>\n<p>它通过识别目的 IP 地址的<strong>网络号</strong>，再根据<strong>路由表</strong>进行数据转发</p>\n<h1 id=\"传输方式\"><a href=\"#传输方式\" class=\"headerlink\" title=\"传输方式\"></a>传输方式</h1><p>面向有连接：发送数据之前，需要在收发主机之间连接一条通信线路。类似于平常打电话。</p>\n<p>面向无连接：发送端可于任何时候自由发送数据，接收端不知道自己会在何时从哪里收到数据。所以接收端需要时常确认是否收到了数据。类似于人们去邮局寄包裹。</p>\n<blockquote>\n<p>电路交换：</p>\n</blockquote>\n<p>电路交换中交换机负责数据的中转处理。</p>\n<p>计算机之间发送数据时需要通过交换机与目标主机建立通信电路。<strong>连接电路称为建立连接</strong>。如果某条电路只是用来连接两台计算机的通信线路，这两台计算机是可以独占线路进行数据传输的；如果一条电路上连接了多台计算机，其他计算机只能等待独占电路的计算机收发信息完毕后才有机会使用电路。如果并发用户数超过交换机之间的通信线路数，通信无法实现。</p>\n<blockquote>\n<p>分组交换：</p>\n</blockquote>\n<p>让连接到通信线路的计算机将所要发送的数据分成多个数据包，按照一定的顺序排列之后分别发送。</p>\n<p>这样所有的计算机就可以一齐收发数据，提高通信线路的利用率。</p>\n<img src=\"https://img-blog.csdnimg.cn/23805b7f155446dd809b0af481a6e741.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>分组交换过程：</p>\n</blockquote>\n<p>发送端计算机将数据分组发送给交换机（路由器），路由器收到这些分组数据以后缓存到自己的缓冲区，然后转发给目标表计算机。</p>\n<img src=\"https://img-blog.csdnimg.cn/039bf48508074f499a2eaa06fe8588a0.png\" style=\"zoom:25%;\" />\n\n<p>电路交换中，计算机间传输速度不变；分组交换中，由于网络拥堵，通信线路的速度可能有所不同。</p>\n<p>路由器的缓存饱和或溢出时，甚至出现分组数据丢失、无法发送到对端。</p>\n<p><strong>单薄、广播、多播、任播</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/b0442a9776144c22a93d0fc08d37d79b.png\" style=\"zoom:25%;\" />\n\n<p>多播：与广播类似，也是将消息发给多个接收主机。但广播不需要限定接收端，而多播需要限定某一组主机作为接收端。</p>\n<p>任播：在特定的多台主机中选出一台作为接收端。任播与多播类似，都是面向特定的一群主机。但任播会从目标主机群中选择一台最符合网络条件的主机作为目标主机发送消息。被选中的那台特定主机会返回一个单薄信号，随后发送端主机会只跟这台主机进行通信。</p>\n"},{"title":"网络安全","_content":"\n# 数字签名\n\n网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改\n\n* 数字签名可以校验数据的完整性\n\n**数字签名有两种功效**：\n\n- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。\n\n- 数字签名能确定消息的完整性，证明数据是否未被篡改过。\n\n将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者\n\n接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。\n\n* 如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。\n\n# SQL注入\n\nSQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。\n\n**SQL注入攻击实例**\n\n比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：\n\n```\n用户名： ‘or 1 = 1 --\n密 码：\n```\n\n* 用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。\n\n下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：\n\n```sql\nString sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;\n```\n\n因此，当输入了上面的用户名和密码，上面的SQL语句变成：\n\n```sql\nSELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’\n```\n\n分析上述SQL语句我们知道，`username=‘ or 1=1` 这个语句一定会成功；然后后面加`两个 -`，这意味着注释，它将后面的语句注释，让他们不起作用，这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。\n\n**应对方法**\n\n> 预编译\n\n使用预编译手段，绑定参数是最好的防SQL注入的方法。\n\n目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。\n\n* 在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和`$`来获取参数值。\n\n* 当使用#时，变量是占位符，就是一般我们使用java的jdbc的PrepareStatement时的占位符，所有可以防止sql注入；\n\n* 当使用`$`时，变量就是直接追加在sql中，一般会有sql注入问题。\n\n> 使用正则表达式过滤传入的参数\n\n> 过滤参数中含有的一些数据库关键词\n\n# 加密算法\n\n加密算法分**对称加密** 和 **非对称加密**，其中对称加密算法的加密与解密密钥相同，非对称加密算法的加密密钥与解密密钥不同，此外，还有一类不需要密钥的**散列算法**。\n\n常见的 **对称加密** 算法主要有 `DES`、`3DES`、`AES` 等，常见的 **非对称算法** 主要有 `RSA`、`DSA` 等，**散列算法** 主要有 `SHA-1`、`MD5` 等。\n\n**对称加密**\n\n在 **对称加密算法** 中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行 **加密** 和 **解密**。\n\n-  数据加密过程：在对称加密算法中，数据发送方 将 **明文** (原始数据) 和 **加密密钥** 一起经过特殊 **加密处理**，生成复杂的 **加密密文** 进行发送。 \n\n-  数据解密过程：**数据接收方** 收到密文后，若想读取原数据，则需要使用 **加密使用的密钥** 及相同算法的 **逆算法** 对加密的密文进行解密，才能使其恢复成 **可读明文**。 \n\n**非对称加密**\n\n**非对称加密算法**，它需要两个密钥，一个称为 **公开密钥** (`public key`)，即 **公钥**，另一个称为 **私有密钥** (`private key`)，即 **私钥**。\n\n因为 **加密** 和 **解密** 使用的是两个不同的密钥，所以这种算法称为 **非对称加密算法**。\n\n1. 如果使用 **公钥** 对数据 **进行加密**，只有用对应的 **私钥** 才能 **进行解密**。\n\n2. 如果使用 **私钥** 对数据 **进行加密**，只有用对应的 **公钥** 才能 **进行解密**。\n\n**例子**：甲方生成 **一对密钥** 并将其中的一把作为 **公钥** 向其它人公开，得到该公钥的 **乙方** 使用该密钥对机密信息 **进行加密** 后再发送给甲方，甲方再使用自己保存的另一把 **专用密钥** (**私钥**)，对 **加密** 后的信息 **进行解密**。\n\n# 网络攻击\n\n## CSRF和XSS\n\n**XSS：**\n\nXSS跨站脚本是一种网站应用程序的安全漏洞攻击，是代码注入的一种。\n\n* 它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响，这类攻击通常包含了HTML以及用户端脚本语言。\n\n* 比如通过客户端脚本语言（最常见如：JavaScript）\n\n在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS。\n\n**XSS攻击分类**\n\n> 反射性XSS攻击 (非持久性XSS攻击)\n\n例如，正常发送消息：\n\n```\nhttp://www.test.com/message.php?send=Hello,World！\n```\n\n接收者将会接收信息并显示HelloWorld；但是，非正常发送消息：\n\n```\nhttp://www.test.com/message.php?send=<script>alert(‘foolish!’)</script>！\n```\n\n接收者接收消息显示的时候将会弹出警告窗口！\n\n> 持久性XSS攻击 (留言板场景)\n\n一般指XSS攻击代码存储在网站数据库，当一个页面被用户打开的时候执行。\n\n也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。\n\n与非持久性XSS攻击相比，持久性XSS攻击危害性更大。\n\n从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。\n\n例如，留言板表单中的表单域：\n\n```\n<input type=\"text\" name=\"content\" value=\"这里是用户填写的数据\">\n```\n\n正常操作流程是：用户是提交相应留言信息 — 将数据存储到数据库 — 其他用户访问留言板，应用去数据并显示；\n\n而非正常操作流程是攻击者在value填写:\n\n```\n<script>alert(‘foolish!’)；</script> <!--或者html其他标签（破坏样式。。。）、一段攻击型代码-->\n```\n\n并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码\n\n**CSRF：**\n\n跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。\n\n* 比如冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。\n\n## DOS攻击\n\nDOS：中文名称是拒绝服务，该攻击的效果是使得计算机或网络无法提供正常的服务\n\n**DDOS：中文名称是分布式拒绝服务攻击**\n\n指的是攻击者控制多台主机同时向同一主机或网络发起`DOS`攻击\n\n* DRDoS分布反射式拒绝服务攻击这是`DDoS`攻击的变形\n\n**DOS攻击的原理：**\n\n首先攻击者向被攻击的服务器发送大量的虚假IP请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认，该过程需要TCP的三次握手，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放\n\n当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪\n\n**DDOS究竟如何攻击**\n\n* 目前最流行也是最好用的攻击方法就是使用`SYN-Flood`进行攻击，SYN-Flood也就是SYN洪水攻击\n\nSYN-Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器，这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做`SYN timeout`，这段时间大约30秒-2分钟左右。\n\n若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求(因为客户的正常请求比率很小)，这样这个服务器就无法工作了，这种攻击就叫做`SYN-Flood`攻击\n\n* 到目前为止，进行DDoS攻击的防御还是比较困难的\n\n首先，这种攻击的特点是它利用了TCP/IP协议的漏洞，除非你不用TCP/IP，才有可能完全抵御住DDoS攻击\n\n* 不过这不等于我们就没有办法阻挡DDoS攻击，我们可以尽力来减少DDoS的攻击\n\n**下面就是一些防御方法:**\n\n1. 关闭不必要的服务\n2. 限制同时打开的SYN半连接数目\n3. 缩短SYN半连接的time out 时间\n4. 正确设置防火墙\n5. 禁止对主机的非开放服务的访问\n6. 限制特定IP地址的访问\n7. 启用防火墙的防DDoS的属性","source":"_posts/图解TCP IP/网络安全.md","raw":"---\ntitle: 网络安全\ncategories: \n- 图解TCP IP\n---\n\n# 数字签名\n\n网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改\n\n* 数字签名可以校验数据的完整性\n\n**数字签名有两种功效**：\n\n- 能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。\n\n- 数字签名能确定消息的完整性，证明数据是否未被篡改过。\n\n将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者\n\n接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。\n\n* 如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。\n\n# SQL注入\n\nSQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。\n\n**SQL注入攻击实例**\n\n比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：\n\n```\n用户名： ‘or 1 = 1 --\n密 码：\n```\n\n* 用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。\n\n下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：\n\n```sql\nString sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;\n```\n\n因此，当输入了上面的用户名和密码，上面的SQL语句变成：\n\n```sql\nSELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’\n```\n\n分析上述SQL语句我们知道，`username=‘ or 1=1` 这个语句一定会成功；然后后面加`两个 -`，这意味着注释，它将后面的语句注释，让他们不起作用，这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。\n\n**应对方法**\n\n> 预编译\n\n使用预编译手段，绑定参数是最好的防SQL注入的方法。\n\n目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。\n\n* 在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和`$`来获取参数值。\n\n* 当使用#时，变量是占位符，就是一般我们使用java的jdbc的PrepareStatement时的占位符，所有可以防止sql注入；\n\n* 当使用`$`时，变量就是直接追加在sql中，一般会有sql注入问题。\n\n> 使用正则表达式过滤传入的参数\n\n> 过滤参数中含有的一些数据库关键词\n\n# 加密算法\n\n加密算法分**对称加密** 和 **非对称加密**，其中对称加密算法的加密与解密密钥相同，非对称加密算法的加密密钥与解密密钥不同，此外，还有一类不需要密钥的**散列算法**。\n\n常见的 **对称加密** 算法主要有 `DES`、`3DES`、`AES` 等，常见的 **非对称算法** 主要有 `RSA`、`DSA` 等，**散列算法** 主要有 `SHA-1`、`MD5` 等。\n\n**对称加密**\n\n在 **对称加密算法** 中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行 **加密** 和 **解密**。\n\n-  数据加密过程：在对称加密算法中，数据发送方 将 **明文** (原始数据) 和 **加密密钥** 一起经过特殊 **加密处理**，生成复杂的 **加密密文** 进行发送。 \n\n-  数据解密过程：**数据接收方** 收到密文后，若想读取原数据，则需要使用 **加密使用的密钥** 及相同算法的 **逆算法** 对加密的密文进行解密，才能使其恢复成 **可读明文**。 \n\n**非对称加密**\n\n**非对称加密算法**，它需要两个密钥，一个称为 **公开密钥** (`public key`)，即 **公钥**，另一个称为 **私有密钥** (`private key`)，即 **私钥**。\n\n因为 **加密** 和 **解密** 使用的是两个不同的密钥，所以这种算法称为 **非对称加密算法**。\n\n1. 如果使用 **公钥** 对数据 **进行加密**，只有用对应的 **私钥** 才能 **进行解密**。\n\n2. 如果使用 **私钥** 对数据 **进行加密**，只有用对应的 **公钥** 才能 **进行解密**。\n\n**例子**：甲方生成 **一对密钥** 并将其中的一把作为 **公钥** 向其它人公开，得到该公钥的 **乙方** 使用该密钥对机密信息 **进行加密** 后再发送给甲方，甲方再使用自己保存的另一把 **专用密钥** (**私钥**)，对 **加密** 后的信息 **进行解密**。\n\n# 网络攻击\n\n## CSRF和XSS\n\n**XSS：**\n\nXSS跨站脚本是一种网站应用程序的安全漏洞攻击，是代码注入的一种。\n\n* 它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响，这类攻击通常包含了HTML以及用户端脚本语言。\n\n* 比如通过客户端脚本语言（最常见如：JavaScript）\n\n在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS。\n\n**XSS攻击分类**\n\n> 反射性XSS攻击 (非持久性XSS攻击)\n\n例如，正常发送消息：\n\n```\nhttp://www.test.com/message.php?send=Hello,World！\n```\n\n接收者将会接收信息并显示HelloWorld；但是，非正常发送消息：\n\n```\nhttp://www.test.com/message.php?send=<script>alert(‘foolish!’)</script>！\n```\n\n接收者接收消息显示的时候将会弹出警告窗口！\n\n> 持久性XSS攻击 (留言板场景)\n\n一般指XSS攻击代码存储在网站数据库，当一个页面被用户打开的时候执行。\n\n也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。\n\n与非持久性XSS攻击相比，持久性XSS攻击危害性更大。\n\n从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。\n\n例如，留言板表单中的表单域：\n\n```\n<input type=\"text\" name=\"content\" value=\"这里是用户填写的数据\">\n```\n\n正常操作流程是：用户是提交相应留言信息 — 将数据存储到数据库 — 其他用户访问留言板，应用去数据并显示；\n\n而非正常操作流程是攻击者在value填写:\n\n```\n<script>alert(‘foolish!’)；</script> <!--或者html其他标签（破坏样式。。。）、一段攻击型代码-->\n```\n\n并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码\n\n**CSRF：**\n\n跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。\n\n* 比如冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。\n\n## DOS攻击\n\nDOS：中文名称是拒绝服务，该攻击的效果是使得计算机或网络无法提供正常的服务\n\n**DDOS：中文名称是分布式拒绝服务攻击**\n\n指的是攻击者控制多台主机同时向同一主机或网络发起`DOS`攻击\n\n* DRDoS分布反射式拒绝服务攻击这是`DDoS`攻击的变形\n\n**DOS攻击的原理：**\n\n首先攻击者向被攻击的服务器发送大量的虚假IP请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认，该过程需要TCP的三次握手，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放\n\n当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪\n\n**DDOS究竟如何攻击**\n\n* 目前最流行也是最好用的攻击方法就是使用`SYN-Flood`进行攻击，SYN-Flood也就是SYN洪水攻击\n\nSYN-Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器，这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做`SYN timeout`，这段时间大约30秒-2分钟左右。\n\n若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求(因为客户的正常请求比率很小)，这样这个服务器就无法工作了，这种攻击就叫做`SYN-Flood`攻击\n\n* 到目前为止，进行DDoS攻击的防御还是比较困难的\n\n首先，这种攻击的特点是它利用了TCP/IP协议的漏洞，除非你不用TCP/IP，才有可能完全抵御住DDoS攻击\n\n* 不过这不等于我们就没有办法阻挡DDoS攻击，我们可以尽力来减少DDoS的攻击\n\n**下面就是一些防御方法:**\n\n1. 关闭不必要的服务\n2. 限制同时打开的SYN半连接数目\n3. 缩短SYN半连接的time out 时间\n4. 正确设置防火墙\n5. 禁止对主机的非开放服务的访问\n6. 限制特定IP地址的访问\n7. 启用防火墙的防DDoS的属性","slug":"图解TCP IP/网络安全","published":1,"date":"2022-02-09T17:33:45.659Z","updated":"2022-02-10T02:20:48.387Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj700fxfhji1dlse5q1","content":"<h1 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h1><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改</p>\n<ul>\n<li>数字签名可以校验数据的完整性</li>\n</ul>\n<p><strong>数字签名有两种功效</strong>：</p>\n<ul>\n<li><p>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</p>\n</li>\n<li><p>数字签名能确定消息的完整性，证明数据是否未被篡改过。</p>\n</li>\n</ul>\n<p>将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者</p>\n<p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。</p>\n<ul>\n<li>如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</li>\n</ul>\n<h1 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h1><p>SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。</p>\n<p><strong>SQL注入攻击实例</strong></p>\n<p>比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：</p>\n<pre><code>用户名： ‘or 1 = 1 --\n密 码：\n</code></pre>\n<ul>\n<li>用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。</li>\n</ul>\n<p>下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：</p>\n<pre><code class=\"sql\">String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;\n</code></pre>\n<p>因此，当输入了上面的用户名和密码，上面的SQL语句变成：</p>\n<pre><code class=\"sql\">SELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’\n</code></pre>\n<p>分析上述SQL语句我们知道，<code>username=‘ or 1=1</code> 这个语句一定会成功；然后后面加<code>两个 -</code>，这意味着注释，它将后面的语句注释，让他们不起作用，这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。</p>\n<p><strong>应对方法</strong></p>\n<blockquote>\n<p>预编译</p>\n</blockquote>\n<p>使用预编译手段，绑定参数是最好的防SQL注入的方法。</p>\n<p>目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。</p>\n<ul>\n<li><p>在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和<code>$</code>来获取参数值。</p>\n</li>\n<li><p>当使用#时，变量是占位符，就是一般我们使用java的jdbc的PrepareStatement时的占位符，所有可以防止sql注入；</p>\n</li>\n<li><p>当使用<code>$</code>时，变量就是直接追加在sql中，一般会有sql注入问题。</p>\n</li>\n</ul>\n<blockquote>\n<p>使用正则表达式过滤传入的参数</p>\n</blockquote>\n<blockquote>\n<p>过滤参数中含有的一些数据库关键词</p>\n</blockquote>\n<h1 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h1><p>加密算法分<strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密密钥相同，非对称加密算法的加密密钥与解密密钥不同，此外，还有一类不需要密钥的<strong>散列算法</strong>。</p>\n<p>常见的 <strong>对称加密</strong> 算法主要有 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等，常见的 <strong>非对称算法</strong> 主要有 <code>RSA</code>、<code>DSA</code> 等，<strong>散列算法</strong> 主要有 <code>SHA-1</code>、<code>MD5</code> 等。</p>\n<p><strong>对称加密</strong></p>\n<p>在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。</p>\n<ul>\n<li><p>数据加密过程：在对称加密算法中，数据发送方 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。 </p>\n</li>\n<li><p>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</p>\n</li>\n</ul>\n<p><strong>非对称加密</strong></p>\n<p><strong>非对称加密算法</strong>，它需要两个密钥，一个称为 <strong>公开密钥</strong> (<code>public key</code>)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (<code>private key</code>)，即 <strong>私钥</strong>。</p>\n<p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。</p>\n<ol>\n<li><p>如果使用 <strong>公钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>私钥</strong> 才能 <strong>进行解密</strong>。</p>\n</li>\n<li><p>如果使用 <strong>私钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>公钥</strong> 才能 <strong>进行解密</strong>。</p>\n</li>\n</ol>\n<p><strong>例子</strong>：甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它人公开，得到该公钥的 <strong>乙方</strong> 使用该密钥对机密信息 <strong>进行加密</strong> 后再发送给甲方，甲方再使用自己保存的另一把 <strong>专用密钥</strong> (<strong>私钥</strong>)，对 <strong>加密</strong> 后的信息 <strong>进行解密</strong>。</p>\n<h1 id=\"网络攻击\"><a href=\"#网络攻击\" class=\"headerlink\" title=\"网络攻击\"></a>网络攻击</h1><h2 id=\"CSRF和XSS\"><a href=\"#CSRF和XSS\" class=\"headerlink\" title=\"CSRF和XSS\"></a>CSRF和XSS</h2><p><strong>XSS：</strong></p>\n<p>XSS跨站脚本是一种网站应用程序的安全漏洞攻击，是代码注入的一种。</p>\n<ul>\n<li><p>它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响，这类攻击通常包含了HTML以及用户端脚本语言。</p>\n</li>\n<li><p>比如通过客户端脚本语言（最常见如：JavaScript）</p>\n</li>\n</ul>\n<p>在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS。</p>\n<p><strong>XSS攻击分类</strong></p>\n<blockquote>\n<p>反射性XSS攻击 (非持久性XSS攻击)</p>\n</blockquote>\n<p>例如，正常发送消息：</p>\n<pre><code>http://www.test.com/message.php?send=Hello,World！\n</code></pre>\n<p>接收者将会接收信息并显示HelloWorld；但是，非正常发送消息：</p>\n<pre><code>http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！\n</code></pre>\n<p>接收者接收消息显示的时候将会弹出警告窗口！</p>\n<blockquote>\n<p>持久性XSS攻击 (留言板场景)</p>\n</blockquote>\n<p>一般指XSS攻击代码存储在网站数据库，当一个页面被用户打开的时候执行。</p>\n<p>也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。</p>\n<p>与非持久性XSS攻击相比，持久性XSS攻击危害性更大。</p>\n<p>从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。</p>\n<p>例如，留言板表单中的表单域：</p>\n<pre><code>&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;这里是用户填写的数据&quot;&gt;\n</code></pre>\n<p>正常操作流程是：用户是提交相应留言信息 — 将数据存储到数据库 — 其他用户访问留言板，应用去数据并显示；</p>\n<p>而非正常操作流程是攻击者在value填写:</p>\n<pre><code>&lt;script&gt;alert(‘foolish!’)；&lt;/script&gt; &lt;!--或者html其他标签（破坏样式。。。）、一段攻击型代码--&gt;\n</code></pre>\n<p>并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码</p>\n<p><strong>CSRF：</strong></p>\n<p>跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p>\n<ul>\n<li>比如冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。</li>\n</ul>\n<h2 id=\"DOS攻击\"><a href=\"#DOS攻击\" class=\"headerlink\" title=\"DOS攻击\"></a>DOS攻击</h2><p>DOS：中文名称是拒绝服务，该攻击的效果是使得计算机或网络无法提供正常的服务</p>\n<p><strong>DDOS：中文名称是分布式拒绝服务攻击</strong></p>\n<p>指的是攻击者控制多台主机同时向同一主机或网络发起<code>DOS</code>攻击</p>\n<ul>\n<li>DRDoS分布反射式拒绝服务攻击这是<code>DDoS</code>攻击的变形</li>\n</ul>\n<p><strong>DOS攻击的原理：</strong></p>\n<p>首先攻击者向被攻击的服务器发送大量的虚假IP请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认，该过程需要TCP的三次握手，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放</p>\n<p>当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪</p>\n<p><strong>DDOS究竟如何攻击</strong></p>\n<ul>\n<li>目前最流行也是最好用的攻击方法就是使用<code>SYN-Flood</code>进行攻击，SYN-Flood也就是SYN洪水攻击</li>\n</ul>\n<p>SYN-Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器，这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做<code>SYN timeout</code>，这段时间大约30秒-2分钟左右。</p>\n<p>若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求(因为客户的正常请求比率很小)，这样这个服务器就无法工作了，这种攻击就叫做<code>SYN-Flood</code>攻击</p>\n<ul>\n<li>到目前为止，进行DDoS攻击的防御还是比较困难的</li>\n</ul>\n<p>首先，这种攻击的特点是它利用了TCP&#x2F;IP协议的漏洞，除非你不用TCP&#x2F;IP，才有可能完全抵御住DDoS攻击</p>\n<ul>\n<li>不过这不等于我们就没有办法阻挡DDoS攻击，我们可以尽力来减少DDoS的攻击</li>\n</ul>\n<p><strong>下面就是一些防御方法:</strong></p>\n<ol>\n<li>关闭不必要的服务</li>\n<li>限制同时打开的SYN半连接数目</li>\n<li>缩短SYN半连接的time out 时间</li>\n<li>正确设置防火墙</li>\n<li>禁止对主机的非开放服务的访问</li>\n<li>限制特定IP地址的访问</li>\n<li>启用防火墙的防DDoS的属性</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"数字签名\"><a href=\"#数字签名\" class=\"headerlink\" title=\"数字签名\"></a>数字签名</h1><p>网络传输过程中需要经过很多中间节点，虽然数据无法被解密，但可能被篡改</p>\n<ul>\n<li>数字签名可以校验数据的完整性</li>\n</ul>\n<p><strong>数字签名有两种功效</strong>：</p>\n<ul>\n<li><p>能确定消息确实是由发送方签名并发出来的，因为别人假冒不了发送方的签名。</p>\n</li>\n<li><p>数字签名能确定消息的完整性，证明数据是否未被篡改过。</p>\n</li>\n</ul>\n<p>将一段文本先用Hash函数生成消息摘要，然后用发送者的私钥加密生成数字签名，与原文文一起传送给接收者</p>\n<p>接收者只有用发送者的公钥才能解密被加密的摘要信息，然后用HASH函数对收到的原文产生一个摘要信息，与上一步得到的摘要信息对比。</p>\n<ul>\n<li>如果相同，则说明收到的信息是完整的，在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。</li>\n</ul>\n<h1 id=\"SQL注入\"><a href=\"#SQL注入\" class=\"headerlink\" title=\"SQL注入\"></a>SQL注入</h1><p>SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。</p>\n<p><strong>SQL注入攻击实例</strong></p>\n<p>比如，在一个登录界面，要求输入用户名和密码，可以这样输入实现免帐号登录：</p>\n<pre><code>用户名： ‘or 1 = 1 --\n密 码：\n</code></pre>\n<ul>\n<li>用户一旦点击登录，如若没有做特殊处理，那么这个非法用户就很得意的登陆进去了。</li>\n</ul>\n<p>下面我们分析一下：从理论上说，后台认证程序中会有如下的SQL语句：</p>\n<pre><code class=\"sql\">String sql = “select * from user_table where username=’ “+userName+” ’ and password=’ “+password+” ‘”;\n</code></pre>\n<p>因此，当输入了上面的用户名和密码，上面的SQL语句变成：</p>\n<pre><code class=\"sql\">SELECT * FROM user_table WHERE username=’’or 1 = 1 –- and password=’’\n</code></pre>\n<p>分析上述SQL语句我们知道，<code>username=‘ or 1=1</code> 这个语句一定会成功；然后后面加<code>两个 -</code>，这意味着注释，它将后面的语句注释，让他们不起作用，这样，上述语句永远都能正确执行，用户轻易骗过系统，获取合法身份。</p>\n<p><strong>应对方法</strong></p>\n<blockquote>\n<p>预编译</p>\n</blockquote>\n<p>使用预编译手段，绑定参数是最好的防SQL注入的方法。</p>\n<p>目前许多的ORM框架及JDBC等都实现了SQL预编译和参数绑定功能，攻击者的恶意SQL会被当做SQL的参数而不是SQL命令被执行。</p>\n<ul>\n<li><p>在mybatis的mapper文件中，对于传递的参数我们一般是使用 # 和<code>$</code>来获取参数值。</p>\n</li>\n<li><p>当使用#时，变量是占位符，就是一般我们使用java的jdbc的PrepareStatement时的占位符，所有可以防止sql注入；</p>\n</li>\n<li><p>当使用<code>$</code>时，变量就是直接追加在sql中，一般会有sql注入问题。</p>\n</li>\n</ul>\n<blockquote>\n<p>使用正则表达式过滤传入的参数</p>\n</blockquote>\n<blockquote>\n<p>过滤参数中含有的一些数据库关键词</p>\n</blockquote>\n<h1 id=\"加密算法\"><a href=\"#加密算法\" class=\"headerlink\" title=\"加密算法\"></a>加密算法</h1><p>加密算法分<strong>对称加密</strong> 和 <strong>非对称加密</strong>，其中对称加密算法的加密与解密密钥相同，非对称加密算法的加密密钥与解密密钥不同，此外，还有一类不需要密钥的<strong>散列算法</strong>。</p>\n<p>常见的 <strong>对称加密</strong> 算法主要有 <code>DES</code>、<code>3DES</code>、<code>AES</code> 等，常见的 <strong>非对称算法</strong> 主要有 <code>RSA</code>、<code>DSA</code> 等，<strong>散列算法</strong> 主要有 <code>SHA-1</code>、<code>MD5</code> 等。</p>\n<p><strong>对称加密</strong></p>\n<p>在 <strong>对称加密算法</strong> 中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行 <strong>加密</strong> 和 <strong>解密</strong>。</p>\n<ul>\n<li><p>数据加密过程：在对称加密算法中，数据发送方 将 <strong>明文</strong> (原始数据) 和 <strong>加密密钥</strong> 一起经过特殊 <strong>加密处理</strong>，生成复杂的 <strong>加密密文</strong> 进行发送。 </p>\n</li>\n<li><p>数据解密过程：<strong>数据接收方</strong> 收到密文后，若想读取原数据，则需要使用 <strong>加密使用的密钥</strong> 及相同算法的 <strong>逆算法</strong> 对加密的密文进行解密，才能使其恢复成 <strong>可读明文</strong>。</p>\n</li>\n</ul>\n<p><strong>非对称加密</strong></p>\n<p><strong>非对称加密算法</strong>，它需要两个密钥，一个称为 <strong>公开密钥</strong> (<code>public key</code>)，即 <strong>公钥</strong>，另一个称为 <strong>私有密钥</strong> (<code>private key</code>)，即 <strong>私钥</strong>。</p>\n<p>因为 <strong>加密</strong> 和 <strong>解密</strong> 使用的是两个不同的密钥，所以这种算法称为 <strong>非对称加密算法</strong>。</p>\n<ol>\n<li><p>如果使用 <strong>公钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>私钥</strong> 才能 <strong>进行解密</strong>。</p>\n</li>\n<li><p>如果使用 <strong>私钥</strong> 对数据 <strong>进行加密</strong>，只有用对应的 <strong>公钥</strong> 才能 <strong>进行解密</strong>。</p>\n</li>\n</ol>\n<p><strong>例子</strong>：甲方生成 <strong>一对密钥</strong> 并将其中的一把作为 <strong>公钥</strong> 向其它人公开，得到该公钥的 <strong>乙方</strong> 使用该密钥对机密信息 <strong>进行加密</strong> 后再发送给甲方，甲方再使用自己保存的另一把 <strong>专用密钥</strong> (<strong>私钥</strong>)，对 <strong>加密</strong> 后的信息 <strong>进行解密</strong>。</p>\n<h1 id=\"网络攻击\"><a href=\"#网络攻击\" class=\"headerlink\" title=\"网络攻击\"></a>网络攻击</h1><h2 id=\"CSRF和XSS\"><a href=\"#CSRF和XSS\" class=\"headerlink\" title=\"CSRF和XSS\"></a>CSRF和XSS</h2><p><strong>XSS：</strong></p>\n<p>XSS跨站脚本是一种网站应用程序的安全漏洞攻击，是代码注入的一种。</p>\n<ul>\n<li><p>它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响，这类攻击通常包含了HTML以及用户端脚本语言。</p>\n</li>\n<li><p>比如通过客户端脚本语言（最常见如：JavaScript）</p>\n</li>\n</ul>\n<p>在一个论坛发帖中发布一段恶意的JavaScript代码就是脚本注入，如果这个代码内容有请求外部服务器，那么就叫做XSS。</p>\n<p><strong>XSS攻击分类</strong></p>\n<blockquote>\n<p>反射性XSS攻击 (非持久性XSS攻击)</p>\n</blockquote>\n<p>例如，正常发送消息：</p>\n<pre><code>http://www.test.com/message.php?send=Hello,World！\n</code></pre>\n<p>接收者将会接收信息并显示HelloWorld；但是，非正常发送消息：</p>\n<pre><code>http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！\n</code></pre>\n<p>接收者接收消息显示的时候将会弹出警告窗口！</p>\n<blockquote>\n<p>持久性XSS攻击 (留言板场景)</p>\n</blockquote>\n<p>一般指XSS攻击代码存储在网站数据库，当一个页面被用户打开的时候执行。</p>\n<p>也就是说，每当用户使用浏览器打开指定页面时，脚本便执行。</p>\n<p>与非持久性XSS攻击相比，持久性XSS攻击危害性更大。</p>\n<p>从名字就可以了解到，持久性XSS攻击就是将攻击代码存入数据库中，然后客户端打开时就执行这些攻击代码。</p>\n<p>例如，留言板表单中的表单域：</p>\n<pre><code>&lt;input type=&quot;text&quot; name=&quot;content&quot; value=&quot;这里是用户填写的数据&quot;&gt;\n</code></pre>\n<p>正常操作流程是：用户是提交相应留言信息 — 将数据存储到数据库 — 其他用户访问留言板，应用去数据并显示；</p>\n<p>而非正常操作流程是攻击者在value填写:</p>\n<pre><code>&lt;script&gt;alert(‘foolish!’)；&lt;/script&gt; &lt;!--或者html其他标签（破坏样式。。。）、一段攻击型代码--&gt;\n</code></pre>\n<p>并将数据提交、存储到数据库中；当其他用户取出数据显示的时候，将会执行这些攻击性代码</p>\n<p><strong>CSRF：</strong></p>\n<p>跨站请求伪造，是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。</p>\n<ul>\n<li>比如冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的请求（如恶意发帖，删帖，改密码，发邮件等）。</li>\n</ul>\n<h2 id=\"DOS攻击\"><a href=\"#DOS攻击\" class=\"headerlink\" title=\"DOS攻击\"></a>DOS攻击</h2><p>DOS：中文名称是拒绝服务，该攻击的效果是使得计算机或网络无法提供正常的服务</p>\n<p><strong>DDOS：中文名称是分布式拒绝服务攻击</strong></p>\n<p>指的是攻击者控制多台主机同时向同一主机或网络发起<code>DOS</code>攻击</p>\n<ul>\n<li>DRDoS分布反射式拒绝服务攻击这是<code>DDoS</code>攻击的变形</li>\n</ul>\n<p><strong>DOS攻击的原理：</strong></p>\n<p>首先攻击者向被攻击的服务器发送大量的虚假IP请求，被攻击者在收到请求后返回确认信息，等待攻击者进行确认，该过程需要TCP的三次握手，由于攻击者发送的请求信息是虚假的，所以服务器接收不到返回的确认信息，在一段时间内服务器会处与等待状态，而分配给这次请求的资源却被有被释放</p>\n<p>当被攻击者等待一定的时间后，会因连接超时而断开，这时攻击者在次发送新的虚假信息请求，这样最终服务器资源被耗尽，直到瘫痪</p>\n<p><strong>DDOS究竟如何攻击</strong></p>\n<ul>\n<li>目前最流行也是最好用的攻击方法就是使用<code>SYN-Flood</code>进行攻击，SYN-Flood也就是SYN洪水攻击</li>\n</ul>\n<p>SYN-Flood不会完成TCP三次握手的第三步，也就是不发送确认连接的信息给服务器，这样，服务器无法完成第三次握手，但服务器不会立即放弃，服务器会不停的重试并等待一定的时间后放弃这个未完成的连接，这段时间叫做<code>SYN timeout</code>，这段时间大约30秒-2分钟左右。</p>\n<p>若是一个用户在连接时出现问题导致服务器的一个线程等待1分钟并不是什么大不了的问题，但是若有人用特殊的软件大量模拟这种情况，那后果就可想而知了。一个服务器若是处理这些大量的半连接信息而消耗大量的系统资源和网络带宽，这样服务器就不会再有空余去处理普通用户的正常请求(因为客户的正常请求比率很小)，这样这个服务器就无法工作了，这种攻击就叫做<code>SYN-Flood</code>攻击</p>\n<ul>\n<li>到目前为止，进行DDoS攻击的防御还是比较困难的</li>\n</ul>\n<p>首先，这种攻击的特点是它利用了TCP&#x2F;IP协议的漏洞，除非你不用TCP&#x2F;IP，才有可能完全抵御住DDoS攻击</p>\n<ul>\n<li>不过这不等于我们就没有办法阻挡DDoS攻击，我们可以尽力来减少DDoS的攻击</li>\n</ul>\n<p><strong>下面就是一些防御方法:</strong></p>\n<ol>\n<li>关闭不必要的服务</li>\n<li>限制同时打开的SYN半连接数目</li>\n<li>缩短SYN半连接的time out 时间</li>\n<li>正确设置防火墙</li>\n<li>禁止对主机的非开放服务的访问</li>\n<li>限制特定IP地址的访问</li>\n<li>启用防火墙的防DDoS的属性</li>\n</ol>\n"},{"title":"10II青蛙跳台阶问题","_content":"\n题目地址：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        if (n<=1) {\n            return 1;\n        }\n        int[] dp = new int[n+1];\n        dp[1]=1;\n        dp[2]=2;\n        for (int i =3;i<=n;i++) {\n            dp[i] = dp[i-1] + dp[i-2];\n            dp[i] %= 1000000007;\n        }\n        return dp[n];\n    }\n}\n```\n\n# 优化\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        int a = 1, b = 1;\n        for (int i = 2;i<=n;i++) {\n            int sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return b;\n    }\n}\n```","source":"_posts/剑指OFFER/10II青蛙跳台阶问题.md","raw":"---\ntitle: 10II青蛙跳台阶问题\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        if (n<=1) {\n            return 1;\n        }\n        int[] dp = new int[n+1];\n        dp[1]=1;\n        dp[2]=2;\n        for (int i =3;i<=n;i++) {\n            dp[i] = dp[i-1] + dp[i-2];\n            dp[i] %= 1000000007;\n        }\n        return dp[n];\n    }\n}\n```\n\n# 优化\n\n```java\nclass Solution {\n    public int numWays(int n) {\n        int a = 1, b = 1;\n        for (int i = 2;i<=n;i++) {\n            int sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        }\n        return b;\n    }\n}\n```","slug":"剑指OFFER/10II青蛙跳台阶问题","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T17:11:39.425Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj800g0fhji42za1xty","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int numWays(int n) &#123;\n        if (n&lt;=1) &#123;\n            return 1;\n        &#125;\n        int[] dp = new int[n+1];\n        dp[1]=1;\n        dp[2]=2;\n        for (int i =3;i&lt;=n;i++) &#123;\n            dp[i] = dp[i-1] + dp[i-2];\n            dp[i] %= 1000000007;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><pre><code class=\"java\">class Solution &#123;\n    public int numWays(int n) &#123;\n        int a = 1, b = 1;\n        for (int i = 2;i&lt;=n;i++) &#123;\n            int sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        &#125;\n        return b;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/\">https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int numWays(int n) &#123;\n        if (n&lt;=1) &#123;\n            return 1;\n        &#125;\n        int[] dp = new int[n+1];\n        dp[1]=1;\n        dp[2]=2;\n        for (int i =3;i&lt;=n;i++) &#123;\n            dp[i] = dp[i-1] + dp[i-2];\n            dp[i] %= 1000000007;\n        &#125;\n        return dp[n];\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h1><pre><code class=\"java\">class Solution &#123;\n    public int numWays(int n) &#123;\n        int a = 1, b = 1;\n        for (int i = 2;i&lt;=n;i++) &#123;\n            int sum = (a + b) % 1000000007;\n            a = b;\n            b = sum;\n        &#125;\n        return b;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"15二进制中1的个数","_content":"\n题目地址：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\n\n```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        int count = 0;\n        while(n!=0) {\n            n = n&(n-1);\n            count++;\n        }\n        return count;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/15二进制中1的个数.md","raw":"---\ntitle: 15二进制中1的个数\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\n\n```java\npublic class Solution {\n    public int hammingWeight(int n) {\n        int count = 0;\n        while(n!=0) {\n            n = n&(n-1);\n            count++;\n        }\n        return count;\n    }\n}\n```\n\n","slug":"剑指OFFER/15二进制中1的个数","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T17:11:44.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj800g1fhjibhm8193g","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public int hammingWeight(int n) &#123;\n        int count = 0;\n        while(n!=0) &#123;\n            n = n&amp;(n-1);\n            count++;\n        &#125;\n        return count;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/\">https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/</a></p>\n<pre><code class=\"java\">public class Solution &#123;\n    public int hammingWeight(int n) &#123;\n        int count = 0;\n        while(n!=0) &#123;\n            n = n&amp;(n-1);\n            count++;\n        &#125;\n        return count;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"18删除链表的节点","_content":"\n题目地址:https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/\n\n遍历链表，直到 `head.val == val` 时跳出，即可定位目标节点\n\n设节点 cur 的前驱节点为 pre ，后继节点为 `cur.next`\n\n则执行 `pre.next = cur.next` ，即可实现删除 cur 节点\n\n```java\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        if (head == null) {\n            return null;\n        }\n        if (head.val == val) {\n            return head.next;\n        }\n        \n        ListNode pre = head, cur = head.next;\n        while (cur!=null&&cur.val!=val) {\n            pre=cur;\n            cur=cur.next;\n        }\n        if (cur!=null) {\n            pre.next=cur.next;\n        }\n        return head;\n    }\n}\n```\n\n时间复杂度 O(N)\n\n空间复杂度 O(1)： cur, pre 占用常数大小额外空间","source":"_posts/剑指OFFER/18删除链表的节点.md","raw":"---\ntitle: 18删除链表的节点\ncategories: \n- 剑指OFFER\n---\n\n题目地址:https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/\n\n遍历链表，直到 `head.val == val` 时跳出，即可定位目标节点\n\n设节点 cur 的前驱节点为 pre ，后继节点为 `cur.next`\n\n则执行 `pre.next = cur.next` ，即可实现删除 cur 节点\n\n```java\nclass Solution {\n    public ListNode deleteNode(ListNode head, int val) {\n        if (head == null) {\n            return null;\n        }\n        if (head.val == val) {\n            return head.next;\n        }\n        \n        ListNode pre = head, cur = head.next;\n        while (cur!=null&&cur.val!=val) {\n            pre=cur;\n            cur=cur.next;\n        }\n        if (cur!=null) {\n            pre.next=cur.next;\n        }\n        return head;\n    }\n}\n```\n\n时间复杂度 O(N)\n\n空间复杂度 O(1)： cur, pre 占用常数大小额外空间","slug":"剑指OFFER/18删除链表的节点","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T17:11:49.150Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj900g4fhjibwdo6ssg","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/\">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/</a></p>\n<p>遍历链表，直到 <code>head.val == val</code> 时跳出，即可定位目标节点</p>\n<p>设节点 cur 的前驱节点为 pre ，后继节点为 <code>cur.next</code></p>\n<p>则执行 <code>pre.next = cur.next</code> ，即可实现删除 cur 节点</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode deleteNode(ListNode head, int val) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n        if (head.val == val) &#123;\n            return head.next;\n        &#125;\n        \n        ListNode pre = head, cur = head.next;\n        while (cur!=null&amp;&amp;cur.val!=val) &#123;\n            pre=cur;\n            cur=cur.next;\n        &#125;\n        if (cur!=null) &#123;\n            pre.next=cur.next;\n        &#125;\n        return head;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)</p>\n<p>空间复杂度 O(1)： cur, pre 占用常数大小额外空间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/\">https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof/</a></p>\n<p>遍历链表，直到 <code>head.val == val</code> 时跳出，即可定位目标节点</p>\n<p>设节点 cur 的前驱节点为 pre ，后继节点为 <code>cur.next</code></p>\n<p>则执行 <code>pre.next = cur.next</code> ，即可实现删除 cur 节点</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode deleteNode(ListNode head, int val) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n        if (head.val == val) &#123;\n            return head.next;\n        &#125;\n        \n        ListNode pre = head, cur = head.next;\n        while (cur!=null&amp;&amp;cur.val!=val) &#123;\n            pre=cur;\n            cur=cur.next;\n        &#125;\n        if (cur!=null) &#123;\n            pre.next=cur.next;\n        &#125;\n        return head;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)</p>\n<p>空间复杂度 O(1)： cur, pre 占用常数大小额外空间</p>\n"},{"title":"21调整数组顺序使奇数位于偶数前面","_content":"\n题目地址：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\n\n考虑定义双指针 i, j分列数组左右两端，循环执行：\n\n* 指针 i从左向右寻找偶数；\n\n* 指针 j从右向左寻找奇数；\n\n* 将 偶数 nums[i]和 奇数 nums[j]交换。\n\n可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数\n\n```java\nclass Solution {\n    public int[] exchange(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return nums;\n        }\n        int i = 0, j = nums.length - 1;\n        while (i < j) {\n            while(i < j && (nums[i] & 1) == 1) {\n                i++;\n            }\n            while (i < j && (nums[j] & 1) == 0) {\n                j--;\n            }\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n        return nums;\n    }\n}\n```\n\n时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。\n\n空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。","source":"_posts/剑指OFFER/21调整数组顺序使奇数位于偶数前面.md","raw":"---\ntitle: 21调整数组顺序使奇数位于偶数前面\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\n\n考虑定义双指针 i, j分列数组左右两端，循环执行：\n\n* 指针 i从左向右寻找偶数；\n\n* 指针 j从右向左寻找奇数；\n\n* 将 偶数 nums[i]和 奇数 nums[j]交换。\n\n可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数\n\n```java\nclass Solution {\n    public int[] exchange(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return nums;\n        }\n        int i = 0, j = nums.length - 1;\n        while (i < j) {\n            while(i < j && (nums[i] & 1) == 1) {\n                i++;\n            }\n            while (i < j && (nums[j] & 1) == 0) {\n                j--;\n            }\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        }\n        return nums;\n    }\n}\n```\n\n时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。\n\n空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。","slug":"剑指OFFER/21调整数组顺序使奇数位于偶数前面","published":1,"date":"2021-09-01T05:22:18.213Z","updated":"2022-01-28T17:11:53.725Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwj900g5fhji22q22gzg","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</a></p>\n<p>考虑定义双指针 i, j分列数组左右两端，循环执行：</p>\n<ul>\n<li><p>指针 i从左向右寻找偶数；</p>\n</li>\n<li><p>指针 j从右向左寻找奇数；</p>\n</li>\n<li><p>将 偶数 nums[i]和 奇数 nums[j]交换。</p>\n</li>\n</ul>\n<p>可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] exchange(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return nums;\n        &#125;\n        int i = 0, j = nums.length - 1;\n        while (i &lt; j) &#123;\n            while(i &lt; j &amp;&amp; (nums[i] &amp; 1) == 1) &#123;\n                i++;\n            &#125;\n            while (i &lt; j &amp;&amp; (nums[j] &amp; 1) == 0) &#123;\n                j--;\n            &#125;\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        &#125;\n        return nums;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。</p>\n<p>空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\">https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/</a></p>\n<p>考虑定义双指针 i, j分列数组左右两端，循环执行：</p>\n<ul>\n<li><p>指针 i从左向右寻找偶数；</p>\n</li>\n<li><p>指针 j从右向左寻找奇数；</p>\n</li>\n<li><p>将 偶数 nums[i]和 奇数 nums[j]交换。</p>\n</li>\n</ul>\n<p>可始终保证： 指针 i 左边都是奇数，指针 j 右边都是偶数</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int[] exchange(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return nums;\n        &#125;\n        int i = 0, j = nums.length - 1;\n        while (i &lt; j) &#123;\n            while(i &lt; j &amp;&amp; (nums[i] &amp; 1) == 1) &#123;\n                i++;\n            &#125;\n            while (i &lt; j &amp;&amp; (nums[j] &amp; 1) == 0) &#123;\n                j--;\n            &#125;\n            int temp = nums[i];\n            nums[i] = nums[j];\n            nums[j] = temp;\n        &#125;\n        return nums;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： N 为数组 nums 长度，双指针 i, j 共同遍历整个数组。</p>\n<p>空间复杂度 O(1) ： 双指针 i, j 使用常数大小的额外空间。</p>\n"},{"title":"24反转链表","_content":"\n题目地址：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\n\n# 双指针迭代\n\n我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。\n\n第二个指针 cur 指向 head，然后不断遍历 cur。\n\n每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。\n\n都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null) {\n            //记录当前节点的下一个节点\n            ListNode tmp = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n}\n```\n\n# 递归\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) {\n            return head;\n        }\n        //这里的cur就是最后一个节点\n        ListNode cur = reverseList(head.next);\n        //如果链表是 1->2->3->4->5，那么此时的cur就是5\n        //而head是4，head的下一个是5，下下一个是空\n        //所以head.next.next 就是5->4\n        head.next.next = head;\n        //防止链表循环，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/24反转链表.md","raw":"---\ntitle: 24反转链表\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\n\n# 双指针迭代\n\n我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。\n\n第二个指针 cur 指向 head，然后不断遍历 cur。\n\n每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。\n\n都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null) {\n            //记录当前节点的下一个节点\n            ListNode tmp = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = tmp;\n        }\n        return pre;\n    }\n}\n```\n\n# 递归\n\n```java\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) {\n            return head;\n        }\n        //这里的cur就是最后一个节点\n        ListNode cur = reverseList(head.next);\n        //如果链表是 1->2->3->4->5，那么此时的cur就是5\n        //而head是4，head的下一个是5，下下一个是空\n        //所以head.next.next 就是5->4\n        head.next.next = head;\n        //防止链表循环，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    }\n}\n```\n\n","slug":"剑指OFFER/24反转链表","published":1,"date":"2021-09-01T05:22:18.214Z","updated":"2022-01-28T17:12:01.841Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwja00g8fhjid1a2h76n","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/</a></p>\n<h1 id=\"双指针迭代\"><a href=\"#双指针迭代\" class=\"headerlink\" title=\"双指针迭代\"></a>双指针迭代</h1><p>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。</p>\n<p>第二个指针 cur 指向 head，然后不断遍历 cur。</p>\n<p>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。</p>\n<p>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null) &#123;\n            //记录当前节点的下一个节点\n            ListNode tmp = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = tmp;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) &#123;\n            return head;\n        &#125;\n        //这里的cur就是最后一个节点\n        ListNode cur = reverseList(head.next);\n        //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5\n        //而head是4，head的下一个是5，下下一个是空\n        //所以head.next.next 就是5-&gt;4\n        head.next.next = head;\n        //防止链表循环，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/\">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/</a></p>\n<h1 id=\"双指针迭代\"><a href=\"#双指针迭代\" class=\"headerlink\" title=\"双指针迭代\"></a>双指针迭代</h1><p>我们可以申请两个指针，第一个指针叫 pre，最初是指向 null 的。</p>\n<p>第二个指针 cur 指向 head，然后不断遍历 cur。</p>\n<p>每次迭代到 cur，都将 cur 的 next 指向 pre，然后 pre 和 cur 前进一位。</p>\n<p>都迭代完了(cur 变成 null 了)，pre 就是最后一个节点了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        ListNode pre = null;\n        ListNode cur = head;\n        while(cur!=null) &#123;\n            //记录当前节点的下一个节点\n            ListNode tmp = cur.next;\n            //然后将当前节点指向pre\n            cur.next = pre;\n            //pre和cur节点都前进一位\n            pre = cur;\n            cur = tmp;\n        &#125;\n        return pre;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode reverseList(ListNode head) &#123;\n        //递归终止条件是当前为空，或者下一个节点为空\n        if(head==null || head.next==null) &#123;\n            return head;\n        &#125;\n        //这里的cur就是最后一个节点\n        ListNode cur = reverseList(head.next);\n        //如果链表是 1-&gt;2-&gt;3-&gt;4-&gt;5，那么此时的cur就是5\n        //而head是4，head的下一个是5，下下一个是空\n        //所以head.next.next 就是5-&gt;4\n        head.next.next = head;\n        //防止链表循环，需要将head.next设置为空\n        head.next = null;\n        //每层递归函数都返回cur，也就是最后一个节点\n        return cur;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"22链表中倒数第K个节点","_content":"\n题目地址：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\n\n```javascript\nclass Solution {\n    public ListNode getKthFromEnd(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        //1->2->3->4->5\n        ListNode pre = head, after = head;\n        for (int i = 0; i < k;i++) {\n            pre = pre.next;\n        }\n        while (pre != null) {\n            pre = pre.next;\n            after = after.next;\n        }\n        return after;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/22链表中倒数第K个节点.md","raw":"---\ntitle: 22链表中倒数第K个节点\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\n\n```javascript\nclass Solution {\n    public ListNode getKthFromEnd(ListNode head, int k) {\n        if (head == null) {\n            return null;\n        }\n        //1->2->3->4->5\n        ListNode pre = head, after = head;\n        for (int i = 0; i < k;i++) {\n            pre = pre.next;\n        }\n        while (pre != null) {\n            pre = pre.next;\n            after = after.next;\n        }\n        return after;\n    }\n}\n```\n\n","slug":"剑指OFFER/22链表中倒数第K个节点","published":1,"date":"2021-09-01T05:22:18.214Z","updated":"2022-01-28T17:11:57.981Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwja00g9fhji9f6bakrv","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>\n<pre><code class=\"javascript\">class Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n        //1-&gt;2-&gt;3-&gt;4-&gt;5\n        ListNode pre = head, after = head;\n        for (int i = 0; i &lt; k;i++) &#123;\n            pre = pre.next;\n        &#125;\n        while (pre != null) &#123;\n            pre = pre.next;\n            after = after.next;\n        &#125;\n        return after;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/\">https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/</a></p>\n<pre><code class=\"javascript\">class Solution &#123;\n    public ListNode getKthFromEnd(ListNode head, int k) &#123;\n        if (head == null) &#123;\n            return null;\n        &#125;\n        //1-&gt;2-&gt;3-&gt;4-&gt;5\n        ListNode pre = head, after = head;\n        for (int i = 0; i &lt; k;i++) &#123;\n            pre = pre.next;\n        &#125;\n        while (pre != null) &#123;\n            pre = pre.next;\n            after = after.next;\n        &#125;\n        return after;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"25合并两个排序的链表","_content":"\n题目地址：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\n\n# 迭代\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null || l2 == null) {\n            return l1 == null ? l2 : l1;\n        }\n\n        ListNode head = new ListNode(-1);//新增头节点\n        ListNode cur = head;//指向已合并部分链表的最后一个节点\n\n        while(l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        //不为空的那条链表的剩余部分接在合并链表的末尾\n        cur.next = (l1 == null ? l2 : l1);\n        return head.next;\n    }\n}\n```\n\n# 递归\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        if (l2 == null) {\n            return l1;\n        }\n        if (l1.val <= l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/25合并两个排序的链表.md","raw":"---\ntitle: 25合并两个排序的链表\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\n\n# 迭代\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null || l2 == null) {\n            return l1 == null ? l2 : l1;\n        }\n\n        ListNode head = new ListNode(-1);//新增头节点\n        ListNode cur = head;//指向已合并部分链表的最后一个节点\n\n        while(l1 != null && l2 != null) {\n            if (l1.val <= l2.val) {\n                cur.next = l1;\n                l1 = l1.next;\n            } else {\n                cur.next = l2;\n                l2 = l2.next;\n            }\n            cur = cur.next;\n        }\n        //不为空的那条链表的剩余部分接在合并链表的末尾\n        cur.next = (l1 == null ? l2 : l1);\n        return head.next;\n    }\n}\n```\n\n# 递归\n\n```java\nclass Solution {\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        if (l1 == null) {\n            return l2;\n        }\n        if (l2 == null) {\n            return l1;\n        }\n        if (l1.val <= l2.val) {\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        } else {\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        }\n    }\n}\n```\n\n","slug":"剑指OFFER/25合并两个排序的链表","published":1,"date":"2021-09-01T05:22:18.214Z","updated":"2022-01-28T17:12:05.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjb00gcfhji6kdm1owl","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        if (l1 == null || l2 == null) &#123;\n            return l1 == null ? l2 : l1;\n        &#125;\n\n        ListNode head = new ListNode(-1);//新增头节点\n        ListNode cur = head;//指向已合并部分链表的最后一个节点\n\n        while(l1 != null &amp;&amp; l2 != null) &#123;\n            if (l1.val &lt;= l2.val) &#123;\n                cur.next = l1;\n                l1 = l1.next;\n            &#125; else &#123;\n                cur.next = l2;\n                l2 = l2.next;\n            &#125;\n            cur = cur.next;\n        &#125;\n        //不为空的那条链表的剩余部分接在合并链表的末尾\n        cur.next = (l1 == null ? l2 : l1);\n        return head.next;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        if (l1 == null) &#123;\n            return l2;\n        &#125;\n        if (l2 == null) &#123;\n            return l1;\n        &#125;\n        if (l1.val &lt;= l2.val) &#123;\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        &#125; else &#123;\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/\">https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/</a></p>\n<h1 id=\"迭代\"><a href=\"#迭代\" class=\"headerlink\" title=\"迭代\"></a>迭代</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        if (l1 == null || l2 == null) &#123;\n            return l1 == null ? l2 : l1;\n        &#125;\n\n        ListNode head = new ListNode(-1);//新增头节点\n        ListNode cur = head;//指向已合并部分链表的最后一个节点\n\n        while(l1 != null &amp;&amp; l2 != null) &#123;\n            if (l1.val &lt;= l2.val) &#123;\n                cur.next = l1;\n                l1 = l1.next;\n            &#125; else &#123;\n                cur.next = l2;\n                l2 = l2.next;\n            &#125;\n            cur = cur.next;\n        &#125;\n        //不为空的那条链表的剩余部分接在合并链表的末尾\n        cur.next = (l1 == null ? l2 : l1);\n        return head.next;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;\n        if (l1 == null) &#123;\n            return l2;\n        &#125;\n        if (l2 == null) &#123;\n            return l1;\n        &#125;\n        if (l1.val &lt;= l2.val) &#123;\n            l1.next = mergeTwoLists(l1.next, l2);\n            return l1;\n        &#125; else &#123;\n            l2.next = mergeTwoLists(l1, l2.next);\n            return l2;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"26树的子结构","_content":"\n题目地址：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\n\n```java\nclass Solution {\n    public boolean isSubStructure(TreeNode A, TreeNode B) {\n        if (A == null || B == null) {\n            return false;\n        }\n        //先从根节点判断B是不是A的子结构，如果不是在分别从左右两个子树判断\n        //只要有一个为true，就说明B是A的子结构\n        return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);\n    }\n\n    boolean isSub(TreeNode A, TreeNode B) {\n        //这里如果B为空，说明B已经访问完了，确定是A的子结构\n        if (B == null) {\n            return true;\n        }\n        //如果B不为空A为空，或者这两个节点值不同，说明B树不是A的子结构，直接返回false\n        if (A == null || A.val != B.val) {\n            return false;\n        }\n        //当前节点比较完之后还要继续判断左右子节点\n        return isSub(A.left, B.left) && isSub(A.right, B.right);\n    }\n}\n```\n\n时间复杂度 O(MN) ： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 isSub(A, B) 判断占用 O(N) 。\n\n空间复杂度 O(M) ","source":"_posts/剑指OFFER/26树的子结构.md","raw":"---\ntitle: 26树的子结构\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\n\n```java\nclass Solution {\n    public boolean isSubStructure(TreeNode A, TreeNode B) {\n        if (A == null || B == null) {\n            return false;\n        }\n        //先从根节点判断B是不是A的子结构，如果不是在分别从左右两个子树判断\n        //只要有一个为true，就说明B是A的子结构\n        return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);\n    }\n\n    boolean isSub(TreeNode A, TreeNode B) {\n        //这里如果B为空，说明B已经访问完了，确定是A的子结构\n        if (B == null) {\n            return true;\n        }\n        //如果B不为空A为空，或者这两个节点值不同，说明B树不是A的子结构，直接返回false\n        if (A == null || A.val != B.val) {\n            return false;\n        }\n        //当前节点比较完之后还要继续判断左右子节点\n        return isSub(A.left, B.left) && isSub(A.right, B.right);\n    }\n}\n```\n\n时间复杂度 O(MN) ： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 isSub(A, B) 判断占用 O(N) 。\n\n空间复杂度 O(M) ","slug":"剑指OFFER/26树的子结构","published":1,"date":"2021-09-01T05:22:18.214Z","updated":"2022-01-28T17:12:09.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjc00gdfhjibm9q0757","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;\n        if (A == null || B == null) &#123;\n            return false;\n        &#125;\n        //先从根节点判断B是不是A的子结构，如果不是在分别从左右两个子树判断\n        //只要有一个为true，就说明B是A的子结构\n        return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);\n    &#125;\n\n    boolean isSub(TreeNode A, TreeNode B) &#123;\n        //这里如果B为空，说明B已经访问完了，确定是A的子结构\n        if (B == null) &#123;\n            return true;\n        &#125;\n        //如果B不为空A为空，或者这两个节点值不同，说明B树不是A的子结构，直接返回false\n        if (A == null || A.val != B.val) &#123;\n            return false;\n        &#125;\n        //当前节点比较完之后还要继续判断左右子节点\n        return isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(MN) ： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 isSub(A, B) 判断占用 O(N) 。</p>\n<p>空间复杂度 O(M) </p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/\">https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean isSubStructure(TreeNode A, TreeNode B) &#123;\n        if (A == null || B == null) &#123;\n            return false;\n        &#125;\n        //先从根节点判断B是不是A的子结构，如果不是在分别从左右两个子树判断\n        //只要有一个为true，就说明B是A的子结构\n        return isSub(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);\n    &#125;\n\n    boolean isSub(TreeNode A, TreeNode B) &#123;\n        //这里如果B为空，说明B已经访问完了，确定是A的子结构\n        if (B == null) &#123;\n            return true;\n        &#125;\n        //如果B不为空A为空，或者这两个节点值不同，说明B树不是A的子结构，直接返回false\n        if (A == null || A.val != B.val) &#123;\n            return false;\n        &#125;\n        //当前节点比较完之后还要继续判断左右子节点\n        return isSub(A.left, B.left) &amp;&amp; isSub(A.right, B.right);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(MN) ： 其中 M,N 分别为树 A 和 树 B 的节点数量；先序遍历树 A 占用 O(M) ，每次调用 isSub(A, B) 判断占用 O(N) 。</p>\n<p>空间复杂度 O(M) </p>\n"},{"title":"27二叉树的镜像","_content":"\n题目地址：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\n\n# 队列\n\n```java\nclass Solution {\n    public TreeNode mirrorTree(TreeNode root) {\n         if (root == null) {\n             return root;\n         }\n         Queue<TreeNode> queue = new LinkedList<>();\n         queue.offer(root);\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n             if (node.left != null) {\n                 queue.offer(node.left);\n             }\n             if (node.right != null) {\n                 queue.offer(node.right);\n             }\n             //交换左右节点\n             TreeNode temp = node.left;\n             node.left = node.right;\n             node.right = temp;\n         }\n         return root;\n    }\n}\n```\n\n时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。\n\n空间复杂度 O(N)\n\n# 递归\n\n```java\nclass Solution {\n    public TreeNode mirrorTree(TreeNode root) {\n         if (root == null) {\n             return root;\n         }\n         TreeNode temp = root.left;\n         root.left = root.right;\n         root.right = temp;\n         mirrorTree(root.left);\n         mirrorTree(root.right);\n         return root;\n    }\n}\n```\n\n时间复杂度 O(N)： 其中 N 为二叉树的节点数量\n\n空间复杂度 O(N) ","source":"_posts/剑指OFFER/27二叉树的镜像.md","raw":"---\ntitle: 27二叉树的镜像\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\n\n# 队列\n\n```java\nclass Solution {\n    public TreeNode mirrorTree(TreeNode root) {\n         if (root == null) {\n             return root;\n         }\n         Queue<TreeNode> queue = new LinkedList<>();\n         queue.offer(root);\n         while(!queue.isEmpty()) {\n             TreeNode node = queue.poll();\n             if (node.left != null) {\n                 queue.offer(node.left);\n             }\n             if (node.right != null) {\n                 queue.offer(node.right);\n             }\n             //交换左右节点\n             TreeNode temp = node.left;\n             node.left = node.right;\n             node.right = temp;\n         }\n         return root;\n    }\n}\n```\n\n时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。\n\n空间复杂度 O(N)\n\n# 递归\n\n```java\nclass Solution {\n    public TreeNode mirrorTree(TreeNode root) {\n         if (root == null) {\n             return root;\n         }\n         TreeNode temp = root.left;\n         root.left = root.right;\n         root.right = temp;\n         mirrorTree(root.left);\n         mirrorTree(root.right);\n         return root;\n    }\n}\n```\n\n时间复杂度 O(N)： 其中 N 为二叉树的节点数量\n\n空间复杂度 O(N) ","slug":"剑指OFFER/27二叉树的镜像","published":1,"date":"2021-09-01T05:22:18.214Z","updated":"2022-01-28T17:12:15.454Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjc00ggfhjigcc17i0j","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode mirrorTree(TreeNode root) &#123;\n         if (root == null) &#123;\n             return root;\n         &#125;\n         Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n         queue.offer(root);\n         while(!queue.isEmpty()) &#123;\n             TreeNode node = queue.poll();\n             if (node.left != null) &#123;\n                 queue.offer(node.left);\n             &#125;\n             if (node.right != null) &#123;\n                 queue.offer(node.right);\n             &#125;\n             //交换左右节点\n             TreeNode temp = node.left;\n             node.left = node.right;\n             node.right = temp;\n         &#125;\n         return root;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。</p>\n<p>空间复杂度 O(N)</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode mirrorTree(TreeNode root) &#123;\n         if (root == null) &#123;\n             return root;\n         &#125;\n         TreeNode temp = root.left;\n         root.left = root.right;\n         root.right = temp;\n         mirrorTree(root.left);\n         mirrorTree(root.right);\n         return root;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)： 其中 N 为二叉树的节点数量</p>\n<p>空间复杂度 O(N) </p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/\">https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/</a></p>\n<h1 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode mirrorTree(TreeNode root) &#123;\n         if (root == null) &#123;\n             return root;\n         &#125;\n         Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n         queue.offer(root);\n         while(!queue.isEmpty()) &#123;\n             TreeNode node = queue.poll();\n             if (node.left != null) &#123;\n                 queue.offer(node.left);\n             &#125;\n             if (node.right != null) &#123;\n                 queue.offer(node.right);\n             &#125;\n             //交换左右节点\n             TreeNode temp = node.left;\n             node.left = node.right;\n             node.right = temp;\n         &#125;\n         return root;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： 其中 N 为二叉树的节点数量，建立二叉树镜像需要遍历树的所有节点，占用 O(N) 时间。</p>\n<p>空间复杂度 O(N)</p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><pre><code class=\"java\">class Solution &#123;\n    public TreeNode mirrorTree(TreeNode root) &#123;\n         if (root == null) &#123;\n             return root;\n         &#125;\n         TreeNode temp = root.left;\n         root.left = root.right;\n         root.right = temp;\n         mirrorTree(root.left);\n         mirrorTree(root.right);\n         return root;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)： 其中 N 为二叉树的节点数量</p>\n<p>空间复杂度 O(N) </p>\n"},{"title":"31栈的压入、弹出序列","_content":"\n题目地址:https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序\n\n例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列（注意：这两个序列的长度是相等的）\n\n```java\nclass Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        Stack<Integer> stack = new Stack<>();\n        int popIndex = 0;\n        for (int i = 0; i < pushed.length; i++){\n            stack.push(pushed[i]);\n            while(!stack.isEmpty()&&stack.peek()==popped[popIndex]) {\n                stack.pop();\n                popIndex++;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/31栈的压入、弹出序列.md","raw":"---\ntitle: 31栈的压入、弹出序列\ncategories:\n- 剑指OFFER\n---\n\n题目地址:https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\n\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序\n\n例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列（注意：这两个序列的长度是相等的）\n\n```java\nclass Solution {\n    public boolean validateStackSequences(int[] pushed, int[] popped) {\n        Stack<Integer> stack = new Stack<>();\n        int popIndex = 0;\n        for (int i = 0; i < pushed.length; i++){\n            stack.push(pushed[i]);\n            while(!stack.isEmpty()&&stack.peek()==popped[popIndex]) {\n                stack.pop();\n                popIndex++;\n            }\n        }\n        return stack.isEmpty();\n    }\n}\n```\n\n","slug":"剑指OFFER/31栈的压入、弹出序列","published":1,"date":"2021-09-01T05:22:18.214Z","updated":"2022-01-28T17:12:19.299Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjd00ghfhji69yxamds","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</a></p>\n<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序</p>\n<p>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列（注意：这两个序列的长度是相等的）</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;\n        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n        int popIndex = 0;\n        for (int i = 0; i &lt; pushed.length; i++)&#123;\n            stack.push(pushed[i]);\n            while(!stack.isEmpty()&amp;&amp;stack.peek()==popped[popIndex]) &#123;\n                stack.pop();\n                popIndex++;\n            &#125;\n        &#125;\n        return stack.isEmpty();\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/\">https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/</a></p>\n<p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序</p>\n<p>例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，但4,3,5,1,2就不可能是该压栈序列的弹出序列（注意：这两个序列的长度是相等的）</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean validateStackSequences(int[] pushed, int[] popped) &#123;\n        Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n        int popIndex = 0;\n        for (int i = 0; i &lt; pushed.length; i++)&#123;\n            stack.push(pushed[i]);\n            while(!stack.isEmpty()&amp;&amp;stack.peek()==popped[popIndex]) &#123;\n                stack.pop();\n                popIndex++;\n            &#125;\n        &#125;\n        return stack.isEmpty();\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"32III从上到下打印二叉树III","_content":"\n题目地址：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        List<List<Integer>> res = new ArrayList<>();\n        if(root != null) {\n            queue.add(root);\n        }\n        while(!queue.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            for(int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if(node.left != null) {\n                    queue.add(node.left);\n                }\n                if(node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n            if((res.size() & 1) == 1) {\n                Collections.reverse(tmp);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/32III从上到下打印二叉树III.md","raw":"---\ntitle: 32III从上到下打印二叉树III\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        List<List<Integer>> res = new ArrayList<>();\n        if(root != null) {\n            queue.add(root);\n        }\n        while(!queue.isEmpty()) {\n            List<Integer> tmp = new ArrayList<>();\n            for(int i = queue.size(); i > 0; i--) {\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if(node.left != null) {\n                    queue.add(node.left);\n                }\n                if(node.right != null) {\n                    queue.add(node.right);\n                }\n            }\n            if((res.size() & 1) == 1) {\n                Collections.reverse(tmp);\n            }\n            res.add(tmp);\n        }\n        return res;\n    }\n}\n```\n\n","slug":"剑指OFFER/32III从上到下打印二叉树III","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:12:25.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwje00gkfhjies0ng2wu","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        if(root != null) &#123;\n            queue.add(root);\n        &#125;\n        while(!queue.isEmpty()) &#123;\n            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n            for(int i = queue.size(); i &gt; 0; i--) &#123;\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if(node.left != null) &#123;\n                    queue.add(node.left);\n                &#125;\n                if(node.right != null) &#123;\n                    queue.add(node.right);\n                &#125;\n            &#125;\n            if((res.size() &amp; 1) == 1) &#123;\n                Collections.reverse(tmp);\n            &#125;\n            res.add(tmp);\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/\">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        if(root != null) &#123;\n            queue.add(root);\n        &#125;\n        while(!queue.isEmpty()) &#123;\n            List&lt;Integer&gt; tmp = new ArrayList&lt;&gt;();\n            for(int i = queue.size(); i &gt; 0; i--) &#123;\n                TreeNode node = queue.poll();\n                tmp.add(node.val);\n                if(node.left != null) &#123;\n                    queue.add(node.left);\n                &#125;\n                if(node.right != null) &#123;\n                    queue.add(node.right);\n                &#125;\n            &#125;\n            if((res.size() &amp; 1) == 1) &#123;\n                Collections.reverse(tmp);\n            &#125;\n            res.add(tmp);\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"32II从上到下打印二叉树II","_content":"\n题目地址：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root==null) {\n            return result;\n        }\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> temp = new ArrayList<>();\n            for (int i = 0;i<size;i++) {\n                TreeNode node = queue.poll();\n                temp.add(node.val);\n                if (node.left!=null) {\n                    queue.add(node.left);\n                }\n                if (node.right!=null) {\n                    queue.add(node.right);\n                }\n            }\n            result.add(temp);\n        }\n        return result;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/32II从上到下打印二叉树II.md","raw":"---\ntitle: 32II从上到下打印二叉树II\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\n\n```java\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root==null) {\n            return result;\n        }\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.add(root);\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> temp = new ArrayList<>();\n            for (int i = 0;i<size;i++) {\n                TreeNode node = queue.poll();\n                temp.add(node.val);\n                if (node.left!=null) {\n                    queue.add(node.left);\n                }\n                if (node.right!=null) {\n                    queue.add(node.right);\n                }\n            }\n            result.add(temp);\n        }\n        return result;\n    }\n}\n```\n\n","slug":"剑指OFFER/32II从上到下打印二叉树II","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:12:29.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwje00glfhji6q1z4qp9","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (root==null) &#123;\n            return result;\n        &#125;\n\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        while(!queue.isEmpty()) &#123;\n            int size = queue.size();\n            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();\n            for (int i = 0;i&lt;size;i++) &#123;\n                TreeNode node = queue.poll();\n                temp.add(node.val);\n                if (node.left!=null) &#123;\n                    queue.add(node.left);\n                &#125;\n                if (node.right!=null) &#123;\n                    queue.add(node.right);\n                &#125;\n            &#125;\n            result.add(temp);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/\">https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/</a></p>\n<pre><code class=\"java\">class Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;\n        List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();\n        if (root==null) &#123;\n            return result;\n        &#125;\n\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.add(root);\n        while(!queue.isEmpty()) &#123;\n            int size = queue.size();\n            List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();\n            for (int i = 0;i&lt;size;i++) &#123;\n                TreeNode node = queue.poll();\n                temp.add(node.val);\n                if (node.left!=null) &#123;\n                    queue.add(node.left);\n                &#125;\n                if (node.right!=null) &#123;\n                    queue.add(node.right);\n                &#125;\n            &#125;\n            result.add(temp);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"33二叉搜索树的后序遍历序列","_content":"\n题目地址：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/\n\n比如下面这棵二叉树，他的后续遍历是[3，5，4，10，12，9]\n\n我们知道后续遍历的最后一个数字一定是根节点，所以数组中最后一个数字9就是根节点，我们从前往后找到第一个比9大的数字10，那么10后面的[10，12]（除了9）都是9的右子节点，10前面的[3，5，4]都是9的左子节点，后面的需要判断一下，如果有小于9的，说明不是二叉搜索树，直接返回false。\n\n然后再以递归的方式判断左右子树。\n\n```java\nclass Solution {\n    public boolean verifyPostorder(int[] postorder) {\n        return helper(postorder, 0, postorder.length - 1);\n    }\n\n    private boolean helper(int[] postorder, int left, int right) {\n        //如果left==right，就一个节点不需要判断了，如果left>right说明没有节点\n        if (left >= right) {\n            return true;\n        }\n        //因为数组中最后一个值postorder[right]是根节点，这里从左往右找出第一个比根节点大的值\n        //他后面的都是根节点的右子节点（不包含最后一个值，因为最后一个是根节点），他前面的都是根节点的左子节点\n        int mid = left;\n        int root = postorder[right];\n        while (postorder[mid] < root) {\n            mid++;\n        }\n        int temp = mid;\n        //因为postorder[mid]前面的值都是比根节点root小的，我们还需要确定postorder[mid]后面的值都要比根节点root大\n        //如果后面有比根节点小的直接返回false\n        while (temp < right) {\n            if (postorder[temp++] < root) {\n                return false;\n            }\n        }\n        //然后对左右子节点进行递归调用\n        return helper(postorder, left, mid - 1) && helper(postorder, mid, right - 1);\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/33二叉搜索树的后序遍历序列.md","raw":"---\ntitle: 33二叉搜索树的后序遍历序列\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/\n\n比如下面这棵二叉树，他的后续遍历是[3，5，4，10，12，9]\n\n我们知道后续遍历的最后一个数字一定是根节点，所以数组中最后一个数字9就是根节点，我们从前往后找到第一个比9大的数字10，那么10后面的[10，12]（除了9）都是9的右子节点，10前面的[3，5，4]都是9的左子节点，后面的需要判断一下，如果有小于9的，说明不是二叉搜索树，直接返回false。\n\n然后再以递归的方式判断左右子树。\n\n```java\nclass Solution {\n    public boolean verifyPostorder(int[] postorder) {\n        return helper(postorder, 0, postorder.length - 1);\n    }\n\n    private boolean helper(int[] postorder, int left, int right) {\n        //如果left==right，就一个节点不需要判断了，如果left>right说明没有节点\n        if (left >= right) {\n            return true;\n        }\n        //因为数组中最后一个值postorder[right]是根节点，这里从左往右找出第一个比根节点大的值\n        //他后面的都是根节点的右子节点（不包含最后一个值，因为最后一个是根节点），他前面的都是根节点的左子节点\n        int mid = left;\n        int root = postorder[right];\n        while (postorder[mid] < root) {\n            mid++;\n        }\n        int temp = mid;\n        //因为postorder[mid]前面的值都是比根节点root小的，我们还需要确定postorder[mid]后面的值都要比根节点root大\n        //如果后面有比根节点小的直接返回false\n        while (temp < right) {\n            if (postorder[temp++] < root) {\n                return false;\n            }\n        }\n        //然后对左右子节点进行递归调用\n        return helper(postorder, left, mid - 1) && helper(postorder, mid, right - 1);\n    }\n}\n```\n\n","slug":"剑指OFFER/33二叉搜索树的后序遍历序列","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:12:42.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjf00gofhjib68ubtv3","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/\">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p>\n<p>比如下面这棵二叉树，他的后续遍历是[3，5，4，10，12，9]</p>\n<p>我们知道后续遍历的最后一个数字一定是根节点，所以数组中最后一个数字9就是根节点，我们从前往后找到第一个比9大的数字10，那么10后面的[10，12]（除了9）都是9的右子节点，10前面的[3，5，4]都是9的左子节点，后面的需要判断一下，如果有小于9的，说明不是二叉搜索树，直接返回false。</p>\n<p>然后再以递归的方式判断左右子树。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean verifyPostorder(int[] postorder) &#123;\n        return helper(postorder, 0, postorder.length - 1);\n    &#125;\n\n    private boolean helper(int[] postorder, int left, int right) &#123;\n        //如果left==right，就一个节点不需要判断了，如果left&gt;right说明没有节点\n        if (left &gt;= right) &#123;\n            return true;\n        &#125;\n        //因为数组中最后一个值postorder[right]是根节点，这里从左往右找出第一个比根节点大的值\n        //他后面的都是根节点的右子节点（不包含最后一个值，因为最后一个是根节点），他前面的都是根节点的左子节点\n        int mid = left;\n        int root = postorder[right];\n        while (postorder[mid] &lt; root) &#123;\n            mid++;\n        &#125;\n        int temp = mid;\n        //因为postorder[mid]前面的值都是比根节点root小的，我们还需要确定postorder[mid]后面的值都要比根节点root大\n        //如果后面有比根节点小的直接返回false\n        while (temp &lt; right) &#123;\n            if (postorder[temp++] &lt; root) &#123;\n                return false;\n            &#125;\n        &#125;\n        //然后对左右子节点进行递归调用\n        return helper(postorder, left, mid - 1) &amp;&amp; helper(postorder, mid, right - 1);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/\">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/</a></p>\n<p>比如下面这棵二叉树，他的后续遍历是[3，5，4，10，12，9]</p>\n<p>我们知道后续遍历的最后一个数字一定是根节点，所以数组中最后一个数字9就是根节点，我们从前往后找到第一个比9大的数字10，那么10后面的[10，12]（除了9）都是9的右子节点，10前面的[3，5，4]都是9的左子节点，后面的需要判断一下，如果有小于9的，说明不是二叉搜索树，直接返回false。</p>\n<p>然后再以递归的方式判断左右子树。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean verifyPostorder(int[] postorder) &#123;\n        return helper(postorder, 0, postorder.length - 1);\n    &#125;\n\n    private boolean helper(int[] postorder, int left, int right) &#123;\n        //如果left==right，就一个节点不需要判断了，如果left&gt;right说明没有节点\n        if (left &gt;= right) &#123;\n            return true;\n        &#125;\n        //因为数组中最后一个值postorder[right]是根节点，这里从左往右找出第一个比根节点大的值\n        //他后面的都是根节点的右子节点（不包含最后一个值，因为最后一个是根节点），他前面的都是根节点的左子节点\n        int mid = left;\n        int root = postorder[right];\n        while (postorder[mid] &lt; root) &#123;\n            mid++;\n        &#125;\n        int temp = mid;\n        //因为postorder[mid]前面的值都是比根节点root小的，我们还需要确定postorder[mid]后面的值都要比根节点root大\n        //如果后面有比根节点小的直接返回false\n        while (temp &lt; right) &#123;\n            if (postorder[temp++] &lt; root) &#123;\n                return false;\n            &#125;\n        &#125;\n        //然后对左右子节点进行递归调用\n        return helper(postorder, left, mid - 1) &amp;&amp; helper(postorder, mid, right - 1);\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"39数组中出现次数超过一半的数字","_content":"\n题目地址：https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/\n\n和LeetCode题目：169多数元素类似\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int result = nums[0], count = 1;\n        for (int num : nums) {\n            if (num == result) {\n                count++;\n            } else {\n                count--;\n            }\n            if (count == 0) {\n                count = 1;\n                result = num;\n            }\n        }\n        return result;\n    }\n}\n```","source":"_posts/剑指OFFER/39数组中出现次数超过一半的数字.md","raw":"---\ntitle: 39数组中出现次数超过一半的数字\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/\n\n和LeetCode题目：169多数元素类似\n\n```java\nclass Solution {\n    public int majorityElement(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int result = nums[0], count = 1;\n        for (int num : nums) {\n            if (num == result) {\n                count++;\n            } else {\n                count--;\n            }\n            if (count == 0) {\n                count = 1;\n                result = num;\n            }\n        }\n        return result;\n    }\n}\n```","slug":"剑指OFFER/39数组中出现次数超过一半的数字","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:12:46.448Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjf00gpfhjidffb8qzm","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/\">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</a></p>\n<p>和LeetCode题目：169多数元素类似</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int majorityElement(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int result = nums[0], count = 1;\n        for (int num : nums) &#123;\n            if (num == result) &#123;\n                count++;\n            &#125; else &#123;\n                count--;\n            &#125;\n            if (count == 0) &#123;\n                count = 1;\n                result = num;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/\">https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/</a></p>\n<p>和LeetCode题目：169多数元素类似</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int majorityElement(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int result = nums[0], count = 1;\n        for (int num : nums) &#123;\n            if (num == result) &#123;\n                count++;\n            &#125; else &#123;\n                count--;\n            &#125;\n            if (count == 0) &#123;\n                count = 1;\n                result = num;\n            &#125;\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"3数组中重复的数字","_content":"\n题目地址：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\n\n遍历数组 nums ，设索引初始值为 i = 0:\n\n若 `nums[i] == i` ： 说明此数字已在对应索引位置，无需交换，因此执行 i += 1 与 continue ；\n\n若 `nums[nums[i]] == nums[i]` ： 说明索引` nums[i] `处的元素值也为 `nums[i]`，即找到一组相同值，返回此值 nums[i]；\n\n否则： 当前数字是第一次遇到，因此交换索引为 i 和 `nums[i]` 的元素值，将此数字交换至对应索引位置。\n\n若遍历完毕尚未返回，则返回 −1 ，代表数组中无相同值。\n\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int i = 0;\n        while (i < nums.length) {\n            if (nums[i] == i) {\n                i++;\n                continue;\n            }\n            if (nums[i] == nums[nums[i]]) {\n                return nums[i];\n            }\n            int temp = nums[i];\n            nums[i] = nums[temp];\n            nums[temp] = temp;\n        }\n        return -1;\n    }\n}\n```\n\n时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。\n\n空间复杂度 O(1) ： 使用常数复杂度的额外空间","source":"_posts/剑指OFFER/3数组中重复的数字.md","raw":"---\ntitle: 3数组中重复的数字\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\n\n遍历数组 nums ，设索引初始值为 i = 0:\n\n若 `nums[i] == i` ： 说明此数字已在对应索引位置，无需交换，因此执行 i += 1 与 continue ；\n\n若 `nums[nums[i]] == nums[i]` ： 说明索引` nums[i] `处的元素值也为 `nums[i]`，即找到一组相同值，返回此值 nums[i]；\n\n否则： 当前数字是第一次遇到，因此交换索引为 i 和 `nums[i]` 的元素值，将此数字交换至对应索引位置。\n\n若遍历完毕尚未返回，则返回 −1 ，代表数组中无相同值。\n\n```java\nclass Solution {\n    public int findRepeatNumber(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return -1;\n        }\n        int i = 0;\n        while (i < nums.length) {\n            if (nums[i] == i) {\n                i++;\n                continue;\n            }\n            if (nums[i] == nums[nums[i]]) {\n                return nums[i];\n            }\n            int temp = nums[i];\n            nums[i] = nums[temp];\n            nums[temp] = temp;\n        }\n        return -1;\n    }\n}\n```\n\n时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。\n\n空间复杂度 O(1) ： 使用常数复杂度的额外空间","slug":"剑指OFFER/3数组中重复的数字","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:12:51.682Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjg00gsfhji4tu65brq","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></p>\n<p>遍历数组 nums ，设索引初始值为 i &#x3D; 0:</p>\n<p>若 <code>nums[i] == i</code> ： 说明此数字已在对应索引位置，无需交换，因此执行 i +&#x3D; 1 与 continue ；</p>\n<p>若 <code>nums[nums[i]] == nums[i]</code> ： 说明索引<code>nums[i]</code>处的元素值也为 <code>nums[i]</code>，即找到一组相同值，返回此值 nums[i]；</p>\n<p>否则： 当前数字是第一次遇到，因此交换索引为 i 和 <code>nums[i]</code> 的元素值，将此数字交换至对应索引位置。</p>\n<p>若遍历完毕尚未返回，则返回 −1 ，代表数组中无相同值。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int findRepeatNumber(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return -1;\n        &#125;\n        int i = 0;\n        while (i &lt; nums.length) &#123;\n            if (nums[i] == i) &#123;\n                i++;\n                continue;\n            &#125;\n            if (nums[i] == nums[nums[i]]) &#123;\n                return nums[i];\n            &#125;\n            int temp = nums[i];\n            nums[i] = nums[temp];\n            nums[temp] = temp;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。</p>\n<p>空间复杂度 O(1) ： 使用常数复杂度的额外空间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/\">https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/</a></p>\n<p>遍历数组 nums ，设索引初始值为 i &#x3D; 0:</p>\n<p>若 <code>nums[i] == i</code> ： 说明此数字已在对应索引位置，无需交换，因此执行 i +&#x3D; 1 与 continue ；</p>\n<p>若 <code>nums[nums[i]] == nums[i]</code> ： 说明索引<code>nums[i]</code>处的元素值也为 <code>nums[i]</code>，即找到一组相同值，返回此值 nums[i]；</p>\n<p>否则： 当前数字是第一次遇到，因此交换索引为 i 和 <code>nums[i]</code> 的元素值，将此数字交换至对应索引位置。</p>\n<p>若遍历完毕尚未返回，则返回 −1 ，代表数组中无相同值。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int findRepeatNumber(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return -1;\n        &#125;\n        int i = 0;\n        while (i &lt; nums.length) &#123;\n            if (nums[i] == i) &#123;\n                i++;\n                continue;\n            &#125;\n            if (nums[i] == nums[nums[i]]) &#123;\n                return nums[i];\n            &#125;\n            int temp = nums[i];\n            nums[i] = nums[temp];\n            nums[temp] = temp;\n        &#125;\n        return -1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： 遍历数组使用 O(N) ，每轮遍历的判断和交换操作使用 O(1) 。</p>\n<p>空间复杂度 O(1) ： 使用常数复杂度的额外空间</p>\n"},{"title":"41数据流中的中位数","_content":"\n题目地址：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\n\n```java\nclass MedianFinder {\n    Queue<Integer> A, B;\n    public MedianFinder() {\n        A = new PriorityQueue<>(); // 小顶堆，保存较大的一半\n        B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半\n    }\n    public void addNum(int num) {\n        if(A.size() != B.size()) {\n            A.add(num);\n            B.add(A.poll());\n        } else {\n            B.add(num);\n            A.add(B.poll());\n        }\n    }\n    public double findMedian() {\n        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/41数据流中的中位数.md","raw":"---\ntitle: 41数据流中的中位数\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\n\n```java\nclass MedianFinder {\n    Queue<Integer> A, B;\n    public MedianFinder() {\n        A = new PriorityQueue<>(); // 小顶堆，保存较大的一半\n        B = new PriorityQueue<>((x, y) -> (y - x)); // 大顶堆，保存较小的一半\n    }\n    public void addNum(int num) {\n        if(A.size() != B.size()) {\n            A.add(num);\n            B.add(A.poll());\n        } else {\n            B.add(num);\n            A.add(B.poll());\n        }\n    }\n    public double findMedian() {\n        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;\n    }\n}\n```\n\n","slug":"剑指OFFER/41数据流中的中位数","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:12:55.938Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjh00gtfhji56xahlzx","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p>\n<pre><code class=\"java\">class MedianFinder &#123;\n    Queue&lt;Integer&gt; A, B;\n    public MedianFinder() &#123;\n        A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半\n        B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半\n    &#125;\n    public void addNum(int num) &#123;\n        if(A.size() != B.size()) &#123;\n            A.add(num);\n            B.add(A.poll());\n        &#125; else &#123;\n            B.add(num);\n            A.add(B.poll());\n        &#125;\n    &#125;\n    public double findMedian() &#123;\n        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/\">https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/</a></p>\n<pre><code class=\"java\">class MedianFinder &#123;\n    Queue&lt;Integer&gt; A, B;\n    public MedianFinder() &#123;\n        A = new PriorityQueue&lt;&gt;(); // 小顶堆，保存较大的一半\n        B = new PriorityQueue&lt;&gt;((x, y) -&gt; (y - x)); // 大顶堆，保存较小的一半\n    &#125;\n    public void addNum(int num) &#123;\n        if(A.size() != B.size()) &#123;\n            A.add(num);\n            B.add(A.poll());\n        &#125; else &#123;\n            B.add(num);\n            A.add(B.poll());\n        &#125;\n    &#125;\n    public double findMedian() &#123;\n        return A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / 2.0;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"42连续子数组的最大和","_content":"\n题目地址：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\n\ndp方程：`dp[n] = Max(dp[n - 1] + arr[n], arr[n]);`\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int result = nums[0];\n        int current = nums[0];\n        for (int i = 1; i<nums.length;i++) {\n            current = Math.max(current + nums[i], nums[i]);\n            result = Math.max(result, current);\n        }\n        return result;\n    }\n}\n```\n\n这里使用了一个current变量，节省了一部分存储空间\n\n时间复杂度 O(N) ： 线性遍历数组 nums即可获得结果，使用 O(N) 时间。\n\n空间复杂度 O(1) ： 使用常数大小的额外空间","source":"_posts/剑指OFFER/42连续子数组的最大和.md","raw":"---\ntitle: 42连续子数组的最大和\ncategories:\n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\n\ndp方程：`dp[n] = Max(dp[n - 1] + arr[n], arr[n]);`\n\n```java\nclass Solution {\n    public int maxSubArray(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int result = nums[0];\n        int current = nums[0];\n        for (int i = 1; i<nums.length;i++) {\n            current = Math.max(current + nums[i], nums[i]);\n            result = Math.max(result, current);\n        }\n        return result;\n    }\n}\n```\n\n这里使用了一个current变量，节省了一部分存储空间\n\n时间复杂度 O(N) ： 线性遍历数组 nums即可获得结果，使用 O(N) 时间。\n\n空间复杂度 O(1) ： 使用常数大小的额外空间","slug":"剑指OFFER/42连续子数组的最大和","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:12:59.772Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjh00gwfhji9py61n7g","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</a></p>\n<p>dp方程：<code>dp[n] = Max(dp[n - 1] + arr[n], arr[n]);</code></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxSubArray(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int result = nums[0];\n        int current = nums[0];\n        for (int i = 1; i&lt;nums.length;i++) &#123;\n            current = Math.max(current + nums[i], nums[i]);\n            result = Math.max(result, current);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>这里使用了一个current变量，节省了一部分存储空间</p>\n<p>时间复杂度 O(N) ： 线性遍历数组 nums即可获得结果，使用 O(N) 时间。</p>\n<p>空间复杂度 O(1) ： 使用常数大小的额外空间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/\">https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/</a></p>\n<p>dp方程：<code>dp[n] = Max(dp[n - 1] + arr[n], arr[n]);</code></p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxSubArray(int[] nums) &#123;\n        if (nums == null || nums.length == 0) &#123;\n            return 0;\n        &#125;\n        int result = nums[0];\n        int current = nums[0];\n        for (int i = 1; i&lt;nums.length;i++) &#123;\n            current = Math.max(current + nums[i], nums[i]);\n            result = Math.max(result, current);\n        &#125;\n        return result;\n    &#125;\n&#125;\n</code></pre>\n<p>这里使用了一个current变量，节省了一部分存储空间</p>\n<p>时间复杂度 O(N) ： 线性遍历数组 nums即可获得结果，使用 O(N) 时间。</p>\n<p>空间复杂度 O(1) ： 使用常数大小的额外空间</p>\n"},{"title":"4二维数组中的查找","_content":"\n题目地址：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\n\n从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 `true`。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行\n\n```java\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n\n        int i = 0, j = matrix[0].length - 1;\n        while(i < matrix.length && j >= 0) {\n            if (matrix[i][j] == target) {\n                return true;\n            } else if (matrix[i][j] > target) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n        return false;\n    }\n}\n```\n\n时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。\n\n空间复杂度 O(1) : i, j 指针使用常数大小额外空间。","source":"_posts/剑指OFFER/4二维数组中的查找.md","raw":"---\ntitle: 4二维数组中的查找\ncategories:\n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\n\n从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 `true`。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行\n\n```java\nclass Solution {\n    public boolean findNumberIn2DArray(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0) {\n            return false;\n        }\n\n        int i = 0, j = matrix[0].length - 1;\n        while(i < matrix.length && j >= 0) {\n            if (matrix[i][j] == target) {\n                return true;\n            } else if (matrix[i][j] > target) {\n                j--;\n            } else {\n                i++;\n            }\n        }\n        return false;\n    }\n}\n```\n\n时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。\n\n空间复杂度 O(1) : i, j 指针使用常数大小额外空间。","slug":"剑指OFFER/4二维数组中的查找","published":1,"date":"2021-09-01T05:22:18.215Z","updated":"2022-01-28T17:13:03.692Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwji00gxfhji55j75op7","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p>\n<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 <code>true</code>。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;\n        if (matrix == null || matrix.length == 0) &#123;\n            return false;\n        &#125;\n\n        int i = 0, j = matrix[0].length - 1;\n        while(i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123;\n            if (matrix[i][j] == target) &#123;\n                return true;\n            &#125; else if (matrix[i][j] &gt; target) &#123;\n                j--;\n            &#125; else &#123;\n                i++;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。</p>\n<p>空间复杂度 O(1) : i, j 指针使用常数大小额外空间。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/\">https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/</a></p>\n<p>从二维数组的右上角开始查找。如果当前元素等于目标值，则返回 <code>true</code>。如果当前元素大于目标值，则移到左边一列。如果当前元素小于目标值，则移到下边一行</p>\n<pre><code class=\"java\">class Solution &#123;\n    public boolean findNumberIn2DArray(int[][] matrix, int target) &#123;\n        if (matrix == null || matrix.length == 0) &#123;\n            return false;\n        &#125;\n\n        int i = 0, j = matrix[0].length - 1;\n        while(i &lt; matrix.length &amp;&amp; j &gt;= 0) &#123;\n            if (matrix[i][j] == target) &#123;\n                return true;\n            &#125; else if (matrix[i][j] &gt; target) &#123;\n                j--;\n            &#125; else &#123;\n                i++;\n            &#125;\n        &#125;\n        return false;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(M+N) ：其中，N 和 M 分别为矩阵行数和列数，此算法最多循环 M+N 次。</p>\n<p>空间复杂度 O(1) : i, j 指针使用常数大小额外空间。</p>\n"},{"title":"52两个链表的第一个公共节点","_content":"\n题目地址：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\n\n使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。\n\n这样，当它们相遇时，所指向的结点就是第一个公共结点\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode node1 = headA, node2 = headB;\n        while (node1 != node2) {\n            //当node1为空，则从headB遍历\n            node1 = (node1 == null ? headB : node1.next);\n            //当node2为空，则从headA遍历\n            node2 = (node2 == null ? headA : node2.next);\n        }\n        return node1;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/52两个链表的第一个公共节点.md","raw":"---\ntitle: 52两个链表的第一个公共节点\ncategories:\n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\n\n使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。\n\n这样，当它们相遇时，所指向的结点就是第一个公共结点\n\n```java\n/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\nclass Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) {\n            return null;\n        }\n\n        ListNode node1 = headA, node2 = headB;\n        while (node1 != node2) {\n            //当node1为空，则从headB遍历\n            node1 = (node1 == null ? headB : node1.next);\n            //当node2为空，则从headA遍历\n            node2 = (node2 == null ? headA : node2.next);\n        }\n        return node1;\n    }\n}\n```\n\n","slug":"剑指OFFER/52两个链表的第一个公共节点","published":1,"date":"2021-09-01T05:22:18.216Z","updated":"2022-01-28T17:13:09.565Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjj00h0fhji2rycb0qe","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p>\n<p>使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p>\n<p>这样，当它们相遇时，所指向的结点就是第一个公共结点</p>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val = x;\n *         next = null;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n        if (headA == null || headB == null) &#123;\n            return null;\n        &#125;\n\n        ListNode node1 = headA, node2 = headB;\n        while (node1 != node2) &#123;\n            //当node1为空，则从headB遍历\n            node1 = (node1 == null ? headB : node1.next);\n            //当node2为空，则从headA遍历\n            node2 = (node2 == null ? headA : node2.next);\n        &#125;\n        return node1;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/\">https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/</a></p>\n<p>使用两个指针 node1，node2 分别指向两个链表 headA，headB 的头结点，然后同时分别逐结点遍历，当 node1 到达链表 headA 的末尾时，重新定位到链表 headB 的头结点；当 node2 到达链表 headB 的末尾时，重新定位到链表 headA 的头结点。</p>\n<p>这样，当它们相遇时，所指向的结点就是第一个公共结点</p>\n<pre><code class=\"java\">/**\n * Definition for singly-linked list.\n * public class ListNode &#123;\n *     int val;\n *     ListNode next;\n *     ListNode(int x) &#123;\n *         val = x;\n *         next = null;\n *     &#125;\n * &#125;\n */\nclass Solution &#123;\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;\n        if (headA == null || headB == null) &#123;\n            return null;\n        &#125;\n\n        ListNode node1 = headA, node2 = headB;\n        while (node1 != node2) &#123;\n            //当node1为空，则从headB遍历\n            node1 = (node1 == null ? headB : node1.next);\n            //当node2为空，则从headA遍历\n            node2 = (node2 == null ? headA : node2.next);\n        &#125;\n        return node1;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"54二叉搜索树的K大节点","_content":"\n题目地址：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\n\n二叉搜索树的中序遍历为递增序列 。\n\n根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。\n\n因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。\n\n中序遍历的倒序 为 “右、根、左” 顺序\n\n```java\nclass Solution {\n    int result = 0, k = 0;\n    public int kthLargest(TreeNode root, int k) {\n        this.k = k;\n        dfs(root);\n        return result;\n    }\n    private void dfs(TreeNode root) {\n        if(root == null || k == 0) {\n            return;\n        }\n        dfs(root.right);\n        if (--k == 0) {\n            result = root.val;\n        }\n        dfs(root.left);\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/54二叉搜索树的K大节点.md","raw":"---\ntitle: 54二叉搜索树的K大节点\ncategories:\n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\n\n二叉搜索树的中序遍历为递增序列 。\n\n根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。\n\n因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。\n\n中序遍历的倒序 为 “右、根、左” 顺序\n\n```java\nclass Solution {\n    int result = 0, k = 0;\n    public int kthLargest(TreeNode root, int k) {\n        this.k = k;\n        dfs(root);\n        return result;\n    }\n    private void dfs(TreeNode root) {\n        if(root == null || k == 0) {\n            return;\n        }\n        dfs(root.right);\n        if (--k == 0) {\n            result = root.val;\n        }\n        dfs(root.left);\n    }\n}\n```\n\n","slug":"剑指OFFER/54二叉搜索树的K大节点","published":1,"date":"2021-09-01T05:22:18.216Z","updated":"2022-01-28T17:13:13.967Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjj00h1fhji06ehbo1d","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p>\n<p>二叉搜索树的中序遍历为递增序列 。</p>\n<p>根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。</p>\n<p>因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。</p>\n<p>中序遍历的倒序 为 “右、根、左” 顺序</p>\n<pre><code class=\"java\">class Solution &#123;\n    int result = 0, k = 0;\n    public int kthLargest(TreeNode root, int k) &#123;\n        this.k = k;\n        dfs(root);\n        return result;\n    &#125;\n    private void dfs(TreeNode root) &#123;\n        if(root == null || k == 0) &#123;\n            return;\n        &#125;\n        dfs(root.right);\n        if (--k == 0) &#123;\n            result = root.val;\n        &#125;\n        dfs(root.left);\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/\">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/</a></p>\n<p>二叉搜索树的中序遍历为递增序列 。</p>\n<p>根据以上性质，易得二叉搜索树的 中序遍历倒序 为 递减序列 。</p>\n<p>因此，求 “二叉搜索树第 k 大的节点” 可转化为求 “此树的中序遍历倒序的第 k 个节点”。</p>\n<p>中序遍历的倒序 为 “右、根、左” 顺序</p>\n<pre><code class=\"java\">class Solution &#123;\n    int result = 0, k = 0;\n    public int kthLargest(TreeNode root, int k) &#123;\n        this.k = k;\n        dfs(root);\n        return result;\n    &#125;\n    private void dfs(TreeNode root) &#123;\n        if(root == null || k == 0) &#123;\n            return;\n        &#125;\n        dfs(root.right);\n        if (--k == 0) &#123;\n            result = root.val;\n        &#125;\n        dfs(root.left);\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"55I二叉树的深度","_content":"\n题目地址：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/\n\n# DFS\n\n此树的深度 等于 左子树的深度 与 右子树的深度 中的 最大值 +1 。\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftLen = maxDepth(root.left);\n        int rightLen = maxDepth(root.right);\n        return Math.max(leftLen, rightLen) + 1;\n    }\n}\n```\n\n时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。\n\n# BFS\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0;i<size;i++) {\n                TreeNode node = queue.poll();\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n                if(node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            res++;\n        }\n        return res;\n    }\n}\n```","source":"_posts/剑指OFFER/55I二叉树的深度.md","raw":"---\ntitle: 55I二叉树的深度\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/\n\n# DFS\n\n此树的深度 等于 左子树的深度 与 右子树的深度 中的 最大值 +1 。\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) {\n            return 0;\n        }\n        int leftLen = maxDepth(root.left);\n        int rightLen = maxDepth(root.right);\n        return Math.max(leftLen, rightLen) + 1;\n    }\n}\n```\n\n时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。\n\n# BFS\n\n```java\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if(root == null) {\n            return 0;\n        }\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int res = 0;\n        while(!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0;i<size;i++) {\n                TreeNode node = queue.poll();\n                if(node.left != null) {\n                    queue.offer(node.left);\n                }\n                if(node.right != null) {\n                    queue.offer(node.right);\n                }\n            }\n            res++;\n        }\n        return res;\n    }\n}\n```","slug":"剑指OFFER/55I二叉树的深度","published":1,"date":"2021-09-01T05:22:18.216Z","updated":"2022-01-28T17:13:20.177Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjk00h4fhji7lgt4u7e","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/\">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</a></p>\n<h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><p>此树的深度 等于 左子树的深度 与 右子树的深度 中的 最大值 +1 。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int leftLen = maxDepth(root.left);\n        int rightLen = maxDepth(root.right);\n        return Math.max(leftLen, rightLen) + 1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</p>\n<h1 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h1><pre><code class=\"java\">class Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if(root == null) &#123;\n            return 0;\n        &#125;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        int res = 0;\n        while(!queue.isEmpty()) &#123;\n            int size = queue.size();\n            for (int i = 0;i&lt;size;i++) &#123;\n                TreeNode node = queue.poll();\n                if(node.left != null) &#123;\n                    queue.offer(node.left);\n                &#125;\n                if(node.right != null) &#123;\n                    queue.offer(node.right);\n                &#125;\n            &#125;\n            res++;\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/\">https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof/</a></p>\n<h1 id=\"DFS\"><a href=\"#DFS\" class=\"headerlink\" title=\"DFS\"></a>DFS</h1><p>此树的深度 等于 左子树的深度 与 右子树的深度 中的 最大值 +1 。</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if (root == null) &#123;\n            return 0;\n        &#125;\n        int leftLen = maxDepth(root.left);\n        int rightLen = maxDepth(root.right);\n        return Math.max(leftLen, rightLen) + 1;\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N) ： N 为树的节点数量，计算树的深度需要遍历所有节点。</p>\n<h1 id=\"BFS\"><a href=\"#BFS\" class=\"headerlink\" title=\"BFS\"></a>BFS</h1><pre><code class=\"java\">class Solution &#123;\n    public int maxDepth(TreeNode root) &#123;\n        if(root == null) &#123;\n            return 0;\n        &#125;\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n        queue.offer(root);\n        int res = 0;\n        while(!queue.isEmpty()) &#123;\n            int size = queue.size();\n            for (int i = 0;i&lt;size;i++) &#123;\n                TreeNode node = queue.poll();\n                if(node.left != null) &#123;\n                    queue.offer(node.left);\n                &#125;\n                if(node.right != null) &#123;\n                    queue.offer(node.right);\n                &#125;\n            &#125;\n            res++;\n        &#125;\n        return res;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"63股票的最大利润","_content":"\n题目地址：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/\n\n动态规划：\n\n1. 状态定义：dp[i]，代表以i结尾的子数组最大利润\n2. 转移方程：\n\n1. 1. 前i日最大利润 = 前i - 1天的最大利润 和 第i天价格 - 前i天最低价格 的最大值\n   2. **dp[i] = max(dp[i - 1], prices[i] - min(price[i] , minPrice)**\n\n1. 初始化，dp[0] = 0,\n2. 返回值 dp[n - 1]\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n        int minPrice = Integer.MAX_VALUE;\n        int profit = 0;\n        for (int price : prices) {\n            minPrice = Math.min(minPrice, price);\n            profit = Math.max(profit, price - minPrice);\n        }\n        return profit;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/63股票的最大利润.md","raw":"---\ntitle: 63股票的最大利润\ncategories:\n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/\n\n动态规划：\n\n1. 状态定义：dp[i]，代表以i结尾的子数组最大利润\n2. 转移方程：\n\n1. 1. 前i日最大利润 = 前i - 1天的最大利润 和 第i天价格 - 前i天最低价格 的最大值\n   2. **dp[i] = max(dp[i - 1], prices[i] - min(price[i] , minPrice)**\n\n1. 初始化，dp[0] = 0,\n2. 返回值 dp[n - 1]\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n        int minPrice = Integer.MAX_VALUE;\n        int profit = 0;\n        for (int price : prices) {\n            minPrice = Math.min(minPrice, price);\n            profit = Math.max(profit, price - minPrice);\n        }\n        return profit;\n    }\n}\n```\n\n","slug":"剑指OFFER/63股票的最大利润","published":1,"date":"2021-09-01T05:22:18.216Z","updated":"2022-01-28T17:13:24.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjk00h5fhjicjo87rdb","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/\">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/</a></p>\n<p>动态规划：</p>\n<ol>\n<li><p>状态定义：dp[i]，代表以i结尾的子数组最大利润</p>\n</li>\n<li><p>转移方程：</p>\n</li>\n<li><ol>\n<li>前i日最大利润 &#x3D; 前i - 1天的最大利润 和 第i天价格 - 前i天最低价格 的最大值</li>\n<li><strong>dp[i] &#x3D; max(dp[i - 1], prices[i] - min(price[i] , minPrice)</strong></li>\n</ol>\n</li>\n<li><p>初始化，dp[0] &#x3D; 0,</p>\n</li>\n<li><p>返回值 dp[n - 1]</p>\n</li>\n</ol>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        if (prices == null || prices.length == 0) &#123;\n            return 0;\n        &#125;\n        int minPrice = Integer.MAX_VALUE;\n        int profit = 0;\n        for (int price : prices) &#123;\n            minPrice = Math.min(minPrice, price);\n            profit = Math.max(profit, price - minPrice);\n        &#125;\n        return profit;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/\">https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof/</a></p>\n<p>动态规划：</p>\n<ol>\n<li><p>状态定义：dp[i]，代表以i结尾的子数组最大利润</p>\n</li>\n<li><p>转移方程：</p>\n</li>\n<li><ol>\n<li>前i日最大利润 &#x3D; 前i - 1天的最大利润 和 第i天价格 - 前i天最低价格 的最大值</li>\n<li><strong>dp[i] &#x3D; max(dp[i - 1], prices[i] - min(price[i] , minPrice)</strong></li>\n</ol>\n</li>\n<li><p>初始化，dp[0] &#x3D; 0,</p>\n</li>\n<li><p>返回值 dp[n - 1]</p>\n</li>\n</ol>\n<pre><code class=\"java\">class Solution &#123;\n    public int maxProfit(int[] prices) &#123;\n        if (prices == null || prices.length == 0) &#123;\n            return 0;\n        &#125;\n        int minPrice = Integer.MAX_VALUE;\n        int profit = 0;\n        for (int price : prices) &#123;\n            minPrice = Math.min(minPrice, price);\n            profit = Math.max(profit, price - minPrice);\n        &#125;\n        return profit;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"65不用加减乘除做加法","_content":"\n题目地址:https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/\n\n不用加减乘除做加法的方法是使用按位异或和按位与运算\n\n计算a + b等价于计算`(a ^ b) + ((a & b) << 1)`\n\n其中`((a & b) << 1)`表示进位。因此令c等于`(a & b) << 1`，令a等于`a ^ b`，直到c变成0，然后返回a\n\n```java\nclass Solution {\n    public int add(int a, int b) {\n        while(b != 0) { // 当进位为 0 时跳出\n            int c = (a & b) << 1;  // c = 进位\n            a ^= b; // a = 非进位和\n            b = c; // b = 进位\n        }\n        return a;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/65不用加减乘除做加法.md","raw":"---\ntitle: 65不用加减乘除做加法\ncategories:\n- 剑指OFFER\n---\n\n题目地址:https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/\n\n不用加减乘除做加法的方法是使用按位异或和按位与运算\n\n计算a + b等价于计算`(a ^ b) + ((a & b) << 1)`\n\n其中`((a & b) << 1)`表示进位。因此令c等于`(a & b) << 1`，令a等于`a ^ b`，直到c变成0，然后返回a\n\n```java\nclass Solution {\n    public int add(int a, int b) {\n        while(b != 0) { // 当进位为 0 时跳出\n            int c = (a & b) << 1;  // c = 进位\n            a ^= b; // a = 非进位和\n            b = c; // b = 进位\n        }\n        return a;\n    }\n}\n```\n\n","slug":"剑指OFFER/65不用加减乘除做加法","published":1,"date":"2021-09-01T05:22:18.216Z","updated":"2022-01-28T17:13:29.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjl00h8fhji310p7f71","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/\">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</a></p>\n<p>不用加减乘除做加法的方法是使用按位异或和按位与运算</p>\n<p>计算a + b等价于计算<code>(a ^ b) + ((a &amp; b) &lt;&lt; 1)</code></p>\n<p>其中<code>((a &amp; b) &lt;&lt; 1)</code>表示进位。因此令c等于<code>(a &amp; b) &lt;&lt; 1</code>，令a等于<code>a ^ b</code>，直到c变成0，然后返回a</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int add(int a, int b) &#123;\n        while(b != 0) &#123; // 当进位为 0 时跳出\n            int c = (a &amp; b) &lt;&lt; 1;  // c = 进位\n            a ^= b; // a = 非进位和\n            b = c; // b = 进位\n        &#125;\n        return a;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/\">https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/</a></p>\n<p>不用加减乘除做加法的方法是使用按位异或和按位与运算</p>\n<p>计算a + b等价于计算<code>(a ^ b) + ((a &amp; b) &lt;&lt; 1)</code></p>\n<p>其中<code>((a &amp; b) &lt;&lt; 1)</code>表示进位。因此令c等于<code>(a &amp; b) &lt;&lt; 1</code>，令a等于<code>a ^ b</code>，直到c变成0，然后返回a</p>\n<pre><code class=\"java\">class Solution &#123;\n    public int add(int a, int b) &#123;\n        while(b != 0) &#123; // 当进位为 0 时跳出\n            int c = (a &amp; b) &lt;&lt; 1;  // c = 进位\n            a ^= b; // a = 非进位和\n            b = c; // b = 进位\n        &#125;\n        return a;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"68II二叉树的最近公共祖先","_content":"\n题目地址：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/\n\n**左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：**\n\n第一种情况：左子树和右子树均找没有p结点或者q结点；\n\n第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；\n\n第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；\n\n第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left == null) {\n            return right;\n        }\n        if (right == null) {\n            return left;\n        }\n        return root;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/68II二叉树的最近公共祖先.md","raw":"---\ntitle: 68II二叉树的最近公共祖先\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/\n\n**左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：**\n\n第一种情况：左子树和右子树均找没有p结点或者q结点；\n\n第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；\n\n第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；\n\n第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) {\n            return root;\n        }\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left == null) {\n            return right;\n        }\n        if (right == null) {\n            return left;\n        }\n        return root;\n    }\n}\n```\n\n","slug":"剑指OFFER/68II二叉树的最近公共祖先","published":1,"date":"2021-09-01T05:22:18.216Z","updated":"2022-01-28T17:13:33.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjm00h9fhji1y4na4be","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/\">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p>\n<p><strong>左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：</strong></p>\n<p>第一种情况：左子树和右子树均找没有p结点或者q结点；</p>\n<p>第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；</p>\n<p>第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；</p>\n<p>第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        if (root == null || root == p || root == q) &#123;\n            return root;\n        &#125;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left == null) &#123;\n            return right;\n        &#125;\n        if (right == null) &#123;\n            return left;\n        &#125;\n        return root;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/\">https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p>\n<p><strong>左右子树分别进行递归，即查找左右子树上是否有p结点或者q结点，就一共有4种情况：</strong></p>\n<p>第一种情况：左子树和右子树均找没有p结点或者q结点；</p>\n<p>第二种情况：左子树上能找到，但是右子树上找不到，此时就应当直接返回左子树的查找结果；</p>\n<p>第三种情况：右子树上能找到，但是左子树上找不到，此时就应当直接返回右子树的查找结果；</p>\n<p>第四种情况：左右子树上均能找到，说明此时的p结点和q结点分居root结点两侧，此时就应当直接返回root结点了</p>\n<pre><code class=\"java\">class Solution &#123;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        if (root == null || root == p || root == q) &#123;\n            return root;\n        &#125;\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n        if (left == null) &#123;\n            return right;\n        &#125;\n        if (right == null) &#123;\n            return left;\n        &#125;\n        return root;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"68I二叉搜索树的最近公共祖先","_content":"\n题目地址：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/\n\n- 从根结点开始搜索，如果根结点的值大于节点p 和节点 q，证明这两个节点都在当前节点的左子树上，于是可以继续沿着左子树向下搜索\n- 如果根结点的值小于节点p 和节点 q，证明这两个节点都在当前节点的右子树上，可以继续沿着右子树向下搜索\n- 如果当前节点大于一个节点且小于另一个节点，则证明两个节点分别处于当前节点的左右两侧， 则该节点就是这两个节点的公共祖先。\n- 若都不满足则返回空。\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || p == null || q == null) {\n            return null;\n        }\n        if (root.val < p.val && root.val < q.val && root.right != null) {\n            return lowestCommonAncestor(root.right, p, q);\n        }\n        if (root.val > p.val && root.val > q.val && root.left != null) {\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        return root;\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/68I二叉搜索树的最近公共祖先.md","raw":"---\ntitle: 68I二叉搜索树的最近公共祖先\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/\n\n- 从根结点开始搜索，如果根结点的值大于节点p 和节点 q，证明这两个节点都在当前节点的左子树上，于是可以继续沿着左子树向下搜索\n- 如果根结点的值小于节点p 和节点 q，证明这两个节点都在当前节点的右子树上，可以继续沿着右子树向下搜索\n- 如果当前节点大于一个节点且小于另一个节点，则证明两个节点分别处于当前节点的左右两侧， 则该节点就是这两个节点的公共祖先。\n- 若都不满足则返回空。\n\n```java\nclass Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || p == null || q == null) {\n            return null;\n        }\n        if (root.val < p.val && root.val < q.val && root.right != null) {\n            return lowestCommonAncestor(root.right, p, q);\n        }\n        if (root.val > p.val && root.val > q.val && root.left != null) {\n            return lowestCommonAncestor(root.left, p, q);\n        }\n        return root;\n    }\n}\n```\n\n","slug":"剑指OFFER/68I二叉搜索树的最近公共祖先","published":1,"date":"2021-09-01T05:22:18.216Z","updated":"2022-01-28T17:13:37.322Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjm00hcfhjihejw6ozc","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/\">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p>\n<ul>\n<li>从根结点开始搜索，如果根结点的值大于节点p 和节点 q，证明这两个节点都在当前节点的左子树上，于是可以继续沿着左子树向下搜索</li>\n<li>如果根结点的值小于节点p 和节点 q，证明这两个节点都在当前节点的右子树上，可以继续沿着右子树向下搜索</li>\n<li>如果当前节点大于一个节点且小于另一个节点，则证明两个节点分别处于当前节点的左右两侧， 则该节点就是这两个节点的公共祖先。</li>\n<li>若都不满足则返回空。</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        if (root == null || p == null || q == null) &#123;\n            return null;\n        &#125;\n        if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val &amp;&amp; root.right != null) &#123;\n            return lowestCommonAncestor(root.right, p, q);\n        &#125;\n        if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val &amp;&amp; root.left != null) &#123;\n            return lowestCommonAncestor(root.left, p, q);\n        &#125;\n        return root;\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/\">https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/</a></p>\n<ul>\n<li>从根结点开始搜索，如果根结点的值大于节点p 和节点 q，证明这两个节点都在当前节点的左子树上，于是可以继续沿着左子树向下搜索</li>\n<li>如果根结点的值小于节点p 和节点 q，证明这两个节点都在当前节点的右子树上，可以继续沿着右子树向下搜索</li>\n<li>如果当前节点大于一个节点且小于另一个节点，则证明两个节点分别处于当前节点的左右两侧， 则该节点就是这两个节点的公共祖先。</li>\n<li>若都不满足则返回空。</li>\n</ul>\n<pre><code class=\"java\">class Solution &#123;\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;\n        if (root == null || p == null || q == null) &#123;\n            return null;\n        &#125;\n        if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val &amp;&amp; root.right != null) &#123;\n            return lowestCommonAncestor(root.right, p, q);\n        &#125;\n        if (root.val &gt; p.val &amp;&amp; root.val &gt; q.val &amp;&amp; root.left != null) &#123;\n            return lowestCommonAncestor(root.left, p, q);\n        &#125;\n        return root;\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"6从尾到头打印链表","_content":"\n题目地址:https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\n\n# 递归\n\n先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出\n\n**基本过程:**\n\n递推阶段： 每次传入 `head.next` ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回\n\n回溯阶段： 层层回溯时，将当前节点值加入列表，即`tmp.add(head.val)`\n\n最终，将列表 tmp 转化为数组 res ，并返回即可\n\n```java\nclass Solution {\n    List<Integer> temp = new ArrayList<>();\n    public int[] reversePrint(ListNode head) {\n        recursive(head);\n        int[] result = new int[temp.size()];\n        for (int i = 0; i<temp.size();i++) {\n            result[i] = temp.get(i);\n        }\n        return result;\n    }\n    private void recursive(ListNode head) {\n        if (head == null) {\n            return;\n        }\n        recursive(head.next);\n        temp.add(head.val);\n    }\n}\n```\n\n时间复杂度 O(N)： 遍历链表，递归 N 次 \n\n空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间\n\n","source":"_posts/剑指OFFER/6从尾到头打印链表.md","raw":"---\ntitle: 6从尾到头打印链表\ncategories: \n- 剑指OFFER\n---\n\n题目地址:https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\n\n# 递归\n\n先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出\n\n**基本过程:**\n\n递推阶段： 每次传入 `head.next` ，以 head == null（即走过链表尾部节点）为递归终止条件，此时直接返回\n\n回溯阶段： 层层回溯时，将当前节点值加入列表，即`tmp.add(head.val)`\n\n最终，将列表 tmp 转化为数组 res ，并返回即可\n\n```java\nclass Solution {\n    List<Integer> temp = new ArrayList<>();\n    public int[] reversePrint(ListNode head) {\n        recursive(head);\n        int[] result = new int[temp.size()];\n        for (int i = 0; i<temp.size();i++) {\n            result[i] = temp.get(i);\n        }\n        return result;\n    }\n    private void recursive(ListNode head) {\n        if (head == null) {\n            return;\n        }\n        recursive(head.next);\n        temp.add(head.val);\n    }\n}\n```\n\n时间复杂度 O(N)： 遍历链表，递归 N 次 \n\n空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间\n\n","slug":"剑指OFFER/6从尾到头打印链表","published":1,"date":"2021-09-01T05:22:18.217Z","updated":"2022-01-28T17:13:41.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjn00hdfhjig1q511q0","content":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出</p>\n<p><strong>基本过程:</strong></p>\n<p>递推阶段： 每次传入 <code>head.next</code> ，以 head &#x3D;&#x3D; null（即走过链表尾部节点）为递归终止条件，此时直接返回</p>\n<p>回溯阶段： 层层回溯时，将当前节点值加入列表，即<code>tmp.add(head.val)</code></p>\n<p>最终，将列表 tmp 转化为数组 res ，并返回即可</p>\n<pre><code class=\"java\">class Solution &#123;\n    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();\n    public int[] reversePrint(ListNode head) &#123;\n        recursive(head);\n        int[] result = new int[temp.size()];\n        for (int i = 0; i&lt;temp.size();i++) &#123;\n            result[i] = temp.get(i);\n        &#125;\n        return result;\n    &#125;\n    private void recursive(ListNode head) &#123;\n        if (head == null) &#123;\n            return;\n        &#125;\n        recursive(head.next);\n        temp.add(head.val);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)： 遍历链表，递归 N 次 </p>\n<p>空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间</p>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址:<a href=\"https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/\">https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/</a></p>\n<h1 id=\"递归\"><a href=\"#递归\" class=\"headerlink\" title=\"递归\"></a>递归</h1><p>先走至链表末端，回溯时依次将节点值加入列表 ，这样就可以实现链表值的倒序输出</p>\n<p><strong>基本过程:</strong></p>\n<p>递推阶段： 每次传入 <code>head.next</code> ，以 head &#x3D;&#x3D; null（即走过链表尾部节点）为递归终止条件，此时直接返回</p>\n<p>回溯阶段： 层层回溯时，将当前节点值加入列表，即<code>tmp.add(head.val)</code></p>\n<p>最终，将列表 tmp 转化为数组 res ，并返回即可</p>\n<pre><code class=\"java\">class Solution &#123;\n    List&lt;Integer&gt; temp = new ArrayList&lt;&gt;();\n    public int[] reversePrint(ListNode head) &#123;\n        recursive(head);\n        int[] result = new int[temp.size()];\n        for (int i = 0; i&lt;temp.size();i++) &#123;\n            result[i] = temp.get(i);\n        &#125;\n        return result;\n    &#125;\n    private void recursive(ListNode head) &#123;\n        if (head == null) &#123;\n            return;\n        &#125;\n        recursive(head.next);\n        temp.add(head.val);\n    &#125;\n&#125;\n</code></pre>\n<p>时间复杂度 O(N)： 遍历链表，递归 N 次 </p>\n<p>空间复杂度 O(N)： 系统递归需要使用 O(N) 的栈空间</p>\n"},{"title":"9用两个栈实现队列","_content":"\n题目地址：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\n\n用`栈A`和`栈B`来实现队列，其中`栈A`负责插入数据，`栈B`负责删除数据。\n\n为了实现队列先进先出的特点，在`栈B`为空时，需要将栈A中的数据取出插入`栈B`中\n\n```java\nclass CQueue {    \n    Stack<Integer> A,B;\n    \n    public CQueue() {\n        A = new Stack<>();\n        B = new Stack<>();\n    }\n    \n    public void appendTail(int value) {\n        A.push(value);\n    }\n    \n    public int deleteHead() {\n        if(B.isEmpty()){\n            if(A.isEmpty()){\n                return -1;\n            }\n            while(!A.isEmpty()){\n                B.push(A.pop());\n            }\n        }\n        return B.pop();\n    }\n}\n```\n\n","source":"_posts/剑指OFFER/9用两个栈实现队列.md","raw":"---\ntitle: 9用两个栈实现队列\ncategories: \n- 剑指OFFER\n---\n\n题目地址：https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\n\n用`栈A`和`栈B`来实现队列，其中`栈A`负责插入数据，`栈B`负责删除数据。\n\n为了实现队列先进先出的特点，在`栈B`为空时，需要将栈A中的数据取出插入`栈B`中\n\n```java\nclass CQueue {    \n    Stack<Integer> A,B;\n    \n    public CQueue() {\n        A = new Stack<>();\n        B = new Stack<>();\n    }\n    \n    public void appendTail(int value) {\n        A.push(value);\n    }\n    \n    public int deleteHead() {\n        if(B.isEmpty()){\n            if(A.isEmpty()){\n                return -1;\n            }\n            while(!A.isEmpty()){\n                B.push(A.pop());\n            }\n        }\n        return B.pop();\n    }\n}\n```\n\n","slug":"剑指OFFER/9用两个栈实现队列","published":1,"date":"2021-09-01T05:22:18.217Z","updated":"2022-01-28T17:13:45.367Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwjn00hgfhji8rwrds1p","content":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a></p>\n<p>用<code>栈A</code>和<code>栈B</code>来实现队列，其中<code>栈A</code>负责插入数据，<code>栈B</code>负责删除数据。</p>\n<p>为了实现队列先进先出的特点，在<code>栈B</code>为空时，需要将栈A中的数据取出插入<code>栈B</code>中</p>\n<pre><code class=\"java\">class CQueue &#123;    \n    Stack&lt;Integer&gt; A,B;\n    \n    public CQueue() &#123;\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    &#125;\n    \n    public void appendTail(int value) &#123;\n        A.push(value);\n    &#125;\n    \n    public int deleteHead() &#123;\n        if(B.isEmpty())&#123;\n            if(A.isEmpty())&#123;\n                return -1;\n            &#125;\n            while(!A.isEmpty())&#123;\n                B.push(A.pop());\n            &#125;\n        &#125;\n        return B.pop();\n    &#125;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>题目地址：<a href=\"https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/\">https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/</a></p>\n<p>用<code>栈A</code>和<code>栈B</code>来实现队列，其中<code>栈A</code>负责插入数据，<code>栈B</code>负责删除数据。</p>\n<p>为了实现队列先进先出的特点，在<code>栈B</code>为空时，需要将栈A中的数据取出插入<code>栈B</code>中</p>\n<pre><code class=\"java\">class CQueue &#123;    \n    Stack&lt;Integer&gt; A,B;\n    \n    public CQueue() &#123;\n        A = new Stack&lt;&gt;();\n        B = new Stack&lt;&gt;();\n    &#125;\n    \n    public void appendTail(int value) &#123;\n        A.push(value);\n    &#125;\n    \n    public int deleteHead() &#123;\n        if(B.isEmpty())&#123;\n            if(A.isEmpty())&#123;\n                return -1;\n            &#125;\n            while(!A.isEmpty())&#123;\n                B.push(A.pop());\n            &#125;\n        &#125;\n        return B.pop();\n    &#125;\n&#125;\n</code></pre>\n"},{"title":"内存管理","_content":"\n**逻辑地址和物理地址**\n\n我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。\n\n物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址，物理地址是内存单元真正的地址。\n\n编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。\n\nCPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 \n\n相对地址又称逻辑地址，绝对地址又称物理地址。\n\n**内存管理有哪几种方式**\n\n1. **块式管理**：将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了，这些在每个块中未被利用的空间，我们称之为碎片。\n2. **页式管理**：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片，页式管理通过页表对应逻辑地址和物理地址。\n\n<img src=\"https://img-blog.csdnimg.cn/a9ac3bf5e08e49ff9ed731ae54424132.png\" style=\"zoom:25%;\" />\n\n1. **段式管理**： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义， 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 ，段式管理通过段表对应逻辑地址和物理地址。\n2. **段页式管理机制：**段页式管理机制结合了段式管理和页式管理的优点，简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说**段页式管理机制**中段与段之间以及段的内部的都是离散的。\n\n<img src=\"https://img-blog.csdnimg.cn/92a8f2f5def248648db8392d96247400.png\" style=\"zoom:25%;\" />\n\n# 虚拟地址\n\n现代处理器使用的是一种称为**虚拟寻址(Virtual Addressing)**的寻址方式\n\n**使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。**\n\n实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为**内存管理单元（Memory Management Unit, MMU）**的硬件\n\n<img src=\"https://img-blog.csdnimg.cn/0ef33a73d3974272909d641634703314.png\" style=\"zoom:50%;\" />\n\n**为什么要有虚拟地址空间**\n\n没有虚拟地址空间的时候，**程序都是直接访问和操作的都是物理内存**。\n\n但是这样有什么问题？\n\n1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。\n2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行，为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。\n\n**通过虚拟地址访问内存有以下优势：**\n\n- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。\n- 不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n\n**MMU如何把虚拟地址翻译成物理地址的**\n\n对于每个程序，内存管理单元MMU都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。\n\n每当为一个虚拟页面寻找到一个物理页面之后，就在页表里增加一条记录来保留该映射关系，当然，随着虚拟页面进出物理内存，页表的内容也会不断更新变化。\n\n<img src=\"https://img-blog.csdnimg.cn/f967e12729bd470eaf9d32221209ba36.png\" style=\"zoom:25%;\" />\n\n# 虚拟内存\n\n很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存\n\n通过 **虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。\n\n另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。\n\n**虚拟内存**是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存\n\n**虚拟内存的重要意义是它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间**\n\n**虚拟内存的实现有以下三种方式：**\n\n1. **请求分页存储管理** ：请求分页是目前最常用的一种实现虚拟存储器的方法，请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行，假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。\n2. **请求分段存储管理** ：请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n3. **请求段页式存储管理**\n\n不管是上面那种实现方式，我们一般都需要：\n\n> 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；\n\n<img src=\"https://img-blog.csdnimg.cn/87aa376bd74a4561962682ecab2c0d43.png\" style=\"zoom:25%;\" />\n\n\n\n# 缺页中断\n\n如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；\n\n在分页系统中，一个虚拟页面既有可能在物理内存，也有可能保存在磁盘上。\n\n如果CPU发出的虚拟地址对应的页面不在物理内存，就将产生一个缺页中断，而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存。\n\n缺页中断的处理步骤如下，省略了中间很多的步骤，只保留最核心的几个步骤：\n\n<img src=\"https://img-blog.csdnimg.cn/0985097c9d61404a83711157b897cb5a.png\" style=\"zoom:50%;\" />\n\n# 页面置换算法\n\n当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。\n\n用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则\n\n- **OPT 页面置换算法（最佳页面置换算法）** ：该置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率，但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，一般作为衡量其他置换算法的方法。\n- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。\n\n- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。\n- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。\n\n# 局部性原理\n\n局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。\n\n局部性原理表现在以下两个方面：\n\n1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问，产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。\n2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。\n\n时间局部性是通过将近来使用的指令和数据保存到**高速缓存存储器**中，并使用高速缓存的层次结构实现。\n\n空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。\n\n# 页表\n\n操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。\n\nPage 到 Frame 的映射，需要一种叫作页表的结构。\n\n<img src=\"https://img-blog.csdnimg.cn/a15bed2353c74a62975e451eac3aff00.png\" style=\"zoom:25%;\" />\n\n上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。 \n\nPage 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。\n\n页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G/4K = 2621440 个条目。\n\n如果每个条目是 64bit，那么一共需要 20480K = 20M 页表，操作系统在内存中划分出小块区域给页表，并负责维护页表。\n\n**页表维护了虚拟地址到真实地址的映射。**\n\n每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：\n\n* 通过虚拟地址计算 Page 编号；\n\n* 查页表，根据 Page 编号，找到 Frame 编号；\n\n* 将虚拟地址换算成物理地址。\n\n## 多级页表\n\n引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中\n\n**一级页表：**\n\n假如物理内存中一共有1048576个页，那么页表就需要总共就是`1048576 * 4B = 4M`。\n\n也就是说我需要4M连续的内存来存放这个页表，也就是一级页表。\n\n随着虚拟地址空间的增大，存放页表所需要的连续空间也会增大，在操作系统内存紧张或者内存碎片较多时，这无疑会带来额外的开销。\n\n页表寻址是用寄存器来确定一级页表地址的，所以一级页表的地址必须指向确定的物理页，否则就会出现错误，所以如果用一级页表的话，就必须把全部的页表都加载进去。\n\n**二级页表：**\n\n而使用二级页表的话，只需要加载一个页目录表(一级页表)，大小为4K，可以管理1024个二级页表。\n\n可能你会有疑问，这1024个二级页表也是需要内存空间的，这下反而需要4MB+4KB的内存，反而更多了。\n\n其实二级页表并不是一定要存在内存中的，内存中只需要一个一级页表地址存在存器即可，二级页表可以使用缺页中断从外存移入内存。\n\n**多级页表属于时间换空间的典型场景**\n\n# 快表\n\n为了解决虚拟地址到物理地址的转换速度，操作系统在**页表方案**基础之上引入了**快表**来加速虚拟地址到物理地址的转换\n\n我们可以把快表理解为一种特殊的**高速缓冲存储器（Cache）**，其中的内容是页表的一部分或者全部内容，作为页表的 Cache，它的作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存，有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。\n\n**使用快表之后的地址转换流程是这样的：**\n\n1. 根据虚拟地址中的页号查快表；\n2. 如果该页在快表中，直接从快表中读取相应的物理地址；\n3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；\n4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n<img src=\"https://img-blog.csdnimg.cn/de56049e24c44756911ceded6d703d53.png\" style=\"zoom:25%;\" />\n\n# 内存管理单元\n\n在 CPU 中一个小型的设备——内存管理单元（MMU）\n\n<img src=\"https://img-blog.csdnimg.cn/2da3a2f130cf415cb0b42c19fda70f30.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/5bddbadd99e244c185886d4cd9ab239f.png\" style=\"zoom:25%;\" />\n\n当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。\n\n在不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。\n\n解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧。\n\n# 动态分区分配算法\n\n内存分配算法，大体来说分为：**连续式分配 与 非连续式分配**\n\n连续式分配就是把所以要执行的程序 **完整的，有序的** 存入内存，连续式分配又可以分为**固定分区分配 和 动态分区分配**\n\n非连续式分配就是把要执行的程序按照一定规则进行拆分，显然这样更有效率，现在的操作系统通常也都是采用这种方式分配内存\n\n所谓动态分区分配，就是指**内存在初始时不会划分区域，而是会在进程装入时，根据所要装入的进程大小动态地对内存空间进行划分，以提高内存空间利用率，降低碎片的大小**\n\n动态分区分配算法有以下四种：\n\n> 首次适应算法（First Fit）\n\n空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小满足要求的第一个空闲分区就进行分配\n\n<img src=\"https://img-blog.csdnimg.cn/e5cf8456bf9941758f6a1bd2ba1c351a.png\" style=\"zoom:25%;\" />\n\n> 邻近适应算法（Next Fit）\n\n又称循环首次适应法，由首次适应法演变而成，不同之处是分配内存时从上一次查找结束的位置开始继续查找\n\n<img src=\"https://img-blog.csdnimg.cn/563c30ab6fdf4f209f8efa7654bfe1a3.png\" style=\"zoom:25%;\" />\n\n> 最佳适应算法（Best Fit）\n\n空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区就进行分配\n\n<img src=\"https://img-blog.csdnimg.cn/585a5ba3e4ad4eaeae77ebd1d8b02b32.png\" style=\"zoom:25%;\" />\n\n> 最坏适应算法（Next Fit）\n\n又称最大适应算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区（也就是最大的分区）就进行分配\n\n<img src=\"https://img-blog.csdnimg.cn/5379ed3464c945bcaf46dbf5f02bfbea.png\" style=\"zoom:25%;\" />\n\n**总结**\n\n首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。\n\n邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。\n\n最佳适应算法导致大量碎片，最坏适应算法导致没有大的空间。\n\n# 内存覆盖\n\n覆盖与交换技术是在程序用来扩充内存的两种方法。\n\n早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。\n\n**覆盖的基本思想是：**\n\n由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。\n\n将经常活跃的部分放在固定区，其余部分按调用关系分段。\n\n首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。\n\n覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。\n\n# 内存交换\n\n**交换的基本思想**\n\n把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；\n\n把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。\n\n> 例如，有一个CPU釆用时间片轮转调度算法的多道程序环境。\n\n时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。\n\n同时，CPU调度器可以将时间片分配给其他已在内存中的进程。\n\n每个进程用完时间片都与另一进程交换。\n\n理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。\n\n> 交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。\n\n由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾\n\n现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。","source":"_posts/操作系统导论/内存管理.md","raw":"---\ntitle: 内存管理\ncategories: \n- 操作系统导论\n---\n\n**逻辑地址和物理地址**\n\n我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。\n\n物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址，物理地址是内存单元真正的地址。\n\n编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。\n\nCPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 \n\n相对地址又称逻辑地址，绝对地址又称物理地址。\n\n**内存管理有哪几种方式**\n\n1. **块式管理**：将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了，这些在每个块中未被利用的空间，我们称之为碎片。\n2. **页式管理**：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片，页式管理通过页表对应逻辑地址和物理地址。\n\n<img src=\"https://img-blog.csdnimg.cn/a9ac3bf5e08e49ff9ed731ae54424132.png\" style=\"zoom:25%;\" />\n\n1. **段式管理**： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义， 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 ，段式管理通过段表对应逻辑地址和物理地址。\n2. **段页式管理机制：**段页式管理机制结合了段式管理和页式管理的优点，简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说**段页式管理机制**中段与段之间以及段的内部的都是离散的。\n\n<img src=\"https://img-blog.csdnimg.cn/92a8f2f5def248648db8392d96247400.png\" style=\"zoom:25%;\" />\n\n# 虚拟地址\n\n现代处理器使用的是一种称为**虚拟寻址(Virtual Addressing)**的寻址方式\n\n**使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。**\n\n实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为**内存管理单元（Memory Management Unit, MMU）**的硬件\n\n<img src=\"https://img-blog.csdnimg.cn/0ef33a73d3974272909d641634703314.png\" style=\"zoom:50%;\" />\n\n**为什么要有虚拟地址空间**\n\n没有虚拟地址空间的时候，**程序都是直接访问和操作的都是物理内存**。\n\n但是这样有什么问题？\n\n1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。\n2. 想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行，为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。\n\n**通过虚拟地址访问内存有以下优势：**\n\n- 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。\n- 程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。\n- 不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。\n\n**MMU如何把虚拟地址翻译成物理地址的**\n\n对于每个程序，内存管理单元MMU都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。\n\n每当为一个虚拟页面寻找到一个物理页面之后，就在页表里增加一条记录来保留该映射关系，当然，随着虚拟页面进出物理内存，页表的内容也会不断更新变化。\n\n<img src=\"https://img-blog.csdnimg.cn/f967e12729bd470eaf9d32221209ba36.png\" style=\"zoom:25%;\" />\n\n# 虚拟内存\n\n很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存\n\n通过 **虚拟内存** 可以让程序可以拥有超过系统物理内存大小的可用内存空间。\n\n另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。\n\n**虚拟内存**是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存\n\n**虚拟内存的重要意义是它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间**\n\n**虚拟内存的实现有以下三种方式：**\n\n1. **请求分页存储管理** ：请求分页是目前最常用的一种实现虚拟存储器的方法，请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行，假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。\n2. **请求分段存储管理** ：请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n3. **请求段页式存储管理**\n\n不管是上面那种实现方式，我们一般都需要：\n\n> 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；\n\n<img src=\"https://img-blog.csdnimg.cn/87aa376bd74a4561962682ecab2c0d43.png\" style=\"zoom:25%;\" />\n\n\n\n# 缺页中断\n\n如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；\n\n在分页系统中，一个虚拟页面既有可能在物理内存，也有可能保存在磁盘上。\n\n如果CPU发出的虚拟地址对应的页面不在物理内存，就将产生一个缺页中断，而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存。\n\n缺页中断的处理步骤如下，省略了中间很多的步骤，只保留最核心的几个步骤：\n\n<img src=\"https://img-blog.csdnimg.cn/0985097c9d61404a83711157b897cb5a.png\" style=\"zoom:50%;\" />\n\n# 页面置换算法\n\n当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。\n\n用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则\n\n- **OPT 页面置换算法（最佳页面置换算法）** ：该置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率，但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，一般作为衡量其他置换算法的方法。\n- **FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）** : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。\n\n- **LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）** ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。\n- **LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）** : 该置换算法选择在之前时期使用最少的页面作为淘汰页。\n\n# 局部性原理\n\n局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。\n\n局部性原理表现在以下两个方面：\n\n1. **时间局部性** ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问，产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。\n2. **空间局部性** ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。\n\n时间局部性是通过将近来使用的指令和数据保存到**高速缓存存储器**中，并使用高速缓存的层次结构实现。\n\n空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。\n\n# 页表\n\n操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。\n\nPage 到 Frame 的映射，需要一种叫作页表的结构。\n\n<img src=\"https://img-blog.csdnimg.cn/a15bed2353c74a62975e451eac3aff00.png\" style=\"zoom:25%;\" />\n\n上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。 \n\nPage 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。\n\n页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G/4K = 2621440 个条目。\n\n如果每个条目是 64bit，那么一共需要 20480K = 20M 页表，操作系统在内存中划分出小块区域给页表，并负责维护页表。\n\n**页表维护了虚拟地址到真实地址的映射。**\n\n每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：\n\n* 通过虚拟地址计算 Page 编号；\n\n* 查页表，根据 Page 编号，找到 Frame 编号；\n\n* 将虚拟地址换算成物理地址。\n\n## 多级页表\n\n引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中\n\n**一级页表：**\n\n假如物理内存中一共有1048576个页，那么页表就需要总共就是`1048576 * 4B = 4M`。\n\n也就是说我需要4M连续的内存来存放这个页表，也就是一级页表。\n\n随着虚拟地址空间的增大，存放页表所需要的连续空间也会增大，在操作系统内存紧张或者内存碎片较多时，这无疑会带来额外的开销。\n\n页表寻址是用寄存器来确定一级页表地址的，所以一级页表的地址必须指向确定的物理页，否则就会出现错误，所以如果用一级页表的话，就必须把全部的页表都加载进去。\n\n**二级页表：**\n\n而使用二级页表的话，只需要加载一个页目录表(一级页表)，大小为4K，可以管理1024个二级页表。\n\n可能你会有疑问，这1024个二级页表也是需要内存空间的，这下反而需要4MB+4KB的内存，反而更多了。\n\n其实二级页表并不是一定要存在内存中的，内存中只需要一个一级页表地址存在存器即可，二级页表可以使用缺页中断从外存移入内存。\n\n**多级页表属于时间换空间的典型场景**\n\n# 快表\n\n为了解决虚拟地址到物理地址的转换速度，操作系统在**页表方案**基础之上引入了**快表**来加速虚拟地址到物理地址的转换\n\n我们可以把快表理解为一种特殊的**高速缓冲存储器（Cache）**，其中的内容是页表的一部分或者全部内容，作为页表的 Cache，它的作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存，有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。\n\n**使用快表之后的地址转换流程是这样的：**\n\n1. 根据虚拟地址中的页号查快表；\n2. 如果该页在快表中，直接从快表中读取相应的物理地址；\n3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；\n4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n<img src=\"https://img-blog.csdnimg.cn/de56049e24c44756911ceded6d703d53.png\" style=\"zoom:25%;\" />\n\n# 内存管理单元\n\n在 CPU 中一个小型的设备——内存管理单元（MMU）\n\n<img src=\"https://img-blog.csdnimg.cn/2da3a2f130cf415cb0b42c19fda70f30.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/5bddbadd99e244c185886d4cd9ab239f.png\" style=\"zoom:25%;\" />\n\n当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。\n\n在不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。\n\n解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧。\n\n# 动态分区分配算法\n\n内存分配算法，大体来说分为：**连续式分配 与 非连续式分配**\n\n连续式分配就是把所以要执行的程序 **完整的，有序的** 存入内存，连续式分配又可以分为**固定分区分配 和 动态分区分配**\n\n非连续式分配就是把要执行的程序按照一定规则进行拆分，显然这样更有效率，现在的操作系统通常也都是采用这种方式分配内存\n\n所谓动态分区分配，就是指**内存在初始时不会划分区域，而是会在进程装入时，根据所要装入的进程大小动态地对内存空间进行划分，以提高内存空间利用率，降低碎片的大小**\n\n动态分区分配算法有以下四种：\n\n> 首次适应算法（First Fit）\n\n空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小满足要求的第一个空闲分区就进行分配\n\n<img src=\"https://img-blog.csdnimg.cn/e5cf8456bf9941758f6a1bd2ba1c351a.png\" style=\"zoom:25%;\" />\n\n> 邻近适应算法（Next Fit）\n\n又称循环首次适应法，由首次适应法演变而成，不同之处是分配内存时从上一次查找结束的位置开始继续查找\n\n<img src=\"https://img-blog.csdnimg.cn/563c30ab6fdf4f209f8efa7654bfe1a3.png\" style=\"zoom:25%;\" />\n\n> 最佳适应算法（Best Fit）\n\n空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区就进行分配\n\n<img src=\"https://img-blog.csdnimg.cn/585a5ba3e4ad4eaeae77ebd1d8b02b32.png\" style=\"zoom:25%;\" />\n\n> 最坏适应算法（Next Fit）\n\n又称最大适应算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区（也就是最大的分区）就进行分配\n\n<img src=\"https://img-blog.csdnimg.cn/5379ed3464c945bcaf46dbf5f02bfbea.png\" style=\"zoom:25%;\" />\n\n**总结**\n\n首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。\n\n邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。\n\n最佳适应算法导致大量碎片，最坏适应算法导致没有大的空间。\n\n# 内存覆盖\n\n覆盖与交换技术是在程序用来扩充内存的两种方法。\n\n早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。\n\n**覆盖的基本思想是：**\n\n由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。\n\n将经常活跃的部分放在固定区，其余部分按调用关系分段。\n\n首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。\n\n覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。\n\n# 内存交换\n\n**交换的基本思想**\n\n把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；\n\n把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。\n\n> 例如，有一个CPU釆用时间片轮转调度算法的多道程序环境。\n\n时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。\n\n同时，CPU调度器可以将时间片分配给其他已在内存中的进程。\n\n每个进程用完时间片都与另一进程交换。\n\n理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。\n\n> 交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。\n\n由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾\n\n现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。","slug":"操作系统导论/内存管理","published":1,"date":"2022-02-01T14:30:42.274Z","updated":"2022-02-01T14:33:15.494Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwk900j1fhji9di4f4yv","content":"<p><strong>逻辑地址和物理地址</strong></p>\n<p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。</p>\n<p>物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址，物理地址是内存单元真正的地址。</p>\n<p>编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。</p>\n<p>CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 </p>\n<p>相对地址又称逻辑地址，绝对地址又称物理地址。</p>\n<p><strong>内存管理有哪几种方式</strong></p>\n<ol>\n<li><strong>块式管理</strong>：将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了，这些在每个块中未被利用的空间，我们称之为碎片。</li>\n<li><strong>页式管理</strong>：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片，页式管理通过页表对应逻辑地址和物理地址。</li>\n</ol>\n<img src=\"https://img-blog.csdnimg.cn/a9ac3bf5e08e49ff9ed731ae54424132.png\" style=\"zoom:25%;\" />\n\n<ol>\n<li><strong>段式管理</strong>： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义， 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 ，段式管理通过段表对应逻辑地址和物理地址。</li>\n<li><strong>段页式管理机制：</strong>段页式管理机制结合了段式管理和页式管理的优点，简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说<strong>段页式管理机制</strong>中段与段之间以及段的内部的都是离散的。</li>\n</ol>\n<img src=\"https://img-blog.csdnimg.cn/92a8f2f5def248648db8392d96247400.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"虚拟地址\"><a href=\"#虚拟地址\" class=\"headerlink\" title=\"虚拟地址\"></a>虚拟地址</h1><p>现代处理器使用的是一种称为**虚拟寻址(Virtual Addressing)**的寻址方式</p>\n<p><strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong></p>\n<p>实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为<strong>内存管理单元（Memory Management Unit, MMU）</strong>的硬件</p>\n<img src=\"https://img-blog.csdnimg.cn/0ef33a73d3974272909d641634703314.png\" style=\"zoom:50%;\" />\n\n<p><strong>为什么要有虚拟地址空间</strong></p>\n<p>没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong>。</p>\n<p>但是这样有什么问题？</p>\n<ol>\n<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。</li>\n<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行，为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>\n</ol>\n<p><strong>通过虚拟地址访问内存有以下优势：</strong></p>\n<ul>\n<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>\n<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。</li>\n<li>不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>\n</ul>\n<p><strong>MMU如何把虚拟地址翻译成物理地址的</strong></p>\n<p>对于每个程序，内存管理单元MMU都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。</p>\n<p>每当为一个虚拟页面寻找到一个物理页面之后，就在页表里增加一条记录来保留该映射关系，当然，随着虚拟页面进出物理内存，页表的内容也会不断更新变化。</p>\n<img src=\"https://img-blog.csdnimg.cn/f967e12729bd470eaf9d32221209ba36.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><p>很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存</p>\n<p>通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。</p>\n<p>另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。</p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存</p>\n<p><strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong></p>\n<p><strong>虚拟内存的实现有以下三种方式：</strong></p>\n<ol>\n<li><strong>请求分页存储管理</strong> ：请求分页是目前最常用的一种实现虚拟存储器的方法，请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行，假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>\n<li><strong>请求分段存储管理</strong> ：请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>\n<li><strong>请求段页式存储管理</strong></li>\n</ol>\n<p>不管是上面那种实现方式，我们一般都需要：</p>\n<blockquote>\n<p>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/87aa376bd74a4561962682ecab2c0d43.png\" style=\"zoom:25%;\" />\n\n\n\n<h1 id=\"缺页中断\"><a href=\"#缺页中断\" class=\"headerlink\" title=\"缺页中断\"></a>缺页中断</h1><p>如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</p>\n<p>在分页系统中，一个虚拟页面既有可能在物理内存，也有可能保存在磁盘上。</p>\n<p>如果CPU发出的虚拟地址对应的页面不在物理内存，就将产生一个缺页中断，而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存。</p>\n<p>缺页中断的处理步骤如下，省略了中间很多的步骤，只保留最核心的几个步骤：</p>\n<img src=\"https://img-blog.csdnimg.cn/0985097c9d61404a83711157b897cb5a.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h1><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。</p>\n<p>用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则</p>\n<ul>\n<li><p><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：该置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率，但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，一般作为衡量其他置换算法的方法。</p>\n</li>\n<li><p><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p>\n</li>\n<li><p><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p>\n</li>\n<li><p><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</p>\n</li>\n</ul>\n<h1 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h1><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>\n<p>局部性原理表现在以下两个方面：</p>\n<ol>\n<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问，产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>\n<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>\n</ol>\n<p>时间局部性是通过将近来使用的指令和数据保存到<strong>高速缓存存储器</strong>中，并使用高速缓存的层次结构实现。</p>\n<p>空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p>\n<h1 id=\"页表\"><a href=\"#页表\" class=\"headerlink\" title=\"页表\"></a>页表</h1><p>操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。</p>\n<p>Page 到 Frame 的映射，需要一种叫作页表的结构。</p>\n<img src=\"https://img-blog.csdnimg.cn/a15bed2353c74a62975e451eac3aff00.png\" style=\"zoom:25%;\" />\n\n<p>上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。 </p>\n<p>Page 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。</p>\n<p>页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G&#x2F;4K &#x3D; 2621440 个条目。</p>\n<p>如果每个条目是 64bit，那么一共需要 20480K &#x3D; 20M 页表，操作系统在内存中划分出小块区域给页表，并负责维护页表。</p>\n<p><strong>页表维护了虚拟地址到真实地址的映射。</strong></p>\n<p>每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：</p>\n<ul>\n<li><p>通过虚拟地址计算 Page 编号；</p>\n</li>\n<li><p>查页表，根据 Page 编号，找到 Frame 编号；</p>\n</li>\n<li><p>将虚拟地址换算成物理地址。</p>\n</li>\n</ul>\n<h2 id=\"多级页表\"><a href=\"#多级页表\" class=\"headerlink\" title=\"多级页表\"></a>多级页表</h2><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中</p>\n<p><strong>一级页表：</strong></p>\n<p>假如物理内存中一共有1048576个页，那么页表就需要总共就是<code>1048576 * 4B = 4M</code>。</p>\n<p>也就是说我需要4M连续的内存来存放这个页表，也就是一级页表。</p>\n<p>随着虚拟地址空间的增大，存放页表所需要的连续空间也会增大，在操作系统内存紧张或者内存碎片较多时，这无疑会带来额外的开销。</p>\n<p>页表寻址是用寄存器来确定一级页表地址的，所以一级页表的地址必须指向确定的物理页，否则就会出现错误，所以如果用一级页表的话，就必须把全部的页表都加载进去。</p>\n<p><strong>二级页表：</strong></p>\n<p>而使用二级页表的话，只需要加载一个页目录表(一级页表)，大小为4K，可以管理1024个二级页表。</p>\n<p>可能你会有疑问，这1024个二级页表也是需要内存空间的，这下反而需要4MB+4KB的内存，反而更多了。</p>\n<p>其实二级页表并不是一定要存在内存中的，内存中只需要一个一级页表地址存在存器即可，二级页表可以使用缺页中断从外存移入内存。</p>\n<p><strong>多级页表属于时间换空间的典型场景</strong></p>\n<h1 id=\"快表\"><a href=\"#快表\" class=\"headerlink\" title=\"快表\"></a>快表</h1><p>为了解决虚拟地址到物理地址的转换速度，操作系统在<strong>页表方案</strong>基础之上引入了<strong>快表</strong>来加速虚拟地址到物理地址的转换</p>\n<p>我们可以把快表理解为一种特殊的<strong>高速缓冲存储器（Cache）</strong>，其中的内容是页表的一部分或者全部内容，作为页表的 Cache，它的作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存，有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>\n<p><strong>使用快表之后的地址转换流程是这样的：</strong></p>\n<ol>\n<li>根据虚拟地址中的页号查快表；</li>\n<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>\n<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>\n<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>\n</ol>\n<img src=\"https://img-blog.csdnimg.cn/de56049e24c44756911ceded6d703d53.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"内存管理单元\"><a href=\"#内存管理单元\" class=\"headerlink\" title=\"内存管理单元\"></a>内存管理单元</h1><p>在 CPU 中一个小型的设备——内存管理单元（MMU）</p>\n<img src=\"https://img-blog.csdnimg.cn/2da3a2f130cf415cb0b42c19fda70f30.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/5bddbadd99e244c185886d4cd9ab239f.png\" style=\"zoom:25%;\" />\n\n<p>当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。</p>\n<p>在不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。</p>\n<p>解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧。</p>\n<h1 id=\"动态分区分配算法\"><a href=\"#动态分区分配算法\" class=\"headerlink\" title=\"动态分区分配算法\"></a>动态分区分配算法</h1><p>内存分配算法，大体来说分为：<strong>连续式分配 与 非连续式分配</strong></p>\n<p>连续式分配就是把所以要执行的程序 <strong>完整的，有序的</strong> 存入内存，连续式分配又可以分为<strong>固定分区分配 和 动态分区分配</strong></p>\n<p>非连续式分配就是把要执行的程序按照一定规则进行拆分，显然这样更有效率，现在的操作系统通常也都是采用这种方式分配内存</p>\n<p>所谓动态分区分配，就是指<strong>内存在初始时不会划分区域，而是会在进程装入时，根据所要装入的进程大小动态地对内存空间进行划分，以提高内存空间利用率，降低碎片的大小</strong></p>\n<p>动态分区分配算法有以下四种：</p>\n<blockquote>\n<p>首次适应算法（First Fit）</p>\n</blockquote>\n<p>空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小满足要求的第一个空闲分区就进行分配</p>\n<img src=\"https://img-blog.csdnimg.cn/e5cf8456bf9941758f6a1bd2ba1c351a.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>邻近适应算法（Next Fit）</p>\n</blockquote>\n<p>又称循环首次适应法，由首次适应法演变而成，不同之处是分配内存时从上一次查找结束的位置开始继续查找</p>\n<img src=\"https://img-blog.csdnimg.cn/563c30ab6fdf4f209f8efa7654bfe1a3.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>最佳适应算法（Best Fit）</p>\n</blockquote>\n<p>空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区就进行分配</p>\n<img src=\"https://img-blog.csdnimg.cn/585a5ba3e4ad4eaeae77ebd1d8b02b32.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>最坏适应算法（Next Fit）</p>\n</blockquote>\n<p>又称最大适应算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区（也就是最大的分区）就进行分配</p>\n<img src=\"https://img-blog.csdnimg.cn/5379ed3464c945bcaf46dbf5f02bfbea.png\" style=\"zoom:25%;\" />\n\n<p><strong>总结</strong></p>\n<p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。</p>\n<p>邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>\n<p>最佳适应算法导致大量碎片，最坏适应算法导致没有大的空间。</p>\n<h1 id=\"内存覆盖\"><a href=\"#内存覆盖\" class=\"headerlink\" title=\"内存覆盖\"></a>内存覆盖</h1><p>覆盖与交换技术是在程序用来扩充内存的两种方法。</p>\n<p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。</p>\n<p><strong>覆盖的基本思想是：</strong></p>\n<p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。</p>\n<p>将经常活跃的部分放在固定区，其余部分按调用关系分段。</p>\n<p>首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</p>\n<p>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。</p>\n<h1 id=\"内存交换\"><a href=\"#内存交换\" class=\"headerlink\" title=\"内存交换\"></a>内存交换</h1><p><strong>交换的基本思想</strong></p>\n<p>把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；</p>\n<p>把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。</p>\n<blockquote>\n<p>例如，有一个CPU釆用时间片轮转调度算法的多道程序环境。</p>\n</blockquote>\n<p>时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。</p>\n<p>同时，CPU调度器可以将时间片分配给其他已在内存中的进程。</p>\n<p>每个进程用完时间片都与另一进程交换。</p>\n<p>理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p>\n<blockquote>\n<p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。</p>\n</blockquote>\n<p>由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾</p>\n<p>现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>逻辑地址和物理地址</strong></p>\n<p>我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。</p>\n<p>物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址，物理地址是内存单元真正的地址。</p>\n<p>编译时只需确定变量x存放的相对地址是100 ( 也就是说相对于进程在内存中的起始地址而言的地址)。</p>\n<p>CPU想要找到x在内存中的实际存放位置，只需要用进程的起始地址+100即可。 </p>\n<p>相对地址又称逻辑地址，绝对地址又称物理地址。</p>\n<p><strong>内存管理有哪几种方式</strong></p>\n<ol>\n<li><strong>块式管理</strong>：将内存分为几个固定大小的块，每个块中只包含一个进程，如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了，这些在每个块中未被利用的空间，我们称之为碎片。</li>\n<li><strong>页式管理</strong>：把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片，页式管理通过页表对应逻辑地址和物理地址。</li>\n</ol>\n<img src=\"https://img-blog.csdnimg.cn/a9ac3bf5e08e49ff9ed731ae54424132.png\" style=\"zoom:25%;\" />\n\n<ol>\n<li><strong>段式管理</strong>： 页式管理虽然提高了内存利用率，但是页式管理其中的页实际并无任何实际意义， 段式管理把主存分为一段段的，每一段的空间又要比一页的空间小很多 ，段式管理通过段表对应逻辑地址和物理地址。</li>\n<li><strong>段页式管理机制：</strong>段页式管理机制结合了段式管理和页式管理的优点，简单来说段页式管理机制就是把主存先分成若干段，每个段又分成若干页，也就是说<strong>段页式管理机制</strong>中段与段之间以及段的内部的都是离散的。</li>\n</ol>\n<img src=\"https://img-blog.csdnimg.cn/92a8f2f5def248648db8392d96247400.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"虚拟地址\"><a href=\"#虚拟地址\" class=\"headerlink\" title=\"虚拟地址\"></a>虚拟地址</h1><p>现代处理器使用的是一种称为**虚拟寻址(Virtual Addressing)**的寻址方式</p>\n<p><strong>使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong></p>\n<p>实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为<strong>内存管理单元（Memory Management Unit, MMU）</strong>的硬件</p>\n<img src=\"https://img-blog.csdnimg.cn/0ef33a73d3974272909d641634703314.png\" style=\"zoom:50%;\" />\n\n<p><strong>为什么要有虚拟地址空间</strong></p>\n<p>没有虚拟地址空间的时候，<strong>程序都是直接访问和操作的都是物理内存</strong>。</p>\n<p>但是这样有什么问题？</p>\n<ol>\n<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易破坏操作系统，造成操作系统崩溃。</li>\n<li>想要同时运行多个程序特别困难，比如你想同时运行一个微信和一个 QQ 音乐都不行，为什么呢？举个简单的例子：微信在运行的时候给内存地址 1xxx 赋值后，QQ 音乐也同样给内存地址 1xxx 赋值，那么 QQ 音乐对内存的赋值就会覆盖微信之前所赋的值，这就造成了微信这个程序就会崩溃。</li>\n</ol>\n<p><strong>通过虚拟地址访问内存有以下优势：</strong></p>\n<ul>\n<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区。</li>\n<li>程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。</li>\n<li>不同进程使用的虚拟地址彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li>\n</ul>\n<p><strong>MMU如何把虚拟地址翻译成物理地址的</strong></p>\n<p>对于每个程序，内存管理单元MMU都为其保存一个页表，该页表中存放的是虚拟页面到物理页面的映射。</p>\n<p>每当为一个虚拟页面寻找到一个物理页面之后，就在页表里增加一条记录来保留该映射关系，当然，随着虚拟页面进出物理内存，页表的内容也会不断更新变化。</p>\n<img src=\"https://img-blog.csdnimg.cn/f967e12729bd470eaf9d32221209ba36.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"虚拟内存\"><a href=\"#虚拟内存\" class=\"headerlink\" title=\"虚拟内存\"></a>虚拟内存</h1><p>很多时候我们使用点开了很多占内存的软件，这些软件占用的内存可能已经远远超出了我们电脑本身具有的物理内存</p>\n<p>通过 <strong>虚拟内存</strong> 可以让程序可以拥有超过系统物理内存大小的可用内存空间。</p>\n<p>另外，虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享主存的错觉（每个进程拥有一片连续完整的内存空间），这样会更加有效地管理内存并减少出错。</p>\n<p><strong>虚拟内存</strong>是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存</p>\n<p><strong>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间</strong>，并且 <strong>把内存扩展到硬盘空间</strong></p>\n<p><strong>虚拟内存的实现有以下三种方式：</strong></p>\n<ol>\n<li><strong>请求分页存储管理</strong> ：请求分页是目前最常用的一种实现虚拟存储器的方法，请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行，假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。</li>\n<li><strong>请求分段存储管理</strong> ：请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。</li>\n<li><strong>请求段页式存储管理</strong></li>\n</ol>\n<p>不管是上面那种实现方式，我们一般都需要：</p>\n<blockquote>\n<p>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/87aa376bd74a4561962682ecab2c0d43.png\" style=\"zoom:25%;\" />\n\n\n\n<h1 id=\"缺页中断\"><a href=\"#缺页中断\" class=\"headerlink\" title=\"缺页中断\"></a>缺页中断</h1><p>如果<strong>需执行的指令或访问的数据尚未在内存</strong>（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段<strong>调入到内存</strong>，然后继续执行程序；</p>\n<p>在分页系统中，一个虚拟页面既有可能在物理内存，也有可能保存在磁盘上。</p>\n<p>如果CPU发出的虚拟地址对应的页面不在物理内存，就将产生一个缺页中断，而缺页中断服务程序负责将需要的虚拟页面找到并加载到内存。</p>\n<p>缺页中断的处理步骤如下，省略了中间很多的步骤，只保留最核心的几个步骤：</p>\n<img src=\"https://img-blog.csdnimg.cn/0985097c9d61404a83711157b897cb5a.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"页面置换算法\"><a href=\"#页面置换算法\" class=\"headerlink\" title=\"页面置换算法\"></a>页面置换算法</h1><p>当发生缺页中断时，如果当前内存中并没有空闲的页面，操作系统就必须在内存选择一个页面将其移出内存，以便为即将调入的页面让出空间。</p>\n<p>用来选择淘汰哪一页的规则叫做页面置换算法，我们可以把页面置换算法看成是淘汰页面的规则</p>\n<ul>\n<li><p><strong>OPT 页面置换算法（最佳页面置换算法）</strong> ：该置换算法所选择的被淘汰页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率，但由于人们目前无法预知进程在内存下的若千页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现，一般作为衡量其他置换算法的方法。</p>\n</li>\n<li><p><strong>FIFO（First In First Out） 页面置换算法（先进先出页面置换算法）</strong> : 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰。</p>\n</li>\n<li><p><strong>LRU （Least Currently Used）页面置换算法（最近最久未使用页面置换算法）</strong> ：LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T，当须淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰。</p>\n</li>\n<li><p><strong>LFU （Least Frequently Used）页面置换算法（最少使用页面置换算法）</strong> : 该置换算法选择在之前时期使用最少的页面作为淘汰页。</p>\n</li>\n</ul>\n<h1 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h1><p>局部性原理是虚拟内存技术的基础，正是因为程序运行具有局部性原理，才可以只装入部分程序到内存就开始运行。</p>\n<p>局部性原理表现在以下两个方面：</p>\n<ol>\n<li><strong>时间局部性</strong> ：如果程序中的某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能再次被访问，产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作。</li>\n<li><strong>空间局部性</strong> ：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>\n</ol>\n<p>时间局部性是通过将近来使用的指令和数据保存到<strong>高速缓存存储器</strong>中，并使用高速缓存的层次结构实现。</p>\n<p>空间局部性通常是使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。</p>\n<h1 id=\"页表\"><a href=\"#页表\" class=\"headerlink\" title=\"页表\"></a>页表</h1><p>操作系统将虚拟内存分块，每个小块称为一个页（Page）；真实内存也需要分块，每个小块我们称为一个 Frame。</p>\n<p>Page 到 Frame 的映射，需要一种叫作页表的结构。</p>\n<img src=\"https://img-blog.csdnimg.cn/a15bed2353c74a62975e451eac3aff00.png\" style=\"zoom:25%;\" />\n\n<p>上图展示了 Page、Frame 和页表 （PageTable）三者之间的关系。 </p>\n<p>Page 大小和 Frame 大小通常相等，页表中记录的某个 Page 对应的 Frame 编号。</p>\n<p>页表也需要存储空间，比如虚拟内存大小为 10G， Page 大小是 4K，那么需要 10G&#x2F;4K &#x3D; 2621440 个条目。</p>\n<p>如果每个条目是 64bit，那么一共需要 20480K &#x3D; 20M 页表，操作系统在内存中划分出小块区域给页表，并负责维护页表。</p>\n<p><strong>页表维护了虚拟地址到真实地址的映射。</strong></p>\n<p>每次程序使用内存时，需要把虚拟内存地址换算成物理内存地址，换算过程分为以下 3 个步骤：</p>\n<ul>\n<li><p>通过虚拟地址计算 Page 编号；</p>\n</li>\n<li><p>查页表，根据 Page 编号，找到 Frame 编号；</p>\n</li>\n<li><p>将虚拟地址换算成物理地址。</p>\n</li>\n</ul>\n<h2 id=\"多级页表\"><a href=\"#多级页表\" class=\"headerlink\" title=\"多级页表\"></a>多级页表</h2><p>引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中</p>\n<p><strong>一级页表：</strong></p>\n<p>假如物理内存中一共有1048576个页，那么页表就需要总共就是<code>1048576 * 4B = 4M</code>。</p>\n<p>也就是说我需要4M连续的内存来存放这个页表，也就是一级页表。</p>\n<p>随着虚拟地址空间的增大，存放页表所需要的连续空间也会增大，在操作系统内存紧张或者内存碎片较多时，这无疑会带来额外的开销。</p>\n<p>页表寻址是用寄存器来确定一级页表地址的，所以一级页表的地址必须指向确定的物理页，否则就会出现错误，所以如果用一级页表的话，就必须把全部的页表都加载进去。</p>\n<p><strong>二级页表：</strong></p>\n<p>而使用二级页表的话，只需要加载一个页目录表(一级页表)，大小为4K，可以管理1024个二级页表。</p>\n<p>可能你会有疑问，这1024个二级页表也是需要内存空间的，这下反而需要4MB+4KB的内存，反而更多了。</p>\n<p>其实二级页表并不是一定要存在内存中的，内存中只需要一个一级页表地址存在存器即可，二级页表可以使用缺页中断从外存移入内存。</p>\n<p><strong>多级页表属于时间换空间的典型场景</strong></p>\n<h1 id=\"快表\"><a href=\"#快表\" class=\"headerlink\" title=\"快表\"></a>快表</h1><p>为了解决虚拟地址到物理地址的转换速度，操作系统在<strong>页表方案</strong>基础之上引入了<strong>快表</strong>来加速虚拟地址到物理地址的转换</p>\n<p>我们可以把快表理解为一种特殊的<strong>高速缓冲存储器（Cache）</strong>，其中的内容是页表的一部分或者全部内容，作为页表的 Cache，它的作用与页表相似，但是提高了访问速率，由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存，有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p>\n<p><strong>使用快表之后的地址转换流程是这样的：</strong></p>\n<ol>\n<li>根据虚拟地址中的页号查快表；</li>\n<li>如果该页在快表中，直接从快表中读取相应的物理地址；</li>\n<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li>\n<li>当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li>\n</ol>\n<img src=\"https://img-blog.csdnimg.cn/de56049e24c44756911ceded6d703d53.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"内存管理单元\"><a href=\"#内存管理单元\" class=\"headerlink\" title=\"内存管理单元\"></a>内存管理单元</h1><p>在 CPU 中一个小型的设备——内存管理单元（MMU）</p>\n<img src=\"https://img-blog.csdnimg.cn/2da3a2f130cf415cb0b42c19fda70f30.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/5bddbadd99e244c185886d4cd9ab239f.png\" style=\"zoom:25%;\" />\n\n<p>当 CPU 需要执行一条指令时，如果指令中涉及内存读写操作，CPU 会把虚拟地址给 MMU，MMU 自动完成虚拟地址到真实地址的计算；然后，MMU 连接了地址总线，帮助 CPU 操作真实地址。</p>\n<p>在不同 CPU 的 MMU 可能是不同的，因此这里会遇到很多跨平台的问题。</p>\n<p>解决跨平台问题不但有繁重的工作量，更需要高超的编程技巧。</p>\n<h1 id=\"动态分区分配算法\"><a href=\"#动态分区分配算法\" class=\"headerlink\" title=\"动态分区分配算法\"></a>动态分区分配算法</h1><p>内存分配算法，大体来说分为：<strong>连续式分配 与 非连续式分配</strong></p>\n<p>连续式分配就是把所以要执行的程序 <strong>完整的，有序的</strong> 存入内存，连续式分配又可以分为<strong>固定分区分配 和 动态分区分配</strong></p>\n<p>非连续式分配就是把要执行的程序按照一定规则进行拆分，显然这样更有效率，现在的操作系统通常也都是采用这种方式分配内存</p>\n<p>所谓动态分区分配，就是指<strong>内存在初始时不会划分区域，而是会在进程装入时，根据所要装入的进程大小动态地对内存空间进行划分，以提高内存空间利用率，降低碎片的大小</strong></p>\n<p>动态分区分配算法有以下四种：</p>\n<blockquote>\n<p>首次适应算法（First Fit）</p>\n</blockquote>\n<p>空闲分区以地址递增的次序链接，分配内存时顺序查找，找到大小满足要求的第一个空闲分区就进行分配</p>\n<img src=\"https://img-blog.csdnimg.cn/e5cf8456bf9941758f6a1bd2ba1c351a.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>邻近适应算法（Next Fit）</p>\n</blockquote>\n<p>又称循环首次适应法，由首次适应法演变而成，不同之处是分配内存时从上一次查找结束的位置开始继续查找</p>\n<img src=\"https://img-blog.csdnimg.cn/563c30ab6fdf4f209f8efa7654bfe1a3.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>最佳适应算法（Best Fit）</p>\n</blockquote>\n<p>空闲分区按容量递增形成分区链，找到第一个能满足要求的空闲分区就进行分配</p>\n<img src=\"https://img-blog.csdnimg.cn/585a5ba3e4ad4eaeae77ebd1d8b02b32.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>最坏适应算法（Next Fit）</p>\n</blockquote>\n<p>又称最大适应算法，空闲分区以容量递减的次序链接，找到第一个能满足要求的空闲分区（也就是最大的分区）就进行分配</p>\n<img src=\"https://img-blog.csdnimg.cn/5379ed3464c945bcaf46dbf5f02bfbea.png\" style=\"zoom:25%;\" />\n\n<p><strong>总结</strong></p>\n<p>首次适应不仅最简单，通常也是最好最快，不过首次适应算法会使得内存低地址部分出现很多小的空闲分区，而每次查找都要经过这些分区，因此也增加了查找的开销。</p>\n<p>邻近算法试图解决这个问题，但实际上，它常常会导致在内存的末尾分配空间分裂成小的碎片，它通常比首次适应算法结果要差。</p>\n<p>最佳适应算法导致大量碎片，最坏适应算法导致没有大的空间。</p>\n<h1 id=\"内存覆盖\"><a href=\"#内存覆盖\" class=\"headerlink\" title=\"内存覆盖\"></a>内存覆盖</h1><p>覆盖与交换技术是在程序用来扩充内存的两种方法。</p>\n<p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但是存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。</p>\n<p><strong>覆盖的基本思想是：</strong></p>\n<p>由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可以把用户空间分成一个固定区和若干个覆盖区。</p>\n<p>将经常活跃的部分放在固定区，其余部分按调用关系分段。</p>\n<p>首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</p>\n<p>覆盖技术的特点是打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行。</p>\n<h1 id=\"内存交换\"><a href=\"#内存交换\" class=\"headerlink\" title=\"内存交换\"></a>内存交换</h1><p><strong>交换的基本思想</strong></p>\n<p>把处于等待状态（或在CPU调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又叫换出；</p>\n<p>把准备好竞争CPU运行的程序从辅存移到内存，这一过程又称为换入。</p>\n<blockquote>\n<p>例如，有一个CPU釆用时间片轮转调度算法的多道程序环境。</p>\n</blockquote>\n<p>时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入到刚刚释放的内存空间中。</p>\n<p>同时，CPU调度器可以将时间片分配给其他已在内存中的进程。</p>\n<p>每个进程用完时间片都与另一进程交换。</p>\n<p>理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p>\n<blockquote>\n<p>交换技术主要是在不同进程（或作业）之间进行，而覆盖则用于同一个程序或进程中。</p>\n</blockquote>\n<p>由于覆盖技术要求给出程序段之间的覆盖结构，使得其对用户和程序员不透明，所以对于主存无法存放用户程序的矛盾</p>\n<p>现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p>\n"},{"title":"常见面试题","_content":"\n**进程、线程的区别**\n\n操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。\n\n<img src=\"https://img-blog.csdnimg.cn/49e02558c5a946ac9509a2f5d77b3739.png\" style=\"zoom:25%;\" />\n\n调度：线程作为CPU调度和分配的基本单位，进程作为拥有资源的基本单位；\n\n并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；\n\n> 拥有资源：\n\n进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。\n\n进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；\n\n线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；\n\n> 系统开销：\n\n在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。\n\n但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。\n\n线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。\n\n**一个进程可以创建多少线程**\n\n理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。\n\n如果要创建多于2048的话，必须修改编译器的设置。\n\n在一般情况下，你不需要那么多的线程，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。\n\n**外中断和异常有什么区别**\n\n外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求，此外还有时钟中断、控制台中断等。\n\n而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。\n\n**解决Hash冲突四种方法**\n\n开放定址法\n\n- 开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。\n\n链地址法\n\n- 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。\n\n再哈希法\n\n- 当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。\n\n建立公共溢出区\n\n- 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。\n\n**分页机制和分段机制有哪些共同点和区别**\n\n共同点\n\n- 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。\n- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。\n\n区别\n\n- 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。\n- 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。\n- 分页是一维地址空间，分段是二维的。\n\n**介绍一下几种典型的锁**\n\n> 读写锁\n\n- 可以同时进行多个读\n- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）\n- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）\n\n> 互斥锁\n\n一次只能一个线程拥有互斥锁，其他线程只有等待\n\n互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。\n\n互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁\n\n> 条件变量\n\n互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。\n\n而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。\n\n当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。\n\n一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。\n\n总的来说**互斥锁是线程间互斥的机制，条件变量则是同步机制。**\n\n> 自旋锁\n\n如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。\n\n如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。\n\n虽然它的效率比互斥锁高，但是它也有些不足之处：\n\n- 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。\n- 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。\n\n**如何让进程后台运行**\n\n1.命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了\n\n2.ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程\n\n3.nohup + &，将标准输出和标准错误缺省会被重定向到 `nohup.out` 文件中，忽略所有挂断（SIGHUP）信号\n\n```\nnohup ping www.ibm.com &\n```\n\n4.运行指令前面 + setsid，使其父进程变成init进程，不受SIGHUP信号的影响\n\n```\n[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef |grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n```\n\n上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。\n\n> 5.将命令+ &放在()括号中，也可以是进程不受HUP信号的影响\n\n```\n[root@pvcent107 ~]# (ping www.ibm.com &)\n```\n\n**异常和中断的区别**\n\n> 中断\n\n当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。\n\n下面这张图显示了中断处理的流程：\n\n<img src=\"https://img-blog.csdnimg.cn/6c0a43b5915e44bf8d05b6d871fd3b25.png\" style=\"zoom:25%;\" />\n\n> 异常\n\nCPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。\n\n**异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常**\n\n下面这张图显示了异常处理的流程：\n\n<img src=\"https://img-blog.csdnimg.cn/fa69b2ce6ee7405ea351b0e4acd2e616.png\" style=\"zoom:25%;\" />\n\n> 相同点\n\n- 最后都是由CPU发送给内核，由内核去处理\n- 处理程序的流程设计上是相似的\n\n> 不同点\n\n- 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的\n- 内核需要根据是异常还是中断调用不同的处理程序\n- 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的\n- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中","source":"_posts/操作系统导论/常见面试题.md","raw":"---\ntitle: 常见面试题\ncategories: \n- 操作系统导论\n---\n\n**进程、线程的区别**\n\n操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。\n\n<img src=\"https://img-blog.csdnimg.cn/49e02558c5a946ac9509a2f5d77b3739.png\" style=\"zoom:25%;\" />\n\n调度：线程作为CPU调度和分配的基本单位，进程作为拥有资源的基本单位；\n\n并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；\n\n> 拥有资源：\n\n进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。\n\n进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；\n\n线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；\n\n> 系统开销：\n\n在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。\n\n但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。\n\n线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。\n\n**一个进程可以创建多少线程**\n\n理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。\n\n如果要创建多于2048的话，必须修改编译器的设置。\n\n在一般情况下，你不需要那么多的线程，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。\n\n**外中断和异常有什么区别**\n\n外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求，此外还有时钟中断、控制台中断等。\n\n而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。\n\n**解决Hash冲突四种方法**\n\n开放定址法\n\n- 开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。\n\n链地址法\n\n- 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。\n\n再哈希法\n\n- 当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。\n\n建立公共溢出区\n\n- 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。\n\n**分页机制和分段机制有哪些共同点和区别**\n\n共同点\n\n- 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。\n- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。\n\n区别\n\n- 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。\n- 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。\n- 分页是一维地址空间，分段是二维的。\n\n**介绍一下几种典型的锁**\n\n> 读写锁\n\n- 可以同时进行多个读\n- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）\n- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）\n\n> 互斥锁\n\n一次只能一个线程拥有互斥锁，其他线程只有等待\n\n互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。\n\n互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁\n\n> 条件变量\n\n互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。\n\n而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。\n\n当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。\n\n一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。\n\n总的来说**互斥锁是线程间互斥的机制，条件变量则是同步机制。**\n\n> 自旋锁\n\n如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。\n\n如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。\n\n虽然它的效率比互斥锁高，但是它也有些不足之处：\n\n- 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。\n- 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。\n\n**如何让进程后台运行**\n\n1.命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了\n\n2.ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程\n\n3.nohup + &，将标准输出和标准错误缺省会被重定向到 `nohup.out` 文件中，忽略所有挂断（SIGHUP）信号\n\n```\nnohup ping www.ibm.com &\n```\n\n4.运行指令前面 + setsid，使其父进程变成init进程，不受SIGHUP信号的影响\n\n```\n[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef |grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n```\n\n上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。\n\n> 5.将命令+ &放在()括号中，也可以是进程不受HUP信号的影响\n\n```\n[root@pvcent107 ~]# (ping www.ibm.com &)\n```\n\n**异常和中断的区别**\n\n> 中断\n\n当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。\n\n下面这张图显示了中断处理的流程：\n\n<img src=\"https://img-blog.csdnimg.cn/6c0a43b5915e44bf8d05b6d871fd3b25.png\" style=\"zoom:25%;\" />\n\n> 异常\n\nCPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。\n\n**异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常**\n\n下面这张图显示了异常处理的流程：\n\n<img src=\"https://img-blog.csdnimg.cn/fa69b2ce6ee7405ea351b0e4acd2e616.png\" style=\"zoom:25%;\" />\n\n> 相同点\n\n- 最后都是由CPU发送给内核，由内核去处理\n- 处理程序的流程设计上是相似的\n\n> 不同点\n\n- 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的\n- 内核需要根据是异常还是中断调用不同的处理程序\n- 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的\n- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中","slug":"操作系统导论/常见面试题","published":1,"date":"2022-02-01T14:33:58.791Z","updated":"2022-02-01T14:34:30.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwk900j4fhjifaqjgf0j","content":"<p><strong>进程、线程的区别</strong></p>\n<p>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p>\n<img src=\"https://img-blog.csdnimg.cn/49e02558c5a946ac9509a2f5d77b3739.png\" style=\"zoom:25%;\" />\n\n<p>调度：线程作为CPU调度和分配的基本单位，进程作为拥有资源的基本单位；</p>\n<p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p>\n<blockquote>\n<p>拥有资源：</p>\n</blockquote>\n<p>进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p>\n<p>进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；</p>\n<p>线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p>\n<blockquote>\n<p>系统开销：</p>\n</blockquote>\n<p>在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</p>\n<p>但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。</p>\n<p>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>\n<p><strong>一个进程可以创建多少线程</strong></p>\n<p>理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。</p>\n<p>如果要创建多于2048的话，必须修改编译器的设置。</p>\n<p>在一般情况下，你不需要那么多的线程，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p>\n<p><strong>外中断和异常有什么区别</strong></p>\n<p>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求，此外还有时钟中断、控制台中断等。</p>\n<p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>\n<p><strong>解决Hash冲突四种方法</strong></p>\n<p>开放定址法</p>\n<ul>\n<li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li>\n</ul>\n<p>链地址法</p>\n<ul>\n<li>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li>\n</ul>\n<p>再哈希法</p>\n<ul>\n<li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li>\n</ul>\n<p>建立公共溢出区</p>\n<ul>\n<li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li>\n</ul>\n<p><strong>分页机制和分段机制有哪些共同点和区别</strong></p>\n<p>共同点</p>\n<ul>\n<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>\n<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>\n</ul>\n<p>区别</p>\n<ul>\n<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>\n<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>\n<li>分页是一维地址空间，分段是二维的。</li>\n</ul>\n<p><strong>介绍一下几种典型的锁</strong></p>\n<blockquote>\n<p>读写锁</p>\n</blockquote>\n<ul>\n<li>可以同时进行多个读</li>\n<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>\n<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>\n</ul>\n<blockquote>\n<p>互斥锁</p>\n</blockquote>\n<p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>\n<p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。</p>\n<p>互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>\n<blockquote>\n<p>条件变量</p>\n</blockquote>\n<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。</p>\n<p>而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。</p>\n<p>当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。</p>\n<p>一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。</p>\n<p>总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p>\n<blockquote>\n<p>自旋锁</p>\n</blockquote>\n<p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</p>\n<p>如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>\n<p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p>\n<ul>\n<li>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</li>\n<li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</li>\n</ul>\n<p><strong>如何让进程后台运行</strong></p>\n<p>1.命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p>\n<p>2.ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</p>\n<p>3.nohup + &amp;，将标准输出和标准错误缺省会被重定向到 <code>nohup.out</code> 文件中，忽略所有挂断（SIGHUP）信号</p>\n<pre><code>nohup ping www.ibm.com &amp;\n</code></pre>\n<p>4.运行指令前面 + setsid，使其父进程变成init进程，不受SIGHUP信号的影响</p>\n<pre><code>[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef |grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n</code></pre>\n<p>上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。</p>\n<blockquote>\n<p>5.将命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</p>\n</blockquote>\n<pre><code>[root@pvcent107 ~]# (ping www.ibm.com &amp;)\n</code></pre>\n<p><strong>异常和中断的区别</strong></p>\n<blockquote>\n<p>中断</p>\n</blockquote>\n<p>当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。</p>\n<p>下面这张图显示了中断处理的流程：</p>\n<img src=\"https://img-blog.csdnimg.cn/6c0a43b5915e44bf8d05b6d871fd3b25.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>异常</p>\n</blockquote>\n<p>CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。</p>\n<p><strong>异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常</strong></p>\n<p>下面这张图显示了异常处理的流程：</p>\n<img src=\"https://img-blog.csdnimg.cn/fa69b2ce6ee7405ea351b0e4acd2e616.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>相同点</p>\n</blockquote>\n<ul>\n<li>最后都是由CPU发送给内核，由内核去处理</li>\n<li>处理程序的流程设计上是相似的</li>\n</ul>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</li>\n<li>内核需要根据是异常还是中断调用不同的处理程序</li>\n<li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li>\n<li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>进程、线程的区别</strong></p>\n<p>操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p>\n<img src=\"https://img-blog.csdnimg.cn/49e02558c5a946ac9509a2f5d77b3739.png\" style=\"zoom:25%;\" />\n\n<p>调度：线程作为CPU调度和分配的基本单位，进程作为拥有资源的基本单位；</p>\n<p>并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；</p>\n<blockquote>\n<p>拥有资源：</p>\n</blockquote>\n<p>进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。</p>\n<p>进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；</p>\n<p>线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；</p>\n<blockquote>\n<p>系统开销：</p>\n</blockquote>\n<p>在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。</p>\n<p>但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。</p>\n<p>线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。</p>\n<p><strong>一个进程可以创建多少线程</strong></p>\n<p>理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。</p>\n<p>如果要创建多于2048的话，必须修改编译器的设置。</p>\n<p>在一般情况下，你不需要那么多的线程，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。</p>\n<p><strong>外中断和异常有什么区别</strong></p>\n<p>外中断是指由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求，此外还有时钟中断、控制台中断等。</p>\n<p>而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。</p>\n<p><strong>解决Hash冲突四种方法</strong></p>\n<p>开放定址法</p>\n<ul>\n<li>开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</li>\n</ul>\n<p>链地址法</p>\n<ul>\n<li>将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。</li>\n</ul>\n<p>再哈希法</p>\n<ul>\n<li>当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。</li>\n</ul>\n<p>建立公共溢出区</p>\n<ul>\n<li>将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。</li>\n</ul>\n<p><strong>分页机制和分段机制有哪些共同点和区别</strong></p>\n<p>共同点</p>\n<ul>\n<li>分页机制和分段机制都是为了提高内存利用率，较少内存碎片。</li>\n<li>页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。</li>\n</ul>\n<p>区别</p>\n<ul>\n<li>页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。</li>\n<li>分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。</li>\n<li>分页是一维地址空间，分段是二维的。</li>\n</ul>\n<p><strong>介绍一下几种典型的锁</strong></p>\n<blockquote>\n<p>读写锁</p>\n</blockquote>\n<ul>\n<li>可以同时进行多个读</li>\n<li>写者必须互斥（只允许一个写者写，也不能读者写者同时进行）</li>\n<li>写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）</li>\n</ul>\n<blockquote>\n<p>互斥锁</p>\n</blockquote>\n<p>一次只能一个线程拥有互斥锁，其他线程只有等待</p>\n<p>互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。</p>\n<p>互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁</p>\n<blockquote>\n<p>条件变量</p>\n</blockquote>\n<p>互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。</p>\n<p>而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。</p>\n<p>当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。</p>\n<p>一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。</p>\n<p>总的来说<strong>互斥锁是线程间互斥的机制，条件变量则是同步机制。</strong></p>\n<blockquote>\n<p>自旋锁</p>\n</blockquote>\n<p>如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。</p>\n<p>如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。</p>\n<p>虽然它的效率比互斥锁高，但是它也有些不足之处：</p>\n<ul>\n<li>自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。</li>\n<li>在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。</li>\n</ul>\n<p><strong>如何让进程后台运行</strong></p>\n<p>1.命令后面加上&amp;即可，实际上，这样是将命令放入到一个作业队列中了</p>\n<p>2.ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程</p>\n<p>3.nohup + &amp;，将标准输出和标准错误缺省会被重定向到 <code>nohup.out</code> 文件中，忽略所有挂断（SIGHUP）信号</p>\n<pre><code>nohup ping www.ibm.com &amp;\n</code></pre>\n<p>4.运行指令前面 + setsid，使其父进程变成init进程，不受SIGHUP信号的影响</p>\n<pre><code>[root@pvcent107 ~]# setsid ping www.ibm.com\n[root@pvcent107 ~]# ps -ef |grep www.ibm.com\nroot     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com\nroot     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com\n</code></pre>\n<p>上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。</p>\n<blockquote>\n<p>5.将命令+ &amp;放在()括号中，也可以是进程不受HUP信号的影响</p>\n</blockquote>\n<pre><code>[root@pvcent107 ~]# (ping www.ibm.com &amp;)\n</code></pre>\n<p><strong>异常和中断的区别</strong></p>\n<blockquote>\n<p>中断</p>\n</blockquote>\n<p>当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。</p>\n<p>下面这张图显示了中断处理的流程：</p>\n<img src=\"https://img-blog.csdnimg.cn/6c0a43b5915e44bf8d05b6d871fd3b25.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>异常</p>\n</blockquote>\n<p>CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。</p>\n<p><strong>异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常</strong></p>\n<p>下面这张图显示了异常处理的流程：</p>\n<img src=\"https://img-blog.csdnimg.cn/fa69b2ce6ee7405ea351b0e4acd2e616.png\" style=\"zoom:25%;\" />\n\n<blockquote>\n<p>相同点</p>\n</blockquote>\n<ul>\n<li>最后都是由CPU发送给内核，由内核去处理</li>\n<li>处理程序的流程设计上是相似的</li>\n</ul>\n<blockquote>\n<p>不同点</p>\n</blockquote>\n<ul>\n<li>产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的</li>\n<li>内核需要根据是异常还是中断调用不同的处理程序</li>\n<li>中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的</li>\n<li>当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中</li>\n</ul>\n"},{"title":"线程","_content":"\n线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位\n\n* 线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。\n\n* 在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。\n\n* 进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。\n\n**用户态线程**\n\n* 用户态线程也称作用户级线程，操作系统内核并不知道它的存在，它完全是在用户空间中创建。\n\n**内核态线程**\n\n* 内核态线程也称作内核级线程（Kernel Level Thread），这种线程执行在内核态，可以通过系统调用创造一个内核级线程。\n\n**用户态线程和内核态线程之间的映射关系**\n\n如果有一个用户态的进程，它下面有多个线程，如果这个进程想要执行下面的某一个线程，应该如何做呢？\n\n> 这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。\n\n* 毕竟，内核线程是真正的线程，因为它会分配到 CPU 的执行资源。\n\n* 如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。\n\n> 这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。\n\n* 这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。\n\n**协程**\n\n<img src=\"https://img-blog.csdnimg.cn/5b83b3ec48f043b4afd8863a6b1c93a7.png\" style=\"zoom:25%;\" />\n\n协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。\n\n这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。\n\n**子程序**\n\n或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。\n\n所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。\n\n* 子程序调用总是一个入口，一次返回，调用顺序是明确的。\n\n**协程的特点在于是一个线程执行，那和多线程比，协程有何优势？**\n\n* 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；\n* 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。\n\n**线程安全**\n\n如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。\n\n如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。","source":"_posts/操作系统导论/线程.md","raw":"---\ntitle: 线程\ncategories: \n- 操作系统导论\n---\n\n线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位\n\n* 线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。\n\n* 在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。\n\n* 进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。\n\n**用户态线程**\n\n* 用户态线程也称作用户级线程，操作系统内核并不知道它的存在，它完全是在用户空间中创建。\n\n**内核态线程**\n\n* 内核态线程也称作内核级线程（Kernel Level Thread），这种线程执行在内核态，可以通过系统调用创造一个内核级线程。\n\n**用户态线程和内核态线程之间的映射关系**\n\n如果有一个用户态的进程，它下面有多个线程，如果这个进程想要执行下面的某一个线程，应该如何做呢？\n\n> 这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。\n\n* 毕竟，内核线程是真正的线程，因为它会分配到 CPU 的执行资源。\n\n* 如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。\n\n> 这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。\n\n* 这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。\n\n**协程**\n\n<img src=\"https://img-blog.csdnimg.cn/5b83b3ec48f043b4afd8863a6b1c93a7.png\" style=\"zoom:25%;\" />\n\n协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。\n\n这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。\n\n**子程序**\n\n或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。\n\n所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。\n\n* 子程序调用总是一个入口，一次返回，调用顺序是明确的。\n\n**协程的特点在于是一个线程执行，那和多线程比，协程有何优势？**\n\n* 极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；\n* 不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。\n\n**线程安全**\n\n如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。\n\n如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。","slug":"操作系统导论/线程","published":1,"date":"2022-02-01T13:38:32.983Z","updated":"2022-02-01T13:53:14.716Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwka00j5fhjihtyh2jmc","content":"<p>线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位</p>\n<ul>\n<li><p>线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p>\n</li>\n<li><p>在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</p>\n</li>\n<li><p>进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。</p>\n</li>\n</ul>\n<p><strong>用户态线程</strong></p>\n<ul>\n<li>用户态线程也称作用户级线程，操作系统内核并不知道它的存在，它完全是在用户空间中创建。</li>\n</ul>\n<p><strong>内核态线程</strong></p>\n<ul>\n<li>内核态线程也称作内核级线程（Kernel Level Thread），这种线程执行在内核态，可以通过系统调用创造一个内核级线程。</li>\n</ul>\n<p><strong>用户态线程和内核态线程之间的映射关系</strong></p>\n<p>如果有一个用户态的进程，它下面有多个线程，如果这个进程想要执行下面的某一个线程，应该如何做呢？</p>\n<blockquote>\n<p>这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。</p>\n</blockquote>\n<ul>\n<li><p>毕竟，内核线程是真正的线程，因为它会分配到 CPU 的执行资源。</p>\n</li>\n<li><p>如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。</p>\n</li>\n</ul>\n<blockquote>\n<p>这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。</p>\n</blockquote>\n<ul>\n<li>这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。</li>\n</ul>\n<p><strong>协程</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/5b83b3ec48f043b4afd8863a6b1c93a7.png\" style=\"zoom:25%;\" />\n\n<p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>\n<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>\n<p><strong>子程序</strong></p>\n<p>或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>\n<p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>\n<ul>\n<li>子程序调用总是一个入口，一次返回，调用顺序是明确的。</li>\n</ul>\n<p><strong>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</strong></p>\n<ul>\n<li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</li>\n<li>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>\n</ul>\n<p><strong>线程安全</strong></p>\n<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。</p>\n<p>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>线程：系统分配处理器时间资源的基本单元，是程序执行的最小单位</p>\n<ul>\n<li><p>线程可以看做轻量级的进程，共享内存空间，每个线程都有自己独立的运行栈和程序计数器，线程之间切换的开销小。</p>\n</li>\n<li><p>在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）。</p>\n</li>\n<li><p>进程可以通过 API 创建用户态的线程，也可以通过系统调用创建内核态的线程。</p>\n</li>\n</ul>\n<p><strong>用户态线程</strong></p>\n<ul>\n<li>用户态线程也称作用户级线程，操作系统内核并不知道它的存在，它完全是在用户空间中创建。</li>\n</ul>\n<p><strong>内核态线程</strong></p>\n<ul>\n<li>内核态线程也称作内核级线程（Kernel Level Thread），这种线程执行在内核态，可以通过系统调用创造一个内核级线程。</li>\n</ul>\n<p><strong>用户态线程和内核态线程之间的映射关系</strong></p>\n<p>如果有一个用户态的进程，它下面有多个线程，如果这个进程想要执行下面的某一个线程，应该如何做呢？</p>\n<blockquote>\n<p>这时，比较常见的一种方式，就是将需要执行的程序，让一个内核线程去执行。</p>\n</blockquote>\n<ul>\n<li><p>毕竟，内核线程是真正的线程，因为它会分配到 CPU 的执行资源。</p>\n</li>\n<li><p>如果一个进程所有的线程都要自己调度，相当于在进程的主线程中实现分时算法调度每一个线程，也就是所有线程都用操作系统分配给主线程的时间片段执行。</p>\n</li>\n</ul>\n<blockquote>\n<p>这种做法，相当于操作系统调度进程的主线程；进程的主线程进行二级调度，调度自己内部的线程。</p>\n</blockquote>\n<ul>\n<li>这样操作劣势非常明显，比如无法利用多核优势，每个线程调度分配到的时间较少，而且这种线程在阻塞场景下会直接交出整个进程的执行权限。</li>\n</ul>\n<p><strong>协程</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/5b83b3ec48f043b4afd8863a6b1c93a7.png\" style=\"zoom:25%;\" />\n\n<p>协程，是一种比线程更加轻量级的存在，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。</p>\n<p>这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。</p>\n<p><strong>子程序</strong></p>\n<p>或者称为函数，在所有语言中都是层级调用，比如A调用B，B在执行过程中又调用了C，C执行完毕返回，B执行完毕返回，最后是A执行完毕。</p>\n<p>所以子程序调用是通过栈实现的，一个线程就是执行一个子程序。</p>\n<ul>\n<li>子程序调用总是一个入口，一次返回，调用顺序是明确的。</li>\n</ul>\n<p><strong>协程的特点在于是一个线程执行，那和多线程比，协程有何优势？</strong></p>\n<ul>\n<li>极高的执行效率：因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显；</li>\n<li>不需要多线程的锁机制：因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。</li>\n</ul>\n<p><strong>线程安全</strong></p>\n<p>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。</p>\n<p>如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。</p>\n"},{"title":"计算机结构","_content":"\n现代计算机模型是基于-**冯诺依曼计算机模型**\n\n* 计算机在运行时，先从内存中取出第一条指令\n\n* 通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工\n\n* 然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去\n\n* 直至遇到停止指令\n\n程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型\n\n**计算机五大核心组成部分**\n\n* 控制器：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。\n\n* 运算器：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。\n\n* 存储器：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。\n\n* 输入：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。\n\n> 常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。\n\n* 输出：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来，微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。\n\n**计算机结构分成以下 5 个部分：**\n\n输入设备；输出设备；内存；中央处理器；总线。\n\n<img src=\"https://img-blog.csdnimg.cn/4492bb442cb44f0e94a49dc3ccec7fd6.png\" style=\"zoom:50%;\" />\n\n# 内存\n\n在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。\n\n存储的数据单位是一个二进制位，英文是 bit，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。\n\n内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。\n\n* 我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。\n\n# CPU\n\n冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。\n\n* 如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；\n\n* 如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。\n\n这里的 32 和 64，称作 CPU 的位宽。\n\n**为什么 CPU 要这样设计呢？** \n\n* 因为一个 byte 最大的表示范围就是 0~255。\n\n* 比如要计算 `20000*50`，就超出了byte 最大的表示范围了。\n\n因此，CPU 需要支持多个 byte 一起计算，当然，CPU 位数越大，可以计算的数值就越大，但是在现实生活中不一定需要计算这么大的数值，比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。\n\n**控制单元和逻辑运算单元**\n\n* CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。\n\n**寄存器**\n\nCPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。\n\n这种存储就是寄存器，寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。\n\n常见的寄存器种类：\n\n- 通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。\n- 程序计数器，用来存储 CPU 要执行下一条指令所在的内存地址，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。\n- 指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。\n\n## 多级缓存\n\n现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构\n\n**CPU缓存**即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器\n\n由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：\n\n**L1-Cache**\n\nL1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。\n\n**L2-Cache**\n\nL2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。\n\n**L3-Cache**\n\nL3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。\n\nL3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。\n\n<img src=\"https://img-blog.csdnimg.cn/a3a5551c8d284dd4a004f3d57f5ca9ec.png\" style=\"zoom:25%;\" />\n\n当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。\n\n<img src=\"https://img-blog.csdnimg.cn/b35877a2be4946a199930bacfe342725.png\" style=\"zoom:25%;\" />\n\n\n\n**总结：**\n\n* 存储器存储空间大小：内存>L3>L2>L1>寄存器；\n\n* 存储器速度快慢排序：寄存器>L1>L2>L3>内存；\n\n## 安全等级\n\n**CPU运行安全等级**\n\nCPU有4个运行级别，分别为：\n\n- ring0，ring1，ring2，ring3\n\nring0只给操作系统用，ring3谁都能用。\n\nring0是指CPU的运行级别，是最高级别，ring1次之，ring2更次之…… \n\n系统（内核）的代码运行在最高运行级别ring0上，可以使用特权指令，控制中断、修改页表、访问设备等等。\n\n应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。\n\n如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。\n\n**这个过程也称作用户态和内核态的切换。**\n\n## 局部性原理\n\n在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理\n\n**时间局部性（Temporal Locality）：**\n\n* 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。\n\n* 比如循环、递归、方法的反复调用等。\n\n**空间局部性（Spatial Locality）：**\n\n* 如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。\n\n* 比如顺序执行的代码、连续创建的两个对象、数组等。\n\n## 程序的执行过程\n\n程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。\n\n**那 CPU 执行程序的过程如下：**\n\n- 第一步，CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。\n- 第二步，CPU 分析指令寄存器中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行；\n- 第三步，CPU 执行完指令后，程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此程序计数器的值会自增 4；\n\n简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。\n\nCPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 **CPU 的指令周期**。\n\n<img src=\"https://img-blog.csdnimg.cn/553eef77ef2544a4a5117e3c4750c49d.png\" style=\"zoom:25%;\" />\n\n## 中断\n\n**中断的类型**\n\n* 按照中断的触发方分成同步中断和异步中断；\n\n* 根据中断是否强制触发分成可屏蔽中断和不可屏蔽中断。\n\n中断可以由 CPU 指令直接触发，这种主动触发的中断，叫作同步中断。\n\n> 同步中断有几种情况。\n\n* 比如系统调用，需要从用户态切换内核态，这种情况需要程序触发一个中断，叫作陷阱（Trap），中断触发后需要继续执行系统调用。\n\n* 还有一种同步中断情况是错误（Fault），通常是因为检测到某种错误，需要触发一个中断，中断响应结束后，会重新执行触发错误的地方，比如后面我们要学习的缺页中断。\n\n* 最后还有一种情况是程序的异常，这种情况和 Trap 类似，用于实现程序抛出的异常。\n\n另一部分中断不是由 CPU 直接触发，是因为需要响应外部的通知，比如响应键盘、鼠标等设备而触发的中断，这种中断我们称为异步中断。\n\nCPU 通常都支持设置一个中断屏蔽位（一个寄存器），设置为 1 之后 CPU 暂时就不再响应中断。\n\n对于键盘鼠标输入，比如陷阱、错误、异常等情况，会被临时屏蔽。\n\n但是对于一些特别重要的中断，比如 CPU 故障导致的掉电中断，还是会正常触发。\n\n**可以被屏蔽的中断我们称为可屏蔽中断，多数中断都是可屏蔽中断。**\n\n# 总线\n\nCPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。\n\n- 地址总线，用于指定 CPU 将要操作的内存地址；\n- 数据总线，用于读写内存的数据；\n- 控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；\n\n当 CPU 要读写内存数据的时候，一般需要通过两个总线：\n\n- 首先要通过地址总线来指定内存的地址；\n- 再通过数据总线来传输数据；\n\n# 输入、输出设备\n\n输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。\n\n如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。\n\n# 内核态和用户态\n\n**什么是用户态和内核态**\n\nKernel 运行在超级权限模式下，所以拥有很高的权限。\n\n按照权限管理的原则，多数应用程序应该运行在最小权限下。\n\n因此，很多操作系统，将内存分成了两个区域：\n\n* 内核空间（Kernal Space），这个空间只有内核程序可以访问；\n\n* 用户空间（User Space），这部分内存专门给应用程序使用。\n\n用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态 执行。\n\n内核空间中的代码可以访问所有内存，我们称这些程序在内核态 执行。\n\n> 按照级别分：\n\n* 当程序运行在0级特权级上时，就可以称之为运行在内核态\n\n* 当程序运行在3级特权级上时，就可以称之为运行在用户态\n\n运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。\n\n当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）\n\n**这两种状态的主要差别**\n\n* 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的\n\n* 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。\n\n**为什么要有用户态和内核态**\n\n由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络\n\n**用户态与内核态的切换**\n\n所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情， 例如从硬盘读取数据，或者从键盘获取输入等，而唯一可以做这些事情的就是操作系统，所以此时程序就需要先操作系统请求以程序的名义来执行这些操作\n\n**用户态和内核态的转换**\n\n> 系统调用\n\n用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用\n\n而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断\n\n**举例：**\n\n<img src=\"https://img-blog.csdnimg.cn/ffe0fb029f7049779dbc735b3efbe12a.png\" style=\"zoom:25%;\" />\n\n如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。\n\n当发生系统调用时，用户态的程序发起系统调用，因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。\n\n发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序，内核程序开始执行，也就是开始处理系统调用。\n\n内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。\n\n> 异常\n\n当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常\n\n> 外围设备的中断\n\n当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换\n\n比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等","source":"_posts/操作系统导论/计算机结构.md","raw":"---\ntitle: 计算机结构\ncategories: \n- 操作系统导论\n---\n\n现代计算机模型是基于-**冯诺依曼计算机模型**\n\n* 计算机在运行时，先从内存中取出第一条指令\n\n* 通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工\n\n* 然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去\n\n* 直至遇到停止指令\n\n程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型\n\n**计算机五大核心组成部分**\n\n* 控制器：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。\n\n* 运算器：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。\n\n* 存储器：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。\n\n* 输入：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。\n\n> 常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。\n\n* 输出：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来，微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。\n\n**计算机结构分成以下 5 个部分：**\n\n输入设备；输出设备；内存；中央处理器；总线。\n\n<img src=\"https://img-blog.csdnimg.cn/4492bb442cb44f0e94a49dc3ccec7fd6.png\" style=\"zoom:50%;\" />\n\n# 内存\n\n在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。\n\n存储的数据单位是一个二进制位，英文是 bit，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。\n\n内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。\n\n* 我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。\n\n# CPU\n\n冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。\n\n* 如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；\n\n* 如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。\n\n这里的 32 和 64，称作 CPU 的位宽。\n\n**为什么 CPU 要这样设计呢？** \n\n* 因为一个 byte 最大的表示范围就是 0~255。\n\n* 比如要计算 `20000*50`，就超出了byte 最大的表示范围了。\n\n因此，CPU 需要支持多个 byte 一起计算，当然，CPU 位数越大，可以计算的数值就越大，但是在现实生活中不一定需要计算这么大的数值，比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。\n\n**控制单元和逻辑运算单元**\n\n* CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。\n\n**寄存器**\n\nCPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。\n\n这种存储就是寄存器，寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。\n\n常见的寄存器种类：\n\n- 通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。\n- 程序计数器，用来存储 CPU 要执行下一条指令所在的内存地址，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。\n- 指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。\n\n## 多级缓存\n\n现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构\n\n**CPU缓存**即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器\n\n由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：\n\n**L1-Cache**\n\nL1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。\n\n**L2-Cache**\n\nL2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。\n\n**L3-Cache**\n\nL3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。\n\nL3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。\n\n<img src=\"https://img-blog.csdnimg.cn/a3a5551c8d284dd4a004f3d57f5ca9ec.png\" style=\"zoom:25%;\" />\n\n当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。\n\n<img src=\"https://img-blog.csdnimg.cn/b35877a2be4946a199930bacfe342725.png\" style=\"zoom:25%;\" />\n\n\n\n**总结：**\n\n* 存储器存储空间大小：内存>L3>L2>L1>寄存器；\n\n* 存储器速度快慢排序：寄存器>L1>L2>L3>内存；\n\n## 安全等级\n\n**CPU运行安全等级**\n\nCPU有4个运行级别，分别为：\n\n- ring0，ring1，ring2，ring3\n\nring0只给操作系统用，ring3谁都能用。\n\nring0是指CPU的运行级别，是最高级别，ring1次之，ring2更次之…… \n\n系统（内核）的代码运行在最高运行级别ring0上，可以使用特权指令，控制中断、修改页表、访问设备等等。\n\n应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。\n\n如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。\n\n**这个过程也称作用户态和内核态的切换。**\n\n## 局部性原理\n\n在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理\n\n**时间局部性（Temporal Locality）：**\n\n* 如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。\n\n* 比如循环、递归、方法的反复调用等。\n\n**空间局部性（Spatial Locality）：**\n\n* 如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。\n\n* 比如顺序执行的代码、连续创建的两个对象、数组等。\n\n## 程序的执行过程\n\n程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。\n\n**那 CPU 执行程序的过程如下：**\n\n- 第一步，CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。\n- 第二步，CPU 分析指令寄存器中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行；\n- 第三步，CPU 执行完指令后，程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此程序计数器的值会自增 4；\n\n简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。\n\nCPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 **CPU 的指令周期**。\n\n<img src=\"https://img-blog.csdnimg.cn/553eef77ef2544a4a5117e3c4750c49d.png\" style=\"zoom:25%;\" />\n\n## 中断\n\n**中断的类型**\n\n* 按照中断的触发方分成同步中断和异步中断；\n\n* 根据中断是否强制触发分成可屏蔽中断和不可屏蔽中断。\n\n中断可以由 CPU 指令直接触发，这种主动触发的中断，叫作同步中断。\n\n> 同步中断有几种情况。\n\n* 比如系统调用，需要从用户态切换内核态，这种情况需要程序触发一个中断，叫作陷阱（Trap），中断触发后需要继续执行系统调用。\n\n* 还有一种同步中断情况是错误（Fault），通常是因为检测到某种错误，需要触发一个中断，中断响应结束后，会重新执行触发错误的地方，比如后面我们要学习的缺页中断。\n\n* 最后还有一种情况是程序的异常，这种情况和 Trap 类似，用于实现程序抛出的异常。\n\n另一部分中断不是由 CPU 直接触发，是因为需要响应外部的通知，比如响应键盘、鼠标等设备而触发的中断，这种中断我们称为异步中断。\n\nCPU 通常都支持设置一个中断屏蔽位（一个寄存器），设置为 1 之后 CPU 暂时就不再响应中断。\n\n对于键盘鼠标输入，比如陷阱、错误、异常等情况，会被临时屏蔽。\n\n但是对于一些特别重要的中断，比如 CPU 故障导致的掉电中断，还是会正常触发。\n\n**可以被屏蔽的中断我们称为可屏蔽中断，多数中断都是可屏蔽中断。**\n\n# 总线\n\nCPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。\n\n- 地址总线，用于指定 CPU 将要操作的内存地址；\n- 数据总线，用于读写内存的数据；\n- 控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；\n\n当 CPU 要读写内存数据的时候，一般需要通过两个总线：\n\n- 首先要通过地址总线来指定内存的地址；\n- 再通过数据总线来传输数据；\n\n# 输入、输出设备\n\n输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。\n\n如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。\n\n# 内核态和用户态\n\n**什么是用户态和内核态**\n\nKernel 运行在超级权限模式下，所以拥有很高的权限。\n\n按照权限管理的原则，多数应用程序应该运行在最小权限下。\n\n因此，很多操作系统，将内存分成了两个区域：\n\n* 内核空间（Kernal Space），这个空间只有内核程序可以访问；\n\n* 用户空间（User Space），这部分内存专门给应用程序使用。\n\n用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态 执行。\n\n内核空间中的代码可以访问所有内存，我们称这些程序在内核态 执行。\n\n> 按照级别分：\n\n* 当程序运行在0级特权级上时，就可以称之为运行在内核态\n\n* 当程序运行在3级特权级上时，就可以称之为运行在用户态\n\n运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。\n\n当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）\n\n**这两种状态的主要差别**\n\n* 处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的\n\n* 处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。\n\n**为什么要有用户态和内核态**\n\n由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络\n\n**用户态与内核态的切换**\n\n所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情， 例如从硬盘读取数据，或者从键盘获取输入等，而唯一可以做这些事情的就是操作系统，所以此时程序就需要先操作系统请求以程序的名义来执行这些操作\n\n**用户态和内核态的转换**\n\n> 系统调用\n\n用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用\n\n而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断\n\n**举例：**\n\n<img src=\"https://img-blog.csdnimg.cn/ffe0fb029f7049779dbc735b3efbe12a.png\" style=\"zoom:25%;\" />\n\n如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。\n\n当发生系统调用时，用户态的程序发起系统调用，因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。\n\n发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序，内核程序开始执行，也就是开始处理系统调用。\n\n内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。\n\n> 异常\n\n当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常\n\n> 外围设备的中断\n\n当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换\n\n比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等","slug":"操作系统导论/计算机结构","published":1,"date":"2022-02-01T13:55:06.469Z","updated":"2022-02-03T10:59:19.198Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwka00j8fhji3s29c6lg","content":"<p>现代计算机模型是基于-<strong>冯诺依曼计算机模型</strong></p>\n<ul>\n<li><p>计算机在运行时，先从内存中取出第一条指令</p>\n</li>\n<li><p>通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工</p>\n</li>\n<li><p>然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去</p>\n</li>\n<li><p>直至遇到停止指令</p>\n</li>\n</ul>\n<p>程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型</p>\n<p><strong>计算机五大核心组成部分</strong></p>\n<ul>\n<li><p>控制器：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</p>\n</li>\n<li><p>运算器：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。</p>\n</li>\n<li><p>存储器：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</p>\n</li>\n<li><p>输入：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。</p>\n</li>\n</ul>\n<blockquote>\n<p>常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。</p>\n</blockquote>\n<ul>\n<li>输出：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来，微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</li>\n</ul>\n<p><strong>计算机结构分成以下 5 个部分：</strong></p>\n<p>输入设备；输出设备；内存；中央处理器；总线。</p>\n<img src=\"https://img-blog.csdnimg.cn/4492bb442cb44f0e94a49dc3ccec7fd6.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><p>在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。</p>\n<p>存储的数据单位是一个二进制位，英文是 bit，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。</p>\n<p>内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p>\n<ul>\n<li>我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</li>\n</ul>\n<h1 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h1><p>冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p>\n<ul>\n<li><p>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</p>\n</li>\n<li><p>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。</p>\n</li>\n</ul>\n<p>这里的 32 和 64，称作 CPU 的位宽。</p>\n<p><strong>为什么 CPU 要这样设计呢？</strong> </p>\n<ul>\n<li><p>因为一个 byte 最大的表示范围就是 0~255。</p>\n</li>\n<li><p>比如要计算 <code>20000*50</code>，就超出了byte 最大的表示范围了。</p>\n</li>\n</ul>\n<p>因此，CPU 需要支持多个 byte 一起计算，当然，CPU 位数越大，可以计算的数值就越大，但是在现实生活中不一定需要计算这么大的数值，比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。</p>\n<p><strong>控制单元和逻辑运算单元</strong></p>\n<ul>\n<li>CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。</li>\n</ul>\n<p><strong>寄存器</strong></p>\n<p>CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。</p>\n<p>这种存储就是寄存器，寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。</p>\n<p>常见的寄存器种类：</p>\n<ul>\n<li>通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li>\n<li>程序计数器，用来存储 CPU 要执行下一条指令所在的内存地址，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li>\n<li>指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li>\n</ul>\n<h2 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h2><p>现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构</p>\n<p><strong>CPU缓存</strong>即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器</p>\n<p>由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：</p>\n<p><strong>L1-Cache</strong></p>\n<p>L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</p>\n<p><strong>L2-Cache</strong></p>\n<p>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。</p>\n<p><strong>L3-Cache</strong></p>\n<p>L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。</p>\n<p>L3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。</p>\n<img src=\"https://img-blog.csdnimg.cn/a3a5551c8d284dd4a004f3d57f5ca9ec.png\" style=\"zoom:25%;\" />\n\n<p>当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。</p>\n<img src=\"https://img-blog.csdnimg.cn/b35877a2be4946a199930bacfe342725.png\" style=\"zoom:25%;\" />\n\n\n\n<p><strong>总结：</strong></p>\n<ul>\n<li><p>存储器存储空间大小：内存&gt;L3&gt;L2&gt;L1&gt;寄存器；</p>\n</li>\n<li><p>存储器速度快慢排序：寄存器&gt;L1&gt;L2&gt;L3&gt;内存；</p>\n</li>\n</ul>\n<h2 id=\"安全等级\"><a href=\"#安全等级\" class=\"headerlink\" title=\"安全等级\"></a>安全等级</h2><p><strong>CPU运行安全等级</strong></p>\n<p>CPU有4个运行级别，分别为：</p>\n<ul>\n<li>ring0，ring1，ring2，ring3</li>\n</ul>\n<p>ring0只给操作系统用，ring3谁都能用。</p>\n<p>ring0是指CPU的运行级别，是最高级别，ring1次之，ring2更次之…… </p>\n<p>系统（内核）的代码运行在最高运行级别ring0上，可以使用特权指令，控制中断、修改页表、访问设备等等。</p>\n<p>应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。</p>\n<p>如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。</p>\n<p><strong>这个过程也称作用户态和内核态的切换。</strong></p>\n<h2 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h2><p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理</p>\n<p><strong>时间局部性（Temporal Locality）：</strong></p>\n<ul>\n<li><p>如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p>\n</li>\n<li><p>比如循环、递归、方法的反复调用等。</p>\n</li>\n</ul>\n<p><strong>空间局部性（Spatial Locality）：</strong></p>\n<ul>\n<li><p>如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</p>\n</li>\n<li><p>比如顺序执行的代码、连续创建的两个对象、数组等。</p>\n</li>\n</ul>\n<h2 id=\"程序的执行过程\"><a href=\"#程序的执行过程\" class=\"headerlink\" title=\"程序的执行过程\"></a>程序的执行过程</h2><p>程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。</p>\n<p><strong>那 CPU 执行程序的过程如下：</strong></p>\n<ul>\n<li>第一步，CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。</li>\n<li>第二步，CPU 分析指令寄存器中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行；</li>\n<li>第三步，CPU 执行完指令后，程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此程序计数器的值会自增 4；</li>\n</ul>\n<p>简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。</p>\n<p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</p>\n<img src=\"https://img-blog.csdnimg.cn/553eef77ef2544a4a5117e3c4750c49d.png\" style=\"zoom:25%;\" />\n\n<h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><p><strong>中断的类型</strong></p>\n<ul>\n<li><p>按照中断的触发方分成同步中断和异步中断；</p>\n</li>\n<li><p>根据中断是否强制触发分成可屏蔽中断和不可屏蔽中断。</p>\n</li>\n</ul>\n<p>中断可以由 CPU 指令直接触发，这种主动触发的中断，叫作同步中断。</p>\n<blockquote>\n<p>同步中断有几种情况。</p>\n</blockquote>\n<ul>\n<li><p>比如系统调用，需要从用户态切换内核态，这种情况需要程序触发一个中断，叫作陷阱（Trap），中断触发后需要继续执行系统调用。</p>\n</li>\n<li><p>还有一种同步中断情况是错误（Fault），通常是因为检测到某种错误，需要触发一个中断，中断响应结束后，会重新执行触发错误的地方，比如后面我们要学习的缺页中断。</p>\n</li>\n<li><p>最后还有一种情况是程序的异常，这种情况和 Trap 类似，用于实现程序抛出的异常。</p>\n</li>\n</ul>\n<p>另一部分中断不是由 CPU 直接触发，是因为需要响应外部的通知，比如响应键盘、鼠标等设备而触发的中断，这种中断我们称为异步中断。</p>\n<p>CPU 通常都支持设置一个中断屏蔽位（一个寄存器），设置为 1 之后 CPU 暂时就不再响应中断。</p>\n<p>对于键盘鼠标输入，比如陷阱、错误、异常等情况，会被临时屏蔽。</p>\n<p>但是对于一些特别重要的中断，比如 CPU 故障导致的掉电中断，还是会正常触发。</p>\n<p><strong>可以被屏蔽的中断我们称为可屏蔽中断，多数中断都是可屏蔽中断。</strong></p>\n<h1 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h1><p>CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。</p>\n<ul>\n<li>地址总线，用于指定 CPU 将要操作的内存地址；</li>\n<li>数据总线，用于读写内存的数据；</li>\n<li>控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</li>\n</ul>\n<p>当 CPU 要读写内存数据的时候，一般需要通过两个总线：</p>\n<ul>\n<li>首先要通过地址总线来指定内存的地址；</li>\n<li>再通过数据总线来传输数据；</li>\n</ul>\n<h1 id=\"输入、输出设备\"><a href=\"#输入、输出设备\" class=\"headerlink\" title=\"输入、输出设备\"></a>输入、输出设备</h1><p>输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。</p>\n<p>如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。</p>\n<h1 id=\"内核态和用户态\"><a href=\"#内核态和用户态\" class=\"headerlink\" title=\"内核态和用户态\"></a>内核态和用户态</h1><p><strong>什么是用户态和内核态</strong></p>\n<p>Kernel 运行在超级权限模式下，所以拥有很高的权限。</p>\n<p>按照权限管理的原则，多数应用程序应该运行在最小权限下。</p>\n<p>因此，很多操作系统，将内存分成了两个区域：</p>\n<ul>\n<li><p>内核空间（Kernal Space），这个空间只有内核程序可以访问；</p>\n</li>\n<li><p>用户空间（User Space），这部分内存专门给应用程序使用。</p>\n</li>\n</ul>\n<p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态 执行。</p>\n<p>内核空间中的代码可以访问所有内存，我们称这些程序在内核态 执行。</p>\n<blockquote>\n<p>按照级别分：</p>\n</blockquote>\n<ul>\n<li><p>当程序运行在0级特权级上时，就可以称之为运行在内核态</p>\n</li>\n<li><p>当程序运行在3级特权级上时，就可以称之为运行在用户态</p>\n</li>\n</ul>\n<p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p>\n<p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）</p>\n<p><strong>这两种状态的主要差别</strong></p>\n<ul>\n<li><p>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的</p>\n</li>\n<li><p>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</p>\n</li>\n</ul>\n<p><strong>为什么要有用户态和内核态</strong></p>\n<p>由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络</p>\n<p><strong>用户态与内核态的切换</strong></p>\n<p>所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情， 例如从硬盘读取数据，或者从键盘获取输入等，而唯一可以做这些事情的就是操作系统，所以此时程序就需要先操作系统请求以程序的名义来执行这些操作</p>\n<p><strong>用户态和内核态的转换</strong></p>\n<blockquote>\n<p>系统调用</p>\n</blockquote>\n<p>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用</p>\n<p>而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断</p>\n<p><strong>举例：</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/ffe0fb029f7049779dbc735b3efbe12a.png\" style=\"zoom:25%;\" />\n\n<p>如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。</p>\n<p>当发生系统调用时，用户态的程序发起系统调用，因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</p>\n<p>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序，内核程序开始执行，也就是开始处理系统调用。</p>\n<p>内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</p>\n<blockquote>\n<p>异常</p>\n</blockquote>\n<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</p>\n<blockquote>\n<p>外围设备的中断</p>\n</blockquote>\n<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换</p>\n<p>比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</p>\n","site":{"data":{}},"excerpt":"","more":"<p>现代计算机模型是基于-<strong>冯诺依曼计算机模型</strong></p>\n<ul>\n<li><p>计算机在运行时，先从内存中取出第一条指令</p>\n</li>\n<li><p>通过控制器的译码，按指令的要求，从存储器中取出数据进行指定的运算和逻辑操作等加工</p>\n</li>\n<li><p>然后再按地址把结果送到内存中去，接下来，再取出第二条指令，在控制器的指挥下完成规定操作，依此进行下去</p>\n</li>\n<li><p>直至遇到停止指令</p>\n</li>\n</ul>\n<p>程序与数据一样存贮，按程序编排的顺序，一步一步地取出指令，自动地完成指令规定的操作是计算机最基本的工作模型</p>\n<p><strong>计算机五大核心组成部分</strong></p>\n<ul>\n<li><p>控制器：是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</p>\n</li>\n<li><p>运算器：运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。</p>\n</li>\n<li><p>存储器：存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</p>\n</li>\n<li><p>输入：输入设备是计算机的重要组成部分，输入设备与输出设备合你为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。</p>\n</li>\n</ul>\n<blockquote>\n<p>常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。</p>\n</blockquote>\n<ul>\n<li>输出：输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来，微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</li>\n</ul>\n<p><strong>计算机结构分成以下 5 个部分：</strong></p>\n<p>输入设备；输出设备；内存；中央处理器；总线。</p>\n<img src=\"https://img-blog.csdnimg.cn/4492bb442cb44f0e94a49dc3ccec7fd6.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"内存\"><a href=\"#内存\" class=\"headerlink\" title=\"内存\"></a>内存</h1><p>在冯诺依曼模型中，程序和数据被存储在一个被称作内存的线性排列存储区域。</p>\n<p>存储的数据单位是一个二进制位，英文是 bit，最小的存储单位叫作字节，也就是 8 位，英文是 byte，每一个字节都对应一个内存地址。</p>\n<p>内存地址由 0 开始编号，比如第 1 个地址是 0，第 2 个地址是 1， 然后自增排列，最后一个地址是内存中的字节数减 1。</p>\n<ul>\n<li>我们通常说的内存都是随机存取器，也就是读取任何一个地址数据的速度是一样的，写入任何一个地址数据的速度也是一样的。</li>\n</ul>\n<h1 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h1><p>冯诺依曼模型中 CPU 负责控制和计算，为了方便计算较大的数值，CPU 每次可以计算多个字节的数据。</p>\n<ul>\n<li><p>如果 CPU 每次可以计算 4 个 byte，那么我们称作 32 位 CPU；</p>\n</li>\n<li><p>如果 CPU 每次可以计算 8 个 byte，那么我们称作 64 位 CPU。</p>\n</li>\n</ul>\n<p>这里的 32 和 64，称作 CPU 的位宽。</p>\n<p><strong>为什么 CPU 要这样设计呢？</strong> </p>\n<ul>\n<li><p>因为一个 byte 最大的表示范围就是 0~255。</p>\n</li>\n<li><p>比如要计算 <code>20000*50</code>，就超出了byte 最大的表示范围了。</p>\n</li>\n</ul>\n<p>因此，CPU 需要支持多个 byte 一起计算，当然，CPU 位数越大，可以计算的数值就越大，但是在现实生活中不一定需要计算这么大的数值，比如说 32 位 CPU 能计算的最大整数是 4294967295，这已经非常大了。</p>\n<p><strong>控制单元和逻辑运算单元</strong></p>\n<ul>\n<li>CPU 中有一个控制单元专门负责控制 CPU 工作；还有逻辑运算单元专门负责计算。</li>\n</ul>\n<p><strong>寄存器</strong></p>\n<p>CPU 要进行计算，比如最简单的加和两个数字时，因为 CPU 离内存太远，所以需要一种离自己近的存储来存储将要被计算的数字。</p>\n<p>这种存储就是寄存器，寄存器就在 CPU 里，控制单元和逻辑运算单元非常近，因此速度很快。</p>\n<p>常见的寄存器种类：</p>\n<ul>\n<li>通用寄存器，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。</li>\n<li>程序计数器，用来存储 CPU 要执行下一条指令所在的内存地址，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令的地址。</li>\n<li>指令寄存器，用来存放程序计数器指向的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。</li>\n</ul>\n<h2 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h2><p>现代CPU为了提升执行效率，减少CPU与内存的交互(交互影响CPU效率)，一般在CPU上集成了多级缓存架构</p>\n<p><strong>CPU缓存</strong>即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器</p>\n<p>由于CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用，减少CPU的等待时间，提高了系统的效率，具体包括以下几种：</p>\n<p><strong>L1-Cache</strong></p>\n<p>L1- 缓存在 CPU 中，相比寄存器，虽然它的位置距离 CPU 核心更远，但造价更低，通常 L1-Cache 大小在几十 Kb 到几百 Kb 不等，读写速度在 2~4 个 CPU 时钟周期。</p>\n<p><strong>L2-Cache</strong></p>\n<p>L2- 缓存也在 CPU 中，位置比 L1- 缓存距离 CPU 核心更远，它的大小比 L1-Cache 更大，具体大小要看 CPU 型号，有 2M 的，也有更小或者更大的，速度在 10~20 个 CPU 周期。</p>\n<p><strong>L3-Cache</strong></p>\n<p>L3- 缓存同样在 CPU 中，位置比 L2- 缓存距离 CPU 核心更远，大小通常比 L2-Cache 更大，读写速度在 20~60 个 CPU 周期。</p>\n<p>L3 缓存大小也是看型号的，比如 i9 CPU 有 512KB L1 Cache；有 2MB L2 Cache； 有16MB L3 Cache。</p>\n<img src=\"https://img-blog.csdnimg.cn/a3a5551c8d284dd4a004f3d57f5ca9ec.png\" style=\"zoom:25%;\" />\n\n<p>当 CPU 需要内存中某个数据的时候，如果寄存器中有这个数据，我们可以直接使用；如果寄存器中没有这个数据，我们就要先查询 L1 缓存；L1 中没有，再查询 L2 缓存；L2 中没有再查询 L3 缓存；L3 中没有，再去内存中拿。</p>\n<img src=\"https://img-blog.csdnimg.cn/b35877a2be4946a199930bacfe342725.png\" style=\"zoom:25%;\" />\n\n\n\n<p><strong>总结：</strong></p>\n<ul>\n<li><p>存储器存储空间大小：内存&gt;L3&gt;L2&gt;L1&gt;寄存器；</p>\n</li>\n<li><p>存储器速度快慢排序：寄存器&gt;L1&gt;L2&gt;L3&gt;内存；</p>\n</li>\n</ul>\n<h2 id=\"安全等级\"><a href=\"#安全等级\" class=\"headerlink\" title=\"安全等级\"></a>安全等级</h2><p><strong>CPU运行安全等级</strong></p>\n<p>CPU有4个运行级别，分别为：</p>\n<ul>\n<li>ring0，ring1，ring2，ring3</li>\n</ul>\n<p>ring0只给操作系统用，ring3谁都能用。</p>\n<p>ring0是指CPU的运行级别，是最高级别，ring1次之，ring2更次之…… </p>\n<p>系统（内核）的代码运行在最高运行级别ring0上，可以使用特权指令，控制中断、修改页表、访问设备等等。</p>\n<p>应用程序的代码运行在最低运行级别上ring3上，不能做受控操作。</p>\n<p>如果要做，比如要访问磁盘，写文件，那就要通过执行系统调用（函数），执行系统调用的时候，CPU的运行级别会发生从ring3到ring0的切换，并跳转到系统调用对应的内核代码位置执行，这样内核就为你完成了设备访问，完成之后再从ring0返回ring3。</p>\n<p><strong>这个过程也称作用户态和内核态的切换。</strong></p>\n<h2 id=\"局部性原理\"><a href=\"#局部性原理\" class=\"headerlink\" title=\"局部性原理\"></a>局部性原理</h2><p>在CPU访问存储设备时，无论是存取数据抑或存取指令，都趋于聚集在一片连续的区域中，这就被称为局部性原理</p>\n<p><strong>时间局部性（Temporal Locality）：</strong></p>\n<ul>\n<li><p>如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p>\n</li>\n<li><p>比如循环、递归、方法的反复调用等。</p>\n</li>\n</ul>\n<p><strong>空间局部性（Spatial Locality）：</strong></p>\n<ul>\n<li><p>如果一个存储器的位置被引用，那么将来他附近的位置也会被引用。</p>\n</li>\n<li><p>比如顺序执行的代码、连续创建的两个对象、数组等。</p>\n</li>\n</ul>\n<h2 id=\"程序的执行过程\"><a href=\"#程序的执行过程\" class=\"headerlink\" title=\"程序的执行过程\"></a>程序的执行过程</h2><p>程序实际上是一条一条指令，所以程序的运行过程就是把每一条指令一步一步的执行起来，负责执行指令的就是 CPU 了。</p>\n<p><strong>那 CPU 执行程序的过程如下：</strong></p>\n<ul>\n<li>第一步，CPU 读取程序计数器的值，这个值是指令的内存地址，然后 CPU 的控制单元操作地址总线指定需要访问的内存地址，接着通知内存设备准备数据，数据准备好后通过数据总线将指令数据传给 CPU，CPU 收到内存传来的数据后，将这个指令数据存入到指令寄存器。</li>\n<li>第二步，CPU 分析指令寄存器中的指令，确定指令的类型和参数，如果是计算类型的指令，就把指令交给逻辑运算单元运算；如果是存储类型的指令，则交由控制单元执行；</li>\n<li>第三步，CPU 执行完指令后，程序计数器的值自增，表示指向下一条指令。这个自增的大小，由 CPU 的位宽决定，比如 32 位的 CPU，指令是 4 个字节，需要 4 个内存地址存放，因此程序计数器的值会自增 4；</li>\n</ul>\n<p>简单总结一下就是，一个程序执行的时候，CPU 会根据程序计数器里的内存地址，从内存里面把需要执行的指令读取到指令寄存器里面执行，然后根据指令长度自增，开始顺序读取下一条指令。</p>\n<p>CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束，这个不断循环的过程被称为 <strong>CPU 的指令周期</strong>。</p>\n<img src=\"https://img-blog.csdnimg.cn/553eef77ef2544a4a5117e3c4750c49d.png\" style=\"zoom:25%;\" />\n\n<h2 id=\"中断\"><a href=\"#中断\" class=\"headerlink\" title=\"中断\"></a>中断</h2><p><strong>中断的类型</strong></p>\n<ul>\n<li><p>按照中断的触发方分成同步中断和异步中断；</p>\n</li>\n<li><p>根据中断是否强制触发分成可屏蔽中断和不可屏蔽中断。</p>\n</li>\n</ul>\n<p>中断可以由 CPU 指令直接触发，这种主动触发的中断，叫作同步中断。</p>\n<blockquote>\n<p>同步中断有几种情况。</p>\n</blockquote>\n<ul>\n<li><p>比如系统调用，需要从用户态切换内核态，这种情况需要程序触发一个中断，叫作陷阱（Trap），中断触发后需要继续执行系统调用。</p>\n</li>\n<li><p>还有一种同步中断情况是错误（Fault），通常是因为检测到某种错误，需要触发一个中断，中断响应结束后，会重新执行触发错误的地方，比如后面我们要学习的缺页中断。</p>\n</li>\n<li><p>最后还有一种情况是程序的异常，这种情况和 Trap 类似，用于实现程序抛出的异常。</p>\n</li>\n</ul>\n<p>另一部分中断不是由 CPU 直接触发，是因为需要响应外部的通知，比如响应键盘、鼠标等设备而触发的中断，这种中断我们称为异步中断。</p>\n<p>CPU 通常都支持设置一个中断屏蔽位（一个寄存器），设置为 1 之后 CPU 暂时就不再响应中断。</p>\n<p>对于键盘鼠标输入，比如陷阱、错误、异常等情况，会被临时屏蔽。</p>\n<p>但是对于一些特别重要的中断，比如 CPU 故障导致的掉电中断，还是会正常触发。</p>\n<p><strong>可以被屏蔽的中断我们称为可屏蔽中断，多数中断都是可屏蔽中断。</strong></p>\n<h1 id=\"总线\"><a href=\"#总线\" class=\"headerlink\" title=\"总线\"></a>总线</h1><p>CPU 和内存以及其他设备之间，也需要通信，因此我们用一种特殊的设备进行控制，就是总线。</p>\n<ul>\n<li>地址总线，用于指定 CPU 将要操作的内存地址；</li>\n<li>数据总线，用于读写内存的数据；</li>\n<li>控制总线，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；</li>\n</ul>\n<p>当 CPU 要读写内存数据的时候，一般需要通过两个总线：</p>\n<ul>\n<li>首先要通过地址总线来指定内存的地址；</li>\n<li>再通过数据总线来传输数据；</li>\n</ul>\n<h1 id=\"输入、输出设备\"><a href=\"#输入、输出设备\" class=\"headerlink\" title=\"输入、输出设备\"></a>输入、输出设备</h1><p>输入设备向计算机输入数据，计算机经过计算，将结果通过输出设备向外界传达。</p>\n<p>如果输入设备、输出设备想要和 CPU 进行交互，比如说用户按键需要 CPU 响应，这时候就需要用到控制总线。</p>\n<h1 id=\"内核态和用户态\"><a href=\"#内核态和用户态\" class=\"headerlink\" title=\"内核态和用户态\"></a>内核态和用户态</h1><p><strong>什么是用户态和内核态</strong></p>\n<p>Kernel 运行在超级权限模式下，所以拥有很高的权限。</p>\n<p>按照权限管理的原则，多数应用程序应该运行在最小权限下。</p>\n<p>因此，很多操作系统，将内存分成了两个区域：</p>\n<ul>\n<li><p>内核空间（Kernal Space），这个空间只有内核程序可以访问；</p>\n</li>\n<li><p>用户空间（User Space），这部分内存专门给应用程序使用。</p>\n</li>\n</ul>\n<p>用户空间中的代码被限制了只能使用一个局部的内存空间，我们说这些程序在用户态 执行。</p>\n<p>内核空间中的代码可以访问所有内存，我们称这些程序在内核态 执行。</p>\n<blockquote>\n<p>按照级别分：</p>\n</blockquote>\n<ul>\n<li><p>当程序运行在0级特权级上时，就可以称之为运行在内核态</p>\n</li>\n<li><p>当程序运行在3级特权级上时，就可以称之为运行在用户态</p>\n</li>\n</ul>\n<p>运行在用户态下的程序不能直接访问操作系统内核数据结构和程序。</p>\n<p>当我们在系统中执行一个程序时，大部分时间是运行在用户态下的，在其需要操作系统帮助完成某些它没有权力和能力完成的工作时就会切换到内核态（比如操作硬件）</p>\n<p><strong>这两种状态的主要差别</strong></p>\n<ul>\n<li><p>处于用户态执行时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理器是可被抢占的</p>\n</li>\n<li><p>处于内核态执行时，则能访问所有的内存空间和对象，且所占有的处理器是不允许被抢占的。</p>\n</li>\n</ul>\n<p><strong>为什么要有用户态和内核态</strong></p>\n<p>由于需要限制不同的程序之间的访问能力，防止他们获取别的程序的内存数据，或者获取外围设备的数据，并发送到网络</p>\n<p><strong>用户态与内核态的切换</strong></p>\n<p>所有用户程序都是运行在用户态的，但是有时候程序确实需要做一些内核态的事情， 例如从硬盘读取数据，或者从键盘获取输入等，而唯一可以做这些事情的就是操作系统，所以此时程序就需要先操作系统请求以程序的名义来执行这些操作</p>\n<p><strong>用户态和内核态的转换</strong></p>\n<blockquote>\n<p>系统调用</p>\n</blockquote>\n<p>用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用</p>\n<p>而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断</p>\n<p><strong>举例：</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/ffe0fb029f7049779dbc735b3efbe12a.png\" style=\"zoom:25%;\" />\n\n<p>如上图所示：内核程序执行在内核态（Kernal Mode），用户程序执行在用户态（User Mode）。</p>\n<p>当发生系统调用时，用户态的程序发起系统调用，因为系统调用中牵扯特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</p>\n<p>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序，内核程序开始执行，也就是开始处理系统调用。</p>\n<p>内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</p>\n<blockquote>\n<p>异常</p>\n</blockquote>\n<p>当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常</p>\n<blockquote>\n<p>外围设备的中断</p>\n</blockquote>\n<p>当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换</p>\n<p>比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等</p>\n"},{"title":"设备管理","_content":"\n# 磁盘调度算法\n\n读写一个磁盘块的时间的影响因素有：\n\n- 旋转时间\n- 寻道时间实际的数据传输时间\n\n其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。\n\n> 先来先服务 FCFS, First Come First Served\n\n按照磁盘请求的顺序进行调度，优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。\n\n> 最短寻道时间优先，SSTF, Shortest Seek Time First\n\n优先调度与当前磁头所在磁道距离最近的磁道， 虽然平均寻道时间比较低，但是不够公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的 磁道请求会一直等待下去，也就是出现饥饿现象，具体来说，两边的磁道请求更容易出现饥饿现象。\n\n> 电梯算法，SCAN\n\n电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向， 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘 请求，然后改变方向，因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题","source":"_posts/操作系统导论/设备管理.md","raw":"---\ntitle: 设备管理\ncategories: \n- 操作系统导论\n---\n\n# 磁盘调度算法\n\n读写一个磁盘块的时间的影响因素有：\n\n- 旋转时间\n- 寻道时间实际的数据传输时间\n\n其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。\n\n> 先来先服务 FCFS, First Come First Served\n\n按照磁盘请求的顺序进行调度，优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。\n\n> 最短寻道时间优先，SSTF, Shortest Seek Time First\n\n优先调度与当前磁头所在磁道距离最近的磁道， 虽然平均寻道时间比较低，但是不够公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的 磁道请求会一直等待下去，也就是出现饥饿现象，具体来说，两边的磁道请求更容易出现饥饿现象。\n\n> 电梯算法，SCAN\n\n电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向， 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘 请求，然后改变方向，因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题","slug":"操作系统导论/设备管理","published":1,"date":"2022-02-01T13:35:37.586Z","updated":"2022-02-01T13:37:30.403Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkb00j9fhjich41b7ui","content":"<h1 id=\"磁盘调度算法\"><a href=\"#磁盘调度算法\" class=\"headerlink\" title=\"磁盘调度算法\"></a>磁盘调度算法</h1><p>读写一个磁盘块的时间的影响因素有：</p>\n<ul>\n<li>旋转时间</li>\n<li>寻道时间实际的数据传输时间</li>\n</ul>\n<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>\n<blockquote>\n<p>先来先服务 FCFS, First Come First Served</p>\n</blockquote>\n<p>按照磁盘请求的顺序进行调度，优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>\n<blockquote>\n<p>最短寻道时间优先，SSTF, Shortest Seek Time First</p>\n</blockquote>\n<p>优先调度与当前磁头所在磁道距离最近的磁道， 虽然平均寻道时间比较低，但是不够公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的 磁道请求会一直等待下去，也就是出现饥饿现象，具体来说，两边的磁道请求更容易出现饥饿现象。</p>\n<blockquote>\n<p>电梯算法，SCAN</p>\n</blockquote>\n<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向， 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘 请求，然后改变方向，因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"磁盘调度算法\"><a href=\"#磁盘调度算法\" class=\"headerlink\" title=\"磁盘调度算法\"></a>磁盘调度算法</h1><p>读写一个磁盘块的时间的影响因素有：</p>\n<ul>\n<li>旋转时间</li>\n<li>寻道时间实际的数据传输时间</li>\n</ul>\n<p>其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。</p>\n<blockquote>\n<p>先来先服务 FCFS, First Come First Served</p>\n</blockquote>\n<p>按照磁盘请求的顺序进行调度，优点是公平和简单，缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。</p>\n<blockquote>\n<p>最短寻道时间优先，SSTF, Shortest Seek Time First</p>\n</blockquote>\n<p>优先调度与当前磁头所在磁道距离最近的磁道， 虽然平均寻道时间比较低，但是不够公平，如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的 磁道请求会一直等待下去，也就是出现饥饿现象，具体来说，两边的磁道请求更容易出现饥饿现象。</p>\n<blockquote>\n<p>电梯算法，SCAN</p>\n</blockquote>\n<p>电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向， 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘 请求，然后改变方向，因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题</p>\n"},{"title":"进程","_content":"\n在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。\n\n在操作系统中能同时运行多个进程；\n\n开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。\n\n进程可以分成**用户态进程和内核态进程**两类，用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。\n\n如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。\n\n每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；\n\n**分时和调度**\n\n每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。\n\n> 注意，现代操作系统都是直接调度线程，不会调度进程。\n\n**分配时间片段**\n\n如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。\n\n因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始，这个就是分时技术。\n\n<img src=\"https://img-blog.csdnimg.cn/ca30e5c197ef4bbe8ae706f4ba577628.png\" style=\"zoom:25%;\" />\n\n# 创建进程\n\n用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用，但对于程序员而言，显然需要更好的设计。\n\n首先，应该有 API 打开应用，比如可以通过函数打开某个应用；\n\n另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。\n\n<img src=\"https://img-blog.csdnimg.cn/1b06cbc132e047ac987f130e50ad68df.png\" style=\"zoom:25%;\" />\n\n也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。\n\n如果要创造 2 个克隆进程，就要 fork 两次。\n\n> 那如果我就是想启动一个新的程序呢？\n\n操作系统提供了启动新程序的 API。\n\n如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。\n\n如果是这种情况，建议你不要单独启动进程，而是使用线程。\n\n因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。\n\n不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。\n\n# 进程状态\n\n<img src=\"https://img-blog.csdnimg.cn/a33a07f3e1b944ecb03ccf39227e378f.png\" style=\"zoom:50%;\" />\n\n**创建状态**\n\n进程由创建而产生，创建进程是一个非常复杂的过程，一般需要通过多个步骤才能完成：如首先由进程申请一个空白的进程控制块(PCB)，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入到就绪队列中\n\n**就绪状态**\n\n这是指进程已经准备好运行的状态，即进程已分配到除CPU以外所有的必要资源后，只要再获得CPU，便可立即执行，如果系统中有许多处于就绪状态的进程，通常将它们按照一定的策略排成一个队列，该队列称为就绪队列，有执行资格，没有执行权的进程\n\n**运行状态**\n\n这里指进程已经获取CPU，其进程处于正在执行的状态。对任何一个时刻而言，在单处理机的系统中，只有一个进程处于执行状态而在多处理机系统中，有多个进程处于执行状态，既有执行资格，又有执行权的进程\n\n**阻塞状态**\n\n这里是指正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，即进程执行受到阻塞，此时引起进程调度，操作系统把处理机分配给另外一个就绪的进程，而让受阻的进程处于暂停的状态，一般将这个暂停状态称为阻塞状态\n\n**终止状态**\n\n# 进程间通信IPC\n\n每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信\n\n**管道/匿名管道**\n\n管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。\n\n* 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);\n\n* 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\n\n* 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。\n\n**有名管道(FIFO)**\n\n匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。\n\n为了克服这个缺点，提出了有名管道(FIFO)。\n\n有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。\n\n**信号**\n\n信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。\n\n如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。\n\n如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。\n\n**消息队列**\n\n消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。\n\n与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。\n\n另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达\n\n**共享内存**\n\n使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的。\n\n为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。\n\n由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。\n\n共享内存示意图：\n\n<img src=\"https://img-blog.csdnimg.cn/535398a7779c4995aee2ae6974410c37.png\" style=\"zoom:25%;\" />\n\n一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。\n\n**信号量**\n\n信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。\n\n为了获得共享资源，进程需要执行下列操作：\n\n1. 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。 \n\n2. 等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞，也称为P操作。 \n3. 挂出一个信号量：该操作将信号量的值加1，也称为V操作。\n\n**套接字(Socket)**\n\n套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。\n\n# 信号\n\n信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。\n\n也可以简单理解为信号是某种形式上的软中断\n\n可运行`kill -l`查看Linux支持的信号列表：\n\n```\nkill -l\n 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP\n 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1\n11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM\n16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP\n21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ\n26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR\n31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3\n38) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8\n43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+13\n48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\t51) SIGRTMAX-13\t52) SIGRTMAX-12\n53) SIGRTMAX-11\t54) SIGRTMAX-10\t55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-7\n58) SIGRTMAX-6\t59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-2\n63) SIGRTMAX-1\t64) SIGRTMAX\n```\n\n**几个常用的信号：**\n\n| 信号    | 描述                                                         |\n| ------- | ------------------------------------------------------------ |\n| SIGHUP  | 当用户退出终端时，由该终端开启的所有进程都会接收到这个信号，默认动作为终止进程。 |\n| SIGINT  | 程序终止(interrupt)信号, 在用户键入INTR字符(通常是`Ctrl+C`)时发出，用于通知前台进程组终止进程。 |\n| SIGQUIT | 和`SIGINT`类似, 但由QUIT字符(通常是`Ctrl+\\`)来控制，进程在因收到`SIGQUIT`退出时会产生`core`文件, 在这个意义上类似于一个程序错误信号。 |\n| SIGKILL | 用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。       |\n| SIGTERM | 程序结束(terminate)信号, 与`SIGKILL`不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。 |\n| SIGSTOP | 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行，本信号不能被阻塞, 处理或忽略 |\n\n# 进程同步\n\n**临界区**\n\n通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问\n\n优点：保证在某一时刻只有一个线程能访问数据的简便办法\n\n缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程\n\n**互斥量**\n\n为协调共同对一个共享资源的单独访问而设计的\n\n互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限\n\n优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享\n\n**信号量**\n\n为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了\n\n信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作\n\n- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；\n- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。\n\ndown 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。\n\n如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。\n\n**事件**\n\n用来通知线程有一些事件已发生，从而启动后继任务的开始\n\n优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作\n\n**管程**\n\n管程有一个重要特性：在一个时刻只能有一个进程使用管程。\n\n进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。\n\n管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。\n\n对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。\n\nsignal() 操作用于唤醒被阻塞的进程。\n\n使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。\n\n# 上下文切换\n\n对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。\n\n上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。\n\n从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。\n\n**在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。**\n\n# 进程调度算法\n\n**先来先服务调度算法**\n\n该算法既可用于作业调度，也可用于进程调度，当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列\n\n**短作业优先调度算法**\n\n从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行\n\n**时间片轮转法**\n\n每次调度时，把CPU分配给队首进程，并令其执行一个时间片，时间片的大小从几ms到几百ms，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾\n\n然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片，这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间\n\n**最短剩余时间优先**\n\n最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。\n\n如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。\n\n**多级反馈队列调度算法**：\n\n前面介绍的几种进程调度的算法都有一定的局限性，如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程**，多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业迅速完成，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。\n\n> 举例：\n\n多级队列，就是多个队列执行调度，先考虑最简单的两级模型\n\n<img src=\"https://img-blog.csdnimg.cn/cbf1f574cfe54f85b01a6c1253c52b92.png\" style=\"zoom:25%;\" />\n\n上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。\n\n只要上层队列有任务，下层队列就会让出执行权限。\n\n低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。\n\n高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分，如果遇到十万火急的情况，就可以优先处理这个任务。\n\n上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题，可以考虑再增加一些队列，让级别更多。\n\n> 比如下图这个模型：\n\n<img src=\"https://img-blog.csdnimg.cn/6f7d4bfa7f2e4df8a9cb56adead8de5a.png\" style=\"zoom:25%;\" />\n\n紧急任务仍然走高优队列，非抢占执行。\n\n普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。\n\n下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。\n\n通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。\n\n实际操作中，可以有 n 层，一层层把大任务筛选出来，最长的任务，放到最闲的时间去执行，要知道，大部分时间 CPU 不是满负荷的。\n\n**优先级调度** \n\n为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推，具有相同优先级的进程以 FCFS 方式执行，可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n\n# 守护进程\n\n守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。\n\n守护进程一般的生命周期是系统启动到系统停止运行。\n\nLinux系统中有很多的守护进程，最典型的就是我们经常看到的服务进程。\n\n当然，我们也经常会利用守护进程来完成很多的系统或者自动化任务。\n\n# 孤儿进程\n\n父进程早于子进程退出时候子进程还在运行，子进程会成为孤儿进程，Linux会对孤儿进程的处理，把孤儿进程的父进程设为进程号为1的进程，也就是由init进程来托管，init进程负责子进程退出后的善后清理工作\n\n# 僵尸进程\n\n子进程执行完毕时发现父进程未退出，会向父进程发送 SIGCHLD 信号，但父进程没有使用 wait/waitpid 或其他方式处理 SIGCHLD 信号来回收子进程，子进程变成为了对系统有害的僵尸进程\n\n子进程退出后留下的进程信息没有被收集，会导致占用的进程控制块PCB不被释放，形成僵尸进程，进程已经死去，但是进程资源没有被释放掉\n\n**问题及危害**\n\n如果系统中存在大量的僵尸进程，他们的进程号就会一直被占用，但是系统所能使用的进程号是有限的，系统将因为没有可用的进程号而导致系统不能产生新的进程\n\n任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段，如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。\n\n如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态\n\n产生僵尸进程的元凶其实是他们的父进程，杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理\n\n# 死锁\n\n**产生原因**\n\n系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。\n\n进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。\n\n**发生死锁的四个必要条件**\n\n互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待\n\n请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放\n\n不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)\n\n循环等待条件: 若干进程间形成首尾相接循环等待资源的关系\n\n这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁\n\n**只要我们破坏其中一个，就可以成功避免死锁的发生**\n\n其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥\n\n1. 对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。\n2. 对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。\n3. 对于循环等待这个条件，可以靠按序申请资源来预防，所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。\n\n**处理方法**\n\n主要有以下四种方法：\n\n- 鸵鸟策略\n- 死锁检测与死锁恢复\n- 死锁预防，破坏4个必要条件\n- 死锁避免，银行家算法\n\n**鸵鸟策略**\n\n把头埋在沙子里，假装根本没发生问题。\n\n因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。\n\n当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。\n\n**死锁检测**\n\n不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。\n\n1. 每种类型一个资源的死锁检测\n\n2. 每种类型多个资源的死锁检测\n\n**死锁恢复**\n\n- 利用抢占恢复\n- 利用回滚恢复\n- 通过杀死进程恢复\n\n# 哲学家进餐问题\n\n五个哲学家围着一张圆桌，每个哲学家面前放着食物。\n\n哲学家的生活有两种交替活动：吃饭以及思考。\n\n当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。\n\n如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。\n\n哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。\n\n**为了防止死锁的发生，可以设置两个条件：**\n\n- 必须同时拿起左右两根筷子；\n- 只有在两个邻居都没有进餐的情况下才允许进餐。\n\n# 银行家算法\n\n银行家算法的命名是它可以用了银行系统，当不能满足所有客户的需求时，银行绝不会分配其资金。\n\n当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量这一数量不可以超过系统资源的总和。\n\n当用户申请一组资源时，系统必须确定这些资源的分配是否处于安全状态，如何安全，则分配，如果不安全，那么进程必须等待指导某个其他进程释放足够资源为止。\n\n**安全状态**\n\n在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待\n\n因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态\n\n# Fork函数\n\n`fork`函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。\n\n`fork`系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为`task_struct`的进程控制块`PCB`的结构。\n\n<img src=\"https://img-blog.csdnimg.cn/5e4479948ed041b080bb71fb84611e7b.png\" style=\"zoom:50%;\" />\n\n每个进程都由独特换不相同的进程标识符（PID），通过`getpid()`函数可获取当前进程的进程标识符，通过`getppid()`函数可获得父进程的进程标识符。\n\n一个现有的进程可通过调用`fork`函数创建一个新进程，由`fork`创建的新进程称为子进程`child process`，`fork`函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。\n\n**为什么`fork`会返回两次呢？**\n\n因为复制时会复制父进程的堆栈段，所以两个进程都停留在`fork`函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。\n\n- 在父进程中将返回新建子进程的进程ID\n- 在子进程中将返回0\n- 若出现错误则返回一个负数\n\n因此可以通过`fork`的返回值来判断当前进程是子进程还是父进程。\n\n**fork执行执行流程**\n\n当进程调用`fork`后控制转入内核，内核将会做4件事儿：\n\n1. 分配新的内存块和内核数据结构给子进程\n2. 将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程\n3. 添加子进程到系统进程列表中\n4. `fork`返回开始调度器调度\n\n**为什么`pid`在父子进程中不同呢？**\n\n其实就相当于链表，进程形成了链表，父进程的`pid`指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的`pid`相当于链表中的指针。","source":"_posts/操作系统导论/进程.md","raw":"---\ntitle: 进程\ncategories: \n- 操作系统导论\n---\n\n在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。\n\n在操作系统中能同时运行多个进程；\n\n开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。\n\n进程可以分成**用户态进程和内核态进程**两类，用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。\n\n如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。\n\n每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；\n\n**分时和调度**\n\n每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。\n\n> 注意，现代操作系统都是直接调度线程，不会调度进程。\n\n**分配时间片段**\n\n如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。\n\n因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始，这个就是分时技术。\n\n<img src=\"https://img-blog.csdnimg.cn/ca30e5c197ef4bbe8ae706f4ba577628.png\" style=\"zoom:25%;\" />\n\n# 创建进程\n\n用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用，但对于程序员而言，显然需要更好的设计。\n\n首先，应该有 API 打开应用，比如可以通过函数打开某个应用；\n\n另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。\n\n<img src=\"https://img-blog.csdnimg.cn/1b06cbc132e047ac987f130e50ad68df.png\" style=\"zoom:25%;\" />\n\n也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。\n\n如果要创造 2 个克隆进程，就要 fork 两次。\n\n> 那如果我就是想启动一个新的程序呢？\n\n操作系统提供了启动新程序的 API。\n\n如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。\n\n如果是这种情况，建议你不要单独启动进程，而是使用线程。\n\n因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。\n\n不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。\n\n# 进程状态\n\n<img src=\"https://img-blog.csdnimg.cn/a33a07f3e1b944ecb03ccf39227e378f.png\" style=\"zoom:50%;\" />\n\n**创建状态**\n\n进程由创建而产生，创建进程是一个非常复杂的过程，一般需要通过多个步骤才能完成：如首先由进程申请一个空白的进程控制块(PCB)，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入到就绪队列中\n\n**就绪状态**\n\n这是指进程已经准备好运行的状态，即进程已分配到除CPU以外所有的必要资源后，只要再获得CPU，便可立即执行，如果系统中有许多处于就绪状态的进程，通常将它们按照一定的策略排成一个队列，该队列称为就绪队列，有执行资格，没有执行权的进程\n\n**运行状态**\n\n这里指进程已经获取CPU，其进程处于正在执行的状态。对任何一个时刻而言，在单处理机的系统中，只有一个进程处于执行状态而在多处理机系统中，有多个进程处于执行状态，既有执行资格，又有执行权的进程\n\n**阻塞状态**\n\n这里是指正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，即进程执行受到阻塞，此时引起进程调度，操作系统把处理机分配给另外一个就绪的进程，而让受阻的进程处于暂停的状态，一般将这个暂停状态称为阻塞状态\n\n**终止状态**\n\n# 进程间通信IPC\n\n每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信\n\n**管道/匿名管道**\n\n管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。\n\n* 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);\n\n* 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。\n\n* 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。\n\n**有名管道(FIFO)**\n\n匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。\n\n为了克服这个缺点，提出了有名管道(FIFO)。\n\n有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。\n\n**信号**\n\n信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。\n\n如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。\n\n如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。\n\n**消息队列**\n\n消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。\n\n与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。\n\n另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达\n\n**共享内存**\n\n使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的。\n\n为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。\n\n由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。\n\n共享内存示意图：\n\n<img src=\"https://img-blog.csdnimg.cn/535398a7779c4995aee2ae6974410c37.png\" style=\"zoom:25%;\" />\n\n一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。\n\n**信号量**\n\n信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。\n\n为了获得共享资源，进程需要执行下列操作：\n\n1. 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。 \n\n2. 等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞，也称为P操作。 \n3. 挂出一个信号量：该操作将信号量的值加1，也称为V操作。\n\n**套接字(Socket)**\n\n套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。\n\n# 信号\n\n信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。\n\n也可以简单理解为信号是某种形式上的软中断\n\n可运行`kill -l`查看Linux支持的信号列表：\n\n```\nkill -l\n 1) SIGHUP\t 2) SIGINT\t 3) SIGQUIT\t 4) SIGILL\t 5) SIGTRAP\n 6) SIGABRT\t 7) SIGBUS\t 8) SIGFPE\t 9) SIGKILL\t10) SIGUSR1\n11) SIGSEGV\t12) SIGUSR2\t13) SIGPIPE\t14) SIGALRM\t15) SIGTERM\n16) SIGSTKFLT\t17) SIGCHLD\t18) SIGCONT\t19) SIGSTOP\t20) SIGTSTP\n21) SIGTTIN\t22) SIGTTOU\t23) SIGURG\t24) SIGXCPU\t25) SIGXFSZ\n26) SIGVTALRM\t27) SIGPROF\t28) SIGWINCH\t29) SIGIO\t30) SIGPWR\n31) SIGSYS\t34) SIGRTMIN\t35) SIGRTMIN+1\t36) SIGRTMIN+2\t37) SIGRTMIN+3\n38) SIGRTMIN+4\t39) SIGRTMIN+5\t40) SIGRTMIN+6\t41) SIGRTMIN+7\t42) SIGRTMIN+8\n43) SIGRTMIN+9\t44) SIGRTMIN+10\t45) SIGRTMIN+11\t46) SIGRTMIN+12\t47) SIGRTMIN+13\n48) SIGRTMIN+14\t49) SIGRTMIN+15\t50) SIGRTMAX-14\t51) SIGRTMAX-13\t52) SIGRTMAX-12\n53) SIGRTMAX-11\t54) SIGRTMAX-10\t55) SIGRTMAX-9\t56) SIGRTMAX-8\t57) SIGRTMAX-7\n58) SIGRTMAX-6\t59) SIGRTMAX-5\t60) SIGRTMAX-4\t61) SIGRTMAX-3\t62) SIGRTMAX-2\n63) SIGRTMAX-1\t64) SIGRTMAX\n```\n\n**几个常用的信号：**\n\n| 信号    | 描述                                                         |\n| ------- | ------------------------------------------------------------ |\n| SIGHUP  | 当用户退出终端时，由该终端开启的所有进程都会接收到这个信号，默认动作为终止进程。 |\n| SIGINT  | 程序终止(interrupt)信号, 在用户键入INTR字符(通常是`Ctrl+C`)时发出，用于通知前台进程组终止进程。 |\n| SIGQUIT | 和`SIGINT`类似, 但由QUIT字符(通常是`Ctrl+\\`)来控制，进程在因收到`SIGQUIT`退出时会产生`core`文件, 在这个意义上类似于一个程序错误信号。 |\n| SIGKILL | 用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。       |\n| SIGTERM | 程序结束(terminate)信号, 与`SIGKILL`不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。 |\n| SIGSTOP | 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行，本信号不能被阻塞, 处理或忽略 |\n\n# 进程同步\n\n**临界区**\n\n通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问\n\n优点：保证在某一时刻只有一个线程能访问数据的简便办法\n\n缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程\n\n**互斥量**\n\n为协调共同对一个共享资源的单独访问而设计的\n\n互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限\n\n优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享\n\n**信号量**\n\n为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了\n\n信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作\n\n- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；\n- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。\n\ndown 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。\n\n如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。\n\n**事件**\n\n用来通知线程有一些事件已发生，从而启动后继任务的开始\n\n优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作\n\n**管程**\n\n管程有一个重要特性：在一个时刻只能有一个进程使用管程。\n\n进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。\n\n管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。\n\n对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。\n\nsignal() 操作用于唤醒被阻塞的进程。\n\n使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。\n\n# 上下文切换\n\n对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。\n\n上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。\n\n从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。\n\n**在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。**\n\n# 进程调度算法\n\n**先来先服务调度算法**\n\n该算法既可用于作业调度，也可用于进程调度，当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列\n\n**短作业优先调度算法**\n\n从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行\n\n**时间片轮转法**\n\n每次调度时，把CPU分配给队首进程，并令其执行一个时间片，时间片的大小从几ms到几百ms，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾\n\n然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片，这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间\n\n**最短剩余时间优先**\n\n最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。\n\n如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。\n\n**多级反馈队列调度算法**：\n\n前面介绍的几种进程调度的算法都有一定的局限性，如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程**，多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业迅速完成，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。\n\n> 举例：\n\n多级队列，就是多个队列执行调度，先考虑最简单的两级模型\n\n<img src=\"https://img-blog.csdnimg.cn/cbf1f574cfe54f85b01a6c1253c52b92.png\" style=\"zoom:25%;\" />\n\n上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。\n\n只要上层队列有任务，下层队列就会让出执行权限。\n\n低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。\n\n高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分，如果遇到十万火急的情况，就可以优先处理这个任务。\n\n上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题，可以考虑再增加一些队列，让级别更多。\n\n> 比如下图这个模型：\n\n<img src=\"https://img-blog.csdnimg.cn/6f7d4bfa7f2e4df8a9cb56adead8de5a.png\" style=\"zoom:25%;\" />\n\n紧急任务仍然走高优队列，非抢占执行。\n\n普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。\n\n下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。\n\n通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。\n\n实际操作中，可以有 n 层，一层层把大任务筛选出来，最长的任务，放到最闲的时间去执行，要知道，大部分时间 CPU 不是满负荷的。\n\n**优先级调度** \n\n为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推，具有相同优先级的进程以 FCFS 方式执行，可以根据内存要求，时间要求或任何其他资源要求来确定优先级。\n\n# 守护进程\n\n守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。\n\n守护进程一般的生命周期是系统启动到系统停止运行。\n\nLinux系统中有很多的守护进程，最典型的就是我们经常看到的服务进程。\n\n当然，我们也经常会利用守护进程来完成很多的系统或者自动化任务。\n\n# 孤儿进程\n\n父进程早于子进程退出时候子进程还在运行，子进程会成为孤儿进程，Linux会对孤儿进程的处理，把孤儿进程的父进程设为进程号为1的进程，也就是由init进程来托管，init进程负责子进程退出后的善后清理工作\n\n# 僵尸进程\n\n子进程执行完毕时发现父进程未退出，会向父进程发送 SIGCHLD 信号，但父进程没有使用 wait/waitpid 或其他方式处理 SIGCHLD 信号来回收子进程，子进程变成为了对系统有害的僵尸进程\n\n子进程退出后留下的进程信息没有被收集，会导致占用的进程控制块PCB不被释放，形成僵尸进程，进程已经死去，但是进程资源没有被释放掉\n\n**问题及危害**\n\n如果系统中存在大量的僵尸进程，他们的进程号就会一直被占用，但是系统所能使用的进程号是有限的，系统将因为没有可用的进程号而导致系统不能产生新的进程\n\n任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段，如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。\n\n如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态\n\n产生僵尸进程的元凶其实是他们的父进程，杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理\n\n# 死锁\n\n**产生原因**\n\n系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。\n\n进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。\n\n**发生死锁的四个必要条件**\n\n互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待\n\n请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放\n\n不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)\n\n循环等待条件: 若干进程间形成首尾相接循环等待资源的关系\n\n这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁\n\n**只要我们破坏其中一个，就可以成功避免死锁的发生**\n\n其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥\n\n1. 对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。\n2. 对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。\n3. 对于循环等待这个条件，可以靠按序申请资源来预防，所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。\n\n**处理方法**\n\n主要有以下四种方法：\n\n- 鸵鸟策略\n- 死锁检测与死锁恢复\n- 死锁预防，破坏4个必要条件\n- 死锁避免，银行家算法\n\n**鸵鸟策略**\n\n把头埋在沙子里，假装根本没发生问题。\n\n因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。\n\n当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。\n\n**死锁检测**\n\n不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。\n\n1. 每种类型一个资源的死锁检测\n\n2. 每种类型多个资源的死锁检测\n\n**死锁恢复**\n\n- 利用抢占恢复\n- 利用回滚恢复\n- 通过杀死进程恢复\n\n# 哲学家进餐问题\n\n五个哲学家围着一张圆桌，每个哲学家面前放着食物。\n\n哲学家的生活有两种交替活动：吃饭以及思考。\n\n当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。\n\n如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。\n\n哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。\n\n**为了防止死锁的发生，可以设置两个条件：**\n\n- 必须同时拿起左右两根筷子；\n- 只有在两个邻居都没有进餐的情况下才允许进餐。\n\n# 银行家算法\n\n银行家算法的命名是它可以用了银行系统，当不能满足所有客户的需求时，银行绝不会分配其资金。\n\n当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量这一数量不可以超过系统资源的总和。\n\n当用户申请一组资源时，系统必须确定这些资源的分配是否处于安全状态，如何安全，则分配，如果不安全，那么进程必须等待指导某个其他进程释放足够资源为止。\n\n**安全状态**\n\n在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待\n\n因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态\n\n# Fork函数\n\n`fork`函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。\n\n`fork`系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为`task_struct`的进程控制块`PCB`的结构。\n\n<img src=\"https://img-blog.csdnimg.cn/5e4479948ed041b080bb71fb84611e7b.png\" style=\"zoom:50%;\" />\n\n每个进程都由独特换不相同的进程标识符（PID），通过`getpid()`函数可获取当前进程的进程标识符，通过`getppid()`函数可获得父进程的进程标识符。\n\n一个现有的进程可通过调用`fork`函数创建一个新进程，由`fork`创建的新进程称为子进程`child process`，`fork`函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。\n\n**为什么`fork`会返回两次呢？**\n\n因为复制时会复制父进程的堆栈段，所以两个进程都停留在`fork`函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。\n\n- 在父进程中将返回新建子进程的进程ID\n- 在子进程中将返回0\n- 若出现错误则返回一个负数\n\n因此可以通过`fork`的返回值来判断当前进程是子进程还是父进程。\n\n**fork执行执行流程**\n\n当进程调用`fork`后控制转入内核，内核将会做4件事儿：\n\n1. 分配新的内存块和内核数据结构给子进程\n2. 将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程\n3. 添加子进程到系统进程列表中\n4. `fork`返回开始调度器调度\n\n**为什么`pid`在父子进程中不同呢？**\n\n其实就相当于链表，进程形成了链表，父进程的`pid`指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的`pid`相当于链表中的指针。","slug":"操作系统导论/进程","published":1,"date":"2022-02-01T14:02:54.487Z","updated":"2022-02-01T14:29:09.182Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkb00jbfhji9ntkff1h","content":"<p>在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。</p>\n<p>在操作系统中能同时运行多个进程；</p>\n<p>开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。</p>\n<p>进程可以分成<strong>用户态进程和内核态进程</strong>两类，用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。</p>\n<p>如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。</p>\n<p>每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；</p>\n<p><strong>分时和调度</strong></p>\n<p>每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。</p>\n<blockquote>\n<p>注意，现代操作系统都是直接调度线程，不会调度进程。</p>\n</blockquote>\n<p><strong>分配时间片段</strong></p>\n<p>如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。</p>\n<p>因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始，这个就是分时技术。</p>\n<img src=\"https://img-blog.csdnimg.cn/ca30e5c197ef4bbe8ae706f4ba577628.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h1><p>用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用，但对于程序员而言，显然需要更好的设计。</p>\n<p>首先，应该有 API 打开应用，比如可以通过函数打开某个应用；</p>\n<p>另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。</p>\n<img src=\"https://img-blog.csdnimg.cn/1b06cbc132e047ac987f130e50ad68df.png\" style=\"zoom:25%;\" />\n\n<p>也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。</p>\n<p>如果要创造 2 个克隆进程，就要 fork 两次。</p>\n<blockquote>\n<p>那如果我就是想启动一个新的程序呢？</p>\n</blockquote>\n<p>操作系统提供了启动新程序的 API。</p>\n<p>如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。</p>\n<p>如果是这种情况，建议你不要单独启动进程，而是使用线程。</p>\n<p>因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。</p>\n<p>不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。</p>\n<h1 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h1><img src=\"https://img-blog.csdnimg.cn/a33a07f3e1b944ecb03ccf39227e378f.png\" style=\"zoom:50%;\" />\n\n<p><strong>创建状态</strong></p>\n<p>进程由创建而产生，创建进程是一个非常复杂的过程，一般需要通过多个步骤才能完成：如首先由进程申请一个空白的进程控制块(PCB)，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入到就绪队列中</p>\n<p><strong>就绪状态</strong></p>\n<p>这是指进程已经准备好运行的状态，即进程已分配到除CPU以外所有的必要资源后，只要再获得CPU，便可立即执行，如果系统中有许多处于就绪状态的进程，通常将它们按照一定的策略排成一个队列，该队列称为就绪队列，有执行资格，没有执行权的进程</p>\n<p><strong>运行状态</strong></p>\n<p>这里指进程已经获取CPU，其进程处于正在执行的状态。对任何一个时刻而言，在单处理机的系统中，只有一个进程处于执行状态而在多处理机系统中，有多个进程处于执行状态，既有执行资格，又有执行权的进程</p>\n<p><strong>阻塞状态</strong></p>\n<p>这里是指正在执行的进程由于发生某事件（如I&#x2F;O请求、申请缓冲区失败等）暂时无法继续执行的状态，即进程执行受到阻塞，此时引起进程调度，操作系统把处理机分配给另外一个就绪的进程，而让受阻的进程处于暂停的状态，一般将这个暂停状态称为阻塞状态</p>\n<p><strong>终止状态</strong></p>\n<h1 id=\"进程间通信IPC\"><a href=\"#进程间通信IPC\" class=\"headerlink\" title=\"进程间通信IPC\"></a>进程间通信IPC</h1><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</p>\n<p><strong>管道&#x2F;匿名管道</strong></p>\n<p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p>\n<ul>\n<li><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p>\n</li>\n<li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p>\n</li>\n<li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>\n</li>\n</ul>\n<p><strong>有名管道(FIFO)</strong></p>\n<p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。</p>\n<p>为了克服这个缺点，提出了有名管道(FIFO)。</p>\n<p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。</p>\n<p><strong>信号</strong></p>\n<p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p>\n<p>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</p>\n<p>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p>\n<p><strong>消息队列</strong></p>\n<p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p>\n<p>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p>\n<p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p>\n<p><strong>共享内存</strong></p>\n<p>使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的。</p>\n<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p>\n<p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p>\n<p>共享内存示意图：</p>\n<img src=\"https://img-blog.csdnimg.cn/535398a7779c4995aee2ae6974410c37.png\" style=\"zoom:25%;\" />\n\n<p>一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。</p>\n<p><strong>信号量</strong></p>\n<p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p>\n<p>为了获得共享资源，进程需要执行下列操作：</p>\n<ol>\n<li><p>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。 </p>\n</li>\n<li><p>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞，也称为P操作。 </p>\n</li>\n<li><p>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</p>\n</li>\n</ol>\n<p><strong>套接字(Socket)</strong></p>\n<p>套接字是一种通信机制，凭借这种机制，客户&#x2F;服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>\n<h1 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h1><p>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。</p>\n<p>也可以简单理解为信号是某种形式上的软中断</p>\n<p>可运行<code>kill -l</code>查看Linux支持的信号列表：</p>\n<pre><code>kill -l\n 1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP\n 6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1\n11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM\n16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP\n21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ\n26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR\n31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3\n38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8\n43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13\n48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12\n53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7\n58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2\n63) SIGRTMAX-1    64) SIGRTMAX\n</code></pre>\n<p><strong>几个常用的信号：</strong></p>\n<table>\n<thead>\n<tr>\n<th>信号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIGHUP</td>\n<td>当用户退出终端时，由该终端开启的所有进程都会接收到这个信号，默认动作为终止进程。</td>\n</tr>\n<tr>\n<td>SIGINT</td>\n<td>程序终止(interrupt)信号, 在用户键入INTR字符(通常是<code>Ctrl+C</code>)时发出，用于通知前台进程组终止进程。</td>\n</tr>\n<tr>\n<td>SIGQUIT</td>\n<td>和<code>SIGINT</code>类似, 但由QUIT字符(通常是<code>Ctrl+\\</code>)来控制，进程在因收到<code>SIGQUIT</code>退出时会产生<code>core</code>文件, 在这个意义上类似于一个程序错误信号。</td>\n</tr>\n<tr>\n<td>SIGKILL</td>\n<td>用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。</td>\n</tr>\n<tr>\n<td>SIGTERM</td>\n<td>程序结束(terminate)信号, 与<code>SIGKILL</code>不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。</td>\n</tr>\n<tr>\n<td>SIGSTOP</td>\n<td>停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行，本信号不能被阻塞, 处理或忽略</td>\n</tr>\n</tbody></table>\n<h1 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h1><p><strong>临界区</strong></p>\n<p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</p>\n<p>优点：保证在某一时刻只有一个线程能访问数据的简便办法</p>\n<p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程</p>\n<p><strong>互斥量</strong></p>\n<p>为协调共同对一个共享资源的单独访问而设计的</p>\n<p>互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限</p>\n<p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享</p>\n<p><strong>信号量</strong></p>\n<p>为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数&#x3D;1就是互斥量了</p>\n<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作</p>\n<ul>\n<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>\n<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>\n</ul>\n<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>\n<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>\n<p><strong>事件</strong></p>\n<p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p>\n<p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作</p>\n<p><strong>管程</strong></p>\n<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。</p>\n<p>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>\n<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。</p>\n<p>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。</p>\n<p>signal() 操作用于唤醒被阻塞的进程。</p>\n<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>\n<h1 id=\"上下文切换\"><a href=\"#上下文切换\" class=\"headerlink\" title=\"上下文切换\"></a>上下文切换</h1><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。</p>\n<p>上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。</p>\n<p>从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。</p>\n<p><strong>在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</strong></p>\n<h1 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h1><p><strong>先来先服务调度算法</strong></p>\n<p>该算法既可用于作业调度，也可用于进程调度，当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p>\n<p><strong>短作业优先调度算法</strong></p>\n<p>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</p>\n<p><strong>时间片轮转法</strong></p>\n<p>每次调度时，把CPU分配给队首进程，并令其执行一个时间片，时间片的大小从几ms到几百ms，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾</p>\n<p>然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片，这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间</p>\n<p><strong>最短剩余时间优先</strong></p>\n<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p>\n<p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>\n<p><strong>多级反馈队列调度算法</strong>：</p>\n<p>前面介绍的几种进程调度的算法都有一定的局限性，如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong>，多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业迅速完成，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</p>\n<blockquote>\n<p>举例：</p>\n</blockquote>\n<p>多级队列，就是多个队列执行调度，先考虑最简单的两级模型</p>\n<img src=\"https://img-blog.csdnimg.cn/cbf1f574cfe54f85b01a6c1253c52b92.png\" style=\"zoom:25%;\" />\n\n<p>上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。</p>\n<p>只要上层队列有任务，下层队列就会让出执行权限。</p>\n<p>低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。</p>\n<p>高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分，如果遇到十万火急的情况，就可以优先处理这个任务。</p>\n<p>上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题，可以考虑再增加一些队列，让级别更多。</p>\n<blockquote>\n<p>比如下图这个模型：</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/6f7d4bfa7f2e4df8a9cb56adead8de5a.png\" style=\"zoom:25%;\" />\n\n<p>紧急任务仍然走高优队列，非抢占执行。</p>\n<p>普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。</p>\n<p>下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。</p>\n<p>通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p>\n<p>实际操作中，可以有 n 层，一层层把大任务筛选出来，最长的任务，放到最闲的时间去执行，要知道，大部分时间 CPU 不是满负荷的。</p>\n<p><strong>优先级调度</strong> </p>\n<p>为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推，具有相同优先级的进程以 FCFS 方式执行，可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p>\n<h1 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h1><p>守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。</p>\n<p>守护进程一般的生命周期是系统启动到系统停止运行。</p>\n<p>Linux系统中有很多的守护进程，最典型的就是我们经常看到的服务进程。</p>\n<p>当然，我们也经常会利用守护进程来完成很多的系统或者自动化任务。</p>\n<h1 id=\"孤儿进程\"><a href=\"#孤儿进程\" class=\"headerlink\" title=\"孤儿进程\"></a>孤儿进程</h1><p>父进程早于子进程退出时候子进程还在运行，子进程会成为孤儿进程，Linux会对孤儿进程的处理，把孤儿进程的父进程设为进程号为1的进程，也就是由init进程来托管，init进程负责子进程退出后的善后清理工作</p>\n<h1 id=\"僵尸进程\"><a href=\"#僵尸进程\" class=\"headerlink\" title=\"僵尸进程\"></a>僵尸进程</h1><p>子进程执行完毕时发现父进程未退出，会向父进程发送 SIGCHLD 信号，但父进程没有使用 wait&#x2F;waitpid 或其他方式处理 SIGCHLD 信号来回收子进程，子进程变成为了对系统有害的僵尸进程</p>\n<p>子进程退出后留下的进程信息没有被收集，会导致占用的进程控制块PCB不被释放，形成僵尸进程，进程已经死去，但是进程资源没有被释放掉</p>\n<p><strong>问题及危害</strong></p>\n<p>如果系统中存在大量的僵尸进程，他们的进程号就会一直被占用，但是系统所能使用的进程号是有限的，系统将因为没有可用的进程号而导致系统不能产生新的进程</p>\n<p>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段，如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。</p>\n<p>如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态</p>\n<p>产生僵尸进程的元凶其实是他们的父进程，杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理</p>\n<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><p><strong>产生原因</strong></p>\n<p>系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p>\n<p>进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</p>\n<p><strong>发生死锁的四个必要条件</strong></p>\n<p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待</p>\n<p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p>\n<p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)</p>\n<p>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系</p>\n<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁</p>\n<p><strong>只要我们破坏其中一个，就可以成功避免死锁的发生</strong></p>\n<p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥</p>\n<ol>\n<li>对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li>\n<li>对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li>\n<li>对于循环等待这个条件，可以靠按序申请资源来预防，所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>\n</ol>\n<p><strong>处理方法</strong></p>\n<p>主要有以下四种方法：</p>\n<ul>\n<li>鸵鸟策略</li>\n<li>死锁检测与死锁恢复</li>\n<li>死锁预防，破坏4个必要条件</li>\n<li>死锁避免，银行家算法</li>\n</ul>\n<p><strong>鸵鸟策略</strong></p>\n<p>把头埋在沙子里，假装根本没发生问题。</p>\n<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>\n<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>\n<p><strong>死锁检测</strong></p>\n<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>\n<ol>\n<li><p>每种类型一个资源的死锁检测</p>\n</li>\n<li><p>每种类型多个资源的死锁检测</p>\n</li>\n</ol>\n<p><strong>死锁恢复</strong></p>\n<ul>\n<li>利用抢占恢复</li>\n<li>利用回滚恢复</li>\n<li>通过杀死进程恢复</li>\n</ul>\n<h1 id=\"哲学家进餐问题\"><a href=\"#哲学家进餐问题\" class=\"headerlink\" title=\"哲学家进餐问题\"></a>哲学家进餐问题</h1><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。</p>\n<p>哲学家的生活有两种交替活动：吃饭以及思考。</p>\n<p>当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>\n<p>如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>\n<p>哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。</p>\n<p><strong>为了防止死锁的发生，可以设置两个条件：</strong></p>\n<ul>\n<li>必须同时拿起左右两根筷子；</li>\n<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>\n</ul>\n<h1 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h1><p>银行家算法的命名是它可以用了银行系统，当不能满足所有客户的需求时，银行绝不会分配其资金。</p>\n<p>当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量这一数量不可以超过系统资源的总和。</p>\n<p>当用户申请一组资源时，系统必须确定这些资源的分配是否处于安全状态，如何安全，则分配，如果不安全，那么进程必须等待指导某个其他进程释放足够资源为止。</p>\n<p><strong>安全状态</strong></p>\n<p>在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待</p>\n<p>因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态</p>\n<h1 id=\"Fork函数\"><a href=\"#Fork函数\" class=\"headerlink\" title=\"Fork函数\"></a>Fork函数</h1><p><code>fork</code>函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。</p>\n<p><code>fork</code>系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为<code>task_struct</code>的进程控制块<code>PCB</code>的结构。</p>\n<img src=\"https://img-blog.csdnimg.cn/5e4479948ed041b080bb71fb84611e7b.png\" style=\"zoom:50%;\" />\n\n<p>每个进程都由独特换不相同的进程标识符（PID），通过<code>getpid()</code>函数可获取当前进程的进程标识符，通过<code>getppid()</code>函数可获得父进程的进程标识符。</p>\n<p>一个现有的进程可通过调用<code>fork</code>函数创建一个新进程，由<code>fork</code>创建的新进程称为子进程<code>child process</code>，<code>fork</code>函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。</p>\n<p><strong>为什么<code>fork</code>会返回两次呢？</strong></p>\n<p>因为复制时会复制父进程的堆栈段，所以两个进程都停留在<code>fork</code>函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。</p>\n<ul>\n<li>在父进程中将返回新建子进程的进程ID</li>\n<li>在子进程中将返回0</li>\n<li>若出现错误则返回一个负数</li>\n</ul>\n<p>因此可以通过<code>fork</code>的返回值来判断当前进程是子进程还是父进程。</p>\n<p><strong>fork执行执行流程</strong></p>\n<p>当进程调用<code>fork</code>后控制转入内核，内核将会做4件事儿：</p>\n<ol>\n<li>分配新的内存块和内核数据结构给子进程</li>\n<li>将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程</li>\n<li>添加子进程到系统进程列表中</li>\n<li><code>fork</code>返回开始调度器调度</li>\n</ol>\n<p><strong>为什么<code>pid</code>在父子进程中不同呢？</strong></p>\n<p>其实就相当于链表，进程形成了链表，父进程的<code>pid</code>指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的<code>pid</code>相当于链表中的指针。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。</p>\n<p>在操作系统中能同时运行多个进程；</p>\n<p>开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。</p>\n<p>进程可以分成<strong>用户态进程和内核态进程</strong>两类，用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。</p>\n<p>如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。</p>\n<p>每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；</p>\n<p><strong>分时和调度</strong></p>\n<p>每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。</p>\n<blockquote>\n<p>注意，现代操作系统都是直接调度线程，不会调度进程。</p>\n</blockquote>\n<p><strong>分配时间片段</strong></p>\n<p>如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。</p>\n<p>因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始，这个就是分时技术。</p>\n<img src=\"https://img-blog.csdnimg.cn/ca30e5c197ef4bbe8ae706f4ba577628.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"创建进程\"><a href=\"#创建进程\" class=\"headerlink\" title=\"创建进程\"></a>创建进程</h1><p>用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用，但对于程序员而言，显然需要更好的设计。</p>\n<p>首先，应该有 API 打开应用，比如可以通过函数打开某个应用；</p>\n<p>另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。</p>\n<img src=\"https://img-blog.csdnimg.cn/1b06cbc132e047ac987f130e50ad68df.png\" style=\"zoom:25%;\" />\n\n<p>也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。</p>\n<p>如果要创造 2 个克隆进程，就要 fork 两次。</p>\n<blockquote>\n<p>那如果我就是想启动一个新的程序呢？</p>\n</blockquote>\n<p>操作系统提供了启动新程序的 API。</p>\n<p>如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。</p>\n<p>如果是这种情况，建议你不要单独启动进程，而是使用线程。</p>\n<p>因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。</p>\n<p>不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。</p>\n<h1 id=\"进程状态\"><a href=\"#进程状态\" class=\"headerlink\" title=\"进程状态\"></a>进程状态</h1><img src=\"https://img-blog.csdnimg.cn/a33a07f3e1b944ecb03ccf39227e378f.png\" style=\"zoom:50%;\" />\n\n<p><strong>创建状态</strong></p>\n<p>进程由创建而产生，创建进程是一个非常复杂的过程，一般需要通过多个步骤才能完成：如首先由进程申请一个空白的进程控制块(PCB)，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入到就绪队列中</p>\n<p><strong>就绪状态</strong></p>\n<p>这是指进程已经准备好运行的状态，即进程已分配到除CPU以外所有的必要资源后，只要再获得CPU，便可立即执行，如果系统中有许多处于就绪状态的进程，通常将它们按照一定的策略排成一个队列，该队列称为就绪队列，有执行资格，没有执行权的进程</p>\n<p><strong>运行状态</strong></p>\n<p>这里指进程已经获取CPU，其进程处于正在执行的状态。对任何一个时刻而言，在单处理机的系统中，只有一个进程处于执行状态而在多处理机系统中，有多个进程处于执行状态，既有执行资格，又有执行权的进程</p>\n<p><strong>阻塞状态</strong></p>\n<p>这里是指正在执行的进程由于发生某事件（如I&#x2F;O请求、申请缓冲区失败等）暂时无法继续执行的状态，即进程执行受到阻塞，此时引起进程调度，操作系统把处理机分配给另外一个就绪的进程，而让受阻的进程处于暂停的状态，一般将这个暂停状态称为阻塞状态</p>\n<p><strong>终止状态</strong></p>\n<h1 id=\"进程间通信IPC\"><a href=\"#进程间通信IPC\" class=\"headerlink\" title=\"进程间通信IPC\"></a>进程间通信IPC</h1><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信</p>\n<p><strong>管道&#x2F;匿名管道</strong></p>\n<p>管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。</p>\n<ul>\n<li><p>只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);</p>\n</li>\n<li><p>单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。</p>\n</li>\n<li><p>数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。</p>\n</li>\n</ul>\n<p><strong>有名管道(FIFO)</strong></p>\n<p>匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。</p>\n<p>为了克服这个缺点，提出了有名管道(FIFO)。</p>\n<p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。</p>\n<p><strong>信号</strong></p>\n<p>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</p>\n<p>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</p>\n<p>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</p>\n<p><strong>消息队列</strong></p>\n<p>消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。</p>\n<p>与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。</p>\n<p>另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达</p>\n<p><strong>共享内存</strong></p>\n<p>使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的。</p>\n<p>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p>\n<p>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</p>\n<p>共享内存示意图：</p>\n<img src=\"https://img-blog.csdnimg.cn/535398a7779c4995aee2ae6974410c37.png\" style=\"zoom:25%;\" />\n\n<p>一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。</p>\n<p><strong>信号量</strong></p>\n<p>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。</p>\n<p>为了获得共享资源，进程需要执行下列操作：</p>\n<ol>\n<li><p>创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。 </p>\n</li>\n<li><p>等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞，也称为P操作。 </p>\n</li>\n<li><p>挂出一个信号量：该操作将信号量的值加1，也称为V操作。</p>\n</li>\n</ol>\n<p><strong>套接字(Socket)</strong></p>\n<p>套接字是一种通信机制，凭借这种机制，客户&#x2F;服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>\n<h1 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h1><p>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。</p>\n<p>也可以简单理解为信号是某种形式上的软中断</p>\n<p>可运行<code>kill -l</code>查看Linux支持的信号列表：</p>\n<pre><code>kill -l\n 1) SIGHUP     2) SIGINT     3) SIGQUIT     4) SIGILL     5) SIGTRAP\n 6) SIGABRT     7) SIGBUS     8) SIGFPE     9) SIGKILL    10) SIGUSR1\n11) SIGSEGV    12) SIGUSR2    13) SIGPIPE    14) SIGALRM    15) SIGTERM\n16) SIGSTKFLT    17) SIGCHLD    18) SIGCONT    19) SIGSTOP    20) SIGTSTP\n21) SIGTTIN    22) SIGTTOU    23) SIGURG    24) SIGXCPU    25) SIGXFSZ\n26) SIGVTALRM    27) SIGPROF    28) SIGWINCH    29) SIGIO    30) SIGPWR\n31) SIGSYS    34) SIGRTMIN    35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3\n38) SIGRTMIN+4    39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8\n43) SIGRTMIN+9    44) SIGRTMIN+10    45) SIGRTMIN+11    46) SIGRTMIN+12    47) SIGRTMIN+13\n48) SIGRTMIN+14    49) SIGRTMIN+15    50) SIGRTMAX-14    51) SIGRTMAX-13    52) SIGRTMAX-12\n53) SIGRTMAX-11    54) SIGRTMAX-10    55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7\n58) SIGRTMAX-6    59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2\n63) SIGRTMAX-1    64) SIGRTMAX\n</code></pre>\n<p><strong>几个常用的信号：</strong></p>\n<table>\n<thead>\n<tr>\n<th>信号</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>SIGHUP</td>\n<td>当用户退出终端时，由该终端开启的所有进程都会接收到这个信号，默认动作为终止进程。</td>\n</tr>\n<tr>\n<td>SIGINT</td>\n<td>程序终止(interrupt)信号, 在用户键入INTR字符(通常是<code>Ctrl+C</code>)时发出，用于通知前台进程组终止进程。</td>\n</tr>\n<tr>\n<td>SIGQUIT</td>\n<td>和<code>SIGINT</code>类似, 但由QUIT字符(通常是<code>Ctrl+\\</code>)来控制，进程在因收到<code>SIGQUIT</code>退出时会产生<code>core</code>文件, 在这个意义上类似于一个程序错误信号。</td>\n</tr>\n<tr>\n<td>SIGKILL</td>\n<td>用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。</td>\n</tr>\n<tr>\n<td>SIGTERM</td>\n<td>程序结束(terminate)信号, 与<code>SIGKILL</code>不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。</td>\n</tr>\n<tr>\n<td>SIGSTOP</td>\n<td>停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行，本信号不能被阻塞, 处理或忽略</td>\n</tr>\n</tbody></table>\n<h1 id=\"进程同步\"><a href=\"#进程同步\" class=\"headerlink\" title=\"进程同步\"></a>进程同步</h1><p><strong>临界区</strong></p>\n<p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问</p>\n<p>优点：保证在某一时刻只有一个线程能访问数据的简便办法</p>\n<p>缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程</p>\n<p><strong>互斥量</strong></p>\n<p>为协调共同对一个共享资源的单独访问而设计的</p>\n<p>互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限</p>\n<p>优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享</p>\n<p><strong>信号量</strong></p>\n<p>为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数&#x3D;1就是互斥量了</p>\n<p>信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作</p>\n<ul>\n<li><strong>down</strong> : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；</li>\n<li><strong>up</strong> ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。</li>\n</ul>\n<p>down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。</p>\n<p>如果信号量的取值只能为 0 或者 1，那么就成为了 <strong>互斥量（Mutex）</strong> ，0 表示临界区已经加锁，1 表示临界区解锁。</p>\n<p><strong>事件</strong></p>\n<p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p>\n<p>优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作</p>\n<p><strong>管程</strong></p>\n<p>管程有一个重要特性：在一个时刻只能有一个进程使用管程。</p>\n<p>进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。</p>\n<p>管程引入了 <strong>条件变量</strong> 以及相关的操作：<strong>wait()</strong> 和 <strong>signal()</strong> 来实现同步操作。</p>\n<p>对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。</p>\n<p>signal() 操作用于唤醒被阻塞的进程。</p>\n<p>使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。</p>\n<h1 id=\"上下文切换\"><a href=\"#上下文切换\" class=\"headerlink\" title=\"上下文切换\"></a>上下文切换</h1><p>对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。</p>\n<p>上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。</p>\n<p>从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。</p>\n<p><strong>在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。</strong></p>\n<h1 id=\"进程调度算法\"><a href=\"#进程调度算法\" class=\"headerlink\" title=\"进程调度算法\"></a>进程调度算法</h1><p><strong>先来先服务调度算法</strong></p>\n<p>该算法既可用于作业调度，也可用于进程调度，当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列</p>\n<p><strong>短作业优先调度算法</strong></p>\n<p>从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行</p>\n<p><strong>时间片轮转法</strong></p>\n<p>每次调度时，把CPU分配给队首进程，并令其执行一个时间片，时间片的大小从几ms到几百ms，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾</p>\n<p>然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片，这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间</p>\n<p><strong>最短剩余时间优先</strong></p>\n<p>最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。</p>\n<p>如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。</p>\n<p><strong>多级反馈队列调度算法</strong>：</p>\n<p>前面介绍的几种进程调度的算法都有一定的局限性，如<strong>短进程优先的调度算法，仅照顾了短进程而忽略了长进程</strong>，多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业迅速完成，因而它是目前<strong>被公认的一种较好的进程调度算法</strong>，UNIX 操作系统采取的便是这种调度算法。</p>\n<blockquote>\n<p>举例：</p>\n</blockquote>\n<p>多级队列，就是多个队列执行调度，先考虑最简单的两级模型</p>\n<img src=\"https://img-blog.csdnimg.cn/cbf1f574cfe54f85b01a6c1253c52b92.png\" style=\"zoom:25%;\" />\n\n<p>上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。</p>\n<p>只要上层队列有任务，下层队列就会让出执行权限。</p>\n<p>低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。</p>\n<p>高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分，如果遇到十万火急的情况，就可以优先处理这个任务。</p>\n<p>上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题，可以考虑再增加一些队列，让级别更多。</p>\n<blockquote>\n<p>比如下图这个模型：</p>\n</blockquote>\n<img src=\"https://img-blog.csdnimg.cn/6f7d4bfa7f2e4df8a9cb56adead8de5a.png\" style=\"zoom:25%;\" />\n\n<p>紧急任务仍然走高优队列，非抢占执行。</p>\n<p>普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。</p>\n<p>下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。</p>\n<p>通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。</p>\n<p>实际操作中，可以有 n 层，一层层把大任务筛选出来，最长的任务，放到最闲的时间去执行，要知道，大部分时间 CPU 不是满负荷的。</p>\n<p><strong>优先级调度</strong> </p>\n<p>为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推，具有相同优先级的进程以 FCFS 方式执行，可以根据内存要求，时间要求或任何其他资源要求来确定优先级。</p>\n<h1 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h1><p>守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。</p>\n<p>守护进程一般的生命周期是系统启动到系统停止运行。</p>\n<p>Linux系统中有很多的守护进程，最典型的就是我们经常看到的服务进程。</p>\n<p>当然，我们也经常会利用守护进程来完成很多的系统或者自动化任务。</p>\n<h1 id=\"孤儿进程\"><a href=\"#孤儿进程\" class=\"headerlink\" title=\"孤儿进程\"></a>孤儿进程</h1><p>父进程早于子进程退出时候子进程还在运行，子进程会成为孤儿进程，Linux会对孤儿进程的处理，把孤儿进程的父进程设为进程号为1的进程，也就是由init进程来托管，init进程负责子进程退出后的善后清理工作</p>\n<h1 id=\"僵尸进程\"><a href=\"#僵尸进程\" class=\"headerlink\" title=\"僵尸进程\"></a>僵尸进程</h1><p>子进程执行完毕时发现父进程未退出，会向父进程发送 SIGCHLD 信号，但父进程没有使用 wait&#x2F;waitpid 或其他方式处理 SIGCHLD 信号来回收子进程，子进程变成为了对系统有害的僵尸进程</p>\n<p>子进程退出后留下的进程信息没有被收集，会导致占用的进程控制块PCB不被释放，形成僵尸进程，进程已经死去，但是进程资源没有被释放掉</p>\n<p><strong>问题及危害</strong></p>\n<p>如果系统中存在大量的僵尸进程，他们的进程号就会一直被占用，但是系统所能使用的进程号是有限的，系统将因为没有可用的进程号而导致系统不能产生新的进程</p>\n<p>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段，如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。</p>\n<p>如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态</p>\n<p>产生僵尸进程的元凶其实是他们的父进程，杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理</p>\n<h1 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h1><p><strong>产生原因</strong></p>\n<p>系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。</p>\n<p>进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。</p>\n<p><strong>发生死锁的四个必要条件</strong></p>\n<p>互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待</p>\n<p>请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放</p>\n<p>不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)</p>\n<p>循环等待条件: 若干进程间形成首尾相接循环等待资源的关系</p>\n<p>这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁</p>\n<p><strong>只要我们破坏其中一个，就可以成功避免死锁的发生</strong></p>\n<p>其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥</p>\n<ol>\n<li>对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。</li>\n<li>对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。</li>\n<li>对于循环等待这个条件，可以靠按序申请资源来预防，所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。</li>\n</ol>\n<p><strong>处理方法</strong></p>\n<p>主要有以下四种方法：</p>\n<ul>\n<li>鸵鸟策略</li>\n<li>死锁检测与死锁恢复</li>\n<li>死锁预防，破坏4个必要条件</li>\n<li>死锁避免，银行家算法</li>\n</ul>\n<p><strong>鸵鸟策略</strong></p>\n<p>把头埋在沙子里，假装根本没发生问题。</p>\n<p>因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。</p>\n<p>当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。</p>\n<p><strong>死锁检测</strong></p>\n<p>不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。</p>\n<ol>\n<li><p>每种类型一个资源的死锁检测</p>\n</li>\n<li><p>每种类型多个资源的死锁检测</p>\n</li>\n</ol>\n<p><strong>死锁恢复</strong></p>\n<ul>\n<li>利用抢占恢复</li>\n<li>利用回滚恢复</li>\n<li>通过杀死进程恢复</li>\n</ul>\n<h1 id=\"哲学家进餐问题\"><a href=\"#哲学家进餐问题\" class=\"headerlink\" title=\"哲学家进餐问题\"></a>哲学家进餐问题</h1><p>五个哲学家围着一张圆桌，每个哲学家面前放着食物。</p>\n<p>哲学家的生活有两种交替活动：吃饭以及思考。</p>\n<p>当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。</p>\n<p>如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。</p>\n<p>哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。</p>\n<p><strong>为了防止死锁的发生，可以设置两个条件：</strong></p>\n<ul>\n<li>必须同时拿起左右两根筷子；</li>\n<li>只有在两个邻居都没有进餐的情况下才允许进餐。</li>\n</ul>\n<h1 id=\"银行家算法\"><a href=\"#银行家算法\" class=\"headerlink\" title=\"银行家算法\"></a>银行家算法</h1><p>银行家算法的命名是它可以用了银行系统，当不能满足所有客户的需求时，银行绝不会分配其资金。</p>\n<p>当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量这一数量不可以超过系统资源的总和。</p>\n<p>当用户申请一组资源时，系统必须确定这些资源的分配是否处于安全状态，如何安全，则分配，如果不安全，那么进程必须等待指导某个其他进程释放足够资源为止。</p>\n<p><strong>安全状态</strong></p>\n<p>在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待</p>\n<p>因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态</p>\n<h1 id=\"Fork函数\"><a href=\"#Fork函数\" class=\"headerlink\" title=\"Fork函数\"></a>Fork函数</h1><p><code>fork</code>函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。</p>\n<p><code>fork</code>系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为<code>task_struct</code>的进程控制块<code>PCB</code>的结构。</p>\n<img src=\"https://img-blog.csdnimg.cn/5e4479948ed041b080bb71fb84611e7b.png\" style=\"zoom:50%;\" />\n\n<p>每个进程都由独特换不相同的进程标识符（PID），通过<code>getpid()</code>函数可获取当前进程的进程标识符，通过<code>getppid()</code>函数可获得父进程的进程标识符。</p>\n<p>一个现有的进程可通过调用<code>fork</code>函数创建一个新进程，由<code>fork</code>创建的新进程称为子进程<code>child process</code>，<code>fork</code>函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。</p>\n<p><strong>为什么<code>fork</code>会返回两次呢？</strong></p>\n<p>因为复制时会复制父进程的堆栈段，所以两个进程都停留在<code>fork</code>函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。</p>\n<ul>\n<li>在父进程中将返回新建子进程的进程ID</li>\n<li>在子进程中将返回0</li>\n<li>若出现错误则返回一个负数</li>\n</ul>\n<p>因此可以通过<code>fork</code>的返回值来判断当前进程是子进程还是父进程。</p>\n<p><strong>fork执行执行流程</strong></p>\n<p>当进程调用<code>fork</code>后控制转入内核，内核将会做4件事儿：</p>\n<ol>\n<li>分配新的内存块和内核数据结构给子进程</li>\n<li>将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程</li>\n<li>添加子进程到系统进程列表中</li>\n<li><code>fork</code>返回开始调度器调度</li>\n</ol>\n<p><strong>为什么<code>pid</code>在父子进程中不同呢？</strong></p>\n<p>其实就相当于链表，进程形成了链表，父进程的<code>pid</code>指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的<code>pid</code>相当于链表中的指针。</p>\n"},{"title":"GC日志","_content":"\n[一个简单案例，带你看懂GC日志！](https://mp.weixin.qq.com/s/VwDzXz_-_EAKegdfmXEo3A)\n\n","source":"_posts/深入理解JVM虚拟机/GC日志.md","raw":"---\ntitle: GC日志\ncategories: \n- 深入理解JVM虚拟机\n---\n\n[一个简单案例，带你看懂GC日志！](https://mp.weixin.qq.com/s/VwDzXz_-_EAKegdfmXEo3A)\n\n","slug":"深入理解JVM虚拟机/GC日志","published":1,"date":"2022-02-01T08:34:05.436Z","updated":"2022-02-01T08:35:11.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwki00jyfhji7zykght4","content":"<p><a href=\"https://mp.weixin.qq.com/s/VwDzXz_-_EAKegdfmXEo3A\">一个简单案例，带你看懂GC日志！</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://mp.weixin.qq.com/s/VwDzXz_-_EAKegdfmXEo3A\">一个简单案例，带你看懂GC日志！</a></p>\n"},{"title":"内存区域","_content":"\n虚拟机所管理的内存将会包括以下几个运行时数据区域\n\n<img src=\"https://img-blog.csdnimg.cn/91025ef2cfcc4b9ca6ca770d333b4efb.png\" style=\"zoom:25%;\" />\n\n**举例子：**\n\n```java\npublic class JVMCase {\n\n\t// 常量\n\tpublic final static String MAN_SEX_TYPE = \"man\";\n\n\t// 静态变量\n\tpublic static String WOMAN_SEX_TYPE = \"woman\";\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tStudent stu = new Student();\n\t\tstu.setName(\"nick\");\n\t\tstu.setSexType(MAN_SEX_TYPE);\n\t\tstu.setAge(20);\n\t\t\n\t\tJVMCase jvmcase = new JVMCase();\n\t\t\n\t\t// 调用静态方法\n\t\tprint(stu);\n\t\t// 调用非静态方法\n\t\tjvmcase.sayHello(stu);\n\t}\n\n\n\t// 常规静态方法\n\tpublic static void print(Student stu) {\n\t\tSystem.out.println(\"name: \" + stu.getName() + \"; sex:\" + stu.getSexType() + \"; age:\" + stu.getAge()); \n\t}\n\n\n\t// 非静态方法\n\tpublic void sayHello(Student stu) {\n\t\tSystem.out.println(stu.getName() + \"say: hello\"); \n\t}\n}\n\nclass Student{\n\tString name;\n\tString sexType;\n\tint age;\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSexType() {\n\t\treturn sexType;\n\t}\n\tpublic void setSexType(String sexType) {\n\t\tthis.sexType = sexType;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n```\n\n创建一个JVMCase对象，调用sayHello非静态方法，sayHello方法属于对象JVMCase，此时sayHello方法入栈，并通过栈中的student引用调用堆中的Student对象；\n\n之后，调用静态方法print，print静态方法属于JVMCase类，是从静态方法中获取，之后放入到栈中，也是通过student引用调用堆中的student对象。\n\n<img src=\"https://img-blog.csdnimg.cn/c5263cdd5cd845b89a16a51c6b374d2c.png\" style=\"zoom:30%;\" />\n\n# 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的\n\n字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一 个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。\n\n因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。\n\n如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址\n\n> 如果正在执行的是本地(Native)方法，这个计数器值则应为空。\n\n此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。\n\n# 虚拟机栈\n\n与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期\n\n虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。\n\n每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n**局部变量表**\n\n存放了编译期可知的各种Java虚拟机基本数据类型、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和`returnAddress `类型(指向了一条字节码指令的地址)。\n\n这些数据类型在局部变量表中的存储空间以局部变量槽(`Slot`)来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。\n\n局部变量表所需的内存空间在编 译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\n这里说的大小是指变量槽的数量， 虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特、64个比特，或者更多)来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。\n\n在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:\n\n> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;\n>\n> 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。\n\n**方法出口信息**\n\n当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。\n\n**动态连接**\n\n动态链接就是将符号引用所表示的方法，转换成方法的直接引用\n\n* 直接引用：当类已经加载到虚拟机时，通过地址直接调用该类\n\n* 符号引用（常量池中）：在编译的时候还不知道类是否被加载，先用符号代替该类，等实际运行时再用直接引用替换间接引用。\n\n# 本地方法栈\n\n本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native) 方法服务。\n\n有的Java虚拟机(譬如`HotSpot虚拟机`)直接 就把本地方法栈和虚拟机栈合二为一。\n\n与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。\n\n# 堆\n\n对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。\n\nJava堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。\n\n此内存区域的唯一目的就是存放对象实例，Java 世界里几乎所有的对象实例都在这里分配内存。\n\n如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (`Thread Local Allocation Buffer，TLAB`)，以提升对象分配时的效率。\n\n不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。\n\n根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。\n\n但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。\n\nJava堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的(通过参数`-Xmx`和`-Xms`设定)。\n\n如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。\n\n**基本组成**\n\n新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短，每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收\n\n新生代内又分三个区：一个Eden区，两个Survivor区，大部分对象在Eden区中生成，当Eden区满时（Minor  GC），还存活的对象将被复制到两个Survivor区中的一个，当这个Survivor区满时，此区的存活的对象将被复制到另外一个Survivor区\n\n老年代（Old Generation）：老年代的垃圾回收（又称Major GC），通常使用标记-清理或标记-整理算法\n\n整堆包括新生代和老年代的垃圾回收称为Full GC\n\n# 方法区\n\n方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作非堆(NonHeap)，目的是与Java堆区 分开来。\n\n在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为永久代(Permanent Generation)，或将两者混为一谈。\n\n到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta space)来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。\n\n这区域的内存回 收目标主要是针对**常量池的回收和对类型的卸载**，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。\n\n根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。\n\n**元数据区**\n\n元数据区：元数据区取代了永久代(1.8以前)，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存\n\n<img src=\"https://img-blog.csdnimg.cn/5618346d647f405ca73280c0ebf3aeb3.png\" style=\"zoom:25%;\" />\n\n元数据区也有可能发生OutOfMemory异常\n\n元数据区的动态扩展，默认`–XX:MetaspaceSize`值为21MB的高水位线，一旦触及则Full GC将被触发并卸载没有用的类，然后高水位线将会重置，新的高水位线的值取决于GC后释放的元空间，如果释放的空间少，这个高水位线则上升。\n\n如果释放空间过多，则高水位线下降\n\n# 运行时常量池\n\n运行时常量池是方法区的一部分。\n\nClass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种**字面量与符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\nJava虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行\n\n但对于运行时常量池《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。\n\nJava语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。\n\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。\n\n# 直接内存\n\n直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。\n\n但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。\n\n在JDK 1.4中新加入了`NIO(New Input/Output)`类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。\n\n这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n\n本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存大小以及处理器寻址空间的限制\n\n一般服务器管理员配置虚拟机参数时，会根据实际内存去设置`-Xmx`等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。","source":"_posts/深入理解JVM虚拟机/内存区域.md","raw":"---\ntitle: 内存区域\ncategories: \n- 深入理解JVM虚拟机\n---\n\n虚拟机所管理的内存将会包括以下几个运行时数据区域\n\n<img src=\"https://img-blog.csdnimg.cn/91025ef2cfcc4b9ca6ca770d333b4efb.png\" style=\"zoom:25%;\" />\n\n**举例子：**\n\n```java\npublic class JVMCase {\n\n\t// 常量\n\tpublic final static String MAN_SEX_TYPE = \"man\";\n\n\t// 静态变量\n\tpublic static String WOMAN_SEX_TYPE = \"woman\";\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tStudent stu = new Student();\n\t\tstu.setName(\"nick\");\n\t\tstu.setSexType(MAN_SEX_TYPE);\n\t\tstu.setAge(20);\n\t\t\n\t\tJVMCase jvmcase = new JVMCase();\n\t\t\n\t\t// 调用静态方法\n\t\tprint(stu);\n\t\t// 调用非静态方法\n\t\tjvmcase.sayHello(stu);\n\t}\n\n\n\t// 常规静态方法\n\tpublic static void print(Student stu) {\n\t\tSystem.out.println(\"name: \" + stu.getName() + \"; sex:\" + stu.getSexType() + \"; age:\" + stu.getAge()); \n\t}\n\n\n\t// 非静态方法\n\tpublic void sayHello(Student stu) {\n\t\tSystem.out.println(stu.getName() + \"say: hello\"); \n\t}\n}\n\nclass Student{\n\tString name;\n\tString sexType;\n\tint age;\n\t\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\t\n\tpublic String getSexType() {\n\t\treturn sexType;\n\t}\n\tpublic void setSexType(String sexType) {\n\t\tthis.sexType = sexType;\n\t}\n\tpublic int getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(int age) {\n\t\tthis.age = age;\n\t}\n}\n```\n\n创建一个JVMCase对象，调用sayHello非静态方法，sayHello方法属于对象JVMCase，此时sayHello方法入栈，并通过栈中的student引用调用堆中的Student对象；\n\n之后，调用静态方法print，print静态方法属于JVMCase类，是从静态方法中获取，之后放入到栈中，也是通过student引用调用堆中的student对象。\n\n<img src=\"https://img-blog.csdnimg.cn/c5263cdd5cd845b89a16a51c6b374d2c.png\" style=\"zoom:30%;\" />\n\n# 程序计数器\n\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的\n\n字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。\n\n由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一 个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。\n\n因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。\n\n如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址\n\n> 如果正在执行的是本地(Native)方法，这个计数器值则应为空。\n\n此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。\n\n# 虚拟机栈\n\n与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期\n\n虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。\n\n每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n\n**局部变量表**\n\n存放了编译期可知的各种Java虚拟机基本数据类型、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和`returnAddress `类型(指向了一条字节码指令的地址)。\n\n这些数据类型在局部变量表中的存储空间以局部变量槽(`Slot`)来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。\n\n局部变量表所需的内存空间在编 译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。\n\n这里说的大小是指变量槽的数量， 虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特、64个比特，或者更多)来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。\n\n在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:\n\n> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;\n>\n> 如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。\n\n**方法出口信息**\n\n当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。\n\n**动态连接**\n\n动态链接就是将符号引用所表示的方法，转换成方法的直接引用\n\n* 直接引用：当类已经加载到虚拟机时，通过地址直接调用该类\n\n* 符号引用（常量池中）：在编译的时候还不知道类是否被加载，先用符号代替该类，等实际运行时再用直接引用替换间接引用。\n\n# 本地方法栈\n\n本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native) 方法服务。\n\n有的Java虚拟机(譬如`HotSpot虚拟机`)直接 就把本地方法栈和虚拟机栈合二为一。\n\n与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。\n\n# 堆\n\n对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。\n\nJava堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。\n\n此内存区域的唯一目的就是存放对象实例，Java 世界里几乎所有的对象实例都在这里分配内存。\n\n如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (`Thread Local Allocation Buffer，TLAB`)，以提升对象分配时的效率。\n\n不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。\n\n根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。\n\n但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。\n\nJava堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的(通过参数`-Xmx`和`-Xms`设定)。\n\n如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。\n\n**基本组成**\n\n新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短，每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收\n\n新生代内又分三个区：一个Eden区，两个Survivor区，大部分对象在Eden区中生成，当Eden区满时（Minor  GC），还存活的对象将被复制到两个Survivor区中的一个，当这个Survivor区满时，此区的存活的对象将被复制到另外一个Survivor区\n\n老年代（Old Generation）：老年代的垃圾回收（又称Major GC），通常使用标记-清理或标记-整理算法\n\n整堆包括新生代和老年代的垃圾回收称为Full GC\n\n# 方法区\n\n方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。\n\n虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作非堆(NonHeap)，目的是与Java堆区 分开来。\n\n在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为永久代(Permanent Generation)，或将两者混为一谈。\n\n到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta space)来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。\n\n这区域的内存回 收目标主要是针对**常量池的回收和对类型的卸载**，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。\n\n根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。\n\n**元数据区**\n\n元数据区：元数据区取代了永久代(1.8以前)，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存\n\n<img src=\"https://img-blog.csdnimg.cn/5618346d647f405ca73280c0ebf3aeb3.png\" style=\"zoom:25%;\" />\n\n元数据区也有可能发生OutOfMemory异常\n\n元数据区的动态扩展，默认`–XX:MetaspaceSize`值为21MB的高水位线，一旦触及则Full GC将被触发并卸载没有用的类，然后高水位线将会重置，新的高水位线的值取决于GC后释放的元空间，如果释放的空间少，这个高水位线则上升。\n\n如果释放空间过多，则高水位线下降\n\n# 运行时常量池\n\n运行时常量池是方法区的一部分。\n\nClass文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种**字面量与符号引用**，这部分内容将在类加载后存放到方法区的运行时常量池中。\n\nJava虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行\n\n但对于运行时常量池《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。\n\nJava语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。\n\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。\n\n# 直接内存\n\n直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。\n\n但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。\n\n在JDK 1.4中新加入了`NIO(New Input/Output)`类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。\n\n这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。\n\n本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存大小以及处理器寻址空间的限制\n\n一般服务器管理员配置虚拟机参数时，会根据实际内存去设置`-Xmx`等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。","slug":"深入理解JVM虚拟机/内存区域","published":1,"date":"2021-12-20T14:54:39.149Z","updated":"2021-12-20T15:12:41.169Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkj00k1fhji6nxgamsh","content":"<p>虚拟机所管理的内存将会包括以下几个运行时数据区域</p>\n<img src=\"https://img-blog.csdnimg.cn/91025ef2cfcc4b9ca6ca770d333b4efb.png\" style=\"zoom:25%;\" />\n\n<p><strong>举例子：</strong></p>\n<pre><code class=\"java\">public class JVMCase &#123;\n\n    // 常量\n    public final static String MAN_SEX_TYPE = &quot;man&quot;;\n\n    // 静态变量\n    public static String WOMAN_SEX_TYPE = &quot;woman&quot;;\n\n    public static void main(String[] args) &#123;\n        \n        Student stu = new Student();\n        stu.setName(&quot;nick&quot;);\n        stu.setSexType(MAN_SEX_TYPE);\n        stu.setAge(20);\n        \n        JVMCase jvmcase = new JVMCase();\n        \n        // 调用静态方法\n        print(stu);\n        // 调用非静态方法\n        jvmcase.sayHello(stu);\n    &#125;\n\n\n    // 常规静态方法\n    public static void print(Student stu) &#123;\n        System.out.println(&quot;name: &quot; + stu.getName() + &quot;; sex:&quot; + stu.getSexType() + &quot;; age:&quot; + stu.getAge()); \n    &#125;\n\n\n    // 非静态方法\n    public void sayHello(Student stu) &#123;\n        System.out.println(stu.getName() + &quot;say: hello&quot;); \n    &#125;\n&#125;\n\nclass Student&#123;\n    String name;\n    String sexType;\n    int age;\n    \n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    \n    public String getSexType() &#123;\n        return sexType;\n    &#125;\n    public void setSexType(String sexType) &#123;\n        this.sexType = sexType;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n</code></pre>\n<p>创建一个JVMCase对象，调用sayHello非静态方法，sayHello方法属于对象JVMCase，此时sayHello方法入栈，并通过栈中的student引用调用堆中的Student对象；</p>\n<p>之后，调用静态方法print，print静态方法属于JVMCase类，是从静态方法中获取，之后放入到栈中，也是通过student引用调用堆中的student对象。</p>\n<img src=\"https://img-blog.csdnimg.cn/c5263cdd5cd845b89a16a51c6b374d2c.png\" style=\"zoom:30%;\" />\n\n<h1 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h1><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的</p>\n<p>字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\n<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一 个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。</p>\n<p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。</p>\n<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址</p>\n<blockquote>\n<p>如果正在执行的是本地(Native)方法，这个计数器值则应为空。</p>\n</blockquote>\n<p>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>\n<h1 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h1><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期</p>\n<p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>\n<p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong></p>\n<p>存放了编译期可知的各种Java虚拟机基本数据类型、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和<code>returnAddress </code>类型(指向了一条字节码指令的地址)。</p>\n<p>这些数据类型在局部变量表中的存储空间以局部变量槽(<code>Slot</code>)来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。</p>\n<p>局部变量表所需的内存空间在编 译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>\n<p>这里说的大小是指变量槽的数量， 虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特、64个比特，或者更多)来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p>\n<p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:</p>\n<blockquote>\n<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;</p>\n<p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>\n</blockquote>\n<p><strong>方法出口信息</strong></p>\n<p>当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。</p>\n<p><strong>动态连接</strong></p>\n<p>动态链接就是将符号引用所表示的方法，转换成方法的直接引用</p>\n<ul>\n<li><p>直接引用：当类已经加载到虚拟机时，通过地址直接调用该类</p>\n</li>\n<li><p>符号引用（常量池中）：在编译的时候还不知道类是否被加载，先用符号代替该类，等实际运行时再用直接引用替换间接引用。</p>\n</li>\n</ul>\n<h1 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h1><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native) 方法服务。</p>\n<p>有的Java虚拟机(譬如<code>HotSpot虚拟机</code>)直接 就把本地方法栈和虚拟机栈合二为一。</p>\n<p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。</p>\n<p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p>\n<p>此内存区域的唯一目的就是存放对象实例，Java 世界里几乎所有的对象实例都在这里分配内存。</p>\n<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (<code>Thread Local Allocation Buffer，TLAB</code>)，以提升对象分配时的效率。</p>\n<p>不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>\n<p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。</p>\n<p>但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p>\n<p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的(通过参数<code>-Xmx</code>和<code>-Xms</code>设定)。</p>\n<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>\n<p><strong>基本组成</strong></p>\n<p>新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短，每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收</p>\n<p>新生代内又分三个区：一个Eden区，两个Survivor区，大部分对象在Eden区中生成，当Eden区满时（Minor  GC），还存活的对象将被复制到两个Survivor区中的一个，当这个Survivor区满时，此区的存活的对象将被复制到另外一个Survivor区</p>\n<p>老年代（Old Generation）：老年代的垃圾回收（又称Major GC），通常使用标记-清理或标记-整理算法</p>\n<p>整堆包括新生代和老年代的垃圾回收称为Full GC</p>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>\n<p>虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作非堆(NonHeap)，目的是与Java堆区 分开来。</p>\n<p>在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为永久代(Permanent Generation)，或将两者混为一谈。</p>\n<p>到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta space)来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。</p>\n<p>这区域的内存回 收目标主要是针对<strong>常量池的回收和对类型的卸载</strong>，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。</p>\n<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。</p>\n<p><strong>元数据区</strong></p>\n<p>元数据区：元数据区取代了永久代(1.8以前)，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存</p>\n<img src=\"https://img-blog.csdnimg.cn/5618346d647f405ca73280c0ebf3aeb3.png\" style=\"zoom:25%;\" />\n\n<p>元数据区也有可能发生OutOfMemory异常</p>\n<p>元数据区的动态扩展，默认<code>–XX:MetaspaceSize</code>值为21MB的高水位线，一旦触及则Full GC将被触发并卸载没有用的类，然后高水位线将会重置，新的高水位线的值取决于GC后释放的元空间，如果释放的空间少，这个高水位线则上升。</p>\n<p>如果释放空间过多，则高水位线下降</p>\n<h1 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h1><p>运行时常量池是方法区的一部分。</p>\n<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种<strong>字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>\n<p>Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行</p>\n<p>但对于运行时常量池《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p>\n<p>Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>\n<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。</p>\n<h1 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h1><p>直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。</p>\n<p>但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>\n<p>在JDK 1.4中新加入了<code>NIO(New Input/Output)</code>类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。</p>\n<p>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>\n<p>本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存大小以及处理器寻址空间的限制</p>\n<p>一般服务器管理员配置虚拟机参数时，会根据实际内存去设置<code>-Xmx</code>等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>虚拟机所管理的内存将会包括以下几个运行时数据区域</p>\n<img src=\"https://img-blog.csdnimg.cn/91025ef2cfcc4b9ca6ca770d333b4efb.png\" style=\"zoom:25%;\" />\n\n<p><strong>举例子：</strong></p>\n<pre><code class=\"java\">public class JVMCase &#123;\n\n    // 常量\n    public final static String MAN_SEX_TYPE = &quot;man&quot;;\n\n    // 静态变量\n    public static String WOMAN_SEX_TYPE = &quot;woman&quot;;\n\n    public static void main(String[] args) &#123;\n        \n        Student stu = new Student();\n        stu.setName(&quot;nick&quot;);\n        stu.setSexType(MAN_SEX_TYPE);\n        stu.setAge(20);\n        \n        JVMCase jvmcase = new JVMCase();\n        \n        // 调用静态方法\n        print(stu);\n        // 调用非静态方法\n        jvmcase.sayHello(stu);\n    &#125;\n\n\n    // 常规静态方法\n    public static void print(Student stu) &#123;\n        System.out.println(&quot;name: &quot; + stu.getName() + &quot;; sex:&quot; + stu.getSexType() + &quot;; age:&quot; + stu.getAge()); \n    &#125;\n\n\n    // 非静态方法\n    public void sayHello(Student stu) &#123;\n        System.out.println(stu.getName() + &quot;say: hello&quot;); \n    &#125;\n&#125;\n\nclass Student&#123;\n    String name;\n    String sexType;\n    int age;\n    \n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    \n    public String getSexType() &#123;\n        return sexType;\n    &#125;\n    public void setSexType(String sexType) &#123;\n        this.sexType = sexType;\n    &#125;\n    public int getAge() &#123;\n        return age;\n    &#125;\n    public void setAge(int age) &#123;\n        this.age = age;\n    &#125;\n&#125;\n</code></pre>\n<p>创建一个JVMCase对象，调用sayHello非静态方法，sayHello方法属于对象JVMCase，此时sayHello方法入栈，并通过栈中的student引用调用堆中的Student对象；</p>\n<p>之后，调用静态方法print，print静态方法属于JVMCase类，是从静态方法中获取，之后放入到栈中，也是通过student引用调用堆中的student对象。</p>\n<img src=\"https://img-blog.csdnimg.cn/c5263cdd5cd845b89a16a51c6b374d2c.png\" style=\"zoom:30%;\" />\n\n<h1 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h1><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的</p>\n<p>字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p>\n<p>由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一 个确定的时刻，一个处理器(对于多核处理器来说是一个内核)都只会执行一条线程中的指令。</p>\n<p>因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为线程私有的内存。</p>\n<p>如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址</p>\n<blockquote>\n<p>如果正在执行的是本地(Native)方法，这个计数器值则应为空。</p>\n</blockquote>\n<p>此内存区域是唯 一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。</p>\n<h1 id=\"虚拟机栈\"><a href=\"#虚拟机栈\" class=\"headerlink\" title=\"虚拟机栈\"></a>虚拟机栈</h1><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期</p>\n<p>虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都会同步创建一个栈帧用于存储局部变量表、操作数栈、动态连接、方法出口等信息。</p>\n<p>每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>\n<p><strong>局部变量表</strong></p>\n<p>存放了编译期可知的各种Java虚拟机基本数据类型、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置)和<code>returnAddress </code>类型(指向了一条字节码指令的地址)。</p>\n<p>这些数据类型在局部变量表中的存储空间以局部变量槽(<code>Slot</code>)来表示，其中64位长度的long和 double类型的数据会占用两个变量槽，其余的数据类型只占用一个。</p>\n<p>局部变量表所需的内存空间在编 译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p>\n<p>这里说的大小是指变量槽的数量， 虚拟机真正使用多大的内存空间(譬如按照1个变量槽占用32个比特、64个比特，或者更多)来实现一 个变量槽，这是完全由具体的虚拟机实现自行决定的事情。</p>\n<p>在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况:</p>\n<blockquote>\n<p>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常;</p>\n<p>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出OutOfMemoryError异常。</p>\n</blockquote>\n<p><strong>方法出口信息</strong></p>\n<p>当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。</p>\n<p><strong>动态连接</strong></p>\n<p>动态链接就是将符号引用所表示的方法，转换成方法的直接引用</p>\n<ul>\n<li><p>直接引用：当类已经加载到虚拟机时，通过地址直接调用该类</p>\n</li>\n<li><p>符号引用（常量池中）：在编译的时候还不知道类是否被加载，先用符号代替该类，等实际运行时再用直接引用替换间接引用。</p>\n</li>\n</ul>\n<h1 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h1><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则是为虚拟机使用到的本地(Native) 方法服务。</p>\n<p>有的Java虚拟机(譬如<code>HotSpot虚拟机</code>)直接 就把本地方法栈和虚拟机栈合二为一。</p>\n<p>与虚拟机栈一样，本地方法栈也会在栈深度溢出或者栈扩展失败时分别抛出StackOverflowError和OutOfMemoryError异常。</p>\n<h1 id=\"堆\"><a href=\"#堆\" class=\"headerlink\" title=\"堆\"></a>堆</h1><p>对于Java应用程序来说，Java堆是虚拟机所管理的内存中最大的一块。</p>\n<p>Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。</p>\n<p>此内存区域的唯一目的就是存放对象实例，Java 世界里几乎所有的对象实例都在这里分配内存。</p>\n<p>如果从分配内存的角度看，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区 (<code>Thread Local Allocation Buffer，TLAB</code>)，以提升对象分配时的效率。</p>\n<p>不过无论从什么角度，无论如何划分，都不会改变Java堆中存储内容的共性，无论是哪个区域，存储的都只能是对象的实例，将Java 堆细分的目的只是为了更好地回收内存，或者更快地分配内存。</p>\n<p>根据《Java虚拟机规范》的规定，Java堆可以处于物理上不连续的内存空间中，但在逻辑上它应该 被视为连续的，这点就像我们用磁盘空间去存储文件一样，并不要求每个文件都连续存放。</p>\n<p>但对于大对象(典型的如数组对象)，多数虚拟机实现出于实现简单、存储高效的考虑，很可能会要求连续的内存空间。</p>\n<p>Java堆既可以被实现成固定大小的，也可以是可扩展的，不过当前主流的Java虚拟机都是按照可扩 展来实现的(通过参数<code>-Xmx</code>和<code>-Xms</code>设定)。</p>\n<p>如果在Java堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java虚拟机将会抛出OutOfMemoryError异常。</p>\n<p><strong>基本组成</strong></p>\n<p>新生代（Young Generation）：大多数对象在新生代中被创建，其中很多对象的生命周期很短，每次新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收</p>\n<p>新生代内又分三个区：一个Eden区，两个Survivor区，大部分对象在Eden区中生成，当Eden区满时（Minor  GC），还存活的对象将被复制到两个Survivor区中的一个，当这个Survivor区满时，此区的存活的对象将被复制到另外一个Survivor区</p>\n<p>老年代（Old Generation）：老年代的垃圾回收（又称Major GC），通常使用标记-清理或标记-整理算法</p>\n<p>整堆包括新生代和老年代的垃圾回收称为Full GC</p>\n<h1 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h1><p>方法区与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p>\n<p>虽然《Java虚拟机规范》中把 方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作非堆(NonHeap)，目的是与Java堆区 分开来。</p>\n<p>在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为永久代(Permanent Generation)，或将两者混为一谈。</p>\n<p>到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间(Meta space)来代替，把JDK 7中永久代还剩余的内容(主要是类型信息)全部移到元空间中。</p>\n<p>这区域的内存回 收目标主要是针对<strong>常量池的回收和对类型的卸载</strong>，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。</p>\n<p>根据《Java虚拟机规范》的规定，如果方法区无法满足新的内存分配需求时，将抛出 OutOfMemoryError异常。</p>\n<p><strong>元数据区</strong></p>\n<p>元数据区：元数据区取代了永久代(1.8以前)，本质和永久代类似，都是对JVM规范中方法区的实现，区别在于元数据区并不在虚拟机中，而是使用本地物理内存</p>\n<img src=\"https://img-blog.csdnimg.cn/5618346d647f405ca73280c0ebf3aeb3.png\" style=\"zoom:25%;\" />\n\n<p>元数据区也有可能发生OutOfMemory异常</p>\n<p>元数据区的动态扩展，默认<code>–XX:MetaspaceSize</code>值为21MB的高水位线，一旦触及则Full GC将被触发并卸载没有用的类，然后高水位线将会重置，新的高水位线的值取决于GC后释放的元空间，如果释放的空间少，这个高水位线则上升。</p>\n<p>如果释放空间过多，则高水位线下降</p>\n<h1 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h1><p>运行时常量池是方法区的一部分。</p>\n<p>Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种<strong>字面量与符号引用</strong>，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>\n<p>Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行</p>\n<p>但对于运行时常量池《Java虚拟机规范》并没有做任何细节的要求，不同提供商实现的虚拟机可以按照自己的需要来实现这个内存区域，不过一般来说，除了保存Class文件中描述的符号引用外，还会把由符号引用翻译出来的直接引用也存储在运行时常量池中。</p>\n<p>Java语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常 量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern()方法。</p>\n<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存 时会抛出OutOfMemoryError异常。</p>\n<h1 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h1><p>直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中 定义的内存区域。</p>\n<p>但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>\n<p>在JDK 1.4中新加入了<code>NIO(New Input/Output)</code>类，引入了一种基于通道(Channel)与缓冲区 (Buffer)的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。</p>\n<p>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</p>\n<p>本机直接内存的分配不会受到Java堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存大小以及处理器寻址空间的限制</p>\n<p>一般服务器管理员配置虚拟机参数时，会根据实际内存去设置<code>-Xmx</code>等参数信息，但经常忽略掉直接内存，使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而导致动态扩展时出现 OutOfMemoryError异常。</p>\n"},{"title":"内存回收","_content":"\n**引用计数算法**\n\n给对象中添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；\n\n当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n\n主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间相互循环引用的问题。\n\n举个简单的例子，对象objA和objB都有字段instance，赋值令`objA.instance=objB`及`objB.instance=objA`，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是他们因为互相引用着对方，导致他们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收他们。\n\n```java\npublic class ReferenceCountingGC {\n \n    public Object instance = null;\n \n    private static final int _1MB = 1024 * 1024;\n \n    /**\n     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过\n     */\n    private byte[] bigSize = new byte[2 * _1MB];\n \n    public static void testGC() {\n        ReferenceCountingGC objA = new ReferenceCountingGC();\n        ReferenceCountingGC objB = new ReferenceCountingGC();\n        objA.instance = objB;\n        objB.instance = objA;\n \n        objA = null;\n        objB = null;\n \n        // 假设在这行发生GC，objA和objB是否能被回收？\n        System.gc();\n    }\n}\n```\n\n从运行结果中可以看到，虚拟机并没有因为这两个对象互相引用就不回收他们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。\n\n**可达性分析算法**\n\n通过 一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。\n\n如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的， 因此它们将会被判定为可回收的对象。\n\n<img src=\"https://img-blog.csdnimg.cn/b0b5dc6b32394501a218007c2b0ba9b9.png\" style=\"zoom:25%;\" />\n\n**可作为GC Roots的对象包括以下几种:**\n\n* 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\n\n* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 \n* 在方法区中常量引用的对象，譬如字符串常量池(`String Table`)里的引用。\n\n* 在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 \n* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。 \n* 所有被同步锁(`synchronized`关键字)持有的对象。 \n* 反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。\n\n除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。\n\n# 四大引用\n\n引用分为强引用(Strongly Reference)、软 引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。\n\n**强引用**是最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似`Object obj=new Object()`这种引用关系。\n\n无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。\n\n**软引用**是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。\n\n在JDK 1.2版之后提供了SoftReference类来实现软引用。\n\n**弱引用**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。\n\n当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。\n\n在JDK 1.2版之后提供了WeakReference类来实现弱引用。\n\n**虚引用**，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。\n\n为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。\n\n在JDK 1.2版之后提供 了Phant omReference类来实现虚引用。\n\n如果一个对象仅持有虚引用，那么它和没有任何引用一样，调用get()方法总返回null，在任何时候都可能被垃圾回收器回收，虚引用必须和引用队列(ReferenceQueue)联合使用。\n\n> 虚引用的唯一目的就是：当该对象被垃圾收集器回收的时候收到一个系统通知或者后续添加进一步处理，它的作用在于跟踪垃圾回收过程。\n\n具体流程：\n\n创建引用时候可以指定关联的队列，当GC释放对象的时候会将引用的对象添加到引用队列中，如果程序发现某个虚引用对象已经被加入到引用队列中，那么就可以在引用对象的内存回收之前采取必要的措施，这就相当于一种通知机制。\n\n# 如何回收\n\n即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候它们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n* 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。\n\n* 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。\n\n* 如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象将会放置在一个叫做`F-Queue`的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的`Finalizer`线程去执行它。\n\n这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致`F-Queue`队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。\n\nfinalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对`F-Queue`中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己\n\n只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出即将回收的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。\n\n任何一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。\n\n# 回收方法区\n\n方法区的垃圾收集主要回收两部分内容:**废弃的常量和不再使用的类型**。\n\n回收废弃常量与回收 Java堆中的对象非常类似。\n\n**举个常量池中字面量回收的例子**\n\n假如一个字符串 java曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是java，换句话说，已经没有任何字符串对象引用 常量池中的`java`常量，且虚拟机中也没有其他地方引用这个字面量。\n\n如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个java常量就将会被系统清理出常量池。\n\n常量池中其他类(接口)、方法、字段的符号引用也与此类似。\n\n判定一个常量是否废弃还是相对简单，而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了。\n\n**需要同时满足下面三个条件:**\n\n* 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 \n\n* 加载该类的类加载器已经被回收。 \n\n* 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\nJava虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是 和对象一样，没有引用了就必然会回收。\n\n关于是否要对类型进行回收，HotSpot虚拟机提供了`- Xnoclassgc`参数进行控制，还可以使用`-verbose:class`以及`-XX:+TraceClass-Loading`、`-XX: +TraceClassUnLoading`查看类加载和卸载信息\n\n在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。\n\n# 内存分配\n\n使用HotSpot虚拟机，以客户端模式运行。\n\n使用Serial加Serial Old客户端默认收集器组合下的内存分配和回收的策略\n\n**对象优先在Eden分配** \n\n大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。\n\n**大对象直接进入老年代**\n\n大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者 元素数量很庞大的数组\n\nHotSpot虚拟机提供了`-XX:PretenureSizeThreshold `参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区 之间来回复制，产生大量的内存复制操作。\n\n**长期存活的对象将进入老年代**\n\n虚拟机给每个对象定义了一个对 象年龄(Age)计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。\n\n对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。\n\n对象晋升老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`设置。\n\n**动态对象年龄判定**\n\nHotSpot虚拟机并不是永远要求对象的年龄必须达到`-XX:M axTenuringThreshold`才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到`-XX:\n M axTenuringThreshold`中要求的年龄。\n\n**空间分配担保**\n\n在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。\n\n如果不成立，则虚拟机会先查看`-XX:HandlePromotionFailure`参数的设置值是否允许担保失败(Handle Promotion Failure)\n\n如果允 许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的;\n\n如果小于，或者`-XX: HandlePromotionFailure`设置不允许冒险，那这时就要改为进行一次Full GC。\n\n在JDK 6 Update 24之后，`-XX:HandlePromotionFailure`参数不会再影响到虚拟机的空间分配担保策略。\n\n**JDK 6 Update 24**之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。","source":"_posts/深入理解JVM虚拟机/内存回收.md","raw":"---\ntitle: 内存回收\ncategories: \n- 深入理解JVM虚拟机\n---\n\n**引用计数算法**\n\n给对象中添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；\n\n当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。\n\n主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间相互循环引用的问题。\n\n举个简单的例子，对象objA和objB都有字段instance，赋值令`objA.instance=objB`及`objB.instance=objA`，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是他们因为互相引用着对方，导致他们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收他们。\n\n```java\npublic class ReferenceCountingGC {\n \n    public Object instance = null;\n \n    private static final int _1MB = 1024 * 1024;\n \n    /**\n     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过\n     */\n    private byte[] bigSize = new byte[2 * _1MB];\n \n    public static void testGC() {\n        ReferenceCountingGC objA = new ReferenceCountingGC();\n        ReferenceCountingGC objB = new ReferenceCountingGC();\n        objA.instance = objB;\n        objB.instance = objA;\n \n        objA = null;\n        objB = null;\n \n        // 假设在这行发生GC，objA和objB是否能被回收？\n        System.gc();\n    }\n}\n```\n\n从运行结果中可以看到，虚拟机并没有因为这两个对象互相引用就不回收他们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。\n\n**可达性分析算法**\n\n通过 一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。\n\n如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的， 因此它们将会被判定为可回收的对象。\n\n<img src=\"https://img-blog.csdnimg.cn/b0b5dc6b32394501a218007c2b0ba9b9.png\" style=\"zoom:25%;\" />\n\n**可作为GC Roots的对象包括以下几种:**\n\n* 在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。\n\n* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 \n* 在方法区中常量引用的对象，譬如字符串常量池(`String Table`)里的引用。\n\n* 在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 \n* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。 \n* 所有被同步锁(`synchronized`关键字)持有的对象。 \n* 反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。\n\n除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。\n\n# 四大引用\n\n引用分为强引用(Strongly Reference)、软 引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。\n\n**强引用**是最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似`Object obj=new Object()`这种引用关系。\n\n无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。\n\n**软引用**是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。\n\n在JDK 1.2版之后提供了SoftReference类来实现软引用。\n\n**弱引用**也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。\n\n当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。\n\n在JDK 1.2版之后提供了WeakReference类来实现弱引用。\n\n**虚引用**，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。\n\n为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。\n\n在JDK 1.2版之后提供 了Phant omReference类来实现虚引用。\n\n如果一个对象仅持有虚引用，那么它和没有任何引用一样，调用get()方法总返回null，在任何时候都可能被垃圾回收器回收，虚引用必须和引用队列(ReferenceQueue)联合使用。\n\n> 虚引用的唯一目的就是：当该对象被垃圾收集器回收的时候收到一个系统通知或者后续添加进一步处理，它的作用在于跟踪垃圾回收过程。\n\n具体流程：\n\n创建引用时候可以指定关联的队列，当GC释放对象的时候会将引用的对象添加到引用队列中，如果程序发现某个虚引用对象已经被加入到引用队列中，那么就可以在引用对象的内存回收之前采取必要的措施，这就相当于一种通知机制。\n\n# 如何回收\n\n即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候它们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：\n\n* 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行`finalize()`方法。\n\n* 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。\n\n* 如果这个对象被判定为有必要执行`finalize()`方法，那么这个对象将会放置在一个叫做`F-Queue`的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的`Finalizer`线程去执行它。\n\n这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致`F-Queue`队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。\n\nfinalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对`F-Queue`中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己\n\n只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出即将回收的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。\n\n任何一个对象的`finalize()`方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。\n\n# 回收方法区\n\n方法区的垃圾收集主要回收两部分内容:**废弃的常量和不再使用的类型**。\n\n回收废弃常量与回收 Java堆中的对象非常类似。\n\n**举个常量池中字面量回收的例子**\n\n假如一个字符串 java曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是java，换句话说，已经没有任何字符串对象引用 常量池中的`java`常量，且虚拟机中也没有其他地方引用这个字面量。\n\n如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个java常量就将会被系统清理出常量池。\n\n常量池中其他类(接口)、方法、字段的符号引用也与此类似。\n\n判定一个常量是否废弃还是相对简单，而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了。\n\n**需要同时满足下面三个条件:**\n\n* 该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 \n\n* 加载该类的类加载器已经被回收。 \n\n* 该类对应的`java.lang.Class`对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。\n\nJava虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是 和对象一样，没有引用了就必然会回收。\n\n关于是否要对类型进行回收，HotSpot虚拟机提供了`- Xnoclassgc`参数进行控制，还可以使用`-verbose:class`以及`-XX:+TraceClass-Loading`、`-XX: +TraceClassUnLoading`查看类加载和卸载信息\n\n在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。\n\n# 内存分配\n\n使用HotSpot虚拟机，以客户端模式运行。\n\n使用Serial加Serial Old客户端默认收集器组合下的内存分配和回收的策略\n\n**对象优先在Eden分配** \n\n大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。\n\n**大对象直接进入老年代**\n\n大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者 元素数量很庞大的数组\n\nHotSpot虚拟机提供了`-XX:PretenureSizeThreshold `参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区 之间来回复制，产生大量的内存复制操作。\n\n**长期存活的对象将进入老年代**\n\n虚拟机给每个对象定义了一个对 象年龄(Age)计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。\n\n对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。\n\n对象晋升老年代的年龄阈值，可以通过参数`-XX:MaxTenuringThreshold`设置。\n\n**动态对象年龄判定**\n\nHotSpot虚拟机并不是永远要求对象的年龄必须达到`-XX:M axTenuringThreshold`才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到`-XX:\n M axTenuringThreshold`中要求的年龄。\n\n**空间分配担保**\n\n在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。\n\n如果不成立，则虚拟机会先查看`-XX:HandlePromotionFailure`参数的设置值是否允许担保失败(Handle Promotion Failure)\n\n如果允 许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的;\n\n如果小于，或者`-XX: HandlePromotionFailure`设置不允许冒险，那这时就要改为进行一次Full GC。\n\n在JDK 6 Update 24之后，`-XX:HandlePromotionFailure`参数不会再影响到虚拟机的空间分配担保策略。\n\n**JDK 6 Update 24**之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。","slug":"深入理解JVM虚拟机/内存回收","published":1,"date":"2021-12-20T16:37:32.661Z","updated":"2021-12-26T06:47:20.079Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkj00k2fhjigrardzdx","content":"<p><strong>引用计数算法</strong></p>\n<p>给对象中添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；</p>\n<p>当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>\n<p>主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间相互循环引用的问题。</p>\n<p>举个简单的例子，对象objA和objB都有字段instance，赋值令<code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是他们因为互相引用着对方，导致他们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收他们。</p>\n<pre><code class=\"java\">public class ReferenceCountingGC &#123;\n \n    public Object instance = null;\n \n    private static final int _1MB = 1024 * 1024;\n \n    /**\n     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过\n     */\n    private byte[] bigSize = new byte[2 * _1MB];\n \n    public static void testGC() &#123;\n        ReferenceCountingGC objA = new ReferenceCountingGC();\n        ReferenceCountingGC objB = new ReferenceCountingGC();\n        objA.instance = objB;\n        objB.instance = objA;\n \n        objA = null;\n        objB = null;\n \n        // 假设在这行发生GC，objA和objB是否能被回收？\n        System.gc();\n    &#125;\n&#125;\n</code></pre>\n<p>从运行结果中可以看到，虚拟机并没有因为这两个对象互相引用就不回收他们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>\n<p><strong>可达性分析算法</strong></p>\n<p>通过 一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>\n<p>如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的， 因此它们将会被判定为可回收的对象。</p>\n<img src=\"https://img-blog.csdnimg.cn/b0b5dc6b32394501a218007c2b0ba9b9.png\" style=\"zoom:25%;\" />\n\n<p><strong>可作为GC Roots的对象包括以下几种:</strong></p>\n<ul>\n<li><p>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p>\n</li>\n<li><p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 </p>\n</li>\n<li><p>在方法区中常量引用的对象，譬如字符串常量池(<code>String Table</code>)里的引用。</p>\n</li>\n<li><p>在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 </p>\n</li>\n<li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。 </p>\n</li>\n<li><p>所有被同步锁(<code>synchronized</code>关键字)持有的对象。 </p>\n</li>\n<li><p>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</p>\n</li>\n</ul>\n<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。</p>\n<h1 id=\"四大引用\"><a href=\"#四大引用\" class=\"headerlink\" title=\"四大引用\"></a>四大引用</h1><p>引用分为强引用(Strongly Reference)、软 引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。</p>\n<p><strong>强引用</strong>是最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似<code>Object obj=new Object()</code>这种引用关系。</p>\n<p>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>\n<p><strong>软引用</strong>是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</p>\n<p>在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>\n<p><strong>弱引用</strong>也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。</p>\n<p>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>\n<p>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>\n<p><strong>虚引用</strong>，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>\n<p>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p>\n<p>在JDK 1.2版之后提供 了Phant omReference类来实现虚引用。</p>\n<p>如果一个对象仅持有虚引用，那么它和没有任何引用一样，调用get()方法总返回null，在任何时候都可能被垃圾回收器回收，虚引用必须和引用队列(ReferenceQueue)联合使用。</p>\n<blockquote>\n<p>虚引用的唯一目的就是：当该对象被垃圾收集器回收的时候收到一个系统通知或者后续添加进一步处理，它的作用在于跟踪垃圾回收过程。</p>\n</blockquote>\n<p>具体流程：</p>\n<p>创建引用时候可以指定关联的队列，当GC释放对象的时候会将引用的对象添加到引用队列中，如果程序发现某个虚引用对象已经被加入到引用队列中，那么就可以在引用对象的内存回收之前采取必要的措施，这就相当于一种通知机制。</p>\n<h1 id=\"如何回收\"><a href=\"#如何回收\" class=\"headerlink\" title=\"如何回收\"></a>如何回收</h1><p>即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候它们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ul>\n<li><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。</p>\n</li>\n<li><p>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。</p>\n</li>\n<li><p>如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会放置在一个叫做<code>F-Queue</code>的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行它。</p>\n</li>\n</ul>\n<p>这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致<code>F-Queue</code>队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。</p>\n<p>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己</p>\n<p>只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出即将回收的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>\n<p>任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>\n<h1 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h1><p>方法区的垃圾收集主要回收两部分内容:<strong>废弃的常量和不再使用的类型</strong>。</p>\n<p>回收废弃常量与回收 Java堆中的对象非常类似。</p>\n<p><strong>举个常量池中字面量回收的例子</strong></p>\n<p>假如一个字符串 java曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是java，换句话说，已经没有任何字符串对象引用 常量池中的<code>java</code>常量，且虚拟机中也没有其他地方引用这个字面量。</p>\n<p>如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个java常量就将会被系统清理出常量池。</p>\n<p>常量池中其他类(接口)、方法、字段的符号引用也与此类似。</p>\n<p>判定一个常量是否废弃还是相对简单，而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了。</p>\n<p><strong>需要同时满足下面三个条件:</strong></p>\n<ul>\n<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </p>\n</li>\n<li><p>加载该类的类加载器已经被回收。 </p>\n</li>\n<li><p>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</li>\n</ul>\n<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是 和对象一样，没有引用了就必然会回收。</p>\n<p>关于是否要对类型进行回收，HotSpot虚拟机提供了<code>- Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX:+TraceClass-Loading</code>、<code>-XX: +TraceClassUnLoading</code>查看类加载和卸载信息</p>\n<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。</p>\n<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><p>使用HotSpot虚拟机，以客户端模式运行。</p>\n<p>使用Serial加Serial Old客户端默认收集器组合下的内存分配和回收的策略</p>\n<p><strong>对象优先在Eden分配</strong> </p>\n<p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>\n<p><strong>大对象直接进入老年代</strong></p>\n<p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者 元素数量很庞大的数组</p>\n<p>HotSpot虚拟机提供了<code>-XX:PretenureSizeThreshold </code>参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区 之间来回复制，产生大量的内存复制操作。</p>\n<p><strong>长期存活的对象将进入老年代</strong></p>\n<p>虚拟机给每个对象定义了一个对 象年龄(Age)计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。</p>\n<p>对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。</p>\n<p>对象晋升老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p>\n<p><strong>动态对象年龄判定</strong></p>\n<p>HotSpot虚拟机并不是永远要求对象的年龄必须达到<code>-XX:M axTenuringThreshold</code>才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<code>-XX:  M axTenuringThreshold</code>中要求的年龄。</p>\n<p><strong>空间分配担保</strong></p>\n<p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。</p>\n<p>如果不成立，则虚拟机会先查看<code>-XX:HandlePromotionFailure</code>参数的设置值是否允许担保失败(Handle Promotion Failure)</p>\n<p>如果允 许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的;</p>\n<p>如果小于，或者<code>-XX: HandlePromotionFailure</code>设置不允许冒险，那这时就要改为进行一次Full GC。</p>\n<p>在JDK 6 Update 24之后，<code>-XX:HandlePromotionFailure</code>参数不会再影响到虚拟机的空间分配担保策略。</p>\n<p><strong>JDK 6 Update 24</strong>之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。</p>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>引用计数算法</strong></p>\n<p>给对象中添加一个引用计数器，每当有一个地方引用他时，计数器值就加1；</p>\n<p>当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>\n<p>主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是他很难解决对象之间相互循环引用的问题。</p>\n<p>举个简单的例子，对象objA和objB都有字段instance，赋值令<code>objA.instance=objB</code>及<code>objB.instance=objA</code>，除此之外，这两个对象再无任何引用，实际上这两个对象已经不可能再被访问，但是他们因为互相引用着对方，导致他们的引用计数都不为0，于是引用计数算法无法通知GC收集器回收他们。</p>\n<pre><code class=\"java\">public class ReferenceCountingGC &#123;\n \n    public Object instance = null;\n \n    private static final int _1MB = 1024 * 1024;\n \n    /**\n     * 这个成员属性的唯一意义就是占点内存，以便在能在GC日志中看清楚是否有回收过\n     */\n    private byte[] bigSize = new byte[2 * _1MB];\n \n    public static void testGC() &#123;\n        ReferenceCountingGC objA = new ReferenceCountingGC();\n        ReferenceCountingGC objB = new ReferenceCountingGC();\n        objA.instance = objB;\n        objB.instance = objA;\n \n        objA = null;\n        objB = null;\n \n        // 假设在这行发生GC，objA和objB是否能被回收？\n        System.gc();\n    &#125;\n&#125;\n</code></pre>\n<p>从运行结果中可以看到，虚拟机并没有因为这两个对象互相引用就不回收他们，这也从侧面说明虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>\n<p><strong>可达性分析算法</strong></p>\n<p>通过 一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为引用链(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连， 或者用图论的话来说就是从GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。</p>\n<p>如图所示，对象object 5、object 6、object 7虽然互有关联，但是它们到GC Roots是不可达的， 因此它们将会被判定为可回收的对象。</p>\n<img src=\"https://img-blog.csdnimg.cn/b0b5dc6b32394501a218007c2b0ba9b9.png\" style=\"zoom:25%;\" />\n\n<p><strong>可作为GC Roots的对象包括以下几种:</strong></p>\n<ul>\n<li><p>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</p>\n</li>\n<li><p>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。 </p>\n</li>\n<li><p>在方法区中常量引用的对象，譬如字符串常量池(<code>String Table</code>)里的引用。</p>\n</li>\n<li><p>在本地方法栈中JNI(即通常所说的Native方法)引用的对象。 </p>\n</li>\n<li><p>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、OutOfMemoryError)等，还有系统类加载器。 </p>\n</li>\n<li><p>所有被同步锁(<code>synchronized</code>关键字)持有的对象。 </p>\n</li>\n<li><p>反映Java虚拟机内部情况的JM XBean、JVM TI中注册的回调、本地代码缓存等。</p>\n</li>\n</ul>\n<p>除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整GC Roots集合。</p>\n<h1 id=\"四大引用\"><a href=\"#四大引用\" class=\"headerlink\" title=\"四大引用\"></a>四大引用</h1><p>引用分为强引用(Strongly Reference)、软 引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)4种，这4种引用强 度依次逐渐减弱。</p>\n<p><strong>强引用</strong>是最传统的引用的定义，是指在程序代码之中普遍存在的引用赋值，即类似<code>Object obj=new Object()</code>这种引用关系。</p>\n<p>无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</p>\n<p><strong>软引用</strong>是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存， 才会抛出内存溢出异常。</p>\n<p>在JDK 1.2版之后提供了SoftReference类来实现软引用。</p>\n<p><strong>弱引用</strong>也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只 能生存到下一次垃圾收集发生为止。</p>\n<p>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p>\n<p>在JDK 1.2版之后提供了WeakReference类来实现弱引用。</p>\n<p><strong>虚引用</strong>，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。</p>\n<p>为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。</p>\n<p>在JDK 1.2版之后提供 了Phant omReference类来实现虚引用。</p>\n<p>如果一个对象仅持有虚引用，那么它和没有任何引用一样，调用get()方法总返回null，在任何时候都可能被垃圾回收器回收，虚引用必须和引用队列(ReferenceQueue)联合使用。</p>\n<blockquote>\n<p>虚引用的唯一目的就是：当该对象被垃圾收集器回收的时候收到一个系统通知或者后续添加进一步处理，它的作用在于跟踪垃圾回收过程。</p>\n</blockquote>\n<p>具体流程：</p>\n<p>创建引用时候可以指定关联的队列，当GC释放对象的时候会将引用的对象添加到引用队列中，如果程序发现某个虚引用对象已经被加入到引用队列中，那么就可以在引用对象的内存回收之前采取必要的措施，这就相当于一种通知机制。</p>\n<h1 id=\"如何回收\"><a href=\"#如何回收\" class=\"headerlink\" title=\"如何回收\"></a>如何回收</h1><p>即使在可达性分析算法中不可达的对象，也并非是非死不可的，这时候它们暂时处于缓刑阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：</p>\n<ul>\n<li><p>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。</p>\n</li>\n<li><p>当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行。</p>\n</li>\n<li><p>如果这个对象被判定为有必要执行<code>finalize()</code>方法，那么这个对象将会放置在一个叫做<code>F-Queue</code>的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的<code>Finalizer</code>线程去执行它。</p>\n</li>\n</ul>\n<p>这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致<code>F-Queue</code>队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。</p>\n<p>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对<code>F-Queue</code>中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己</p>\n<p>只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出即将回收的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>\n<p>任何一个对象的<code>finalize()</code>方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize()方法不会被再次执行，因此第二段代码的自救行动失败了。</p>\n<h1 id=\"回收方法区\"><a href=\"#回收方法区\" class=\"headerlink\" title=\"回收方法区\"></a>回收方法区</h1><p>方法区的垃圾收集主要回收两部分内容:<strong>废弃的常量和不再使用的类型</strong>。</p>\n<p>回收废弃常量与回收 Java堆中的对象非常类似。</p>\n<p><strong>举个常量池中字面量回收的例子</strong></p>\n<p>假如一个字符串 java曾经进入常量池 中，但是当前系统又没有任何一个字符串对象的值是java，换句话说，已经没有任何字符串对象引用 常量池中的<code>java</code>常量，且虚拟机中也没有其他地方引用这个字面量。</p>\n<p>如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个java常量就将会被系统清理出常量池。</p>\n<p>常量池中其他类(接口)、方法、字段的符号引用也与此类似。</p>\n<p>判定一个常量是否废弃还是相对简单，而要判定一个类型是否属于不再被使用的类的条件就比较苛刻了。</p>\n<p><strong>需要同时满足下面三个条件:</strong></p>\n<ul>\n<li><p>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。 </p>\n</li>\n<li><p>加载该类的类加载器已经被回收。 </p>\n</li>\n<li><p>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</p>\n</li>\n</ul>\n<p>Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是被允许，而并不是 和对象一样，没有引用了就必然会回收。</p>\n<p>关于是否要对类型进行回收，HotSpot虚拟机提供了<code>- Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX:+TraceClass-Loading</code>、<code>-XX: +TraceClassUnLoading</code>查看类加载和卸载信息</p>\n<p>在大量使用反射、动态代理、CGLib等字节码框架，动态生成JSP以及OSGi这类频繁自定义类加载器的场景中，通常都需要Java虚拟机具备类型卸载的能力，以保证不会对方法区造成过大的内存压 力。</p>\n<h1 id=\"内存分配\"><a href=\"#内存分配\" class=\"headerlink\" title=\"内存分配\"></a>内存分配</h1><p>使用HotSpot虚拟机，以客户端模式运行。</p>\n<p>使用Serial加Serial Old客户端默认收集器组合下的内存分配和回收的策略</p>\n<p><strong>对象优先在Eden分配</strong> </p>\n<p>大多数情况下，对象在新生代Eden区中分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>\n<p><strong>大对象直接进入老年代</strong></p>\n<p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者 元素数量很庞大的数组</p>\n<p>HotSpot虚拟机提供了<code>-XX:PretenureSizeThreshold </code>参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区 之间来回复制，产生大量的内存复制操作。</p>\n<p><strong>长期存活的对象将进入老年代</strong></p>\n<p>虚拟机给每个对象定义了一个对 象年龄(Age)计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。</p>\n<p>对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。</p>\n<p>对象晋升老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p>\n<p><strong>动态对象年龄判定</strong></p>\n<p>HotSpot虚拟机并不是永远要求对象的年龄必须达到<code>-XX:M axTenuringThreshold</code>才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到<code>-XX:  M axTenuringThreshold</code>中要求的年龄。</p>\n<p><strong>空间分配担保</strong></p>\n<p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总 空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。</p>\n<p>如果不成立，则虚拟机会先查看<code>-XX:HandlePromotionFailure</code>参数的设置值是否允许担保失败(Handle Promotion Failure)</p>\n<p>如果允 许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的;</p>\n<p>如果小于，或者<code>-XX: HandlePromotionFailure</code>设置不允许冒险，那这时就要改为进行一次Full GC。</p>\n<p>在JDK 6 Update 24之后，<code>-XX:HandlePromotionFailure</code>参数不会再影响到虚拟机的空间分配担保策略。</p>\n<p><strong>JDK 6 Update 24</strong>之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行Minor GC，否则将进行Full GC。</p>\n"},{"title":"内存溢出","_content":"\n[关于内存安全问题，你应该了解的几点！](https://mp.weixin.qq.com/s/BJUgnDPP2wtUUEjPnCX0oA)\n\n# 堆溢出\n\nJava堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。\n\n代码限制Java堆的大小为20M，不可扩展（将堆的最小值`-Xms`参数与最大值`-Xmx`参数设置为一样即可避免堆自动扩展）\n\n通过参数 `-XX:+HeapDumpOnOutOfMemoryError `可以让虚拟机在出现内存溢出异常时Dump出当前的内存转储快照以便事后进行分析\n\n```java\npublic class HeapOOM {\n    static class OOMObject{\n    }\n    \n    public class void main(String[] args) {\n        List<OOMObject> list = new ArrayList<OOMObject)();\n        \n        while(true) {\n            list.add(new OOMObject());\n        }\n    }\n}\n```\n\n# 虚拟机栈和本地方法栈溢出\n\n由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，`-Xoss`参数(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，栈容量只能由`-Xss`参数来设定。\n\n关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常:\n\n* 如 果线程请求的栈深度大于虚拟机所允许的最大深度 ， 将抛出StackOverflowError异 常 。 \n* 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。\n\n《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机 的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异 常 。\n\n为了验证这点，我们可以做两个实验，先将实验范围限制在单线程中操作，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常:\n\n* 使用`-Xss`参数减少栈内存容量。\n* 定义了大量的本地变量，增大此方法帧中本地变量表的长度。\n\n**用例1**\n\n使用`-Xss`参数减少栈内存容量。\n\n结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。\n\n```java\npublic class JavaVMStackSOF {\n\n    private int stackLength = 1;\n\n    public void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n     public static void main(String[] args) throws Throwable {\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try {\n            oom.stackLeak();\n        } catch (Throwable e) {\n            System.out.println(\"stack length:\" + oom.stackLength);\n            throw e;\n        }\n    }\n}\n```\n\n**用例2**\n\n定义了大量的本地变量，增大此方法帧中本地变量表的长度。\n\n结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。\n\n# 方法区和运行时常量池溢出\n\n由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。\n\n前面曾经提到HotSpot从JDK 7开始逐步去永久代的计划，并在JDK 8中完全使用元空间来代替永久代，在此我们就以测试代码来观察一下，使用永久代还是元空间来实现方法区，对程序有什么实际的影响。\n\n`String::intern()`是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。\n\n在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过`-XX:PermSize`和`-XX:MaxPermSize`限制永久代的大小，即可间接限制其中常量池的容量\n\n```java\n/** \n * VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M \n */ \npublic class RuntimeConstantPoolOOM { \n \n    public static void main(String[] args) { \n        // 使用Set保持着常量池引用，避免Full GC回收常量池行为 \n        Set<String> set = new HashSet<String>(); \n        // 在short范围内足以让6MB的PermSize产生OOM了 \n        short i = 0; \n        while (true) { \n            set.add(String.valueOf(i++).intern()); \n        } \n    } \n} \n```\n\n从运行结果中可以看到，运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是**PermGen space**，说明运行时常量池的确是属于方法区（即JDK6的HotSpot虚拟机中的永久代）的一部分。\n\n而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用`-XX:MaxPermSize`参数或者在JDK 8及以上版本使用`-XX:MaxMeta-spaceSize`参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将一直进行下去，永不停歇。\n\n出现这种变化，是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中，所以在JDK 7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。\n\n这时候使用`-Xmx`参数限制最大堆到6MB就能够看到以下两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：\n\n```\n// OOM异常一： \nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.lang.Integer.toString(Integer.java:440) \n    at java.base/java.lang.String.valueOf(String.java:3058) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:12) \n \n// OOM异常二： \nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.util.HashMap.resize(HashMap.java:699) \n    at java.base/java.util.HashMap.putVal(HashMap.java:658) \n    at java.base/java.util.HashMap.put(HashMap.java:607) \n    at java.base/java.util.HashSet.add(HashSet.java:220) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java from InputFile-Object:14) \n```\n\n**我们再来看看方法区的其他部分的内容**\n\n方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。\n\n对于这部分区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出为止。\n\n当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。\n\n借助CGLib直接操作字节码运行时生成了大量的动态类。 \n\n```java\npublic class JavaMethodAreaOOM { \n \n    public static void main(String[] args) { \n        while (true) { \n            Enhancer enhancer = new Enhancer(); \n            enhancer.setSuperclass(OOMObject.class); \n            enhancer.setUseCache(false); \n            enhancer.setCallback(new MethodInterceptor() { \n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { \n                    return proxy.invokeSuper(obj, args); \n                } \n            }); \n            enhancer.create(); \n        } \n    } \n \n    static class OOMObject { \n    } \n} \n```\n\n在JDK 7中的运行结果：\n\n```\nCaused by: java.lang.OutOfMemoryError: PermGen space \n    at java.lang.ClassLoader.defineClass1(Native Method) \n    at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) \n    at java.lang.ClassLoader.defineClass(ClassLoader.java:616) \n    ... 8 more \n```\n\n方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。\n\n在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。\n\n这类场景除了之前提到的程序使用了CGLib字节码增强和动态语言外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。\n\n**在JDK 8以后，永久代便完全退出了历史舞台，元空间作为其替代者登场。**\n\n为了让使用者有预防实际应用里出现类似于代码那样的破坏性的操作，HotSpot还是提供了一些参数作为元空间的防御措施，主要包括：\n\n* -XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。\n\n* -XX:MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过`-XX:MaxMetaspaceSize`（如果设置了的话）的情况下，适当提高该值。\n\n* -XX:MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有`-XX:Max-MetaspaceFreeRatio`，用于控制最大的元空间剩余容量的百分比。\n\n# 本机直接内存溢出\n\n直接内存(Direct Memory)的容量大小可通过`-XX:MaxDirectMemorySize`参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致\n\n直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有`rt.jar`中的类才能使用Unsafe的功能）。\n\n因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是`unsafe.allocateMemory()`。\n\n```java\n/**\n * VM参数 : -Xmx20m -XX:MaxDirectMemorySize=10m\n * MaxDirectMemorySize如果不指定，则默认与Java堆最大值（-Xmx指定）一样\n */\npublic class Main {\n \n    private static final int _1MB = 1024 * 1024;\n \n    public static void main(String[] args) throws IllegalAccessException {\n \n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        //获取私有属性的时候必须先设置Accessible为true\n        unsafeField.setAccessible(true);\n        //因为unsafe是静态字段，所以传null\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true){\n            //死循环申请分配内存\n            unsafe.allocateMemory(_1MB);\n        }\n \n    }\n```\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError\n\tat sun.misc.Unsafe.allocateMemory(Native Method)\n\tat Main.main(Main.java:18)\n```\n\n由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。\n\n# 内存泄漏\n\n内存泄露的定义：对于应用程序来说，当对象已经不再被使用，但是Java的垃圾回收器不能回收它们的时候，就产生了内存泄露。\n\n**造成内存泄露的常见情形**\n\n> 1.集合类，比如HashMap，ArrayList等，这些对象经常会发生内存泄露。\n\n比如当它们被声明为静态对象时，它们的生命周期会跟应用程序的生命周期一样长，很容易造成内存不足。\n\n像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。\n\n```java\nStatic Vector v = new Vector(10);\nfor (int i = 1; i<100; i++) {\n    Object o = new Object();\n    v.add(o);\n    o = null;\n}\n```\n\n> 2.当集合里面的对象属性被修改后，再调用remove()方法时不起作用。\n\n> 3.监听器\n\n释放对象的时候却没有记住去删除对应的监听器，从而增加了内存泄漏的机会。\n\n> 4.各种连接\n\n比如数据库连接（`dataSourse.getConnection()`），网络连接(socket)和io连接，除非其显式的调用了其close()方法将其连接关闭，否则是不会自动被GC 回收的。\n\n一般都会在try里面去的连接，在finally里面释放连接。\n\n> 5.内部类和外部模块的引用\n\n内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。\n\n例如程序员A负责A模块，调用了B模块的一个方法如： `public void registerMsg(Object b);` 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。\n\n> 6.单例模式\n\n不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏","source":"_posts/深入理解JVM虚拟机/内存溢出.md","raw":"---\ntitle: 内存溢出\ncategories: \n- 深入理解JVM虚拟机\n---\n\n[关于内存安全问题，你应该了解的几点！](https://mp.weixin.qq.com/s/BJUgnDPP2wtUUEjPnCX0oA)\n\n# 堆溢出\n\nJava堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。\n\n代码限制Java堆的大小为20M，不可扩展（将堆的最小值`-Xms`参数与最大值`-Xmx`参数设置为一样即可避免堆自动扩展）\n\n通过参数 `-XX:+HeapDumpOnOutOfMemoryError `可以让虚拟机在出现内存溢出异常时Dump出当前的内存转储快照以便事后进行分析\n\n```java\npublic class HeapOOM {\n    static class OOMObject{\n    }\n    \n    public class void main(String[] args) {\n        List<OOMObject> list = new ArrayList<OOMObject)();\n        \n        while(true) {\n            list.add(new OOMObject());\n        }\n    }\n}\n```\n\n# 虚拟机栈和本地方法栈溢出\n\n由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，`-Xoss`参数(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，栈容量只能由`-Xss`参数来设定。\n\n关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常:\n\n* 如 果线程请求的栈深度大于虚拟机所允许的最大深度 ， 将抛出StackOverflowError异 常 。 \n* 如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。\n\n《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机 的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异 常 。\n\n为了验证这点，我们可以做两个实验，先将实验范围限制在单线程中操作，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常:\n\n* 使用`-Xss`参数减少栈内存容量。\n* 定义了大量的本地变量，增大此方法帧中本地变量表的长度。\n\n**用例1**\n\n使用`-Xss`参数减少栈内存容量。\n\n结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。\n\n```java\npublic class JavaVMStackSOF {\n\n    private int stackLength = 1;\n\n    public void stackLeak() {\n        stackLength++;\n        stackLeak();\n    }\n\n     public static void main(String[] args) throws Throwable {\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try {\n            oom.stackLeak();\n        } catch (Throwable e) {\n            System.out.println(\"stack length:\" + oom.stackLength);\n            throw e;\n        }\n    }\n}\n```\n\n**用例2**\n\n定义了大量的本地变量，增大此方法帧中本地变量表的长度。\n\n结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。\n\n# 方法区和运行时常量池溢出\n\n由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。\n\n前面曾经提到HotSpot从JDK 7开始逐步去永久代的计划，并在JDK 8中完全使用元空间来代替永久代，在此我们就以测试代码来观察一下，使用永久代还是元空间来实现方法区，对程序有什么实际的影响。\n\n`String::intern()`是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。\n\n在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过`-XX:PermSize`和`-XX:MaxPermSize`限制永久代的大小，即可间接限制其中常量池的容量\n\n```java\n/** \n * VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M \n */ \npublic class RuntimeConstantPoolOOM { \n \n    public static void main(String[] args) { \n        // 使用Set保持着常量池引用，避免Full GC回收常量池行为 \n        Set<String> set = new HashSet<String>(); \n        // 在short范围内足以让6MB的PermSize产生OOM了 \n        short i = 0; \n        while (true) { \n            set.add(String.valueOf(i++).intern()); \n        } \n    } \n} \n```\n\n从运行结果中可以看到，运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是**PermGen space**，说明运行时常量池的确是属于方法区（即JDK6的HotSpot虚拟机中的永久代）的一部分。\n\n而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用`-XX:MaxPermSize`参数或者在JDK 8及以上版本使用`-XX:MaxMeta-spaceSize`参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将一直进行下去，永不停歇。\n\n出现这种变化，是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中，所以在JDK 7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。\n\n这时候使用`-Xmx`参数限制最大堆到6MB就能够看到以下两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：\n\n```\n// OOM异常一： \nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.lang.Integer.toString(Integer.java:440) \n    at java.base/java.lang.String.valueOf(String.java:3058) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:12) \n \n// OOM异常二： \nException in thread \"main\" java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.util.HashMap.resize(HashMap.java:699) \n    at java.base/java.util.HashMap.putVal(HashMap.java:658) \n    at java.base/java.util.HashMap.put(HashMap.java:607) \n    at java.base/java.util.HashSet.add(HashSet.java:220) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java from InputFile-Object:14) \n```\n\n**我们再来看看方法区的其他部分的内容**\n\n方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。\n\n对于这部分区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出为止。\n\n当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。\n\n借助CGLib直接操作字节码运行时生成了大量的动态类。 \n\n```java\npublic class JavaMethodAreaOOM { \n \n    public static void main(String[] args) { \n        while (true) { \n            Enhancer enhancer = new Enhancer(); \n            enhancer.setSuperclass(OOMObject.class); \n            enhancer.setUseCache(false); \n            enhancer.setCallback(new MethodInterceptor() { \n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { \n                    return proxy.invokeSuper(obj, args); \n                } \n            }); \n            enhancer.create(); \n        } \n    } \n \n    static class OOMObject { \n    } \n} \n```\n\n在JDK 7中的运行结果：\n\n```\nCaused by: java.lang.OutOfMemoryError: PermGen space \n    at java.lang.ClassLoader.defineClass1(Native Method) \n    at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) \n    at java.lang.ClassLoader.defineClass(ClassLoader.java:616) \n    ... 8 more \n```\n\n方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。\n\n在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。\n\n这类场景除了之前提到的程序使用了CGLib字节码增强和动态语言外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。\n\n**在JDK 8以后，永久代便完全退出了历史舞台，元空间作为其替代者登场。**\n\n为了让使用者有预防实际应用里出现类似于代码那样的破坏性的操作，HotSpot还是提供了一些参数作为元空间的防御措施，主要包括：\n\n* -XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。\n\n* -XX:MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过`-XX:MaxMetaspaceSize`（如果设置了的话）的情况下，适当提高该值。\n\n* -XX:MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有`-XX:Max-MetaspaceFreeRatio`，用于控制最大的元空间剩余容量的百分比。\n\n# 本机直接内存溢出\n\n直接内存(Direct Memory)的容量大小可通过`-XX:MaxDirectMemorySize`参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致\n\n直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有`rt.jar`中的类才能使用Unsafe的功能）。\n\n因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是`unsafe.allocateMemory()`。\n\n```java\n/**\n * VM参数 : -Xmx20m -XX:MaxDirectMemorySize=10m\n * MaxDirectMemorySize如果不指定，则默认与Java堆最大值（-Xmx指定）一样\n */\npublic class Main {\n \n    private static final int _1MB = 1024 * 1024;\n \n    public static void main(String[] args) throws IllegalAccessException {\n \n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        //获取私有属性的时候必须先设置Accessible为true\n        unsafeField.setAccessible(true);\n        //因为unsafe是静态字段，所以传null\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true){\n            //死循环申请分配内存\n            unsafe.allocateMemory(_1MB);\n        }\n \n    }\n```\n\n```\nException in thread \"main\" java.lang.OutOfMemoryError\n\tat sun.misc.Unsafe.allocateMemory(Native Method)\n\tat Main.main(Main.java:18)\n```\n\n由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。\n\n# 内存泄漏\n\n内存泄露的定义：对于应用程序来说，当对象已经不再被使用，但是Java的垃圾回收器不能回收它们的时候，就产生了内存泄露。\n\n**造成内存泄露的常见情形**\n\n> 1.集合类，比如HashMap，ArrayList等，这些对象经常会发生内存泄露。\n\n比如当它们被声明为静态对象时，它们的生命周期会跟应用程序的生命周期一样长，很容易造成内存不足。\n\n像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。\n\n```java\nStatic Vector v = new Vector(10);\nfor (int i = 1; i<100; i++) {\n    Object o = new Object();\n    v.add(o);\n    o = null;\n}\n```\n\n> 2.当集合里面的对象属性被修改后，再调用remove()方法时不起作用。\n\n> 3.监听器\n\n释放对象的时候却没有记住去删除对应的监听器，从而增加了内存泄漏的机会。\n\n> 4.各种连接\n\n比如数据库连接（`dataSourse.getConnection()`），网络连接(socket)和io连接，除非其显式的调用了其close()方法将其连接关闭，否则是不会自动被GC 回收的。\n\n一般都会在try里面去的连接，在finally里面释放连接。\n\n> 5.内部类和外部模块的引用\n\n内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。\n\n例如程序员A负责A模块，调用了B模块的一个方法如： `public void registerMsg(Object b);` 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。\n\n> 6.单例模式\n\n不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏","slug":"深入理解JVM虚拟机/内存溢出","published":1,"date":"2021-12-20T16:29:59.491Z","updated":"2022-02-01T09:22:30.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkk00k5fhjiezdjg5r9","content":"<p><a href=\"https://mp.weixin.qq.com/s/BJUgnDPP2wtUUEjPnCX0oA\">关于内存安全问题，你应该了解的几点！</a></p>\n<h1 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h1><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>\n<p>代码限制Java堆的大小为20M，不可扩展（将堆的最小值<code>-Xms</code>参数与最大值<code>-Xmx</code>参数设置为一样即可避免堆自动扩展）</p>\n<p>通过参数 <code>-XX:+HeapDumpOnOutOfMemoryError </code>可以让虚拟机在出现内存溢出异常时Dump出当前的内存转储快照以便事后进行分析</p>\n<pre><code class=\"java\">public class HeapOOM &#123;\n    static class OOMObject&#123;\n    &#125;\n    \n    public class void main(String[] args) &#123;\n        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject)();\n        \n        while(true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"虚拟机栈和本地方法栈溢出\"><a href=\"#虚拟机栈和本地方法栈溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈溢出\"></a>虚拟机栈和本地方法栈溢出</h1><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss</code>参数(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，栈容量只能由<code>-Xss</code>参数来设定。</p>\n<p>关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常:</p>\n<ul>\n<li>如 果线程请求的栈深度大于虚拟机所允许的最大深度 ， 将抛出StackOverflowError异 常 。 </li>\n<li>如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</li>\n</ul>\n<p>《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机 的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异 常 。</p>\n<p>为了验证这点，我们可以做两个实验，先将实验范围限制在单线程中操作，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常:</p>\n<ul>\n<li>使用<code>-Xss</code>参数减少栈内存容量。</li>\n<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。</li>\n</ul>\n<p><strong>用例1</strong></p>\n<p>使用<code>-Xss</code>参数减少栈内存容量。</p>\n<p>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</p>\n<pre><code class=\"java\">public class JavaVMStackSOF &#123;\n\n    private int stackLength = 1;\n\n    public void stackLeak() &#123;\n        stackLength++;\n        stackLeak();\n    &#125;\n\n     public static void main(String[] args) throws Throwable &#123;\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try &#123;\n            oom.stackLeak();\n        &#125; catch (Throwable e) &#123;\n            System.out.println(&quot;stack length:&quot; + oom.stackLength);\n            throw e;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>用例2</strong></p>\n<p>定义了大量的本地变量，增大此方法帧中本地变量表的长度。</p>\n<p>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</p>\n<h1 id=\"方法区和运行时常量池溢出\"><a href=\"#方法区和运行时常量池溢出\" class=\"headerlink\" title=\"方法区和运行时常量池溢出\"></a>方法区和运行时常量池溢出</h1><p>由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。</p>\n<p>前面曾经提到HotSpot从JDK 7开始逐步去永久代的计划，并在JDK 8中完全使用元空间来代替永久代，在此我们就以测试代码来观察一下，使用永久代还是元空间来实现方法区，对程序有什么实际的影响。</p>\n<p><code>String::intern()</code>是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p>\n<p>在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>限制永久代的大小，即可间接限制其中常量池的容量</p>\n<pre><code class=\"java\">/** \n * VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M \n */ \npublic class RuntimeConstantPoolOOM &#123; \n \n    public static void main(String[] args) &#123; \n        // 使用Set保持着常量池引用，避免Full GC回收常量池行为 \n        Set&lt;String&gt; set = new HashSet&lt;String&gt;(); \n        // 在short范围内足以让6MB的PermSize产生OOM了 \n        short i = 0; \n        while (true) &#123; \n            set.add(String.valueOf(i++).intern()); \n        &#125; \n    &#125; \n&#125; \n</code></pre>\n<p>从运行结果中可以看到，运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是<strong>PermGen space</strong>，说明运行时常量池的确是属于方法区（即JDK6的HotSpot虚拟机中的永久代）的一部分。</p>\n<p>而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用<code>-XX:MaxPermSize</code>参数或者在JDK 8及以上版本使用<code>-XX:MaxMeta-spaceSize</code>参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将一直进行下去，永不停歇。</p>\n<p>出现这种变化，是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中，所以在JDK 7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。</p>\n<p>这时候使用<code>-Xmx</code>参数限制最大堆到6MB就能够看到以下两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：</p>\n<pre><code>// OOM异常一： \nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.lang.Integer.toString(Integer.java:440) \n    at java.base/java.lang.String.valueOf(String.java:3058) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:12) \n \n// OOM异常二： \nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.util.HashMap.resize(HashMap.java:699) \n    at java.base/java.util.HashMap.putVal(HashMap.java:658) \n    at java.base/java.util.HashMap.put(HashMap.java:607) \n    at java.base/java.util.HashSet.add(HashSet.java:220) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java from InputFile-Object:14) \n</code></pre>\n<p><strong>我们再来看看方法区的其他部分的内容</strong></p>\n<p>方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>\n<p>对于这部分区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出为止。</p>\n<p>当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。</p>\n<p>借助CGLib直接操作字节码运行时生成了大量的动态类。 </p>\n<pre><code class=\"java\">public class JavaMethodAreaOOM &#123; \n \n    public static void main(String[] args) &#123; \n        while (true) &#123; \n            Enhancer enhancer = new Enhancer(); \n            enhancer.setSuperclass(OOMObject.class); \n            enhancer.setUseCache(false); \n            enhancer.setCallback(new MethodInterceptor() &#123; \n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; \n                    return proxy.invokeSuper(obj, args); \n                &#125; \n            &#125;); \n            enhancer.create(); \n        &#125; \n    &#125; \n \n    static class OOMObject &#123; \n    &#125; \n&#125; \n</code></pre>\n<p>在JDK 7中的运行结果：</p>\n<pre><code>Caused by: java.lang.OutOfMemoryError: PermGen space \n    at java.lang.ClassLoader.defineClass1(Native Method) \n    at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) \n    at java.lang.ClassLoader.defineClass(ClassLoader.java:616) \n    ... 8 more \n</code></pre>\n<p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。</p>\n<p>在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。</p>\n<p>这类场景除了之前提到的程序使用了CGLib字节码增强和动态语言外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>\n<p><strong>在JDK 8以后，永久代便完全退出了历史舞台，元空间作为其替代者登场。</strong></p>\n<p>为了让使用者有预防实际应用里出现类似于代码那样的破坏性的操作，HotSpot还是提供了一些参数作为元空间的防御措施，主要包括：</p>\n<ul>\n<li><p>-XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。</p>\n</li>\n<li><p>-XX:MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过<code>-XX:MaxMetaspaceSize</code>（如果设置了的话）的情况下，适当提高该值。</p>\n</li>\n<li><p>-XX:MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有<code>-XX:Max-MetaspaceFreeRatio</code>，用于控制最大的元空间剩余容量的百分比。</p>\n</li>\n</ul>\n<h1 id=\"本机直接内存溢出\"><a href=\"#本机直接内存溢出\" class=\"headerlink\" title=\"本机直接内存溢出\"></a>本机直接内存溢出</h1><p>直接内存(Direct Memory)的容量大小可通过<code>-XX:MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致</p>\n<p>直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有<code>rt.jar</code>中的类才能使用Unsafe的功能）。</p>\n<p>因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是<code>unsafe.allocateMemory()</code>。</p>\n<pre><code class=\"java\">/**\n * VM参数 : -Xmx20m -XX:MaxDirectMemorySize=10m\n * MaxDirectMemorySize如果不指定，则默认与Java堆最大值（-Xmx指定）一样\n */\npublic class Main &#123;\n \n    private static final int _1MB = 1024 * 1024;\n \n    public static void main(String[] args) throws IllegalAccessException &#123;\n \n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        //获取私有属性的时候必须先设置Accessible为true\n        unsafeField.setAccessible(true);\n        //因为unsafe是静态字段，所以传null\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true)&#123;\n            //死循环申请分配内存\n            unsafe.allocateMemory(_1MB);\n        &#125;\n \n    &#125;\n</code></pre>\n<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError\n    at sun.misc.Unsafe.allocateMemory(Native Method)\n    at Main.main(Main.java:18)\n</code></pre>\n<p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>\n<h1 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h1><p>内存泄露的定义：对于应用程序来说，当对象已经不再被使用，但是Java的垃圾回收器不能回收它们的时候，就产生了内存泄露。</p>\n<p><strong>造成内存泄露的常见情形</strong></p>\n<blockquote>\n<p>1.集合类，比如HashMap，ArrayList等，这些对象经常会发生内存泄露。</p>\n</blockquote>\n<p>比如当它们被声明为静态对象时，它们的生命周期会跟应用程序的生命周期一样长，很容易造成内存不足。</p>\n<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>\n<pre><code class=\"java\">Static Vector v = new Vector(10);\nfor (int i = 1; i&lt;100; i++) &#123;\n    Object o = new Object();\n    v.add(o);\n    o = null;\n&#125;\n</code></pre>\n<blockquote>\n<p>2.当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p>\n</blockquote>\n<blockquote>\n<p>3.监听器</p>\n</blockquote>\n<p>释放对象的时候却没有记住去删除对应的监听器，从而增加了内存泄漏的机会。</p>\n<blockquote>\n<p>4.各种连接</p>\n</blockquote>\n<p>比如数据库连接（<code>dataSourse.getConnection()</code>），网络连接(socket)和io连接，除非其显式的调用了其close()方法将其连接关闭，否则是不会自动被GC 回收的。</p>\n<p>一般都会在try里面去的连接，在finally里面释放连接。</p>\n<blockquote>\n<p>5.内部类和外部模块的引用</p>\n</blockquote>\n<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。</p>\n<p>例如程序员A负责A模块，调用了B模块的一个方法如： <code>public void registerMsg(Object b);</code> 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。</p>\n<blockquote>\n<p>6.单例模式</p>\n</blockquote>\n<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏</p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://mp.weixin.qq.com/s/BJUgnDPP2wtUUEjPnCX0oA\">关于内存安全问题，你应该了解的几点！</a></p>\n<h1 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h1><p>Java堆用于存储对象实例，只要不断地创建对象，并且保证 GC Roots 到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p>\n<p>代码限制Java堆的大小为20M，不可扩展（将堆的最小值<code>-Xms</code>参数与最大值<code>-Xmx</code>参数设置为一样即可避免堆自动扩展）</p>\n<p>通过参数 <code>-XX:+HeapDumpOnOutOfMemoryError </code>可以让虚拟机在出现内存溢出异常时Dump出当前的内存转储快照以便事后进行分析</p>\n<pre><code class=\"java\">public class HeapOOM &#123;\n    static class OOMObject&#123;\n    &#125;\n    \n    public class void main(String[] args) &#123;\n        List&lt;OOMObject&gt; list = new ArrayList&lt;OOMObject)();\n        \n        while(true) &#123;\n            list.add(new OOMObject());\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"虚拟机栈和本地方法栈溢出\"><a href=\"#虚拟机栈和本地方法栈溢出\" class=\"headerlink\" title=\"虚拟机栈和本地方法栈溢出\"></a>虚拟机栈和本地方法栈溢出</h1><p>由于HotSpot虚拟机中并不区分虚拟机栈和本地方法栈，因此对于HotSpot来说，<code>-Xoss</code>参数(设置本地方法栈大小)虽然存在，但实际上是没有任何效果的，栈容量只能由<code>-Xss</code>参数来设定。</p>\n<p>关于虚拟机栈和本地方法栈，在《Java虚拟机规范》中描述了两种异常:</p>\n<ul>\n<li>如 果线程请求的栈深度大于虚拟机所允许的最大深度 ， 将抛出StackOverflowError异 常 。 </li>\n<li>如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将抛出OutOfMemoryError异常。</li>\n</ul>\n<p>《Java虚拟机规范》明确允许Java虚拟机实现自行选择是否支持栈的动态扩展，而HotSpot虚拟机 的选择是不支持扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OutOfMemoryError异常，否则在线程运行时是不会因为扩展而导致内存溢出的，只会因为栈容量无法容纳新的栈帧而导致StackOverflowError异 常 。</p>\n<p>为了验证这点，我们可以做两个实验，先将实验范围限制在单线程中操作，尝试下面两种行为是否能让HotSpot虚拟机产生OutOfMemoryError异常:</p>\n<ul>\n<li>使用<code>-Xss</code>参数减少栈内存容量。</li>\n<li>定义了大量的本地变量，增大此方法帧中本地变量表的长度。</li>\n</ul>\n<p><strong>用例1</strong></p>\n<p>使用<code>-Xss</code>参数减少栈内存容量。</p>\n<p>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</p>\n<pre><code class=\"java\">public class JavaVMStackSOF &#123;\n\n    private int stackLength = 1;\n\n    public void stackLeak() &#123;\n        stackLength++;\n        stackLeak();\n    &#125;\n\n     public static void main(String[] args) throws Throwable &#123;\n        JavaVMStackSOF oom = new JavaVMStackSOF();\n        try &#123;\n            oom.stackLeak();\n        &#125; catch (Throwable e) &#123;\n            System.out.println(&quot;stack length:&quot; + oom.stackLength);\n            throw e;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>用例2</strong></p>\n<p>定义了大量的本地变量，增大此方法帧中本地变量表的长度。</p>\n<p>结果：抛出StackOverflowError异常，异常出现时输出的堆栈深度相应缩小。</p>\n<h1 id=\"方法区和运行时常量池溢出\"><a href=\"#方法区和运行时常量池溢出\" class=\"headerlink\" title=\"方法区和运行时常量池溢出\"></a>方法区和运行时常量池溢出</h1><p>由于运行时常量池是方法区的一部分，所以这两个区域的溢出测试可以放到一起进行。</p>\n<p>前面曾经提到HotSpot从JDK 7开始逐步去永久代的计划，并在JDK 8中完全使用元空间来代替永久代，在此我们就以测试代码来观察一下，使用永久代还是元空间来实现方法区，对程序有什么实际的影响。</p>\n<p><code>String::intern()</code>是一个本地方法，它的作用是如果字符串常量池中已经包含一个等于此String对象的字符串，则返回代表池中这个字符串的String对象的引用；否则，会将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。</p>\n<p>在JDK 6或更早之前的HotSpot虚拟机中，常量池都是分配在永久代中，我们可以通过<code>-XX:PermSize</code>和<code>-XX:MaxPermSize</code>限制永久代的大小，即可间接限制其中常量池的容量</p>\n<pre><code class=\"java\">/** \n * VM Args：-XX:PermSize=6M -XX:MaxPermSize=6M \n */ \npublic class RuntimeConstantPoolOOM &#123; \n \n    public static void main(String[] args) &#123; \n        // 使用Set保持着常量池引用，避免Full GC回收常量池行为 \n        Set&lt;String&gt; set = new HashSet&lt;String&gt;(); \n        // 在short范围内足以让6MB的PermSize产生OOM了 \n        short i = 0; \n        while (true) &#123; \n            set.add(String.valueOf(i++).intern()); \n        &#125; \n    &#125; \n&#125; \n</code></pre>\n<p>从运行结果中可以看到，运行时常量池溢出时，在OutOfMemoryError异常后面跟随的提示信息是<strong>PermGen space</strong>，说明运行时常量池的确是属于方法区（即JDK6的HotSpot虚拟机中的永久代）的一部分。</p>\n<p>而使用JDK 7或更高版本的JDK来运行这段程序并不会得到相同的结果，无论是在JDK 7中继续使用<code>-XX:MaxPermSize</code>参数或者在JDK 8及以上版本使用<code>-XX:MaxMeta-spaceSize</code>参数把方法区容量同样限制在6MB，也都不会重现JDK 6中的溢出异常，循环将一直进行下去，永不停歇。</p>\n<p>出现这种变化，是因为自JDK 7起，原本存放在永久代的字符串常量池被移至Java堆之中，所以在JDK 7及以上版本，限制方法区的容量对该测试用例来说是毫无意义的。</p>\n<p>这时候使用<code>-Xmx</code>参数限制最大堆到6MB就能够看到以下两种运行结果之一，具体取决于哪里的对象分配时产生了溢出：</p>\n<pre><code>// OOM异常一： \nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.lang.Integer.toString(Integer.java:440) \n    at java.base/java.lang.String.valueOf(String.java:3058) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:12) \n \n// OOM异常二： \nException in thread &quot;main&quot; java.lang.OutOfMemoryError: Java heap space \n    at java.base/java.util.HashMap.resize(HashMap.java:699) \n    at java.base/java.util.HashMap.putVal(HashMap.java:658) \n    at java.base/java.util.HashMap.put(HashMap.java:607) \n    at java.base/java.util.HashSet.add(HashSet.java:220) \n    at RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java from InputFile-Object:14) \n</code></pre>\n<p><strong>我们再来看看方法区的其他部分的内容</strong></p>\n<p>方法区的主要职责是用于存放类型的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。</p>\n<p>对于这部分区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出为止。</p>\n<p>当前的很多主流框架，如Spring、Hibernate对类进行增强时，都会使用到CGLib这类字节码技术，当增强的类越多，就需要越大的方法区以保证动态生成的新类型可以载入内存。</p>\n<p>借助CGLib直接操作字节码运行时生成了大量的动态类。 </p>\n<pre><code class=\"java\">public class JavaMethodAreaOOM &#123; \n \n    public static void main(String[] args) &#123; \n        while (true) &#123; \n            Enhancer enhancer = new Enhancer(); \n            enhancer.setSuperclass(OOMObject.class); \n            enhancer.setUseCache(false); \n            enhancer.setCallback(new MethodInterceptor() &#123; \n                public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; \n                    return proxy.invokeSuper(obj, args); \n                &#125; \n            &#125;); \n            enhancer.create(); \n        &#125; \n    &#125; \n \n    static class OOMObject &#123; \n    &#125; \n&#125; \n</code></pre>\n<p>在JDK 7中的运行结果：</p>\n<pre><code>Caused by: java.lang.OutOfMemoryError: PermGen space \n    at java.lang.ClassLoader.defineClass1(Native Method) \n    at java.lang.ClassLoader.defineClassCond(ClassLoader.java:632) \n    at java.lang.ClassLoader.defineClass(ClassLoader.java:616) \n    ... 8 more \n</code></pre>\n<p>方法区溢出也是一种常见的内存溢出异常，一个类如果要被垃圾收集器回收，要达成的条件是比较苛刻的。</p>\n<p>在经常运行时生成大量动态类的应用场景里，就应该特别关注这些类的回收状况。</p>\n<p>这类场景除了之前提到的程序使用了CGLib字节码增强和动态语言外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>\n<p><strong>在JDK 8以后，永久代便完全退出了历史舞台，元空间作为其替代者登场。</strong></p>\n<p>为了让使用者有预防实际应用里出现类似于代码那样的破坏性的操作，HotSpot还是提供了一些参数作为元空间的防御措施，主要包括：</p>\n<ul>\n<li><p>-XX:MaxMetaspaceSize：设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。</p>\n</li>\n<li><p>-XX:MetaspaceSize：指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整：如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过<code>-XX:MaxMetaspaceSize</code>（如果设置了的话）的情况下，适当提高该值。</p>\n</li>\n<li><p>-XX:MinMetaspaceFreeRatio：作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有<code>-XX:Max-MetaspaceFreeRatio</code>，用于控制最大的元空间剩余容量的百分比。</p>\n</li>\n</ul>\n<h1 id=\"本机直接内存溢出\"><a href=\"#本机直接内存溢出\" class=\"headerlink\" title=\"本机直接内存溢出\"></a>本机直接内存溢出</h1><p>直接内存(Direct Memory)的容量大小可通过<code>-XX:MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定)一致</p>\n<p>直接通过反射获取Unsafe实例进行内存分配（Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例，也就是设计者希望只有<code>rt.jar</code>中的类才能使用Unsafe的功能）。</p>\n<p>因为，虽然使用DirectByteBuffer分配内存也会抛出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配，于是手动抛出异常，真正申请分配内存的方法是<code>unsafe.allocateMemory()</code>。</p>\n<pre><code class=\"java\">/**\n * VM参数 : -Xmx20m -XX:MaxDirectMemorySize=10m\n * MaxDirectMemorySize如果不指定，则默认与Java堆最大值（-Xmx指定）一样\n */\npublic class Main &#123;\n \n    private static final int _1MB = 1024 * 1024;\n \n    public static void main(String[] args) throws IllegalAccessException &#123;\n \n        Field unsafeField = Unsafe.class.getDeclaredFields()[0];\n        //获取私有属性的时候必须先设置Accessible为true\n        unsafeField.setAccessible(true);\n        //因为unsafe是静态字段，所以传null\n        Unsafe unsafe = (Unsafe) unsafeField.get(null);\n        while (true)&#123;\n            //死循环申请分配内存\n            unsafe.allocateMemory(_1MB);\n        &#125;\n \n    &#125;\n</code></pre>\n<pre><code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError\n    at sun.misc.Unsafe.allocateMemory(Native Method)\n    at Main.main(Main.java:18)\n</code></pre>\n<p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>\n<h1 id=\"内存泄漏\"><a href=\"#内存泄漏\" class=\"headerlink\" title=\"内存泄漏\"></a>内存泄漏</h1><p>内存泄露的定义：对于应用程序来说，当对象已经不再被使用，但是Java的垃圾回收器不能回收它们的时候，就产生了内存泄露。</p>\n<p><strong>造成内存泄露的常见情形</strong></p>\n<blockquote>\n<p>1.集合类，比如HashMap，ArrayList等，这些对象经常会发生内存泄露。</p>\n</blockquote>\n<p>比如当它们被声明为静态对象时，它们的生命周期会跟应用程序的生命周期一样长，很容易造成内存不足。</p>\n<p>像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。</p>\n<pre><code class=\"java\">Static Vector v = new Vector(10);\nfor (int i = 1; i&lt;100; i++) &#123;\n    Object o = new Object();\n    v.add(o);\n    o = null;\n&#125;\n</code></pre>\n<blockquote>\n<p>2.当集合里面的对象属性被修改后，再调用remove()方法时不起作用。</p>\n</blockquote>\n<blockquote>\n<p>3.监听器</p>\n</blockquote>\n<p>释放对象的时候却没有记住去删除对应的监听器，从而增加了内存泄漏的机会。</p>\n<blockquote>\n<p>4.各种连接</p>\n</blockquote>\n<p>比如数据库连接（<code>dataSourse.getConnection()</code>），网络连接(socket)和io连接，除非其显式的调用了其close()方法将其连接关闭，否则是不会自动被GC 回收的。</p>\n<p>一般都会在try里面去的连接，在finally里面释放连接。</p>\n<blockquote>\n<p>5.内部类和外部模块的引用</p>\n</blockquote>\n<p>内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。</p>\n<p>例如程序员A负责A模块，调用了B模块的一个方法如： <code>public void registerMsg(Object b);</code> 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B是否提供相应的操作去除引用。</p>\n<blockquote>\n<p>6.单例模式</p>\n</blockquote>\n<p>不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏</p>\n"},{"title":"垃圾收集器","_content":"\n<img src=\"https://img-blog.csdnimg.cn/94796d43894d49b7b80a52b63f692953.png\" style=\"zoom:25%;\" />\n\n# Serial\n\nSerial收集器是最基础、历史最悠久的收集器，曾经(在JDK 1.3.1之前)是HotSpot虚拟机新生代收集器的唯一选择。\n\n这个收集器是一个单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。\n\n<img src=\"https://img-blog.csdnimg.cn/33bebd30b61743e48de9a90181004f69.png\" style=\"zoom:50%;\" />\n\n它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器\n\n# ParNew\n\nParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外 ，其余的Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。\n\n<img src=\"https://img-blog.csdnimg.cn/59c6c9cc2c024a9286ae9522fa1fa8b7.png\" style=\"zoom:50%;\" />\n\n除了Serial收集器外，目前只有它能与CMS 收集器配合工作。\n\n在JDK 5发布时，HotSpot推出了一款垃圾收集器 ——CMS收集器。\n\n这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次 实现了让垃圾收集线程与用户线程(基本上)同时工作。\n\n在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者 Serial收集器中的一个。\n\n> 自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。\n\n官方希望它能完全被G1所取代，甚至还取消了ParNew加 Serial Old以及Serial加CMS这两组收集器组合的支持(其实原本也很少人这样使用)，并直接取消了`- XX:+UseParNewGC`参数。\n\n它默认开启的收集线程数与处理器核心数量相同\n\n可以使用`-XX:ParallelGCT hreads`参数来限制垃圾收集的线程数。\n\n* 并行(Parallel):并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。\n\n* 并发(Concurrent):并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。\n\n# Parallel Scavenge\n\nParallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器\n\nParallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(`Throughput`)。\n\n**所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值**\n\nParallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数。\n\nParallel Scavenge收集器还有一个参数`-XX:+UseAdaptiveSizePolicy`。\n\n这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小(`-Xmn`)、Eden与Survivor区 的 比 例、 晋 升老 年代对 象 大 小等 细 节 参 数\n\n虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。\n\n这种调节方式称为垃圾收集的**自适应的调节策略(GC Ergonomics)**\n\n# Serial Old\n\nSerial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。\n\n这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。\n\n如果在服务端模式下，它也可能有两种用途:\n\n* 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。\n\n* 另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent M ode Failure时使用。\n\n<img src=\"https://img-blog.csdnimg.cn/70e78dfa74d2429a886ac362a502e2f2.png\" style=\"zoom:50%;\" />\n\n# Parallel Old\n\nParallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实 现。\n\n在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。\n\n<img src=\"https://img-blog.csdnimg.cn/81f40d50d7ce4f28a88333ec61dde988.png\" style=\"zoom:50%;\" />\n\n# CMS\n\nCMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。\n\n从名字(包含Mark Sweep)上就可以看出CMS收集器是基于标记-清除算法实现的：\n\n* 初始标记(CMS initial mark) \n\n* 并发标记(CMS concurrent mark) \n\n* 重新标记(CMS remark) \n\n* 并发清除(CMS concurrent sweep)\n\n其中初始标记、重新标记这两个步骤仍然需要Stop The World。\n\n* 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快\n\n* 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行\n\n  在这个阶段的执行过程中，可能会产生很多变化：\n\n  -  有些对象，从新生代晋升到了老年代； \n\n  -  有些对象，直接分配到了老年代； \n\n  -  老年代或者新生代的对象引用发生了变化。 \n\n  在这个阶段受到影响的老年代对象所对应的卡页，会被标记为 dirty，用于后续重新标记阶段的扫描。\n\n* 重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短\n\n* 并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的\n\n由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的**内存回收过程是与用户线程**一起并发执行的。\n\n<img src=\"https://img-blog.csdnimg.cn/69374386f15146ddb402650de4f0b71f.png\" style=\"zoom:50%;\" />\n\nCM S是一款优秀的收集器，它最主要的优点在名字上已经体现出来:并发收集、低停顿，\n\n**CM S收集器至少有以下三个明显的 缺点:**\n\n* CM S收集器对处理器资源非常敏感，因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量\n\n**CMS收集器无法处理浮动垃圾**\n\n有可能出现Con-current Mode Failure失败进而导致另一次完全Stop The World的Full GC的产生，在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分 垃圾对象是出现在标记过程结束以后，CM S无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。\n\n**这一部分垃圾就称为浮动垃圾**\n\n同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待 到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。\n\n在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，如果 在实际应用中老年代增长并不是太快，可以适当调高参数`-XX:CMSInitiatingOccupancyFraction`的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。\n\n到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。\n\n要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次并发失败(Concurrent Mode Failure)，这时候虚拟机将不 得不启动后备预案:\n\n* 冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。\n\n所以参数`-XX:CMSInitiatingOccupancyFraction`设置得太高将会很容易导致 大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。\n\n> CMS是一款基于标记-清除算法实现的收集器，会有大量空间碎片产生。\n\n空间 碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找 到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。\n\n为了解决这个问题， CMS收集器提供了一个`-XX:+UseCMSCompactAtFullCollection`开关参数(默认是开启的，此参数从 JDK 9开始废弃)，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程\n\n**由于这个内存整理必须移动存活对象的。** \n\n这样停顿时间又会变长，另外一个参数`-XX:CM SFullGCsBeforeCompaction`(此参数从JDK 9开始废弃)，这个参数的作用是要求CMS收集器在执行过若干次(数量由参数值决定)不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整理)。\n\n# Garbage First\n\nG1是一款主要面向服务端应用的垃圾收集器。\n\nJDK 9发布之 日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器\n\n如果对JDK 9及以上版本的HotSpot虚拟机使用参数`-XX:+UseConcMarkSweepGC`来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃\n\nG1把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间：\n\n* Region中还有一类特殊的Humongous区域，专门用来存储大对象。\n\n* G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。\n\n* 每个Region的大小可以通过参数`-XX:G1Heap RegionSize`设 定，取值范围为1M B~32M B，且应为2的N次幂。\n\n而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代 的一部分来进行看待\n\n虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域(不需要连续)的动态集合。\n\n> G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。\n>\n> 在垃圾收集过程中，G1收集器会记 录每个Region的回收耗时。\n\nG1在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数`-XX:MaxGCPauseMillis`指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region。 \n\n这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。\n\n**将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决?**\n\n使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。\n\nG1的记忆集在存储结构的本质上是一种哈希表 ，Key是别的Region的起始地址 ，Value是一个集合 ，里面存储的元素是卡表的索引号 。 \n\n这 种双向的卡表结构(卡表是我指向谁，这种结构还记录了谁指向我)比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃 圾收集器有着更高的内存占用负担。\n\n根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。\n\n**G1收集器的运作过程大致可划分为以下四个步骤:**\n\n* 初始标记:仅仅只是标记一下GC Roots能直接关联到的对象。\n\n* 并发标记:从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。\n\n* 最终标记:对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。\n\n* 筛选回收:负责更新Region的统计数据，对各个`Region`的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分`Region`的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间，这里的操作涉及存活对象的移动，是必须**暂停用户线程**，由多条收集器线程并行完成的。\n\n<img src=\"https://img-blog.csdnimg.cn/84db616d120a43c0890d320154aca3c4.png\" style=\"zoom:50%;\" />\n\nG1从整体来看是基于标记-整理算法实现的收集器，但从局部(两个`Region `之间)上看又是基于标记-复制算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。\n\n这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。\n\n目前在小内存应用上CM S的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其 优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间\n\n**在并发标记阶段如何保证收集线程与用户线程互不干扰地运行?**\n\nCM S收集器采用增量更新算法实现，而G1 收集器则是通过原始快照(SATB)算法来实现的。\n\n**GC模式**\n\nG1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。\n\n> young gc\n\n发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。\n\n| 参数                    | 含义                                |\n| ----------------------- | ----------------------------------- |\n| -XX:MaxGCPauseMillis    | 设置G1收集过程目标时间，默认值200ms |\n| -XX:G1NewSizePercent    | 新生代最小值，默认值5%              |\n| -XX:G1MaxNewSizePercent | 新生代最大值，默认值60%             |\n\n> mixed gc\n\n当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。\n\nmixed gc中有一个阈值参数 `-XX:InitiatingHeapOccupancyPercent`，当老年代使用大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc\n\n> full gc\n\n如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。\n\n**参数：**\n\n-XX:InitiatingHeapOccupancyPercent，默认值是45%：\n\n- 老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。\n\n-XX:G1MixedGCCountTarget，在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次\n\n- 意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。\n\n-XX:G1HeapWastePercent，默认值是5%\n\n- 在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。\n\n# ZGC\n\nZGC是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器\n\nZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。","source":"_posts/深入理解JVM虚拟机/垃圾收集器.md","raw":"---\ntitle: 垃圾收集器\ncategories: \n- 深入理解JVM虚拟机\n---\n\n<img src=\"https://img-blog.csdnimg.cn/94796d43894d49b7b80a52b63f692953.png\" style=\"zoom:25%;\" />\n\n# Serial\n\nSerial收集器是最基础、历史最悠久的收集器，曾经(在JDK 1.3.1之前)是HotSpot虚拟机新生代收集器的唯一选择。\n\n这个收集器是一个单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。\n\n<img src=\"https://img-blog.csdnimg.cn/33bebd30b61743e48de9a90181004f69.png\" style=\"zoom:50%;\" />\n\n它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器\n\n# ParNew\n\nParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外 ，其余的Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。\n\n<img src=\"https://img-blog.csdnimg.cn/59c6c9cc2c024a9286ae9522fa1fa8b7.png\" style=\"zoom:50%;\" />\n\n除了Serial收集器外，目前只有它能与CMS 收集器配合工作。\n\n在JDK 5发布时，HotSpot推出了一款垃圾收集器 ——CMS收集器。\n\n这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次 实现了让垃圾收集线程与用户线程(基本上)同时工作。\n\n在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者 Serial收集器中的一个。\n\n> 自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。\n\n官方希望它能完全被G1所取代，甚至还取消了ParNew加 Serial Old以及Serial加CMS这两组收集器组合的支持(其实原本也很少人这样使用)，并直接取消了`- XX:+UseParNewGC`参数。\n\n它默认开启的收集线程数与处理器核心数量相同\n\n可以使用`-XX:ParallelGCT hreads`参数来限制垃圾收集的线程数。\n\n* 并行(Parallel):并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。\n\n* 并发(Concurrent):并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。\n\n# Parallel Scavenge\n\nParallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器\n\nParallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(`Throughput`)。\n\n**所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值**\n\nParallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数。\n\nParallel Scavenge收集器还有一个参数`-XX:+UseAdaptiveSizePolicy`。\n\n这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小(`-Xmn`)、Eden与Survivor区 的 比 例、 晋 升老 年代对 象 大 小等 细 节 参 数\n\n虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。\n\n这种调节方式称为垃圾收集的**自适应的调节策略(GC Ergonomics)**\n\n# Serial Old\n\nSerial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。\n\n这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。\n\n如果在服务端模式下，它也可能有两种用途:\n\n* 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。\n\n* 另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent M ode Failure时使用。\n\n<img src=\"https://img-blog.csdnimg.cn/70e78dfa74d2429a886ac362a502e2f2.png\" style=\"zoom:50%;\" />\n\n# Parallel Old\n\nParallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实 现。\n\n在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。\n\n<img src=\"https://img-blog.csdnimg.cn/81f40d50d7ce4f28a88333ec61dde988.png\" style=\"zoom:50%;\" />\n\n# CMS\n\nCMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。\n\n从名字(包含Mark Sweep)上就可以看出CMS收集器是基于标记-清除算法实现的：\n\n* 初始标记(CMS initial mark) \n\n* 并发标记(CMS concurrent mark) \n\n* 重新标记(CMS remark) \n\n* 并发清除(CMS concurrent sweep)\n\n其中初始标记、重新标记这两个步骤仍然需要Stop The World。\n\n* 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快\n\n* 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行\n\n  在这个阶段的执行过程中，可能会产生很多变化：\n\n  -  有些对象，从新生代晋升到了老年代； \n\n  -  有些对象，直接分配到了老年代； \n\n  -  老年代或者新生代的对象引用发生了变化。 \n\n  在这个阶段受到影响的老年代对象所对应的卡页，会被标记为 dirty，用于后续重新标记阶段的扫描。\n\n* 重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短\n\n* 并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的\n\n由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的**内存回收过程是与用户线程**一起并发执行的。\n\n<img src=\"https://img-blog.csdnimg.cn/69374386f15146ddb402650de4f0b71f.png\" style=\"zoom:50%;\" />\n\nCM S是一款优秀的收集器，它最主要的优点在名字上已经体现出来:并发收集、低停顿，\n\n**CM S收集器至少有以下三个明显的 缺点:**\n\n* CM S收集器对处理器资源非常敏感，因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量\n\n**CMS收集器无法处理浮动垃圾**\n\n有可能出现Con-current Mode Failure失败进而导致另一次完全Stop The World的Full GC的产生，在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分 垃圾对象是出现在标记过程结束以后，CM S无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。\n\n**这一部分垃圾就称为浮动垃圾**\n\n同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待 到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。\n\n在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，如果 在实际应用中老年代增长并不是太快，可以适当调高参数`-XX:CMSInitiatingOccupancyFraction`的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。\n\n到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。\n\n要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次并发失败(Concurrent Mode Failure)，这时候虚拟机将不 得不启动后备预案:\n\n* 冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。\n\n所以参数`-XX:CMSInitiatingOccupancyFraction`设置得太高将会很容易导致 大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。\n\n> CMS是一款基于标记-清除算法实现的收集器，会有大量空间碎片产生。\n\n空间 碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找 到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。\n\n为了解决这个问题， CMS收集器提供了一个`-XX:+UseCMSCompactAtFullCollection`开关参数(默认是开启的，此参数从 JDK 9开始废弃)，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程\n\n**由于这个内存整理必须移动存活对象的。** \n\n这样停顿时间又会变长，另外一个参数`-XX:CM SFullGCsBeforeCompaction`(此参数从JDK 9开始废弃)，这个参数的作用是要求CMS收集器在执行过若干次(数量由参数值决定)不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整理)。\n\n# Garbage First\n\nG1是一款主要面向服务端应用的垃圾收集器。\n\nJDK 9发布之 日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器\n\n如果对JDK 9及以上版本的HotSpot虚拟机使用参数`-XX:+UseConcMarkSweepGC`来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃\n\nG1把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间：\n\n* Region中还有一类特殊的Humongous区域，专门用来存储大对象。\n\n* G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。\n\n* 每个Region的大小可以通过参数`-XX:G1Heap RegionSize`设 定，取值范围为1M B~32M B，且应为2的N次幂。\n\n而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代 的一部分来进行看待\n\n虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域(不需要连续)的动态集合。\n\n> G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。\n>\n> 在垃圾收集过程中，G1收集器会记 录每个Region的回收耗时。\n\nG1在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数`-XX:MaxGCPauseMillis`指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region。 \n\n这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。\n\n**将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决?**\n\n使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。\n\nG1的记忆集在存储结构的本质上是一种哈希表 ，Key是别的Region的起始地址 ，Value是一个集合 ，里面存储的元素是卡表的索引号 。 \n\n这 种双向的卡表结构(卡表是我指向谁，这种结构还记录了谁指向我)比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃 圾收集器有着更高的内存占用负担。\n\n根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。\n\n**G1收集器的运作过程大致可划分为以下四个步骤:**\n\n* 初始标记:仅仅只是标记一下GC Roots能直接关联到的对象。\n\n* 并发标记:从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。\n\n* 最终标记:对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。\n\n* 筛选回收:负责更新Region的统计数据，对各个`Region`的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分`Region`的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间，这里的操作涉及存活对象的移动，是必须**暂停用户线程**，由多条收集器线程并行完成的。\n\n<img src=\"https://img-blog.csdnimg.cn/84db616d120a43c0890d320154aca3c4.png\" style=\"zoom:50%;\" />\n\nG1从整体来看是基于标记-整理算法实现的收集器，但从局部(两个`Region `之间)上看又是基于标记-复制算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。\n\n这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。\n\n目前在小内存应用上CM S的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其 优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间\n\n**在并发标记阶段如何保证收集线程与用户线程互不干扰地运行?**\n\nCM S收集器采用增量更新算法实现，而G1 收集器则是通过原始快照(SATB)算法来实现的。\n\n**GC模式**\n\nG1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。\n\n> young gc\n\n发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。\n\n| 参数                    | 含义                                |\n| ----------------------- | ----------------------------------- |\n| -XX:MaxGCPauseMillis    | 设置G1收集过程目标时间，默认值200ms |\n| -XX:G1NewSizePercent    | 新生代最小值，默认值5%              |\n| -XX:G1MaxNewSizePercent | 新生代最大值，默认值60%             |\n\n> mixed gc\n\n当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。\n\nmixed gc中有一个阈值参数 `-XX:InitiatingHeapOccupancyPercent`，当老年代使用大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc\n\n> full gc\n\n如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。\n\n**参数：**\n\n-XX:InitiatingHeapOccupancyPercent，默认值是45%：\n\n- 老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。\n\n-XX:G1MixedGCCountTarget，在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次\n\n- 意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。\n\n-XX:G1HeapWastePercent，默认值是5%\n\n- 在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。\n\n# ZGC\n\nZGC是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器\n\nZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。","slug":"深入理解JVM虚拟机/垃圾收集器","published":1,"date":"2021-12-20T15:19:56.679Z","updated":"2021-12-20T15:48:29.544Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkk00k6fhji6ooibuiz","content":"<img src=\"https://img-blog.csdnimg.cn/94796d43894d49b7b80a52b63f692953.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h1><p>Serial收集器是最基础、历史最悠久的收集器，曾经(在JDK 1.3.1之前)是HotSpot虚拟机新生代收集器的唯一选择。</p>\n<p>这个收集器是一个单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>\n<img src=\"https://img-blog.csdnimg.cn/33bebd30b61743e48de9a90181004f69.png\" style=\"zoom:50%;\" />\n\n<p>它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器</p>\n<h1 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h1><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外 ，其余的Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>\n<img src=\"https://img-blog.csdnimg.cn/59c6c9cc2c024a9286ae9522fa1fa8b7.png\" style=\"zoom:50%;\" />\n\n<p>除了Serial收集器外，目前只有它能与CMS 收集器配合工作。</p>\n<p>在JDK 5发布时，HotSpot推出了一款垃圾收集器 ——CMS收集器。</p>\n<p>这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次 实现了让垃圾收集线程与用户线程(基本上)同时工作。</p>\n<p>在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者 Serial收集器中的一个。</p>\n<blockquote>\n<p>自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。</p>\n</blockquote>\n<p>官方希望它能完全被G1所取代，甚至还取消了ParNew加 Serial Old以及Serial加CMS这两组收集器组合的支持(其实原本也很少人这样使用)，并直接取消了<code>- XX:+UseParNewGC</code>参数。</p>\n<p>它默认开启的收集线程数与处理器核心数量相同</p>\n<p>可以使用<code>-XX:ParallelGCT hreads</code>参数来限制垃圾收集的线程数。</p>\n<ul>\n<li><p>并行(Parallel):并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。</p>\n</li>\n<li><p>并发(Concurrent):并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。</p>\n</li>\n</ul>\n<h1 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h1><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器</p>\n<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(<code>Throughput</code>)。</p>\n<p><strong>所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</strong></p>\n<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。</p>\n<p>Parallel Scavenge收集器还有一个参数<code>-XX:+UseAdaptiveSizePolicy</code>。</p>\n<p>这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小(<code>-Xmn</code>)、Eden与Survivor区 的 比 例、 晋 升老 年代对 象 大 小等 细 节 参 数</p>\n<p>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>\n<p>这种调节方式称为垃圾收集的<strong>自适应的调节策略(GC Ergonomics)</strong></p>\n<h1 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h1><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>\n<p>这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。</p>\n<p>如果在服务端模式下，它也可能有两种用途:</p>\n<ul>\n<li><p>一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。</p>\n</li>\n<li><p>另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent M ode Failure时使用。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/70e78dfa74d2429a886ac362a502e2f2.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h1><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实 现。</p>\n<p>在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>\n<img src=\"https://img-blog.csdnimg.cn/81f40d50d7ce4f28a88333ec61dde988.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h1><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。</p>\n<p>从名字(包含Mark Sweep)上就可以看出CMS收集器是基于标记-清除算法实现的：</p>\n<ul>\n<li><p>初始标记(CMS initial mark) </p>\n</li>\n<li><p>并发标记(CMS concurrent mark) </p>\n</li>\n<li><p>重新标记(CMS remark) </p>\n</li>\n<li><p>并发清除(CMS concurrent sweep)</p>\n</li>\n</ul>\n<p>其中初始标记、重新标记这两个步骤仍然需要Stop The World。</p>\n<ul>\n<li><p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</p>\n</li>\n<li><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</p>\n<p>在这个阶段的执行过程中，可能会产生很多变化：</p>\n<ul>\n<li><p>有些对象，从新生代晋升到了老年代； </p>\n</li>\n<li><p>有些对象，直接分配到了老年代； </p>\n</li>\n<li><p>老年代或者新生代的对象引用发生了变化。</p>\n</li>\n</ul>\n<p>在这个阶段受到影响的老年代对象所对应的卡页，会被标记为 dirty，用于后续重新标记阶段的扫描。</p>\n</li>\n<li><p>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短</p>\n</li>\n<li><p>并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>\n</li>\n</ul>\n<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的<strong>内存回收过程是与用户线程</strong>一起并发执行的。</p>\n<img src=\"https://img-blog.csdnimg.cn/69374386f15146ddb402650de4f0b71f.png\" style=\"zoom:50%;\" />\n\n<p>CM S是一款优秀的收集器，它最主要的优点在名字上已经体现出来:并发收集、低停顿，</p>\n<p><strong>CM S收集器至少有以下三个明显的 缺点:</strong></p>\n<ul>\n<li>CM S收集器对处理器资源非常敏感，因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量</li>\n</ul>\n<p><strong>CMS收集器无法处理浮动垃圾</strong></p>\n<p>有可能出现Con-current Mode Failure失败进而导致另一次完全Stop The World的Full GC的产生，在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分 垃圾对象是出现在标记过程结束以后，CM S无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</p>\n<p><strong>这一部分垃圾就称为浮动垃圾</strong></p>\n<p>同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待 到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。</p>\n<p>在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，如果 在实际应用中老年代增长并不是太快，可以适当调高参数<code>-XX:CMSInitiatingOccupancyFraction</code>的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。</p>\n<p>到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。</p>\n<p>要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次并发失败(Concurrent Mode Failure)，这时候虚拟机将不 得不启动后备预案:</p>\n<ul>\n<li>冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。</li>\n</ul>\n<p>所以参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置得太高将会很容易导致 大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。</p>\n<blockquote>\n<p>CMS是一款基于标记-清除算法实现的收集器，会有大量空间碎片产生。</p>\n</blockquote>\n<p>空间 碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找 到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</p>\n<p>为了解决这个问题， CMS收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数(默认是开启的，此参数从 JDK 9开始废弃)，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程</p>\n<p><strong>由于这个内存整理必须移动存活对象的。</strong> </p>\n<p>这样停顿时间又会变长，另外一个参数<code>-XX:CM SFullGCsBeforeCompaction</code>(此参数从JDK 9开始废弃)，这个参数的作用是要求CMS收集器在执行过若干次(数量由参数值决定)不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整理)。</p>\n<h1 id=\"Garbage-First\"><a href=\"#Garbage-First\" class=\"headerlink\" title=\"Garbage First\"></a>Garbage First</h1><p>G1是一款主要面向服务端应用的垃圾收集器。</p>\n<p>JDK 9发布之 日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器</p>\n<p>如果对JDK 9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃</p>\n<p>G1把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间：</p>\n<ul>\n<li><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。</p>\n</li>\n<li><p>G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p>\n</li>\n<li><p>每个Region的大小可以通过参数<code>-XX:G1Heap RegionSize</code>设 定，取值范围为1M B~32M B，且应为2的N次幂。</p>\n</li>\n</ul>\n<p>而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代 的一部分来进行看待</p>\n<p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域(不需要连续)的动态集合。</p>\n<blockquote>\n<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>\n<p>在垃圾收集过程中，G1收集器会记 录每个Region的回收耗时。</p>\n</blockquote>\n<p>G1在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数<code>-XX:MaxGCPauseMillis</code>指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region。 </p>\n<p>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>\n<p><strong>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决?</strong></p>\n<p>使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。</p>\n<p>G1的记忆集在存储结构的本质上是一种哈希表 ，Key是别的Region的起始地址 ，Value是一个集合 ，里面存储的元素是卡表的索引号 。 </p>\n<p>这 种双向的卡表结构(卡表是我指向谁，这种结构还记录了谁指向我)比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃 圾收集器有着更高的内存占用负担。</p>\n<p>根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。</p>\n<p><strong>G1收集器的运作过程大致可划分为以下四个步骤:</strong></p>\n<ul>\n<li><p>初始标记:仅仅只是标记一下GC Roots能直接关联到的对象。</p>\n</li>\n<li><p>并发标记:从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>\n</li>\n<li><p>最终标记:对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。</p>\n</li>\n<li><p>筛选回收:负责更新Region的统计数据，对各个<code>Region</code>的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分<code>Region</code>的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间，这里的操作涉及存活对象的移动，是必须<strong>暂停用户线程</strong>，由多条收集器线程并行完成的。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/84db616d120a43c0890d320154aca3c4.png\" style=\"zoom:50%;\" />\n\n<p>G1从整体来看是基于标记-整理算法实现的收集器，但从局部(两个<code>Region </code>之间)上看又是基于标记-复制算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。</p>\n<p>这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>\n<p>目前在小内存应用上CM S的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其 优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间</p>\n<p><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行?</strong></p>\n<p>CM S收集器采用增量更新算法实现，而G1 收集器则是通过原始快照(SATB)算法来实现的。</p>\n<p><strong>GC模式</strong></p>\n<p>G1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。</p>\n<blockquote>\n<p>young gc</p>\n</blockquote>\n<p>发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:MaxGCPauseMillis</td>\n<td>设置G1收集过程目标时间，默认值200ms</td>\n</tr>\n<tr>\n<td>-XX:G1NewSizePercent</td>\n<td>新生代最小值，默认值5%</td>\n</tr>\n<tr>\n<td>-XX:G1MaxNewSizePercent</td>\n<td>新生代最大值，默认值60%</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>mixed gc</p>\n</blockquote>\n<p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。</p>\n<p>mixed gc中有一个阈值参数 <code>-XX:InitiatingHeapOccupancyPercent</code>，当老年代使用大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc</p>\n<blockquote>\n<p>full gc</p>\n</blockquote>\n<p>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。</p>\n<p><strong>参数：</strong></p>\n<p>-XX:InitiatingHeapOccupancyPercent，默认值是45%：</p>\n<ul>\n<li>老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。</li>\n</ul>\n<p>-XX:G1MixedGCCountTarget，在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次</p>\n<ul>\n<li>意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。</li>\n</ul>\n<p>-XX:G1HeapWastePercent，默认值是5%</p>\n<ul>\n<li>在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</li>\n</ul>\n<h1 id=\"ZGC\"><a href=\"#ZGC\" class=\"headerlink\" title=\"ZGC\"></a>ZGC</h1><p>ZGC是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器</p>\n<p>ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>\n","site":{"data":{}},"excerpt":"","more":"<img src=\"https://img-blog.csdnimg.cn/94796d43894d49b7b80a52b63f692953.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h1><p>Serial收集器是最基础、历史最悠久的收集器，曾经(在JDK 1.3.1之前)是HotSpot虚拟机新生代收集器的唯一选择。</p>\n<p>这个收集器是一个单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。</p>\n<img src=\"https://img-blog.csdnimg.cn/33bebd30b61743e48de9a90181004f69.png\" style=\"zoom:50%;\" />\n\n<p>它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器</p>\n<h1 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h1><p>ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外 ，其余的Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。</p>\n<img src=\"https://img-blog.csdnimg.cn/59c6c9cc2c024a9286ae9522fa1fa8b7.png\" style=\"zoom:50%;\" />\n\n<p>除了Serial收集器外，目前只有它能与CMS 收集器配合工作。</p>\n<p>在JDK 5发布时，HotSpot推出了一款垃圾收集器 ——CMS收集器。</p>\n<p>这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次 实现了让垃圾收集线程与用户线程(基本上)同时工作。</p>\n<p>在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者 Serial收集器中的一个。</p>\n<blockquote>\n<p>自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。</p>\n</blockquote>\n<p>官方希望它能完全被G1所取代，甚至还取消了ParNew加 Serial Old以及Serial加CMS这两组收集器组合的支持(其实原本也很少人这样使用)，并直接取消了<code>- XX:+UseParNewGC</code>参数。</p>\n<p>它默认开启的收集线程数与处理器核心数量相同</p>\n<p>可以使用<code>-XX:ParallelGCT hreads</code>参数来限制垃圾收集的线程数。</p>\n<ul>\n<li><p>并行(Parallel):并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。</p>\n</li>\n<li><p>并发(Concurrent):并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。</p>\n</li>\n</ul>\n<h1 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h1><p>Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器</p>\n<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(<code>Throughput</code>)。</p>\n<p><strong>所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值</strong></p>\n<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的<code>-XX:MaxGCPauseMillis</code>参数以及直接设置吞吐量大小的<code>-XX:GCTimeRatio</code>参数。</p>\n<p>Parallel Scavenge收集器还有一个参数<code>-XX:+UseAdaptiveSizePolicy</code>。</p>\n<p>这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小(<code>-Xmn</code>)、Eden与Survivor区 的 比 例、 晋 升老 年代对 象 大 小等 细 节 参 数</p>\n<p>虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。</p>\n<p>这种调节方式称为垃圾收集的<strong>自适应的调节策略(GC Ergonomics)</strong></p>\n<h1 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h1><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。</p>\n<p>这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。</p>\n<p>如果在服务端模式下，它也可能有两种用途:</p>\n<ul>\n<li><p>一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。</p>\n</li>\n<li><p>另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent M ode Failure时使用。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/70e78dfa74d2429a886ac362a502e2f2.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h1><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实 现。</p>\n<p>在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。</p>\n<img src=\"https://img-blog.csdnimg.cn/81f40d50d7ce4f28a88333ec61dde988.png\" style=\"zoom:50%;\" />\n\n<h1 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h1><p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。</p>\n<p>从名字(包含Mark Sweep)上就可以看出CMS收集器是基于标记-清除算法实现的：</p>\n<ul>\n<li><p>初始标记(CMS initial mark) </p>\n</li>\n<li><p>并发标记(CMS concurrent mark) </p>\n</li>\n<li><p>重新标记(CMS remark) </p>\n</li>\n<li><p>并发清除(CMS concurrent sweep)</p>\n</li>\n</ul>\n<p>其中初始标记、重新标记这两个步骤仍然需要Stop The World。</p>\n<ul>\n<li><p>初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快</p>\n</li>\n<li><p>并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对 象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</p>\n<p>在这个阶段的执行过程中，可能会产生很多变化：</p>\n<ul>\n<li><p>有些对象，从新生代晋升到了老年代； </p>\n</li>\n<li><p>有些对象，直接分配到了老年代； </p>\n</li>\n<li><p>老年代或者新生代的对象引用发生了变化。</p>\n</li>\n</ul>\n<p>在这个阶段受到影响的老年代对象所对应的卡页，会被标记为 dirty，用于后续重新标记阶段的扫描。</p>\n</li>\n<li><p>重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短</p>\n</li>\n<li><p>并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的</p>\n</li>\n</ul>\n<p>由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的<strong>内存回收过程是与用户线程</strong>一起并发执行的。</p>\n<img src=\"https://img-blog.csdnimg.cn/69374386f15146ddb402650de4f0b71f.png\" style=\"zoom:50%;\" />\n\n<p>CM S是一款优秀的收集器，它最主要的优点在名字上已经体现出来:并发收集、低停顿，</p>\n<p><strong>CM S收集器至少有以下三个明显的 缺点:</strong></p>\n<ul>\n<li>CM S收集器对处理器资源非常敏感，因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量</li>\n</ul>\n<p><strong>CMS收集器无法处理浮动垃圾</strong></p>\n<p>有可能出现Con-current Mode Failure失败进而导致另一次完全Stop The World的Full GC的产生，在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分 垃圾对象是出现在标记过程结束以后，CM S无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</p>\n<p><strong>这一部分垃圾就称为浮动垃圾</strong></p>\n<p>同样也是由于在垃圾收集阶段用户线程还需要持续运行，那就还需要预留足够内存空间提供给用户线程使用，因此CMS收集器不能像其他收集器那样等待 到老年代几乎完全被填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。</p>\n<p>在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，如果 在实际应用中老年代增长并不是太快，可以适当调高参数<code>-XX:CMSInitiatingOccupancyFraction</code>的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。</p>\n<p>到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。</p>\n<p>要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次并发失败(Concurrent Mode Failure)，这时候虚拟机将不 得不启动后备预案:</p>\n<ul>\n<li>冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。</li>\n</ul>\n<p>所以参数<code>-XX:CMSInitiatingOccupancyFraction</code>设置得太高将会很容易导致 大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。</p>\n<blockquote>\n<p>CMS是一款基于标记-清除算法实现的收集器，会有大量空间碎片产生。</p>\n</blockquote>\n<p>空间 碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找 到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。</p>\n<p>为了解决这个问题， CMS收集器提供了一个<code>-XX:+UseCMSCompactAtFullCollection</code>开关参数(默认是开启的，此参数从 JDK 9开始废弃)，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程</p>\n<p><strong>由于这个内存整理必须移动存活对象的。</strong> </p>\n<p>这样停顿时间又会变长，另外一个参数<code>-XX:CM SFullGCsBeforeCompaction</code>(此参数从JDK 9开始废弃)，这个参数的作用是要求CMS收集器在执行过若干次(数量由参数值决定)不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整理)。</p>\n<h1 id=\"Garbage-First\"><a href=\"#Garbage-First\" class=\"headerlink\" title=\"Garbage First\"></a>Garbage First</h1><p>G1是一款主要面向服务端应用的垃圾收集器。</p>\n<p>JDK 9发布之 日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器</p>\n<p>如果对JDK 9及以上版本的HotSpot虚拟机使用参数<code>-XX:+UseConcMarkSweepGC</code>来开启CMS收集器的话，用户会收到一个警告信息，提示CMS未来将会被废弃</p>\n<p>G1把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间：</p>\n<ul>\n<li><p>Region中还有一类特殊的Humongous区域，专门用来存储大对象。</p>\n</li>\n<li><p>G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。</p>\n</li>\n<li><p>每个Region的大小可以通过参数<code>-XX:G1Heap RegionSize</code>设 定，取值范围为1M B~32M B，且应为2的N次幂。</p>\n</li>\n</ul>\n<p>而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代 的一部分来进行看待</p>\n<p>虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区 域(不需要连续)的动态集合。</p>\n<blockquote>\n<p>G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。</p>\n<p>在垃圾收集过程中，G1收集器会记 录每个Region的回收耗时。</p>\n</blockquote>\n<p>G1在后台维护一 个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数<code>-XX:MaxGCPauseMillis</code>指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region。 </p>\n<p>这种使用Region划分内存空间，以及具有优先级的区域回收方式，保证了G1收集器在有限的时间内获取尽可能高的收集效率。</p>\n<p><strong>将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决?</strong></p>\n<p>使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。</p>\n<p>G1的记忆集在存储结构的本质上是一种哈希表 ，Key是别的Region的起始地址 ，Value是一个集合 ，里面存储的元素是卡表的索引号 。 </p>\n<p>这 种双向的卡表结构(卡表是我指向谁，这种结构还记录了谁指向我)比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃 圾收集器有着更高的内存占用负担。</p>\n<p>根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。</p>\n<p><strong>G1收集器的运作过程大致可划分为以下四个步骤:</strong></p>\n<ul>\n<li><p>初始标记:仅仅只是标记一下GC Roots能直接关联到的对象。</p>\n</li>\n<li><p>并发标记:从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆 里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。</p>\n</li>\n<li><p>最终标记:对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留 下来的最后那少量的SATB记录。</p>\n</li>\n<li><p>筛选回收:负责更新Region的统计数据，对各个<code>Region</code>的回 收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分<code>Region</code>的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间，这里的操作涉及存活对象的移动，是必须<strong>暂停用户线程</strong>，由多条收集器线程并行完成的。</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/84db616d120a43c0890d320154aca3c4.png\" style=\"zoom:50%;\" />\n\n<p>G1从整体来看是基于标记-整理算法实现的收集器，但从局部(两个<code>Region </code>之间)上看又是基于标记-复制算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存 空间碎片，垃圾收集完成之后能提供规整的可用内存。</p>\n<p>这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。</p>\n<p>目前在小内存应用上CM S的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其 优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间</p>\n<p><strong>在并发标记阶段如何保证收集线程与用户线程互不干扰地运行?</strong></p>\n<p>CM S收集器采用增量更新算法实现，而G1 收集器则是通过原始快照(SATB)算法来实现的。</p>\n<p><strong>GC模式</strong></p>\n<p>G1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。</p>\n<blockquote>\n<p>young gc</p>\n</blockquote>\n<p>发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>-XX:MaxGCPauseMillis</td>\n<td>设置G1收集过程目标时间，默认值200ms</td>\n</tr>\n<tr>\n<td>-XX:G1NewSizePercent</td>\n<td>新生代最小值，默认值5%</td>\n</tr>\n<tr>\n<td>-XX:G1MaxNewSizePercent</td>\n<td>新生代最大值，默认值60%</td>\n</tr>\n</tbody></table>\n<blockquote>\n<p>mixed gc</p>\n</blockquote>\n<p>当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。</p>\n<p>mixed gc中有一个阈值参数 <code>-XX:InitiatingHeapOccupancyPercent</code>，当老年代使用大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc</p>\n<blockquote>\n<p>full gc</p>\n</blockquote>\n<p>如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。</p>\n<p><strong>参数：</strong></p>\n<p>-XX:InitiatingHeapOccupancyPercent，默认值是45%：</p>\n<ul>\n<li>老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。</li>\n</ul>\n<p>-XX:G1MixedGCCountTarget，在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次</p>\n<ul>\n<li>意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。</li>\n</ul>\n<p>-XX:G1HeapWastePercent，默认值是5%</p>\n<ul>\n<li>在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。</li>\n</ul>\n<h1 id=\"ZGC\"><a href=\"#ZGC\" class=\"headerlink\" title=\"ZGC\"></a>ZGC</h1><p>ZGC是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器</p>\n<p>ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。</p>\n"},{"title":"即时编译器","_content":"\n书籍地址：https://book.douban.com/subject/34907497/\n\n**HotSpot VM**\n\nSun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机。\n\nJava 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈\n\n<img src=\"https://img-blog.csdnimg.cn/80d300c0670c47d588ea465e88326fee.png\" alt=\"img\" style=\"zoom:25%;\" />\n\n\n\n栈帧的创建是需要耗费资源的，尤其是对于 Java 中常见的 getter、setter 方法来说，这些代码通常只有一行，每次都创建栈帧的话就太浪费了\n\n另外，Java 虚拟机栈对代码的执行，采用的是字节码解释的方式，考虑到下面这段代码，变量 a 声明之后，就再也不被使用，要是按照字节码指令解释执行的话，就要做很多无用功\n\n```java\npublic class A{\n    int attr = 0;\n    public void test(){\n        int a = attr;\n        System.out.println(\"ok\");\n    }\n}\n```\n\n下面是这段代码的字节码指令，我们能够看到 `aload_0，getfield ，istore_1`这三个无用的字节码指令操作\n\n```java\n public void test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field attr:I\n         4: istore_1\n         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         8: ldc           #4                  // String ok\n        10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        13: return\n      LineNumberTable:\n        line 4: 0\n        line 5: 5\n        line 6: 13\n```\n\n垃圾回收器回收的目标区域主要是堆，堆上创建的对象越多，GC 的压力就越大。\n\n要是能把一些变量，直接在栈上分配，那 GC 的压力就会小一些，其实，我们说的这几个优化的可能性，JVM 已经通过 JIT 编译器（Just In Time Compiler）去做了，JIT 最主要的目标是把解释执行变成编译执行\n\n为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，这就是 JIT 编译器的功能\n\n<img src=\"https://img-blog.csdnimg.cn/94457d30db0a402dbe75080fd150cd01.png\" alt=\"img\" style=\"zoom:25%;\" />\n\nJVM 会将调用次数很高，或者在 for 循环里频繁被使用的代码，编译成机器码，然后缓存在 CodeCache 区域里，下次调用相同方法的时候，就可以直接使用\n\n**方法内联**\n\n它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。\n\n这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念\n\n可以使用 `-XX:-Inline` 参数来禁用方法内联，如果想要更细粒度的控制，可以使用 CompileCommand 参数，例如`-XX:CompileCommand=exclude,java/lang/String.indexOf`，JMH 就是使用这个参数来实现的自定义编译特性。\n\n在 JDK 的源码里，也有很多被 [@ForceInline ]() 注解的方法，这些方法，会在执行的时候被强制进行内联；而被 [@DontInline ]() 注解的方法，则始终不会被内联\n\n**Code Cache**\n\nJIT 编译之后的二进制代码，是放在 Code Cache 区域里的。这个区域的大小是固定的，而且一旦启动无法扩容。\n\n如果 Code Cache 满了，JVM 并不会报错，但会停止编译。所以编译执行就会退化为解释执行，性能就会降低。不仅如此，JIT 编译器会一直尝试去优化你的代码，造成 CPU 占用上升\n\n通过参数`-XX:ReservedCodeCacheSize`可以指定 Code Cache 区域的大小，如果你通过监控发现空间达到了上限，就要适当的增加它的大小\n\nCode Cache 的容量达到上限，会影响程序执行的效率，但除非你有特别多的代码，默认的 240M 一般来说，足够用了\n\n**新一代即时编译器**\n\n对需要长时间运行的应用来说，由于经过充分预热，热点代码会被HotSpot的探测机制准确定位捕获，并将其编译为物理硬件可直接执行的机器码，在这类应用中Java的运行效率很大程度上取决于即时编译器所输出的代码质量。\n\n> HotSpot虚拟机中含有两个即时编译器：\n\n分别是编译耗时短但输出代码优化程度较低的客户端编译器(简称为C1)以及编译耗时长但输出代码优化质量也更高的服务端编译器(简称为C2)，通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统。\n\n> 自JDK 10起，HotSpot中又加入了一个全新的即时编译器:Graal编译器。\n\n使用 jstack 命令获得的线程信息，经常能看到它们的身影\n\n使用额外线程进行即时编译，可以不用阻塞解释执行的逻辑。\n\nJIT 通常会在触发之后就在后台运行，编译完成之后就将相应的字节码替换为编译后的代码\n\nJIT 编译方式有两种：一种是编译方法，另一种是编译循环\n\n在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的总和，超过由参数`-XX:CompileThreshold`指定的阈值时，便会触发即时编译；但当启用分层编译时，这个参数将会失效，会采用一套动态调整进行调整\n\n我们可以通过 java -version命令行可以直接查看到当前系统使用的编译模式：\n\n```\nC:\\Users\\Administrator>java -version\njava version \"1.8.0_45\"\nJava(TM) SE Runtime Environment (build 1.8.0_45-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)\n```\n\nmixed mode代表是默认的混合编译模式，除了这种模式外，我们还可以使用`-Xint`参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数`-Xcomp`强制虚拟机运行于只有 JIT 的编译模式下\n\n**逃逸分析**\n\n通过逃逸分析，JVM 能够分析出一个新的对象的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析现在是 JVM 的默认行为，可以通过参数 `-XX:-DoEscapeAnalysis`关掉它\n\n> 什么样的对象算是逃逸的呢？\n\n可以看一下下面的两种典型情况\n\n如代码所示，对象被赋值给成员变量或者静态变量，可能被外部使用，变量就发生了逃逸\n\n```java\npublic class EscapeAttr {\n    Object attr;\n    public void test() {\n        attr = new Object();\n    }\n}\n```\n\n再看下面这段代码，对象通过 return 语句返回。由于程序并不能确定这个对象后续会不会被使用，外部的线程能够访问到这个结果，对象也发生了逃逸\n\n```java\npublic class EscapeReturn {\n    Object attr;\n    public Object test() {\n        Object obj = new Object();\n        return obj;\n    }\n}\n```\n\n**那逃逸分析有什么好处呢？**\n\n> 栈上分配\n\n如果一个对象在子程序中被分配，指向该对象的指针永远不会逃逸，对象有可能会被优化为栈分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再分配到堆空间，可以有效地减少 GC 的压力\n\n> 分离对象或标量替换\n\nJIT 可以将对象打散，全部替换为一个个小的局部变量，这个打散的过程，就叫作标量替换（标量就是不能被进一步分割的变量，比如 int、long 等基本类型）。也就是说，标量替换后的对象，全部变成了局部变量，可以方便地进行栈上分配，而无须改动其他的代码\n\n并不是所有的对象或者数组，都会在堆上分配。由于JIT的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成栈分配\n\n> 同步消除\n\n如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步，注意这是针对 synchronized 来说的，JUC 中的 Lock 并不能被消除\n\n要开启同步消除，需要加上`-XX:+EliminateLocks`参数。由于这个参数依赖逃逸分析，所以同时要打开`-XX:+DoEscapeAnalysis`选项\n\n比如下面这段代码，JIT 判断对象锁只能被一个线程访问，就可以去掉这个同步的影响\n\n```java\npublic class SyncEliminate {\n    public void test() {\n        synchronized (new Object()) {\n        }\n    }\n}\n```\n\n**JITWatch**\n\n可以使用 jitwatch 工具来观测 JIT 的一些行为\n\nhttps://github.com/AdoptOpenJDK/jitwatch","source":"_posts/深入理解JVM虚拟机/即时编译器.md","raw":"---\ntitle: 即时编译器\ncategories: \n- 深入理解JVM虚拟机\n---\n\n书籍地址：https://book.douban.com/subject/34907497/\n\n**HotSpot VM**\n\nSun/OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机。\n\nJava 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈\n\n<img src=\"https://img-blog.csdnimg.cn/80d300c0670c47d588ea465e88326fee.png\" alt=\"img\" style=\"zoom:25%;\" />\n\n\n\n栈帧的创建是需要耗费资源的，尤其是对于 Java 中常见的 getter、setter 方法来说，这些代码通常只有一行，每次都创建栈帧的话就太浪费了\n\n另外，Java 虚拟机栈对代码的执行，采用的是字节码解释的方式，考虑到下面这段代码，变量 a 声明之后，就再也不被使用，要是按照字节码指令解释执行的话，就要做很多无用功\n\n```java\npublic class A{\n    int attr = 0;\n    public void test(){\n        int a = attr;\n        System.out.println(\"ok\");\n    }\n}\n```\n\n下面是这段代码的字节码指令，我们能够看到 `aload_0，getfield ，istore_1`这三个无用的字节码指令操作\n\n```java\n public void test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field attr:I\n         4: istore_1\n         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         8: ldc           #4                  // String ok\n        10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        13: return\n      LineNumberTable:\n        line 4: 0\n        line 5: 5\n        line 6: 13\n```\n\n垃圾回收器回收的目标区域主要是堆，堆上创建的对象越多，GC 的压力就越大。\n\n要是能把一些变量，直接在栈上分配，那 GC 的压力就会小一些，其实，我们说的这几个优化的可能性，JVM 已经通过 JIT 编译器（Just In Time Compiler）去做了，JIT 最主要的目标是把解释执行变成编译执行\n\n为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，这就是 JIT 编译器的功能\n\n<img src=\"https://img-blog.csdnimg.cn/94457d30db0a402dbe75080fd150cd01.png\" alt=\"img\" style=\"zoom:25%;\" />\n\nJVM 会将调用次数很高，或者在 for 循环里频繁被使用的代码，编译成机器码，然后缓存在 CodeCache 区域里，下次调用相同方法的时候，就可以直接使用\n\n**方法内联**\n\n它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。\n\n这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念\n\n可以使用 `-XX:-Inline` 参数来禁用方法内联，如果想要更细粒度的控制，可以使用 CompileCommand 参数，例如`-XX:CompileCommand=exclude,java/lang/String.indexOf`，JMH 就是使用这个参数来实现的自定义编译特性。\n\n在 JDK 的源码里，也有很多被 [@ForceInline ]() 注解的方法，这些方法，会在执行的时候被强制进行内联；而被 [@DontInline ]() 注解的方法，则始终不会被内联\n\n**Code Cache**\n\nJIT 编译之后的二进制代码，是放在 Code Cache 区域里的。这个区域的大小是固定的，而且一旦启动无法扩容。\n\n如果 Code Cache 满了，JVM 并不会报错，但会停止编译。所以编译执行就会退化为解释执行，性能就会降低。不仅如此，JIT 编译器会一直尝试去优化你的代码，造成 CPU 占用上升\n\n通过参数`-XX:ReservedCodeCacheSize`可以指定 Code Cache 区域的大小，如果你通过监控发现空间达到了上限，就要适当的增加它的大小\n\nCode Cache 的容量达到上限，会影响程序执行的效率，但除非你有特别多的代码，默认的 240M 一般来说，足够用了\n\n**新一代即时编译器**\n\n对需要长时间运行的应用来说，由于经过充分预热，热点代码会被HotSpot的探测机制准确定位捕获，并将其编译为物理硬件可直接执行的机器码，在这类应用中Java的运行效率很大程度上取决于即时编译器所输出的代码质量。\n\n> HotSpot虚拟机中含有两个即时编译器：\n\n分别是编译耗时短但输出代码优化程度较低的客户端编译器(简称为C1)以及编译耗时长但输出代码优化质量也更高的服务端编译器(简称为C2)，通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统。\n\n> 自JDK 10起，HotSpot中又加入了一个全新的即时编译器:Graal编译器。\n\n使用 jstack 命令获得的线程信息，经常能看到它们的身影\n\n使用额外线程进行即时编译，可以不用阻塞解释执行的逻辑。\n\nJIT 通常会在触发之后就在后台运行，编译完成之后就将相应的字节码替换为编译后的代码\n\nJIT 编译方式有两种：一种是编译方法，另一种是编译循环\n\n在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的总和，超过由参数`-XX:CompileThreshold`指定的阈值时，便会触发即时编译；但当启用分层编译时，这个参数将会失效，会采用一套动态调整进行调整\n\n我们可以通过 java -version命令行可以直接查看到当前系统使用的编译模式：\n\n```\nC:\\Users\\Administrator>java -version\njava version \"1.8.0_45\"\nJava(TM) SE Runtime Environment (build 1.8.0_45-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)\n```\n\nmixed mode代表是默认的混合编译模式，除了这种模式外，我们还可以使用`-Xint`参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数`-Xcomp`强制虚拟机运行于只有 JIT 的编译模式下\n\n**逃逸分析**\n\n通过逃逸分析，JVM 能够分析出一个新的对象的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析现在是 JVM 的默认行为，可以通过参数 `-XX:-DoEscapeAnalysis`关掉它\n\n> 什么样的对象算是逃逸的呢？\n\n可以看一下下面的两种典型情况\n\n如代码所示，对象被赋值给成员变量或者静态变量，可能被外部使用，变量就发生了逃逸\n\n```java\npublic class EscapeAttr {\n    Object attr;\n    public void test() {\n        attr = new Object();\n    }\n}\n```\n\n再看下面这段代码，对象通过 return 语句返回。由于程序并不能确定这个对象后续会不会被使用，外部的线程能够访问到这个结果，对象也发生了逃逸\n\n```java\npublic class EscapeReturn {\n    Object attr;\n    public Object test() {\n        Object obj = new Object();\n        return obj;\n    }\n}\n```\n\n**那逃逸分析有什么好处呢？**\n\n> 栈上分配\n\n如果一个对象在子程序中被分配，指向该对象的指针永远不会逃逸，对象有可能会被优化为栈分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再分配到堆空间，可以有效地减少 GC 的压力\n\n> 分离对象或标量替换\n\nJIT 可以将对象打散，全部替换为一个个小的局部变量，这个打散的过程，就叫作标量替换（标量就是不能被进一步分割的变量，比如 int、long 等基本类型）。也就是说，标量替换后的对象，全部变成了局部变量，可以方便地进行栈上分配，而无须改动其他的代码\n\n并不是所有的对象或者数组，都会在堆上分配。由于JIT的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成栈分配\n\n> 同步消除\n\n如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步，注意这是针对 synchronized 来说的，JUC 中的 Lock 并不能被消除\n\n要开启同步消除，需要加上`-XX:+EliminateLocks`参数。由于这个参数依赖逃逸分析，所以同时要打开`-XX:+DoEscapeAnalysis`选项\n\n比如下面这段代码，JIT 判断对象锁只能被一个线程访问，就可以去掉这个同步的影响\n\n```java\npublic class SyncEliminate {\n    public void test() {\n        synchronized (new Object()) {\n        }\n    }\n}\n```\n\n**JITWatch**\n\n可以使用 jitwatch 工具来观测 JIT 的一些行为\n\nhttps://github.com/AdoptOpenJDK/jitwatch","slug":"深入理解JVM虚拟机/即时编译器","published":1,"date":"2021-12-25T11:48:55.385Z","updated":"2021-12-26T16:12:23.114Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkl00k9fhji02rl1log","content":"<p>书籍地址：<a href=\"https://book.douban.com/subject/34907497/\">https://book.douban.com/subject/34907497/</a></p>\n<p><strong>HotSpot VM</strong></p>\n<p>Sun&#x2F;OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机。</p>\n<p>Java 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈</p>\n<img src=\"https://img-blog.csdnimg.cn/80d300c0670c47d588ea465e88326fee.png\" alt=\"img\" style=\"zoom:25%;\" />\n\n\n\n<p>栈帧的创建是需要耗费资源的，尤其是对于 Java 中常见的 getter、setter 方法来说，这些代码通常只有一行，每次都创建栈帧的话就太浪费了</p>\n<p>另外，Java 虚拟机栈对代码的执行，采用的是字节码解释的方式，考虑到下面这段代码，变量 a 声明之后，就再也不被使用，要是按照字节码指令解释执行的话，就要做很多无用功</p>\n<pre><code class=\"java\">public class A&#123;\n    int attr = 0;\n    public void test()&#123;\n        int a = attr;\n        System.out.println(&quot;ok&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>下面是这段代码的字节码指令，我们能够看到 <code>aload_0，getfield ，istore_1</code>这三个无用的字节码指令操作</p>\n<pre><code class=\"java\"> public void test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field attr:I\n         4: istore_1\n         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         8: ldc           #4                  // String ok\n        10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        13: return\n      LineNumberTable:\n        line 4: 0\n        line 5: 5\n        line 6: 13\n</code></pre>\n<p>垃圾回收器回收的目标区域主要是堆，堆上创建的对象越多，GC 的压力就越大。</p>\n<p>要是能把一些变量，直接在栈上分配，那 GC 的压力就会小一些，其实，我们说的这几个优化的可能性，JVM 已经通过 JIT 编译器（Just In Time Compiler）去做了，JIT 最主要的目标是把解释执行变成编译执行</p>\n<p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，这就是 JIT 编译器的功能</p>\n<img src=\"https://img-blog.csdnimg.cn/94457d30db0a402dbe75080fd150cd01.png\" alt=\"img\" style=\"zoom:25%;\" />\n\n<p>JVM 会将调用次数很高，或者在 for 循环里频繁被使用的代码，编译成机器码，然后缓存在 CodeCache 区域里，下次调用相同方法的时候，就可以直接使用</p>\n<p><strong>方法内联</strong></p>\n<p>它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。</p>\n<p>这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念</p>\n<p>可以使用 <code>-XX:-Inline</code> 参数来禁用方法内联，如果想要更细粒度的控制，可以使用 CompileCommand 参数，例如<code>-XX:CompileCommand=exclude,java/lang/String.indexOf</code>，JMH 就是使用这个参数来实现的自定义编译特性。</p>\n<p>在 JDK 的源码里，也有很多被 <a href=\"\">@ForceInline </a> 注解的方法，这些方法，会在执行的时候被强制进行内联；而被 <a href=\"\">@DontInline </a> 注解的方法，则始终不会被内联</p>\n<p><strong>Code Cache</strong></p>\n<p>JIT 编译之后的二进制代码，是放在 Code Cache 区域里的。这个区域的大小是固定的，而且一旦启动无法扩容。</p>\n<p>如果 Code Cache 满了，JVM 并不会报错，但会停止编译。所以编译执行就会退化为解释执行，性能就会降低。不仅如此，JIT 编译器会一直尝试去优化你的代码，造成 CPU 占用上升</p>\n<p>通过参数<code>-XX:ReservedCodeCacheSize</code>可以指定 Code Cache 区域的大小，如果你通过监控发现空间达到了上限，就要适当的增加它的大小</p>\n<p>Code Cache 的容量达到上限，会影响程序执行的效率，但除非你有特别多的代码，默认的 240M 一般来说，足够用了</p>\n<p><strong>新一代即时编译器</strong></p>\n<p>对需要长时间运行的应用来说，由于经过充分预热，热点代码会被HotSpot的探测机制准确定位捕获，并将其编译为物理硬件可直接执行的机器码，在这类应用中Java的运行效率很大程度上取决于即时编译器所输出的代码质量。</p>\n<blockquote>\n<p>HotSpot虚拟机中含有两个即时编译器：</p>\n</blockquote>\n<p>分别是编译耗时短但输出代码优化程度较低的客户端编译器(简称为C1)以及编译耗时长但输出代码优化质量也更高的服务端编译器(简称为C2)，通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统。</p>\n<blockquote>\n<p>自JDK 10起，HotSpot中又加入了一个全新的即时编译器:Graal编译器。</p>\n</blockquote>\n<p>使用 jstack 命令获得的线程信息，经常能看到它们的身影</p>\n<p>使用额外线程进行即时编译，可以不用阻塞解释执行的逻辑。</p>\n<p>JIT 通常会在触发之后就在后台运行，编译完成之后就将相应的字节码替换为编译后的代码</p>\n<p>JIT 编译方式有两种：一种是编译方法，另一种是编译循环</p>\n<p>在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的总和，超过由参数<code>-XX:CompileThreshold</code>指定的阈值时，便会触发即时编译；但当启用分层编译时，这个参数将会失效，会采用一套动态调整进行调整</p>\n<p>我们可以通过 java -version命令行可以直接查看到当前系统使用的编译模式：</p>\n<pre><code>C:\\Users\\Administrator&gt;java -version\njava version &quot;1.8.0_45&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_45-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)\n</code></pre>\n<p>mixed mode代表是默认的混合编译模式，除了这种模式外，我们还可以使用<code>-Xint</code>参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数<code>-Xcomp</code>强制虚拟机运行于只有 JIT 的编译模式下</p>\n<p><strong>逃逸分析</strong></p>\n<p>通过逃逸分析，JVM 能够分析出一个新的对象的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析现在是 JVM 的默认行为，可以通过参数 <code>-XX:-DoEscapeAnalysis</code>关掉它</p>\n<blockquote>\n<p>什么样的对象算是逃逸的呢？</p>\n</blockquote>\n<p>可以看一下下面的两种典型情况</p>\n<p>如代码所示，对象被赋值给成员变量或者静态变量，可能被外部使用，变量就发生了逃逸</p>\n<pre><code class=\"java\">public class EscapeAttr &#123;\n    Object attr;\n    public void test() &#123;\n        attr = new Object();\n    &#125;\n&#125;\n</code></pre>\n<p>再看下面这段代码，对象通过 return 语句返回。由于程序并不能确定这个对象后续会不会被使用，外部的线程能够访问到这个结果，对象也发生了逃逸</p>\n<pre><code class=\"java\">public class EscapeReturn &#123;\n    Object attr;\n    public Object test() &#123;\n        Object obj = new Object();\n        return obj;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>那逃逸分析有什么好处呢？</strong></p>\n<blockquote>\n<p>栈上分配</p>\n</blockquote>\n<p>如果一个对象在子程序中被分配，指向该对象的指针永远不会逃逸，对象有可能会被优化为栈分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再分配到堆空间，可以有效地减少 GC 的压力</p>\n<blockquote>\n<p>分离对象或标量替换</p>\n</blockquote>\n<p>JIT 可以将对象打散，全部替换为一个个小的局部变量，这个打散的过程，就叫作标量替换（标量就是不能被进一步分割的变量，比如 int、long 等基本类型）。也就是说，标量替换后的对象，全部变成了局部变量，可以方便地进行栈上分配，而无须改动其他的代码</p>\n<p>并不是所有的对象或者数组，都会在堆上分配。由于JIT的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成栈分配</p>\n<blockquote>\n<p>同步消除</p>\n</blockquote>\n<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步，注意这是针对 synchronized 来说的，JUC 中的 Lock 并不能被消除</p>\n<p>要开启同步消除，需要加上<code>-XX:+EliminateLocks</code>参数。由于这个参数依赖逃逸分析，所以同时要打开<code>-XX:+DoEscapeAnalysis</code>选项</p>\n<p>比如下面这段代码，JIT 判断对象锁只能被一个线程访问，就可以去掉这个同步的影响</p>\n<pre><code class=\"java\">public class SyncEliminate &#123;\n    public void test() &#123;\n        synchronized (new Object()) &#123;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>JITWatch</strong></p>\n<p>可以使用 jitwatch 工具来观测 JIT 的一些行为</p>\n<p><a href=\"https://github.com/AdoptOpenJDK/jitwatch\">https://github.com/AdoptOpenJDK/jitwatch</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>书籍地址：<a href=\"https://book.douban.com/subject/34907497/\">https://book.douban.com/subject/34907497/</a></p>\n<p><strong>HotSpot VM</strong></p>\n<p>Sun&#x2F;OracleJDK和OpenJDK中的默认Java虚拟机，也是目前使用范围最广的Java虚拟机。</p>\n<p>Java 虚拟机栈，其实是一个双层的栈，如下图所示，第一层就是针对 method 的栈帧，第二层是针对字节码指令的操作数栈</p>\n<img src=\"https://img-blog.csdnimg.cn/80d300c0670c47d588ea465e88326fee.png\" alt=\"img\" style=\"zoom:25%;\" />\n\n\n\n<p>栈帧的创建是需要耗费资源的，尤其是对于 Java 中常见的 getter、setter 方法来说，这些代码通常只有一行，每次都创建栈帧的话就太浪费了</p>\n<p>另外，Java 虚拟机栈对代码的执行，采用的是字节码解释的方式，考虑到下面这段代码，变量 a 声明之后，就再也不被使用，要是按照字节码指令解释执行的话，就要做很多无用功</p>\n<pre><code class=\"java\">public class A&#123;\n    int attr = 0;\n    public void test()&#123;\n        int a = attr;\n        System.out.println(&quot;ok&quot;);\n    &#125;\n&#125;\n</code></pre>\n<p>下面是这段代码的字节码指令，我们能够看到 <code>aload_0，getfield ，istore_1</code>这三个无用的字节码指令操作</p>\n<pre><code class=\"java\"> public void test();\n    descriptor: ()V\n    flags: ACC_PUBLIC\n    Code:\n      stack=2, locals=2, args_size=1\n         0: aload_0\n         1: getfield      #2                  // Field attr:I\n         4: istore_1\n         5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;\n         8: ldc           #4                  // String ok\n        10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V\n        13: return\n      LineNumberTable:\n        line 4: 0\n        line 5: 5\n        line 6: 13\n</code></pre>\n<p>垃圾回收器回收的目标区域主要是堆，堆上创建的对象越多，GC 的压力就越大。</p>\n<p>要是能把一些变量，直接在栈上分配，那 GC 的压力就会小一些，其实，我们说的这几个优化的可能性，JVM 已经通过 JIT 编译器（Just In Time Compiler）去做了，JIT 最主要的目标是把解释执行变成编译执行</p>\n<p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，这就是 JIT 编译器的功能</p>\n<img src=\"https://img-blog.csdnimg.cn/94457d30db0a402dbe75080fd150cd01.png\" alt=\"img\" style=\"zoom:25%;\" />\n\n<p>JVM 会将调用次数很高，或者在 for 循环里频繁被使用的代码，编译成机器码，然后缓存在 CodeCache 区域里，下次调用相同方法的时候，就可以直接使用</p>\n<p><strong>方法内联</strong></p>\n<p>它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。</p>\n<p>这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念</p>\n<p>可以使用 <code>-XX:-Inline</code> 参数来禁用方法内联，如果想要更细粒度的控制，可以使用 CompileCommand 参数，例如<code>-XX:CompileCommand=exclude,java/lang/String.indexOf</code>，JMH 就是使用这个参数来实现的自定义编译特性。</p>\n<p>在 JDK 的源码里，也有很多被 <a href=\"\">@ForceInline </a> 注解的方法，这些方法，会在执行的时候被强制进行内联；而被 <a href=\"\">@DontInline </a> 注解的方法，则始终不会被内联</p>\n<p><strong>Code Cache</strong></p>\n<p>JIT 编译之后的二进制代码，是放在 Code Cache 区域里的。这个区域的大小是固定的，而且一旦启动无法扩容。</p>\n<p>如果 Code Cache 满了，JVM 并不会报错，但会停止编译。所以编译执行就会退化为解释执行，性能就会降低。不仅如此，JIT 编译器会一直尝试去优化你的代码，造成 CPU 占用上升</p>\n<p>通过参数<code>-XX:ReservedCodeCacheSize</code>可以指定 Code Cache 区域的大小，如果你通过监控发现空间达到了上限，就要适当的增加它的大小</p>\n<p>Code Cache 的容量达到上限，会影响程序执行的效率，但除非你有特别多的代码，默认的 240M 一般来说，足够用了</p>\n<p><strong>新一代即时编译器</strong></p>\n<p>对需要长时间运行的应用来说，由于经过充分预热，热点代码会被HotSpot的探测机制准确定位捕获，并将其编译为物理硬件可直接执行的机器码，在这类应用中Java的运行效率很大程度上取决于即时编译器所输出的代码质量。</p>\n<blockquote>\n<p>HotSpot虚拟机中含有两个即时编译器：</p>\n</blockquote>\n<p>分别是编译耗时短但输出代码优化程度较低的客户端编译器(简称为C1)以及编译耗时长但输出代码优化质量也更高的服务端编译器(简称为C2)，通常它们会在分层编译机制下与解释器互相配合来共同构成HotSpot虚拟机的执行子系统。</p>\n<blockquote>\n<p>自JDK 10起，HotSpot中又加入了一个全新的即时编译器:Graal编译器。</p>\n</blockquote>\n<p>使用 jstack 命令获得的线程信息，经常能看到它们的身影</p>\n<p>使用额外线程进行即时编译，可以不用阻塞解释执行的逻辑。</p>\n<p>JIT 通常会在触发之后就在后台运行，编译完成之后就将相应的字节码替换为编译后的代码</p>\n<p>JIT 编译方式有两种：一种是编译方法，另一种是编译循环</p>\n<p>在不启用分层编译的情况下，当方法的调用次数和循环回边的次数的总和，超过由参数<code>-XX:CompileThreshold</code>指定的阈值时，便会触发即时编译；但当启用分层编译时，这个参数将会失效，会采用一套动态调整进行调整</p>\n<p>我们可以通过 java -version命令行可以直接查看到当前系统使用的编译模式：</p>\n<pre><code>C:\\Users\\Administrator&gt;java -version\njava version &quot;1.8.0_45&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_45-b14)\nJava HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)\n</code></pre>\n<p>mixed mode代表是默认的混合编译模式，除了这种模式外，我们还可以使用<code>-Xint</code>参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数<code>-Xcomp</code>强制虚拟机运行于只有 JIT 的编译模式下</p>\n<p><strong>逃逸分析</strong></p>\n<p>通过逃逸分析，JVM 能够分析出一个新的对象的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析现在是 JVM 的默认行为，可以通过参数 <code>-XX:-DoEscapeAnalysis</code>关掉它</p>\n<blockquote>\n<p>什么样的对象算是逃逸的呢？</p>\n</blockquote>\n<p>可以看一下下面的两种典型情况</p>\n<p>如代码所示，对象被赋值给成员变量或者静态变量，可能被外部使用，变量就发生了逃逸</p>\n<pre><code class=\"java\">public class EscapeAttr &#123;\n    Object attr;\n    public void test() &#123;\n        attr = new Object();\n    &#125;\n&#125;\n</code></pre>\n<p>再看下面这段代码，对象通过 return 语句返回。由于程序并不能确定这个对象后续会不会被使用，外部的线程能够访问到这个结果，对象也发生了逃逸</p>\n<pre><code class=\"java\">public class EscapeReturn &#123;\n    Object attr;\n    public Object test() &#123;\n        Object obj = new Object();\n        return obj;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>那逃逸分析有什么好处呢？</strong></p>\n<blockquote>\n<p>栈上分配</p>\n</blockquote>\n<p>如果一个对象在子程序中被分配，指向该对象的指针永远不会逃逸，对象有可能会被优化为栈分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再分配到堆空间，可以有效地减少 GC 的压力</p>\n<blockquote>\n<p>分离对象或标量替换</p>\n</blockquote>\n<p>JIT 可以将对象打散，全部替换为一个个小的局部变量，这个打散的过程，就叫作标量替换（标量就是不能被进一步分割的变量，比如 int、long 等基本类型）。也就是说，标量替换后的对象，全部变成了局部变量，可以方便地进行栈上分配，而无须改动其他的代码</p>\n<p>并不是所有的对象或者数组，都会在堆上分配。由于JIT的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成栈分配</p>\n<blockquote>\n<p>同步消除</p>\n</blockquote>\n<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步，注意这是针对 synchronized 来说的，JUC 中的 Lock 并不能被消除</p>\n<p>要开启同步消除，需要加上<code>-XX:+EliminateLocks</code>参数。由于这个参数依赖逃逸分析，所以同时要打开<code>-XX:+DoEscapeAnalysis</code>选项</p>\n<p>比如下面这段代码，JIT 判断对象锁只能被一个线程访问，就可以去掉这个同步的影响</p>\n<pre><code class=\"java\">public class SyncEliminate &#123;\n    public void test() &#123;\n        synchronized (new Object()) &#123;\n        &#125;\n    &#125;\n&#125;\n</code></pre>\n<p><strong>JITWatch</strong></p>\n<p>可以使用 jitwatch 工具来观测 JIT 的一些行为</p>\n<p><a href=\"https://github.com/AdoptOpenJDK/jitwatch\">https://github.com/AdoptOpenJDK/jitwatch</a></p>\n"},{"title":"类加载机制","_content":"\n\n一个类型从被加载到虚拟机内存开始，到卸载出内存为止，它的生命周期将会经历加载，验证，准备，解析，初始化，使用和卸载七个阶段。\n\n<img src=\"https://img-blog.csdnimg.cn/583d4b7da4bc468ebba212aae0fc5a6a.png\" alt=\"、\" style=\"zoom:50%;\" />\n\n加载，验证，准备，初始化和卸载这五个阶段的开始顺序是确定的（注意确定的只有开始顺序，完成顺序不确定），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）\n\n**什么情况下需要开始类加载的第一个阶段加载呢？**\n\n这个《Java虚拟机规范》中没有进行强制约束\n\n只是严格规定了有且只有6种情况必须立即对类进行**初始化**（而加载，验证，准备自然需要在此之前开始）\n\n1. 遇到new、getstatic、putstatic或invokestatic这四条字节码时，如果类型没有进行过初始化，则需要先触发其初始化阶段。\n\n   能够生成这四种指令的典型Java代码场景有：\n\n* 使用new关键字实例化对象的时候。\n\n* 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。\n\n* 调用一个类型的静态方法的时候。\n\n2. 使用`java.lang.reflect`包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发初始化\n\n3. 当初始化类的时候，如果发现其父类还没有初始化，则先触发器父类的初始化\n\n4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类\n\n5. 当使用JDK 7新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解 析结果为`REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial`四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。\n\n6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有接口的实现类发生了初始化，那么该接口要在其之前先被初始化\n\n这六种场景称为对一个类型的**主动引用**。除此之外，所有引用类型的方式都不会触发其初始化，称为**被动引用**。\n\n需要注意的是，new数组对象也算作不会触发其类的初始化，因为实际上虚拟机会自动生成一个数组类，这个动作触发的是这个**数组类**的初始化。\n\n接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：\n\n接口也有初始化过程， 这点与类是一致的，上面的代码都是用静态语句块`static{}`来输出初始化信息的，而接口中不能使用`static{}`语句块，但编译器仍然会为接口生成`<clinit>()`类构造器，用于初始化接口中所定义的成员变量。\n\n接口与类真正有所区别的是前面讲述的六种有且仅有需要触发初始化场景中的第三种：\n\n> 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。\n\n**被动引用的例子一**\n\n```java\npackage org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示一：\n * 通过子类引用父类的静态字段，不会导致子类初始化\n **/\npublic class SuperClass {\n\n    static {\n        System.out.println(\"SuperClass init!\");\n    }\n\n    public static int value = 123;\n}\n\npublic class SubClass extends SuperClass {\n\n    static {\n        System.out.println(\"SubClass init!\");\n    }\n}\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        System.out.println(SubClass.value);\n    }\n\n}\n```\n\n**对于静态字段,只有直接定义这个字段的类才会被初始化** ，因此通过其子类来引用父类中定义的静态字段 ，只会触发父类的初始化而不会触发子类的初始化。\n\n至于是否要触发子类的加载和验证,在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。\n\n对于Sun HotSpot虚拟机，可通过`-XX : +TraceClassLoading`参数观察到此操作会导致子类的加载。\n\n**被动引用的例子二**\n\n```java\npackage org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示二：\n * 通过数组定义来引用类，不会触发此类的初始化\n **/\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        SuperClass[] sca = new SuperClass[10];\n    }\n\n}\n```\n\n这段代码里面触发了另外一个名为`[Lorg.fenixsoftclassloading.Superclass`的类的初始化阶段 ，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于`java.lang.Object`的子类，创建动作由字节码指令newarray触发。\n\n这个类代表了一个元素类型为`org.fenixsoft.classloading.SuperClass`的一维数组，数组中应有的属性和方法(用户可直接使用的只有被修饰为public的length属性和clone()方法)都实现在这个类里。\n\n**被动引用的例子三**\n\n```java\npackage org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示三：\n * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n **/\npublic class ConstClass {\n\n    static {\n        System.out.println(\"ConstClass init!\");\n    }\n\n    public static final String HELLOWORLD = \"hello world\";\n}\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        System.out.println(ConstClass.HELLOWORLD);\n    }\n}\n```\n\n虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过**常量传播优化**，已经将此常量的值`hello world`存储到了Notlnitialization类的常量池中，以后Notlnitialization对常量`ConstClass.HELLOWORLD`的引用实际都被转化为Notlnitializationl对自身常量池的引用了。 \n\n也就是说,实际上Notlnitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。\n\n# 类加载过程\n\n## 加载\n\n在加载阶段虚拟机需要完成以下三件事：\n\n1. 通过一个类的全限定名称来获取此类的二进制字节流\n2. 将这个字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**\n3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口\n\n通常来讲，一个类的全限定名称可以从zip、jar包中加载，也可以从网络中获取，也可以在运行的时候生成（反射机制）。\n\n对于类的加载，可以分为**数组类型和非数组类型**，对于非数组类型可以通过系统的引导类加载器进行加载，也可以通过自定义的类加载器进行加载。\n\n对于数组类型，数组类本身不通过类加载器进行加载，而是通过Java虚拟机直接进行加载的，那么是不是数组类型的类就不需要类加载器了呢？答案是否定的。\n\n> 因为当数组去除所有维度之后的类型最终还是要依靠类加载器进行加载的，所以数组类型的类与类加载器的关系还是很密切的。\n\n**通常一个数组类型的类进行加载需要遵循以下的原则：**\n\n1. 如果数组的组件类型（也就是数组类去除一个维度之后的类型，比如对于二维数组，去除一个维度之后是一个一维数组）是引用类型，那么递归采用上面的过程加载这个组件类型\n2. 如果数组类的组件类型不是引用类型，比如是基本数据类型，Java虚拟机将把数组类标记为与引导类加载器关联\n3. 数组类的可见性与组件类型的可见性是一致的。如果组件类型不是引用类型，那么数组类的可见性是public，意味着组件类型的可见性也是public。\n\n加载阶段与连接阶段是**交叉进行**的，所以可能加载阶段还没有完成，连接阶段就已经开始。\n\n但是即便如此，加载阶段与连接阶段之间的开始顺序仍然保持着**固定的顺序**。\n\n## 验证\n\n验证阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。\n\n虚拟机的验证阶段主要完后以下4项验证：文件格式验证、元数据验证、字节码验证、符号引用验证。（结合前文，查看Class类文件结构）\n\n**文件格式验证**\n\n这里的文件格式是指Class的文件规范，这一步的验证主要保证加载的字节流符合Class文件的规范（比如前四个字节是否是一个魔数等）以及保证这个字节流可以被虚拟机接受处理。\n\n**元数据验证**\n\n元数据验证主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范（Java语法）的元数据信息。\n\n具体的验证信息包括以下几个方面：\n\n1. 这个类是否有父类（除了`java.lang.Object`外其余的类都应该有父类）\n2. 这个类的父类是否继承了不允许被继承的类（比如被final修饰的类）\n3. 如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的方法\n4. 类中的字段、方法是否与父类产生矛盾（比如是否覆盖了父类的final字段）\n\n**字节码验证**\n\n**符号引用验证**\n\n这个验证是最后阶段的验证，符号引用是Class文件的逻辑符号，直接引用指向的方法区中某一个地址，在**解析阶段**，将符号引用转为直接引用，这里只进行转化前的匹配性校验。\n\n符号引用验证主要是对类自身以外的信息进行匹配性校验。比如符号引用是否通过字符串描述的全限定名是否能够找到对应点类。\n\n- 符号引用：\n  符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可（**符号字面量，还没有涉及到内存**）。\n- 直接引用：\n  直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄（可以理解为**内存地址**）。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。\n\n进行符号引用验证的目的在于确保解析动作能够正常执行，如果无法通过符号引用验证那么将会抛出`java.lang.IncomingChangeError`异常的子类。\n\n## 准备\n\n完成了验证阶段之后，就进入准备阶段。准备阶段是正式**为变量分配内存空间并且设置类变量初始值**。\n\n需要注意的是，这时候进行内存分配的仅仅是类变量（也就是被static修饰的变量），实例变量是不包括的，实例变量的初始化是在对象实例化的时候进行初始化，而且分配的内存区域是Java堆。这里的初始值也就是在编程中默认值，也就是零值。\n\n例如`public static int value = 123 ；`value在准备阶段后的初始值是0而不是123，因为此时尚未执行任何的Java方法，而把value赋值为123的putStatic指令是程序被编译后，存放在类构造器clinit()方法之中，把value赋值为123的动作将在初始化阶段才会执行。\n\n特殊情况：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，例如`public static final int value = 123 `编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量赋值为123。\n\n## 解析\n\n解析阶段是将常量池中的符号引用替换为直接引用的过程（前面已经提到了符号引用与直接引用的区别）。\n\n在进行解析之前需要对符号引用进行解析，不同虚拟机实现可以根据需要判断到底是在类被加载器加载的时候对常量池的符号引用进行解析（也就是初始化之前），还是等到一个符号引用被使用之前进行解析（也就是在初始化之后）。\n\n解析动作主要针对的是类或者接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用。\n\n## 初始化\n\n**到了初始化阶段，虚拟机才开始真正执行Java程序代码**。\n\n只有到了初始化阶段，才开始真正执行这个自定义的过程，所以也可以说初始化阶段是执行类构造器方法clinit() 的过程。\n\n那么这个`clinit() `方法是这么生成的呢？\n\nclinit() 是编译器自动收集类中所有**类变量的赋值动作和静态语句块**合并生成的。\n\n**编译器收集的顺序是由语句在源文件中出现的顺序决定的**。\n\n静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。\n\n```java\npublic class Test {\n  static{\n   i =0;   //给变量赋值可以正常编译通过\n   System.out.println(i); //这句编译器会提示“非法向前引用”\n  }\n  static int i = 1;\n}\n```\n\n**clinit() 方法与类的构造器方法不同，因为前者不需要显式调用父类构造器，因为虚拟机会保证在子类的clinit() 方法执行之前，父类的clinit() 方法已经执行完毕**\n\n由于父类的clinit() 方法会先执行，所以就表示**父类的static方法会先于子类的clinit() 方法执行**。\n\n如下面的例子所示，输出结果为2而不是1\n\n```java\npublic class Parent { \n public static int A = 1; \n static{ \n  A = 2; \n } \n} \n \npublic class Sub extends Parent{ \n public static int B = A; \n} \n \npublic class Test { \n public static void main(String[] args) { \n  System.out.println(Sub.B); \n } \n}\n```\n\nclinit()方法对于类或者接口来说**并不是必需**的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。\n\n接口中不能使用静态语句块，但仍然有变量赋值的初始化操作，因此接口也会生成clinit()方法。\n\n但是接口与类不同，执行接口的clinit()方法不需要先执行父接口的`clinit()`方法。\n\n只有当父接口中定义的变量被使用时，父接口才会被初始化。\n\n另外，接口的实现类在初始化时也不会执行接口的clinit()方法。\n\n**虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁和同步**。\n\n如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其它线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。\n\n如果在一个类的clinit()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。\n\n# 类加载器\n\n类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。\n\n两个类即使来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的虚拟机不同，那这两个类就必定不相等。\n\n自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。\n\n1. **启动类加载器（Bootstrap Class Loader）**\n   负责加载存放在`<JAVA_HOME>\\lib`目录，或被`-Xbootclasspath`参数所指定的路径中存放的，且是Java虚拟机能够识别的（按照文件名识别，如`rt.jar、tools.jar`名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用null代替即可。\n2. **扩展类加载器 （Extension Class Loader）**\n   在类`sun.misc.Launcher$ExtClassLoader`中以Java代码的形式实现，负责加载`<JAVA_HOME>\\lib\\ext`目录中，或被`java.ext.dirs`系统变量所指定的路径中所有的类库，这是一种Java系统类库的扩展机制，将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代，由于是由Java代码实现，开发者可直接在程序中使用扩展类加载器来加载Class文件。\n3. **应用程序类加载器（Application Class Loader）**\n   由`sun.misc.Launcher$AppClassLoader`来实现。由于应用程序类加载器是ClassLoader类中的`getSystemClassLoader()`方法的返回值，也称为系统类加载器，负责加载用户类路径（ClassPath）上所有的类库，可直接在代码中使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n# 双亲委派模型\n\n<img src=\"https://img-blog.csdnimg.cn/0722d01166e24dbca09ed50e63ee6b21.png\" style=\"zoom:25%;\" />\n\nJDK9之前的Java应用都由三种类加载器互相配合来完成加载，也可以加入自定义的类加载器来进行拓展，如增加除了磁盘位置以外的Class文件来源，或通过类加载器实现类的隔离、重载等功能。\n\n它要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。\n\n这里的类加载器之间的父子关系一般不是继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。\n\n**双亲委派模型的工作过程：**\n\n* 如果一个类加载器收到了类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它搜索范围中没有找到所需的类）中，子加载器才会尝试自己去完成加载。\n\n* 使用双亲委派模型来组织类加载器之间的关系，显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，如类`java.lang.Object`，它存放在`rt.jar`之中，无论哪一种类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。\n\n* 反之，如果没有使用双亲委派模型，都由各个类加载器自行加载的话，如果用户编写了一个名为`java.lang.Object`的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。\n\n双亲委派模型对于保证Java程序的未定运行极为重要，但它的实现去异常简单，用以实现双亲委派的代码仅有短短十余行，全部集中在`java.lang.ClassLoader`的loadClass()方法之中。\n\n先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败， 抛出`ClassNotFoundException`异常的话，才调用自己的findClass()方法尝试进行加载。\n\n**破坏双亲委派模型**\n\n双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型的基础是指他们是总被用户代码继承、调用的API的存在。\n\n但程序设计往往没有绝对不变的完美规则，当有基础类型又要调回用户的代码，该怎么办？\n\n> 典型例子：\n\n- JNDI服务：是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到`rt.jar`）属于基础类型，但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。\n- 问题：启动类加载器绝不可能认识、加载这些代码，该怎么办？\n- 解决方案：为解决这个困境，Java设计团队只好引入一个不太优雅的设计，线程上下文类加载器（Thread Context ClassLoader）。\n- 这个类加载器可以通过`java.lang.Thread`类的setContextClassLoader()方法设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应有程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n\n有了线程上下文类加载器，JNDI使用它去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。\n\nJava中涉及SPI的加载基本都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。\n\n不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK1.6时，JDK提供了`java.util.ServiceLoader`类，以`META-INF/services`中的配置信息，辅以责任链模式，这才算给SPI的加载提供了一种相对合理的解决方案。\n\n**OSGi实现模块化热部署**\n\nOSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。\n\n在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构\n\n**Tomcat为什么要破坏双亲委派模型**\n\n每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器\n\n大致是出于下面三类目的：\n\n- 对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源\n\n- 与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏\n\n- 热部署\n\n<img src=\"https://img-blog.csdnimg.cn/c4275d2dc32e44438d08738f38a8244b.png\" style=\"zoom:25%;\" />\n\n对于一些需要加载的非基础类，会由一个叫作 WebAppClassLoader 的类加载器优先加载。\n\n等它加载不到的时候，再交给上层的 ClassLoader 进行加载。\n\n这个加载器用来隔绝不同应用的`.class`文件，比如你的两个应用，可能会依赖同一个第三方的不同版本，它们是相互没有影响的。\n\n# 模块化系统\n\n在JDK 9中引入的Java模块化系统(Java Platform Module System，JPMS)是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做 出了相应的变动调整，才使模块化系统得以顺利地运作。\n\n**模块化下的类加载器**\n\n<img src=\"https://img-blog.csdnimg.cn/4820f3cc3c0349578363eef45abba95e.png\" style=\"zoom:25%;\" />\n\nJDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了 变动。\n\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器 完成加载，也许这可以算是对双亲委派的第四次破坏。","source":"_posts/深入理解JVM虚拟机/类加载机制.md","raw":"---\ntitle: 类加载机制\ncategories: \n- 深入理解JVM虚拟机\n---\n\n\n一个类型从被加载到虚拟机内存开始，到卸载出内存为止，它的生命周期将会经历加载，验证，准备，解析，初始化，使用和卸载七个阶段。\n\n<img src=\"https://img-blog.csdnimg.cn/583d4b7da4bc468ebba212aae0fc5a6a.png\" alt=\"、\" style=\"zoom:50%;\" />\n\n加载，验证，准备，初始化和卸载这五个阶段的开始顺序是确定的（注意确定的只有开始顺序，完成顺序不确定），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）\n\n**什么情况下需要开始类加载的第一个阶段加载呢？**\n\n这个《Java虚拟机规范》中没有进行强制约束\n\n只是严格规定了有且只有6种情况必须立即对类进行**初始化**（而加载，验证，准备自然需要在此之前开始）\n\n1. 遇到new、getstatic、putstatic或invokestatic这四条字节码时，如果类型没有进行过初始化，则需要先触发其初始化阶段。\n\n   能够生成这四种指令的典型Java代码场景有：\n\n* 使用new关键字实例化对象的时候。\n\n* 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。\n\n* 调用一个类型的静态方法的时候。\n\n2. 使用`java.lang.reflect`包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发初始化\n\n3. 当初始化类的时候，如果发现其父类还没有初始化，则先触发器父类的初始化\n\n4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类\n\n5. 当使用JDK 7新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解 析结果为`REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial`四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。\n\n6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有接口的实现类发生了初始化，那么该接口要在其之前先被初始化\n\n这六种场景称为对一个类型的**主动引用**。除此之外，所有引用类型的方式都不会触发其初始化，称为**被动引用**。\n\n需要注意的是，new数组对象也算作不会触发其类的初始化，因为实际上虚拟机会自动生成一个数组类，这个动作触发的是这个**数组类**的初始化。\n\n接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：\n\n接口也有初始化过程， 这点与类是一致的，上面的代码都是用静态语句块`static{}`来输出初始化信息的，而接口中不能使用`static{}`语句块，但编译器仍然会为接口生成`<clinit>()`类构造器，用于初始化接口中所定义的成员变量。\n\n接口与类真正有所区别的是前面讲述的六种有且仅有需要触发初始化场景中的第三种：\n\n> 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。\n\n**被动引用的例子一**\n\n```java\npackage org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示一：\n * 通过子类引用父类的静态字段，不会导致子类初始化\n **/\npublic class SuperClass {\n\n    static {\n        System.out.println(\"SuperClass init!\");\n    }\n\n    public static int value = 123;\n}\n\npublic class SubClass extends SuperClass {\n\n    static {\n        System.out.println(\"SubClass init!\");\n    }\n}\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        System.out.println(SubClass.value);\n    }\n\n}\n```\n\n**对于静态字段,只有直接定义这个字段的类才会被初始化** ，因此通过其子类来引用父类中定义的静态字段 ，只会触发父类的初始化而不会触发子类的初始化。\n\n至于是否要触发子类的加载和验证,在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。\n\n对于Sun HotSpot虚拟机，可通过`-XX : +TraceClassLoading`参数观察到此操作会导致子类的加载。\n\n**被动引用的例子二**\n\n```java\npackage org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示二：\n * 通过数组定义来引用类，不会触发此类的初始化\n **/\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        SuperClass[] sca = new SuperClass[10];\n    }\n\n}\n```\n\n这段代码里面触发了另外一个名为`[Lorg.fenixsoftclassloading.Superclass`的类的初始化阶段 ，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于`java.lang.Object`的子类，创建动作由字节码指令newarray触发。\n\n这个类代表了一个元素类型为`org.fenixsoft.classloading.SuperClass`的一维数组，数组中应有的属性和方法(用户可直接使用的只有被修饰为public的length属性和clone()方法)都实现在这个类里。\n\n**被动引用的例子三**\n\n```java\npackage org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示三：\n * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n **/\npublic class ConstClass {\n\n    static {\n        System.out.println(\"ConstClass init!\");\n    }\n\n    public static final String HELLOWORLD = \"hello world\";\n}\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization {\n\n    public static void main(String[] args) {\n        System.out.println(ConstClass.HELLOWORLD);\n    }\n}\n```\n\n虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过**常量传播优化**，已经将此常量的值`hello world`存储到了Notlnitialization类的常量池中，以后Notlnitialization对常量`ConstClass.HELLOWORLD`的引用实际都被转化为Notlnitializationl对自身常量池的引用了。 \n\n也就是说,实际上Notlnitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。\n\n# 类加载过程\n\n## 加载\n\n在加载阶段虚拟机需要完成以下三件事：\n\n1. 通过一个类的全限定名称来获取此类的二进制字节流\n2. 将这个字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**\n3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口\n\n通常来讲，一个类的全限定名称可以从zip、jar包中加载，也可以从网络中获取，也可以在运行的时候生成（反射机制）。\n\n对于类的加载，可以分为**数组类型和非数组类型**，对于非数组类型可以通过系统的引导类加载器进行加载，也可以通过自定义的类加载器进行加载。\n\n对于数组类型，数组类本身不通过类加载器进行加载，而是通过Java虚拟机直接进行加载的，那么是不是数组类型的类就不需要类加载器了呢？答案是否定的。\n\n> 因为当数组去除所有维度之后的类型最终还是要依靠类加载器进行加载的，所以数组类型的类与类加载器的关系还是很密切的。\n\n**通常一个数组类型的类进行加载需要遵循以下的原则：**\n\n1. 如果数组的组件类型（也就是数组类去除一个维度之后的类型，比如对于二维数组，去除一个维度之后是一个一维数组）是引用类型，那么递归采用上面的过程加载这个组件类型\n2. 如果数组类的组件类型不是引用类型，比如是基本数据类型，Java虚拟机将把数组类标记为与引导类加载器关联\n3. 数组类的可见性与组件类型的可见性是一致的。如果组件类型不是引用类型，那么数组类的可见性是public，意味着组件类型的可见性也是public。\n\n加载阶段与连接阶段是**交叉进行**的，所以可能加载阶段还没有完成，连接阶段就已经开始。\n\n但是即便如此，加载阶段与连接阶段之间的开始顺序仍然保持着**固定的顺序**。\n\n## 验证\n\n验证阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。\n\n虚拟机的验证阶段主要完后以下4项验证：文件格式验证、元数据验证、字节码验证、符号引用验证。（结合前文，查看Class类文件结构）\n\n**文件格式验证**\n\n这里的文件格式是指Class的文件规范，这一步的验证主要保证加载的字节流符合Class文件的规范（比如前四个字节是否是一个魔数等）以及保证这个字节流可以被虚拟机接受处理。\n\n**元数据验证**\n\n元数据验证主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范（Java语法）的元数据信息。\n\n具体的验证信息包括以下几个方面：\n\n1. 这个类是否有父类（除了`java.lang.Object`外其余的类都应该有父类）\n2. 这个类的父类是否继承了不允许被继承的类（比如被final修饰的类）\n3. 如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的方法\n4. 类中的字段、方法是否与父类产生矛盾（比如是否覆盖了父类的final字段）\n\n**字节码验证**\n\n**符号引用验证**\n\n这个验证是最后阶段的验证，符号引用是Class文件的逻辑符号，直接引用指向的方法区中某一个地址，在**解析阶段**，将符号引用转为直接引用，这里只进行转化前的匹配性校验。\n\n符号引用验证主要是对类自身以外的信息进行匹配性校验。比如符号引用是否通过字符串描述的全限定名是否能够找到对应点类。\n\n- 符号引用：\n  符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可（**符号字面量，还没有涉及到内存**）。\n- 直接引用：\n  直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄（可以理解为**内存地址**）。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。\n\n进行符号引用验证的目的在于确保解析动作能够正常执行，如果无法通过符号引用验证那么将会抛出`java.lang.IncomingChangeError`异常的子类。\n\n## 准备\n\n完成了验证阶段之后，就进入准备阶段。准备阶段是正式**为变量分配内存空间并且设置类变量初始值**。\n\n需要注意的是，这时候进行内存分配的仅仅是类变量（也就是被static修饰的变量），实例变量是不包括的，实例变量的初始化是在对象实例化的时候进行初始化，而且分配的内存区域是Java堆。这里的初始值也就是在编程中默认值，也就是零值。\n\n例如`public static int value = 123 ；`value在准备阶段后的初始值是0而不是123，因为此时尚未执行任何的Java方法，而把value赋值为123的putStatic指令是程序被编译后，存放在类构造器clinit()方法之中，把value赋值为123的动作将在初始化阶段才会执行。\n\n特殊情况：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，例如`public static final int value = 123 `编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量赋值为123。\n\n## 解析\n\n解析阶段是将常量池中的符号引用替换为直接引用的过程（前面已经提到了符号引用与直接引用的区别）。\n\n在进行解析之前需要对符号引用进行解析，不同虚拟机实现可以根据需要判断到底是在类被加载器加载的时候对常量池的符号引用进行解析（也就是初始化之前），还是等到一个符号引用被使用之前进行解析（也就是在初始化之后）。\n\n解析动作主要针对的是类或者接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用。\n\n## 初始化\n\n**到了初始化阶段，虚拟机才开始真正执行Java程序代码**。\n\n只有到了初始化阶段，才开始真正执行这个自定义的过程，所以也可以说初始化阶段是执行类构造器方法clinit() 的过程。\n\n那么这个`clinit() `方法是这么生成的呢？\n\nclinit() 是编译器自动收集类中所有**类变量的赋值动作和静态语句块**合并生成的。\n\n**编译器收集的顺序是由语句在源文件中出现的顺序决定的**。\n\n静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。\n\n```java\npublic class Test {\n  static{\n   i =0;   //给变量赋值可以正常编译通过\n   System.out.println(i); //这句编译器会提示“非法向前引用”\n  }\n  static int i = 1;\n}\n```\n\n**clinit() 方法与类的构造器方法不同，因为前者不需要显式调用父类构造器，因为虚拟机会保证在子类的clinit() 方法执行之前，父类的clinit() 方法已经执行完毕**\n\n由于父类的clinit() 方法会先执行，所以就表示**父类的static方法会先于子类的clinit() 方法执行**。\n\n如下面的例子所示，输出结果为2而不是1\n\n```java\npublic class Parent { \n public static int A = 1; \n static{ \n  A = 2; \n } \n} \n \npublic class Sub extends Parent{ \n public static int B = A; \n} \n \npublic class Test { \n public static void main(String[] args) { \n  System.out.println(Sub.B); \n } \n}\n```\n\nclinit()方法对于类或者接口来说**并不是必需**的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。\n\n接口中不能使用静态语句块，但仍然有变量赋值的初始化操作，因此接口也会生成clinit()方法。\n\n但是接口与类不同，执行接口的clinit()方法不需要先执行父接口的`clinit()`方法。\n\n只有当父接口中定义的变量被使用时，父接口才会被初始化。\n\n另外，接口的实现类在初始化时也不会执行接口的clinit()方法。\n\n**虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁和同步**。\n\n如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其它线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。\n\n如果在一个类的clinit()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。\n\n# 类加载器\n\n类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。\n\n对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。\n\n两个类即使来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的虚拟机不同，那这两个类就必定不相等。\n\n自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。\n\n1. **启动类加载器（Bootstrap Class Loader）**\n   负责加载存放在`<JAVA_HOME>\\lib`目录，或被`-Xbootclasspath`参数所指定的路径中存放的，且是Java虚拟机能够识别的（按照文件名识别，如`rt.jar、tools.jar`名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用null代替即可。\n2. **扩展类加载器 （Extension Class Loader）**\n   在类`sun.misc.Launcher$ExtClassLoader`中以Java代码的形式实现，负责加载`<JAVA_HOME>\\lib\\ext`目录中，或被`java.ext.dirs`系统变量所指定的路径中所有的类库，这是一种Java系统类库的扩展机制，将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代，由于是由Java代码实现，开发者可直接在程序中使用扩展类加载器来加载Class文件。\n3. **应用程序类加载器（Application Class Loader）**\n   由`sun.misc.Launcher$AppClassLoader`来实现。由于应用程序类加载器是ClassLoader类中的`getSystemClassLoader()`方法的返回值，也称为系统类加载器，负责加载用户类路径（ClassPath）上所有的类库，可直接在代码中使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。\n\n# 双亲委派模型\n\n<img src=\"https://img-blog.csdnimg.cn/0722d01166e24dbca09ed50e63ee6b21.png\" style=\"zoom:25%;\" />\n\nJDK9之前的Java应用都由三种类加载器互相配合来完成加载，也可以加入自定义的类加载器来进行拓展，如增加除了磁盘位置以外的Class文件来源，或通过类加载器实现类的隔离、重载等功能。\n\n它要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。\n\n这里的类加载器之间的父子关系一般不是继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。\n\n**双亲委派模型的工作过程：**\n\n* 如果一个类加载器收到了类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它搜索范围中没有找到所需的类）中，子加载器才会尝试自己去完成加载。\n\n* 使用双亲委派模型来组织类加载器之间的关系，显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，如类`java.lang.Object`，它存放在`rt.jar`之中，无论哪一种类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。\n\n* 反之，如果没有使用双亲委派模型，都由各个类加载器自行加载的话，如果用户编写了一个名为`java.lang.Object`的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。\n\n双亲委派模型对于保证Java程序的未定运行极为重要，但它的实现去异常简单，用以实现双亲委派的代码仅有短短十余行，全部集中在`java.lang.ClassLoader`的loadClass()方法之中。\n\n先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败， 抛出`ClassNotFoundException`异常的话，才调用自己的findClass()方法尝试进行加载。\n\n**破坏双亲委派模型**\n\n双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型的基础是指他们是总被用户代码继承、调用的API的存在。\n\n但程序设计往往没有绝对不变的完美规则，当有基础类型又要调回用户的代码，该怎么办？\n\n> 典型例子：\n\n- JNDI服务：是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到`rt.jar`）属于基础类型，但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。\n- 问题：启动类加载器绝不可能认识、加载这些代码，该怎么办？\n- 解决方案：为解决这个困境，Java设计团队只好引入一个不太优雅的设计，线程上下文类加载器（Thread Context ClassLoader）。\n- 这个类加载器可以通过`java.lang.Thread`类的setContextClassLoader()方法设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应有程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。\n\n有了线程上下文类加载器，JNDI使用它去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。\n\nJava中涉及SPI的加载基本都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。\n\n不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK1.6时，JDK提供了`java.util.ServiceLoader`类，以`META-INF/services`中的配置信息，辅以责任链模式，这才算给SPI的加载提供了一种相对合理的解决方案。\n\n**OSGi实现模块化热部署**\n\nOSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。\n\n在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构\n\n**Tomcat为什么要破坏双亲委派模型**\n\n每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器\n\n大致是出于下面三类目的：\n\n- 对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源\n\n- 与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏\n\n- 热部署\n\n<img src=\"https://img-blog.csdnimg.cn/c4275d2dc32e44438d08738f38a8244b.png\" style=\"zoom:25%;\" />\n\n对于一些需要加载的非基础类，会由一个叫作 WebAppClassLoader 的类加载器优先加载。\n\n等它加载不到的时候，再交给上层的 ClassLoader 进行加载。\n\n这个加载器用来隔绝不同应用的`.class`文件，比如你的两个应用，可能会依赖同一个第三方的不同版本，它们是相互没有影响的。\n\n# 模块化系统\n\n在JDK 9中引入的Java模块化系统(Java Platform Module System，JPMS)是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做 出了相应的变动调整，才使模块化系统得以顺利地运作。\n\n**模块化下的类加载器**\n\n<img src=\"https://img-blog.csdnimg.cn/4820f3cc3c0349578363eef45abba95e.png\" style=\"zoom:25%;\" />\n\nJDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了 变动。\n\n当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器 完成加载，也许这可以算是对双亲委派的第四次破坏。","slug":"深入理解JVM虚拟机/类加载机制","published":1,"date":"2021-12-20T16:10:55.545Z","updated":"2021-12-20T16:27:03.397Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkl00kafhji4mrq6bvf","content":"<p>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，它的生命周期将会经历加载，验证，准备，解析，初始化，使用和卸载七个阶段。</p>\n<img src=\"https://img-blog.csdnimg.cn/583d4b7da4bc468ebba212aae0fc5a6a.png\" alt=\"、\" style=\"zoom:50%;\" />\n\n<p>加载，验证，准备，初始化和卸载这五个阶段的开始顺序是确定的（注意确定的只有开始顺序，完成顺序不确定），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p>\n<p><strong>什么情况下需要开始类加载的第一个阶段加载呢？</strong></p>\n<p>这个《Java虚拟机规范》中没有进行强制约束</p>\n<p>只是严格规定了有且只有6种情况必须立即对类进行<strong>初始化</strong>（而加载，验证，准备自然需要在此之前开始）</p>\n<ol>\n<li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码时，如果类型没有进行过初始化，则需要先触发其初始化阶段。</p>\n<p>能够生成这四种指令的典型Java代码场景有：</p>\n</li>\n</ol>\n<ul>\n<li><p>使用new关键字实例化对象的时候。</p>\n</li>\n<li><p>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。</p>\n</li>\n<li><p>调用一个类型的静态方法的时候。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发初始化</p>\n</li>\n<li><p>当初始化类的时候，如果发现其父类还没有初始化，则先触发器父类的初始化</p>\n</li>\n<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</p>\n</li>\n<li><p>当使用JDK 7新加入的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解 析结果为<code>REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial</code>四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>\n</li>\n<li><p>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有接口的实现类发生了初始化，那么该接口要在其之前先被初始化</p>\n</li>\n</ol>\n<p>这六种场景称为对一个类型的<strong>主动引用</strong>。除此之外，所有引用类型的方式都不会触发其初始化，称为<strong>被动引用</strong>。</p>\n<p>需要注意的是，new数组对象也算作不会触发其类的初始化，因为实际上虚拟机会自动生成一个数组类，这个动作触发的是这个<strong>数组类</strong>的初始化。</p>\n<p>接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：</p>\n<p>接口也有初始化过程， 这点与类是一致的，上面的代码都是用静态语句块<code>static&#123;&#125;</code>来输出初始化信息的，而接口中不能使用<code>static&#123;&#125;</code>语句块，但编译器仍然会为接口生成<code>&lt;clinit&gt;()</code>类构造器，用于初始化接口中所定义的成员变量。</p>\n<p>接口与类真正有所区别的是前面讲述的六种有且仅有需要触发初始化场景中的第三种：</p>\n<blockquote>\n<p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>\n</blockquote>\n<p><strong>被动引用的例子一</strong></p>\n<pre><code class=\"java\">package org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示一：\n * 通过子类引用父类的静态字段，不会导致子类初始化\n **/\npublic class SuperClass &#123;\n\n    static &#123;\n        System.out.println(&quot;SuperClass init!&quot;);\n    &#125;\n\n    public static int value = 123;\n&#125;\n\npublic class SubClass extends SuperClass &#123;\n\n    static &#123;\n        System.out.println(&quot;SubClass init!&quot;);\n    &#125;\n&#125;\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(SubClass.value);\n    &#125;\n\n&#125;\n</code></pre>\n<p><strong>对于静态字段,只有直接定义这个字段的类才会被初始化</strong> ，因此通过其子类来引用父类中定义的静态字段 ，只会触发父类的初始化而不会触发子类的初始化。</p>\n<p>至于是否要触发子类的加载和验证,在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。</p>\n<p>对于Sun HotSpot虚拟机，可通过<code>-XX : +TraceClassLoading</code>参数观察到此操作会导致子类的加载。</p>\n<p><strong>被动引用的例子二</strong></p>\n<pre><code class=\"java\">package org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示二：\n * 通过数组定义来引用类，不会触发此类的初始化\n **/\npublic class NotInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        SuperClass[] sca = new SuperClass[10];\n    &#125;\n\n&#125;\n</code></pre>\n<p>这段代码里面触发了另外一个名为<code>[Lorg.fenixsoftclassloading.Superclass</code>的类的初始化阶段 ，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于<code>java.lang.Object</code>的子类，创建动作由字节码指令newarray触发。</p>\n<p>这个类代表了一个元素类型为<code>org.fenixsoft.classloading.SuperClass</code>的一维数组，数组中应有的属性和方法(用户可直接使用的只有被修饰为public的length属性和clone()方法)都实现在这个类里。</p>\n<p><strong>被动引用的例子三</strong></p>\n<pre><code class=\"java\">package org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示三：\n * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n **/\npublic class ConstClass &#123;\n\n    static &#123;\n        System.out.println(&quot;ConstClass init!&quot;);\n    &#125;\n\n    public static final String HELLOWORLD = &quot;hello world&quot;;\n&#125;\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(ConstClass.HELLOWORLD);\n    &#125;\n&#125;\n</code></pre>\n<p>虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过<strong>常量传播优化</strong>，已经将此常量的值<code>hello world</code>存储到了Notlnitialization类的常量池中，以后Notlnitialization对常量<code>ConstClass.HELLOWORLD</code>的引用实际都被转化为Notlnitializationl对自身常量池的引用了。 </p>\n<p>也就是说,实际上Notlnitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</p>\n<h1 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h1><h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><p>在加载阶段虚拟机需要完成以下三件事：</p>\n<ol>\n<li>通过一个类的全限定名称来获取此类的二进制字节流</li>\n<li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong></li>\n<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>通常来讲，一个类的全限定名称可以从zip、jar包中加载，也可以从网络中获取，也可以在运行的时候生成（反射机制）。</p>\n<p>对于类的加载，可以分为<strong>数组类型和非数组类型</strong>，对于非数组类型可以通过系统的引导类加载器进行加载，也可以通过自定义的类加载器进行加载。</p>\n<p>对于数组类型，数组类本身不通过类加载器进行加载，而是通过Java虚拟机直接进行加载的，那么是不是数组类型的类就不需要类加载器了呢？答案是否定的。</p>\n<blockquote>\n<p>因为当数组去除所有维度之后的类型最终还是要依靠类加载器进行加载的，所以数组类型的类与类加载器的关系还是很密切的。</p>\n</blockquote>\n<p><strong>通常一个数组类型的类进行加载需要遵循以下的原则：</strong></p>\n<ol>\n<li>如果数组的组件类型（也就是数组类去除一个维度之后的类型，比如对于二维数组，去除一个维度之后是一个一维数组）是引用类型，那么递归采用上面的过程加载这个组件类型</li>\n<li>如果数组类的组件类型不是引用类型，比如是基本数据类型，Java虚拟机将把数组类标记为与引导类加载器关联</li>\n<li>数组类的可见性与组件类型的可见性是一致的。如果组件类型不是引用类型，那么数组类的可见性是public，意味着组件类型的可见性也是public。</li>\n</ol>\n<p>加载阶段与连接阶段是<strong>交叉进行</strong>的，所以可能加载阶段还没有完成，连接阶段就已经开始。</p>\n<p>但是即便如此，加载阶段与连接阶段之间的开始顺序仍然保持着<strong>固定的顺序</strong>。</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>验证阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。</p>\n<p>虚拟机的验证阶段主要完后以下4项验证：文件格式验证、元数据验证、字节码验证、符号引用验证。（结合前文，查看Class类文件结构）</p>\n<p><strong>文件格式验证</strong></p>\n<p>这里的文件格式是指Class的文件规范，这一步的验证主要保证加载的字节流符合Class文件的规范（比如前四个字节是否是一个魔数等）以及保证这个字节流可以被虚拟机接受处理。</p>\n<p><strong>元数据验证</strong></p>\n<p>元数据验证主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范（Java语法）的元数据信息。</p>\n<p>具体的验证信息包括以下几个方面：</p>\n<ol>\n<li>这个类是否有父类（除了<code>java.lang.Object</code>外其余的类都应该有父类）</li>\n<li>这个类的父类是否继承了不允许被继承的类（比如被final修饰的类）</li>\n<li>如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的方法</li>\n<li>类中的字段、方法是否与父类产生矛盾（比如是否覆盖了父类的final字段）</li>\n</ol>\n<p><strong>字节码验证</strong></p>\n<p><strong>符号引用验证</strong></p>\n<p>这个验证是最后阶段的验证，符号引用是Class文件的逻辑符号，直接引用指向的方法区中某一个地址，在<strong>解析阶段</strong>，将符号引用转为直接引用，这里只进行转化前的匹配性校验。</p>\n<p>符号引用验证主要是对类自身以外的信息进行匹配性校验。比如符号引用是否通过字符串描述的全限定名是否能够找到对应点类。</p>\n<ul>\n<li>符号引用：<br>符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可（<strong>符号字面量，还没有涉及到内存</strong>）。</li>\n<li>直接引用：<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄（可以理解为<strong>内存地址</strong>）。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</li>\n</ul>\n<p>进行符号引用验证的目的在于确保解析动作能够正常执行，如果无法通过符号引用验证那么将会抛出<code>java.lang.IncomingChangeError</code>异常的子类。</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>完成了验证阶段之后，就进入准备阶段。准备阶段是正式<strong>为变量分配内存空间并且设置类变量初始值</strong>。</p>\n<p>需要注意的是，这时候进行内存分配的仅仅是类变量（也就是被static修饰的变量），实例变量是不包括的，实例变量的初始化是在对象实例化的时候进行初始化，而且分配的内存区域是Java堆。这里的初始值也就是在编程中默认值，也就是零值。</p>\n<p>例如<code>public static int value = 123 ；</code>value在准备阶段后的初始值是0而不是123，因为此时尚未执行任何的Java方法，而把value赋值为123的putStatic指令是程序被编译后，存放在类构造器clinit()方法之中，把value赋值为123的动作将在初始化阶段才会执行。</p>\n<p>特殊情况：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，例如<code>public static final int value = 123 </code>编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量赋值为123。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>解析阶段是将常量池中的符号引用替换为直接引用的过程（前面已经提到了符号引用与直接引用的区别）。</p>\n<p>在进行解析之前需要对符号引用进行解析，不同虚拟机实现可以根据需要判断到底是在类被加载器加载的时候对常量池的符号引用进行解析（也就是初始化之前），还是等到一个符号引用被使用之前进行解析（也就是在初始化之后）。</p>\n<p>解析动作主要针对的是类或者接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用。</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p><strong>到了初始化阶段，虚拟机才开始真正执行Java程序代码</strong>。</p>\n<p>只有到了初始化阶段，才开始真正执行这个自定义的过程，所以也可以说初始化阶段是执行类构造器方法clinit() 的过程。</p>\n<p>那么这个<code>clinit() </code>方法是这么生成的呢？</p>\n<p>clinit() 是编译器自动收集类中所有<strong>类变量的赋值动作和静态语句块</strong>合并生成的。</p>\n<p><strong>编译器收集的顺序是由语句在源文件中出现的顺序决定的</strong>。</p>\n<p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>\n<pre><code class=\"java\">public class Test &#123;\n  static&#123;\n   i =0;   //给变量赋值可以正常编译通过\n   System.out.println(i); //这句编译器会提示“非法向前引用”\n  &#125;\n  static int i = 1;\n&#125;\n</code></pre>\n<p><strong>clinit() 方法与类的构造器方法不同，因为前者不需要显式调用父类构造器，因为虚拟机会保证在子类的clinit() 方法执行之前，父类的clinit() 方法已经执行完毕</strong></p>\n<p>由于父类的clinit() 方法会先执行，所以就表示<strong>父类的static方法会先于子类的clinit() 方法执行</strong>。</p>\n<p>如下面的例子所示，输出结果为2而不是1</p>\n<pre><code class=\"java\">public class Parent &#123; \n public static int A = 1; \n static&#123; \n  A = 2; \n &#125; \n&#125; \n \npublic class Sub extends Parent&#123; \n public static int B = A; \n&#125; \n \npublic class Test &#123; \n public static void main(String[] args) &#123; \n  System.out.println(Sub.B); \n &#125; \n&#125;\n</code></pre>\n<p>clinit()方法对于类或者接口来说<strong>并不是必需</strong>的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。</p>\n<p>接口中不能使用静态语句块，但仍然有变量赋值的初始化操作，因此接口也会生成clinit()方法。</p>\n<p>但是接口与类不同，执行接口的clinit()方法不需要先执行父接口的<code>clinit()</code>方法。</p>\n<p>只有当父接口中定义的变量被使用时，父接口才会被初始化。</p>\n<p>另外，接口的实现类在初始化时也不会执行接口的clinit()方法。</p>\n<p><strong>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁和同步</strong>。</p>\n<p>如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其它线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。</p>\n<p>如果在一个类的clinit()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。</p>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。</p>\n<p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。</p>\n<p>两个类即使来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的虚拟机不同，那这两个类就必定不相等。</p>\n<p>自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。</p>\n<ol>\n<li><strong>启动类加载器（Bootstrap Class Loader）</strong><br>负责加载存放在<code>&lt;JAVA_HOME&gt;\\lib</code>目录，或被<code>-Xbootclasspath</code>参数所指定的路径中存放的，且是Java虚拟机能够识别的（按照文件名识别，如<code>rt.jar、tools.jar</code>名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用null代替即可。</li>\n<li><strong>扩展类加载器 （Extension Class Loader）</strong><br>在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现，负责加载<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录中，或被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库，这是一种Java系统类库的扩展机制，将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代，由于是由Java代码实现，开发者可直接在程序中使用扩展类加载器来加载Class文件。</li>\n<li><strong>应用程序类加载器（Application Class Loader）</strong><br>由<code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，也称为系统类加载器，负责加载用户类路径（ClassPath）上所有的类库，可直接在代码中使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>\n</ol>\n<h1 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h1><img src=\"https://img-blog.csdnimg.cn/0722d01166e24dbca09ed50e63ee6b21.png\" style=\"zoom:25%;\" />\n\n<p>JDK9之前的Java应用都由三种类加载器互相配合来完成加载，也可以加入自定义的类加载器来进行拓展，如增加除了磁盘位置以外的Class文件来源，或通过类加载器实现类的隔离、重载等功能。</p>\n<p>它要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>\n<p>这里的类加载器之间的父子关系一般不是继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>\n<p><strong>双亲委派模型的工作过程：</strong></p>\n<ul>\n<li><p>如果一个类加载器收到了类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它搜索范围中没有找到所需的类）中，子加载器才会尝试自己去完成加载。</p>\n</li>\n<li><p>使用双亲委派模型来组织类加载器之间的关系，显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>之中，无论哪一种类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p>\n</li>\n<li><p>反之，如果没有使用双亲委派模型，都由各个类加载器自行加载的话，如果用户编写了一个名为<code>java.lang.Object</code>的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。</p>\n</li>\n</ul>\n<p>双亲委派模型对于保证Java程序的未定运行极为重要，但它的实现去异常简单，用以实现双亲委派的代码仅有短短十余行，全部集中在<code>java.lang.ClassLoader</code>的loadClass()方法之中。</p>\n<p>先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败， 抛出<code>ClassNotFoundException</code>异常的话，才调用自己的findClass()方法尝试进行加载。</p>\n<p><strong>破坏双亲委派模型</strong></p>\n<p>双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型的基础是指他们是总被用户代码继承、调用的API的存在。</p>\n<p>但程序设计往往没有绝对不变的完美规则，当有基础类型又要调回用户的代码，该怎么办？</p>\n<blockquote>\n<p>典型例子：</p>\n</blockquote>\n<ul>\n<li>JNDI服务：是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到<code>rt.jar</code>）属于基础类型，但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。</li>\n<li>问题：启动类加载器绝不可能认识、加载这些代码，该怎么办？</li>\n<li>解决方案：为解决这个困境，Java设计团队只好引入一个不太优雅的设计，线程上下文类加载器（Thread Context ClassLoader）。</li>\n<li>这个类加载器可以通过<code>java.lang.Thread</code>类的setContextClassLoader()方法设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应有程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>\n</ul>\n<p>有了线程上下文类加载器，JNDI使用它去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。</p>\n<p>Java中涉及SPI的加载基本都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>\n<p>不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK1.6时，JDK提供了<code>java.util.ServiceLoader</code>类，以<code>META-INF/services</code>中的配置信息，辅以责任链模式，这才算给SPI的加载提供了一种相对合理的解决方案。</p>\n<p><strong>OSGi实现模块化热部署</strong></p>\n<p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p>\n<p>在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p>\n<p><strong>Tomcat为什么要破坏双亲委派模型</strong></p>\n<p>每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器</p>\n<p>大致是出于下面三类目的：</p>\n<ul>\n<li><p>对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源</p>\n</li>\n<li><p>与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏</p>\n</li>\n<li><p>热部署</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/c4275d2dc32e44438d08738f38a8244b.png\" style=\"zoom:25%;\" />\n\n<p>对于一些需要加载的非基础类，会由一个叫作 WebAppClassLoader 的类加载器优先加载。</p>\n<p>等它加载不到的时候，再交给上层的 ClassLoader 进行加载。</p>\n<p>这个加载器用来隔绝不同应用的<code>.class</code>文件，比如你的两个应用，可能会依赖同一个第三方的不同版本，它们是相互没有影响的。</p>\n<h1 id=\"模块化系统\"><a href=\"#模块化系统\" class=\"headerlink\" title=\"模块化系统\"></a>模块化系统</h1><p>在JDK 9中引入的Java模块化系统(Java Platform Module System，JPMS)是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做 出了相应的变动调整，才使模块化系统得以顺利地运作。</p>\n<p><strong>模块化下的类加载器</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/4820f3cc3c0349578363eef45abba95e.png\" style=\"zoom:25%;\" />\n\n<p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了 变动。</p>\n<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器 完成加载，也许这可以算是对双亲委派的第四次破坏。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，它的生命周期将会经历加载，验证，准备，解析，初始化，使用和卸载七个阶段。</p>\n<img src=\"https://img-blog.csdnimg.cn/583d4b7da4bc468ebba212aae0fc5a6a.png\" alt=\"、\" style=\"zoom:50%;\" />\n\n<p>加载，验证，准备，初始化和卸载这五个阶段的开始顺序是确定的（注意确定的只有开始顺序，完成顺序不确定），而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</p>\n<p><strong>什么情况下需要开始类加载的第一个阶段加载呢？</strong></p>\n<p>这个《Java虚拟机规范》中没有进行强制约束</p>\n<p>只是严格规定了有且只有6种情况必须立即对类进行<strong>初始化</strong>（而加载，验证，准备自然需要在此之前开始）</p>\n<ol>\n<li><p>遇到new、getstatic、putstatic或invokestatic这四条字节码时，如果类型没有进行过初始化，则需要先触发其初始化阶段。</p>\n<p>能够生成这四种指令的典型Java代码场景有：</p>\n</li>\n</ol>\n<ul>\n<li><p>使用new关键字实例化对象的时候。</p>\n</li>\n<li><p>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。</p>\n</li>\n<li><p>调用一个类型的静态方法的时候。</p>\n</li>\n</ul>\n<ol start=\"2\">\n<li><p>使用<code>java.lang.reflect</code>包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发初始化</p>\n</li>\n<li><p>当初始化类的时候，如果发现其父类还没有初始化，则先触发器父类的初始化</p>\n</li>\n<li><p>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类</p>\n</li>\n<li><p>当使用JDK 7新加入的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解 析结果为<code>REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial</code>四种类型的方法句 柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</p>\n</li>\n<li><p>当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有接口的实现类发生了初始化，那么该接口要在其之前先被初始化</p>\n</li>\n</ol>\n<p>这六种场景称为对一个类型的<strong>主动引用</strong>。除此之外，所有引用类型的方式都不会触发其初始化，称为<strong>被动引用</strong>。</p>\n<p>需要注意的是，new数组对象也算作不会触发其类的初始化，因为实际上虚拟机会自动生成一个数组类，这个动作触发的是这个<strong>数组类</strong>的初始化。</p>\n<p>接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：</p>\n<p>接口也有初始化过程， 这点与类是一致的，上面的代码都是用静态语句块<code>static&#123;&#125;</code>来输出初始化信息的，而接口中不能使用<code>static&#123;&#125;</code>语句块，但编译器仍然会为接口生成<code>&lt;clinit&gt;()</code>类构造器，用于初始化接口中所定义的成员变量。</p>\n<p>接口与类真正有所区别的是前面讲述的六种有且仅有需要触发初始化场景中的第三种：</p>\n<blockquote>\n<p>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>\n</blockquote>\n<p><strong>被动引用的例子一</strong></p>\n<pre><code class=\"java\">package org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示一：\n * 通过子类引用父类的静态字段，不会导致子类初始化\n **/\npublic class SuperClass &#123;\n\n    static &#123;\n        System.out.println(&quot;SuperClass init!&quot;);\n    &#125;\n\n    public static int value = 123;\n&#125;\n\npublic class SubClass extends SuperClass &#123;\n\n    static &#123;\n        System.out.println(&quot;SubClass init!&quot;);\n    &#125;\n&#125;\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(SubClass.value);\n    &#125;\n\n&#125;\n</code></pre>\n<p><strong>对于静态字段,只有直接定义这个字段的类才会被初始化</strong> ，因此通过其子类来引用父类中定义的静态字段 ，只会触发父类的初始化而不会触发子类的初始化。</p>\n<p>至于是否要触发子类的加载和验证,在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。</p>\n<p>对于Sun HotSpot虚拟机，可通过<code>-XX : +TraceClassLoading</code>参数观察到此操作会导致子类的加载。</p>\n<p><strong>被动引用的例子二</strong></p>\n<pre><code class=\"java\">package org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示二：\n * 通过数组定义来引用类，不会触发此类的初始化\n **/\npublic class NotInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        SuperClass[] sca = new SuperClass[10];\n    &#125;\n\n&#125;\n</code></pre>\n<p>这段代码里面触发了另外一个名为<code>[Lorg.fenixsoftclassloading.Superclass</code>的类的初始化阶段 ，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于<code>java.lang.Object</code>的子类，创建动作由字节码指令newarray触发。</p>\n<p>这个类代表了一个元素类型为<code>org.fenixsoft.classloading.SuperClass</code>的一维数组，数组中应有的属性和方法(用户可直接使用的只有被修饰为public的length属性和clone()方法)都实现在这个类里。</p>\n<p><strong>被动引用的例子三</strong></p>\n<pre><code class=\"java\">package org.fenixsoft.classloading;\n\n/**\n * 被动使用类字段演示三：\n * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。\n **/\npublic class ConstClass &#123;\n\n    static &#123;\n        System.out.println(&quot;ConstClass init!&quot;);\n    &#125;\n\n    public static final String HELLOWORLD = &quot;hello world&quot;;\n&#125;\n\n/**\n * 非主动使用类字段演示\n **/\npublic class NotInitialization &#123;\n\n    public static void main(String[] args) &#123;\n        System.out.println(ConstClass.HELLOWORLD);\n    &#125;\n&#125;\n</code></pre>\n<p>虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过<strong>常量传播优化</strong>，已经将此常量的值<code>hello world</code>存储到了Notlnitialization类的常量池中，以后Notlnitialization对常量<code>ConstClass.HELLOWORLD</code>的引用实际都被转化为Notlnitializationl对自身常量池的引用了。 </p>\n<p>也就是说,实际上Notlnitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。</p>\n<h1 id=\"类加载过程\"><a href=\"#类加载过程\" class=\"headerlink\" title=\"类加载过程\"></a>类加载过程</h1><h2 id=\"加载\"><a href=\"#加载\" class=\"headerlink\" title=\"加载\"></a>加载</h2><p>在加载阶段虚拟机需要完成以下三件事：</p>\n<ol>\n<li>通过一个类的全限定名称来获取此类的二进制字节流</li>\n<li>将这个字节流所代表的<strong>静态存储结构</strong>转化为方法区的<strong>运行时数据结构</strong></li>\n<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li>\n</ol>\n<p>通常来讲，一个类的全限定名称可以从zip、jar包中加载，也可以从网络中获取，也可以在运行的时候生成（反射机制）。</p>\n<p>对于类的加载，可以分为<strong>数组类型和非数组类型</strong>，对于非数组类型可以通过系统的引导类加载器进行加载，也可以通过自定义的类加载器进行加载。</p>\n<p>对于数组类型，数组类本身不通过类加载器进行加载，而是通过Java虚拟机直接进行加载的，那么是不是数组类型的类就不需要类加载器了呢？答案是否定的。</p>\n<blockquote>\n<p>因为当数组去除所有维度之后的类型最终还是要依靠类加载器进行加载的，所以数组类型的类与类加载器的关系还是很密切的。</p>\n</blockquote>\n<p><strong>通常一个数组类型的类进行加载需要遵循以下的原则：</strong></p>\n<ol>\n<li>如果数组的组件类型（也就是数组类去除一个维度之后的类型，比如对于二维数组，去除一个维度之后是一个一维数组）是引用类型，那么递归采用上面的过程加载这个组件类型</li>\n<li>如果数组类的组件类型不是引用类型，比如是基本数据类型，Java虚拟机将把数组类标记为与引导类加载器关联</li>\n<li>数组类的可见性与组件类型的可见性是一致的。如果组件类型不是引用类型，那么数组类的可见性是public，意味着组件类型的可见性也是public。</li>\n</ol>\n<p>加载阶段与连接阶段是<strong>交叉进行</strong>的，所以可能加载阶段还没有完成，连接阶段就已经开始。</p>\n<p>但是即便如此，加载阶段与连接阶段之间的开始顺序仍然保持着<strong>固定的顺序</strong>。</p>\n<h2 id=\"验证\"><a href=\"#验证\" class=\"headerlink\" title=\"验证\"></a>验证</h2><p>验证阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。</p>\n<p>虚拟机的验证阶段主要完后以下4项验证：文件格式验证、元数据验证、字节码验证、符号引用验证。（结合前文，查看Class类文件结构）</p>\n<p><strong>文件格式验证</strong></p>\n<p>这里的文件格式是指Class的文件规范，这一步的验证主要保证加载的字节流符合Class文件的规范（比如前四个字节是否是一个魔数等）以及保证这个字节流可以被虚拟机接受处理。</p>\n<p><strong>元数据验证</strong></p>\n<p>元数据验证主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范（Java语法）的元数据信息。</p>\n<p>具体的验证信息包括以下几个方面：</p>\n<ol>\n<li>这个类是否有父类（除了<code>java.lang.Object</code>外其余的类都应该有父类）</li>\n<li>这个类的父类是否继承了不允许被继承的类（比如被final修饰的类）</li>\n<li>如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的方法</li>\n<li>类中的字段、方法是否与父类产生矛盾（比如是否覆盖了父类的final字段）</li>\n</ol>\n<p><strong>字节码验证</strong></p>\n<p><strong>符号引用验证</strong></p>\n<p>这个验证是最后阶段的验证，符号引用是Class文件的逻辑符号，直接引用指向的方法区中某一个地址，在<strong>解析阶段</strong>，将符号引用转为直接引用，这里只进行转化前的匹配性校验。</p>\n<p>符号引用验证主要是对类自身以外的信息进行匹配性校验。比如符号引用是否通过字符串描述的全限定名是否能够找到对应点类。</p>\n<ul>\n<li>符号引用：<br>符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可（<strong>符号字面量，还没有涉及到内存</strong>）。</li>\n<li>直接引用：<br>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄（可以理解为<strong>内存地址</strong>）。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</li>\n</ul>\n<p>进行符号引用验证的目的在于确保解析动作能够正常执行，如果无法通过符号引用验证那么将会抛出<code>java.lang.IncomingChangeError</code>异常的子类。</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>完成了验证阶段之后，就进入准备阶段。准备阶段是正式<strong>为变量分配内存空间并且设置类变量初始值</strong>。</p>\n<p>需要注意的是，这时候进行内存分配的仅仅是类变量（也就是被static修饰的变量），实例变量是不包括的，实例变量的初始化是在对象实例化的时候进行初始化，而且分配的内存区域是Java堆。这里的初始值也就是在编程中默认值，也就是零值。</p>\n<p>例如<code>public static int value = 123 ；</code>value在准备阶段后的初始值是0而不是123，因为此时尚未执行任何的Java方法，而把value赋值为123的putStatic指令是程序被编译后，存放在类构造器clinit()方法之中，把value赋值为123的动作将在初始化阶段才会执行。</p>\n<p>特殊情况：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，例如<code>public static final int value = 123 </code>编译时javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将变量赋值为123。</p>\n<h2 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h2><p>解析阶段是将常量池中的符号引用替换为直接引用的过程（前面已经提到了符号引用与直接引用的区别）。</p>\n<p>在进行解析之前需要对符号引用进行解析，不同虚拟机实现可以根据需要判断到底是在类被加载器加载的时候对常量池的符号引用进行解析（也就是初始化之前），还是等到一个符号引用被使用之前进行解析（也就是在初始化之后）。</p>\n<p>解析动作主要针对的是类或者接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用。</p>\n<h2 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h2><p><strong>到了初始化阶段，虚拟机才开始真正执行Java程序代码</strong>。</p>\n<p>只有到了初始化阶段，才开始真正执行这个自定义的过程，所以也可以说初始化阶段是执行类构造器方法clinit() 的过程。</p>\n<p>那么这个<code>clinit() </code>方法是这么生成的呢？</p>\n<p>clinit() 是编译器自动收集类中所有<strong>类变量的赋值动作和静态语句块</strong>合并生成的。</p>\n<p><strong>编译器收集的顺序是由语句在源文件中出现的顺序决定的</strong>。</p>\n<p>静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。</p>\n<pre><code class=\"java\">public class Test &#123;\n  static&#123;\n   i =0;   //给变量赋值可以正常编译通过\n   System.out.println(i); //这句编译器会提示“非法向前引用”\n  &#125;\n  static int i = 1;\n&#125;\n</code></pre>\n<p><strong>clinit() 方法与类的构造器方法不同，因为前者不需要显式调用父类构造器，因为虚拟机会保证在子类的clinit() 方法执行之前，父类的clinit() 方法已经执行完毕</strong></p>\n<p>由于父类的clinit() 方法会先执行，所以就表示<strong>父类的static方法会先于子类的clinit() 方法执行</strong>。</p>\n<p>如下面的例子所示，输出结果为2而不是1</p>\n<pre><code class=\"java\">public class Parent &#123; \n public static int A = 1; \n static&#123; \n  A = 2; \n &#125; \n&#125; \n \npublic class Sub extends Parent&#123; \n public static int B = A; \n&#125; \n \npublic class Test &#123; \n public static void main(String[] args) &#123; \n  System.out.println(Sub.B); \n &#125; \n&#125;\n</code></pre>\n<p>clinit()方法对于类或者接口来说<strong>并不是必需</strong>的，如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。</p>\n<p>接口中不能使用静态语句块，但仍然有变量赋值的初始化操作，因此接口也会生成clinit()方法。</p>\n<p>但是接口与类不同，执行接口的clinit()方法不需要先执行父接口的<code>clinit()</code>方法。</p>\n<p>只有当父接口中定义的变量被使用时，父接口才会被初始化。</p>\n<p>另外，接口的实现类在初始化时也不会执行接口的clinit()方法。</p>\n<p><strong>虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁和同步</strong>。</p>\n<p>如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其它线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。</p>\n<p>如果在一个类的clinit()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。</p>\n<h1 id=\"类加载器\"><a href=\"#类加载器\" class=\"headerlink\" title=\"类加载器\"></a>类加载器</h1><p>类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远超类加载阶段。</p>\n<p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。</p>\n<p>两个类即使来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的虚拟机不同，那这两个类就必定不相等。</p>\n<p>自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。</p>\n<ol>\n<li><strong>启动类加载器（Bootstrap Class Loader）</strong><br>负责加载存放在<code>&lt;JAVA_HOME&gt;\\lib</code>目录，或被<code>-Xbootclasspath</code>参数所指定的路径中存放的，且是Java虚拟机能够识别的（按照文件名识别，如<code>rt.jar、tools.jar</code>名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用null代替即可。</li>\n<li><strong>扩展类加载器 （Extension Class Loader）</strong><br>在类<code>sun.misc.Launcher$ExtClassLoader</code>中以Java代码的形式实现，负责加载<code>&lt;JAVA_HOME&gt;\\lib\\ext</code>目录中，或被<code>java.ext.dirs</code>系统变量所指定的路径中所有的类库，这是一种Java系统类库的扩展机制，将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代，由于是由Java代码实现，开发者可直接在程序中使用扩展类加载器来加载Class文件。</li>\n<li><strong>应用程序类加载器（Application Class Loader）</strong><br>由<code>sun.misc.Launcher$AppClassLoader</code>来实现。由于应用程序类加载器是ClassLoader类中的<code>getSystemClassLoader()</code>方法的返回值，也称为系统类加载器，负责加载用户类路径（ClassPath）上所有的类库，可直接在代码中使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>\n</ol>\n<h1 id=\"双亲委派模型\"><a href=\"#双亲委派模型\" class=\"headerlink\" title=\"双亲委派模型\"></a>双亲委派模型</h1><img src=\"https://img-blog.csdnimg.cn/0722d01166e24dbca09ed50e63ee6b21.png\" style=\"zoom:25%;\" />\n\n<p>JDK9之前的Java应用都由三种类加载器互相配合来完成加载，也可以加入自定义的类加载器来进行拓展，如增加除了磁盘位置以外的Class文件来源，或通过类加载器实现类的隔离、重载等功能。</p>\n<p>它要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。</p>\n<p>这里的类加载器之间的父子关系一般不是继承（Inheritance）的关系来实现的，而是通常使用组合（Composition）关系来复用父加载器的代码。</p>\n<p><strong>双亲委派模型的工作过程：</strong></p>\n<ul>\n<li><p>如果一个类加载器收到了类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它搜索范围中没有找到所需的类）中，子加载器才会尝试自己去完成加载。</p>\n</li>\n<li><p>使用双亲委派模型来组织类加载器之间的关系，显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，如类<code>java.lang.Object</code>，它存放在<code>rt.jar</code>之中，无论哪一种类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。</p>\n</li>\n<li><p>反之，如果没有使用双亲委派模型，都由各个类加载器自行加载的话，如果用户编写了一个名为<code>java.lang.Object</code>的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。</p>\n</li>\n</ul>\n<p>双亲委派模型对于保证Java程序的未定运行极为重要，但它的实现去异常简单，用以实现双亲委派的代码仅有短短十余行，全部集中在<code>java.lang.ClassLoader</code>的loadClass()方法之中。</p>\n<p>先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败， 抛出<code>ClassNotFoundException</code>异常的话，才调用自己的findClass()方法尝试进行加载。</p>\n<p><strong>破坏双亲委派模型</strong></p>\n<p>双亲委派模型很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型的基础是指他们是总被用户代码继承、调用的API的存在。</p>\n<p>但程序设计往往没有绝对不变的完美规则，当有基础类型又要调回用户的代码，该怎么办？</p>\n<blockquote>\n<p>典型例子：</p>\n</blockquote>\n<ul>\n<li>JNDI服务：是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到<code>rt.jar</code>）属于基础类型，但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码。</li>\n<li>问题：启动类加载器绝不可能认识、加载这些代码，该怎么办？</li>\n<li>解决方案：为解决这个困境，Java设计团队只好引入一个不太优雅的设计，线程上下文类加载器（Thread Context ClassLoader）。</li>\n<li>这个类加载器可以通过<code>java.lang.Thread</code>类的setContextClassLoader()方法设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应有程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。</li>\n</ul>\n<p>有了线程上下文类加载器，JNDI使用它去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。</p>\n<p>Java中涉及SPI的加载基本都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。</p>\n<p>不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK1.6时，JDK提供了<code>java.util.ServiceLoader</code>类，以<code>META-INF/services</code>中的配置信息，辅以责任链模式，这才算给SPI的加载提供了一种相对合理的解决方案。</p>\n<p><strong>OSGi实现模块化热部署</strong></p>\n<p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。</p>\n<p>在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构</p>\n<p><strong>Tomcat为什么要破坏双亲委派模型</strong></p>\n<p>每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器</p>\n<p>大致是出于下面三类目的：</p>\n<ul>\n<li><p>对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源</p>\n</li>\n<li><p>与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏</p>\n</li>\n<li><p>热部署</p>\n</li>\n</ul>\n<img src=\"https://img-blog.csdnimg.cn/c4275d2dc32e44438d08738f38a8244b.png\" style=\"zoom:25%;\" />\n\n<p>对于一些需要加载的非基础类，会由一个叫作 WebAppClassLoader 的类加载器优先加载。</p>\n<p>等它加载不到的时候，再交给上层的 ClassLoader 进行加载。</p>\n<p>这个加载器用来隔绝不同应用的<code>.class</code>文件，比如你的两个应用，可能会依赖同一个第三方的不同版本，它们是相互没有影响的。</p>\n<h1 id=\"模块化系统\"><a href=\"#模块化系统\" class=\"headerlink\" title=\"模块化系统\"></a>模块化系统</h1><p>在JDK 9中引入的Java模块化系统(Java Platform Module System，JPMS)是对Java技术的一次重要升级，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做 出了相应的变动调整，才使模块化系统得以顺利地运作。</p>\n<p><strong>模块化下的类加载器</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/4820f3cc3c0349578363eef45abba95e.png\" style=\"zoom:25%;\" />\n\n<p>JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了 变动。</p>\n<p>当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器 完成加载，也许这可以算是对双亲委派的第四次破坏。</p>\n"},{"title":"垃圾收集算法","_content":"\n假如要现在进行一次只局限于新生代区域内的收集(`Minor GC`)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。\n\n遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。\n\n**跨代引用假说**\n\n跨代引用相对于同代引用来说仅占极少数。\n\n举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。\n\n依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称为记忆集，`Remembered Set`)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。\n\n此后当发生`Minor GC`时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。\n\n虽然这种方法需要在对象改变引用关)时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。\n\n**部分收集(Partial GC)：**\n\n指目标不是完整收集整个Java堆的垃圾收集，其中又分为:\n\n* 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集。\n* 老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集。目前只有`CMS`收集器会有单独收集老年代的行为。\n* 混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有G1收 集器会有这种行为。\n* 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。\n\n**FullGC触发条件：**\n\n1.Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。\n\n此时老年代都放不下这些存活对象了，就会发生Handle Promotion Failure的情况，这个时候就会触 发一次Full GC\n\n如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的 OOM内存溢出了\n\n2.老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；\n\n开启空间担保参数，老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；\n\n3.CMS收集器老年代已经使用的内存空间超过了这个参数`-XX:CMSInitiatingOccupancyFaction`指定的比例，也会自动触发Full GC\n\n4.显示调用`System.gc`\n\n调用`System.gc()`方法会建议JVM进行Full GC，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过`-XX:+ DisableExplicitGC`来禁止RMI调用`System.gc`。\n\n5.Metaspace区内存达到阈值\n\nMetaspace使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace的大小只与本地内存大小有关。\n\n`-XX:MetaspaceSize=21810376B（约为20.8MB`）超过这个值就会引发Full GC，这个值不是固定的，是会随着JVM的运行进行动态调整的\n\n# 标记清除算法\n\n算法分为**标记和清除**两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。\n\n标记过程就是对象是否属于垃圾的判定过程。\n\n**它的主要缺点有两个:**\n\n第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;\n\n第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n# 复制算法\n\n它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。\n\n当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n\n如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。\n\n这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。\n\n**现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代。**\n\nHotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%(Eden的80%加上一个Survivor的10%)，只有一个Survivor空间，即10%的新生代是会 被浪费的。\n\n# 标记整理算法\n\n标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。\n\n其中的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存。\n\n从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整 个程序的吞吐量来看，移动对象会更划算。\n\nHotSpot虚拟机里面关注吞吐量的`Parallel Scavenge`收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。\n\n# 根节点枚举\n\n迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的Stop The World的困扰。\n\n现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行\n\n> 这里一致性的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。\n\n这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者(几乎)不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。\n\n由于目前主流Java虚拟机使用的都是**准确式垃圾收集**，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。\n\n* 在HotSpot 的解决方案里，是使用一组称为`OopMap`的数据结构来达到这个目的。\n\n一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。\n\n这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。\n\n# 安全点\n\n在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来:\n\n* 可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。\n\n实际上HotSpot也的确没有为每条指令都生成OopMap，只是在**特定的位置**记录了这些信息，这些位置被称为安全点(Safep oint)。\n\n有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。\n\n因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。\n\n> 安全点位置的选取基本上是以**是否具有让程序长时间执行的特征**为标准进行选定的\n\n因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，长时间执行的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。\n\n对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程(这里其实不包括执行JNI调用的线程)都跑到最近的安全点，然后停顿下来。\n\n**这里有两种方案可供选择:**\n\n**抢先式中断 (Preemptive Suspension)和主动式中断(Voluntary Suspension)**\n\n抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地 方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。\n\n现在几乎没有虚 拟机实现采用抢先式中断来暂停线程响应GC事件。\n\n而**主动式中断**的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。\n\n轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。\n\n由于轮询操作在代码中会频繁出现，这要求它必须足够高效。\n\nHotSpot使用**内存保护陷阱**的方式， 把轮询操作精简至只有一条汇编指令的程度。\n\n# 安全区域\n\n使用安全点的设计似乎已经完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态的问题了， 但实际情况却并不一定。\n\n安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。\n\n**但是，程序不执行的时候呢?**\n\n所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep 状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。\n\n对于这种情况，就必须引入**安全区域(Safe Region)**来解决。\n\n安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的。\n\n我们也可以把安全区域看作被扩展拉伸了的安全点。\n\n当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。\n\n当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的 阶段)，如果完成了，那线程就当作没事发生过，继续执行\n\n否则它就必须一直等待，直到收到可以离开安全区域的信号为止。\n\n# 记忆集与卡表\n\n分代收集的时候，为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(`Remembered Set`)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。\n\n事 实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(`Partial GC`)行为的 垃圾收集器 \n\n典型的如G1 、 ZGC收集器 ， 都会面临相同的问题 \n\n记忆集是一种用于记录从**非收集区域指向收集区域**的指针集合的抽象数据结构。\n\n如果我们不考虑 效率和成本的话，最简单的实现可以用**非收集区域**中所有含跨代引用的对象数组来实现这个数据结构\n\n卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。\n\n# 写屏障\n\n我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。\n\n卡表元素何时变脏的答案是很明确的\n\n> 有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。\n\n在HotSpot虚拟机里是通过**写屏障(Write Barrier)**技术维护卡表状态的。\n\n应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与`Minor GC`时扫描整个老年代的代价相比还是低得多的。\n\n除了写屏障的开销外，卡表在高并发场景下还面临着**伪共享(False Sharing)**问题。\n\n伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响(写回、无效化或者同步)而导致性能降低，这就是伪共享问题。\n\n假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。\n\n这64个卡表元素对应的卡页总的内存为32KB(64×512字节)，也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。\n\n> 为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏\n\n在JDK 7之后，HotSpot虚拟机增加了一个新的参数`-XX:+UseCondCardMark`，用来决定是否开启卡表更新的条件判断。\n\n开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损 耗，是否打开要根据应用实际运行情况来进行测试权衡。\n\n# 并发可达性分析\n\n当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能**保障一致性的快照**中才能够进行分析， 这意味着必须全程冻结用户线程的运行。\n\n在根节点枚举这个步骤中，由于`GC Roots`相比 起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧(如OopMap)的加持下，它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了。\n\n可从GC Roots再继续往下遍历对象 图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了:\n\n> 堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。\n\n如果这个标记阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时 间的话，那收益也将会是系统性的。\n\n想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进 行对象图的遍历?\n\n> 为了能解释清楚这个问题，我们引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照是否访问过这个条件标记成以下三种颜色:\n\n* 白色:表示对象尚未被垃圾收集器访问过，显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。\n\n* 黑色:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍，黑色对 象不可能直接(不经过灰色对象)指向某个白色对象。\n\n* 灰色:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。\n\n如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。\n\n> 但如果用户线程与收集器是并发工作呢?\n\n收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果：\n\n* 一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。\n\n* 另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误\n\n**因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。**\n\n由此分别产生了两种解决方案:\n\n> 增量更新(Incremental Update)和原始快照(Snapshot At The Beginning， SAT B ) 。\n\n增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新 插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫 描一次。\n\n这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。\n\n> 原始快照要破坏的是第二个条件\n\n当灰色对象要删除指向白色对象的引用关系时，就将这个要删 除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。\n\n这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来 进行搜索。\n\n**以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。**\n\n在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现。","source":"_posts/深入理解JVM虚拟机/垃圾收集算法.md","raw":"---\ntitle: 垃圾收集算法\ncategories: \n- 深入理解JVM虚拟机\n---\n\n假如要现在进行一次只局限于新生代区域内的收集(`Minor GC`)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。\n\n遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。\n\n**跨代引用假说**\n\n跨代引用相对于同代引用来说仅占极少数。\n\n举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。\n\n依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称为记忆集，`Remembered Set`)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。\n\n此后当发生`Minor GC`时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。\n\n虽然这种方法需要在对象改变引用关)时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。\n\n**部分收集(Partial GC)：**\n\n指目标不是完整收集整个Java堆的垃圾收集，其中又分为:\n\n* 新生代收集(Minor GC/Young GC):指目标只是新生代的垃圾收集。\n* 老年代收集(Major GC/Old GC):指目标只是老年代的垃圾收集。目前只有`CMS`收集器会有单独收集老年代的行为。\n* 混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有G1收 集器会有这种行为。\n* 整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。\n\n**FullGC触发条件：**\n\n1.Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。\n\n此时老年代都放不下这些存活对象了，就会发生Handle Promotion Failure的情况，这个时候就会触 发一次Full GC\n\n如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的 OOM内存溢出了\n\n2.老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；\n\n开启空间担保参数，老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；\n\n3.CMS收集器老年代已经使用的内存空间超过了这个参数`-XX:CMSInitiatingOccupancyFaction`指定的比例，也会自动触发Full GC\n\n4.显示调用`System.gc`\n\n调用`System.gc()`方法会建议JVM进行Full GC，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过`-XX:+ DisableExplicitGC`来禁止RMI调用`System.gc`。\n\n5.Metaspace区内存达到阈值\n\nMetaspace使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace的大小只与本地内存大小有关。\n\n`-XX:MetaspaceSize=21810376B（约为20.8MB`）超过这个值就会引发Full GC，这个值不是固定的，是会随着JVM的运行进行动态调整的\n\n# 标记清除算法\n\n算法分为**标记和清除**两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。\n\n标记过程就是对象是否属于垃圾的判定过程。\n\n**它的主要缺点有两个:**\n\n第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;\n\n第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n\n# 复制算法\n\n它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。\n\n当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n\n如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。\n\n这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。\n\n**现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代。**\n\nHotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%(Eden的80%加上一个Survivor的10%)，只有一个Survivor空间，即10%的新生代是会 被浪费的。\n\n# 标记整理算法\n\n标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。\n\n其中的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存。\n\n从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整 个程序的吞吐量来看，移动对象会更划算。\n\nHotSpot虚拟机里面关注吞吐量的`Parallel Scavenge`收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。\n\n# 根节点枚举\n\n迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的Stop The World的困扰。\n\n现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行\n\n> 这里一致性的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。\n\n这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者(几乎)不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。\n\n由于目前主流Java虚拟机使用的都是**准确式垃圾收集**，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。\n\n* 在HotSpot 的解决方案里，是使用一组称为`OopMap`的数据结构来达到这个目的。\n\n一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。\n\n这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。\n\n# 安全点\n\n在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来:\n\n* 可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。\n\n实际上HotSpot也的确没有为每条指令都生成OopMap，只是在**特定的位置**记录了这些信息，这些位置被称为安全点(Safep oint)。\n\n有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。\n\n因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。\n\n> 安全点位置的选取基本上是以**是否具有让程序长时间执行的特征**为标准进行选定的\n\n因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，长时间执行的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。\n\n对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程(这里其实不包括执行JNI调用的线程)都跑到最近的安全点，然后停顿下来。\n\n**这里有两种方案可供选择:**\n\n**抢先式中断 (Preemptive Suspension)和主动式中断(Voluntary Suspension)**\n\n抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地 方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。\n\n现在几乎没有虚 拟机实现采用抢先式中断来暂停线程响应GC事件。\n\n而**主动式中断**的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。\n\n轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。\n\n由于轮询操作在代码中会频繁出现，这要求它必须足够高效。\n\nHotSpot使用**内存保护陷阱**的方式， 把轮询操作精简至只有一条汇编指令的程度。\n\n# 安全区域\n\n使用安全点的设计似乎已经完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态的问题了， 但实际情况却并不一定。\n\n安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。\n\n**但是，程序不执行的时候呢?**\n\n所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep 状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。\n\n对于这种情况，就必须引入**安全区域(Safe Region)**来解决。\n\n安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的。\n\n我们也可以把安全区域看作被扩展拉伸了的安全点。\n\n当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。\n\n当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的 阶段)，如果完成了，那线程就当作没事发生过，继续执行\n\n否则它就必须一直等待，直到收到可以离开安全区域的信号为止。\n\n# 记忆集与卡表\n\n分代收集的时候，为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(`Remembered Set`)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。\n\n事 实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(`Partial GC`)行为的 垃圾收集器 \n\n典型的如G1 、 ZGC收集器 ， 都会面临相同的问题 \n\n记忆集是一种用于记录从**非收集区域指向收集区域**的指针集合的抽象数据结构。\n\n如果我们不考虑 效率和成本的话，最简单的实现可以用**非收集区域**中所有含跨代引用的对象数组来实现这个数据结构\n\n卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。\n\n# 写屏障\n\n我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。\n\n卡表元素何时变脏的答案是很明确的\n\n> 有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。\n\n在HotSpot虚拟机里是通过**写屏障(Write Barrier)**技术维护卡表状态的。\n\n应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与`Minor GC`时扫描整个老年代的代价相比还是低得多的。\n\n除了写屏障的开销外，卡表在高并发场景下还面临着**伪共享(False Sharing)**问题。\n\n伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响(写回、无效化或者同步)而导致性能降低，这就是伪共享问题。\n\n假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。\n\n这64个卡表元素对应的卡页总的内存为32KB(64×512字节)，也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。\n\n> 为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏\n\n在JDK 7之后，HotSpot虚拟机增加了一个新的参数`-XX:+UseCondCardMark`，用来决定是否开启卡表更新的条件判断。\n\n开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损 耗，是否打开要根据应用实际运行情况来进行测试权衡。\n\n# 并发可达性分析\n\n当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能**保障一致性的快照**中才能够进行分析， 这意味着必须全程冻结用户线程的运行。\n\n在根节点枚举这个步骤中，由于`GC Roots`相比 起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧(如OopMap)的加持下，它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了。\n\n可从GC Roots再继续往下遍历对象 图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了:\n\n> 堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。\n\n如果这个标记阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时 间的话，那收益也将会是系统性的。\n\n想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进 行对象图的遍历?\n\n> 为了能解释清楚这个问题，我们引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照是否访问过这个条件标记成以下三种颜色:\n\n* 白色:表示对象尚未被垃圾收集器访问过，显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。\n\n* 黑色:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍，黑色对 象不可能直接(不经过灰色对象)指向某个白色对象。\n\n* 灰色:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。\n\n如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。\n\n> 但如果用户线程与收集器是并发工作呢?\n\n收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果：\n\n* 一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。\n\n* 另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误\n\n**因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。**\n\n由此分别产生了两种解决方案:\n\n> 增量更新(Incremental Update)和原始快照(Snapshot At The Beginning， SAT B ) 。\n\n增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新 插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫 描一次。\n\n这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。\n\n> 原始快照要破坏的是第二个条件\n\n当灰色对象要删除指向白色对象的引用关系时，就将这个要删 除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。\n\n这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来 进行搜索。\n\n**以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。**\n\n在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现。","slug":"深入理解JVM虚拟机/垃圾收集算法","published":1,"date":"2021-12-25T11:30:32.268Z","updated":"2021-12-26T06:53:26.109Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkm00kdfhji7v7n7d8v","content":"<p>假如要现在进行一次只局限于新生代区域内的收集(<code>Minor GC</code>)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。</p>\n<p>遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。</p>\n<p><strong>跨代引用假说</strong></p>\n<p>跨代引用相对于同代引用来说仅占极少数。</p>\n<p>举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p>\n<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称为记忆集，<code>Remembered Set</code>)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。</p>\n<p>此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>\n<p>虽然这种方法需要在对象改变引用关)时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>\n<p><strong>部分收集(Partial GC)：</strong></p>\n<p>指目标不是完整收集整个Java堆的垃圾收集，其中又分为:</p>\n<ul>\n<li>新生代收集(Minor GC&#x2F;Young GC):指目标只是新生代的垃圾收集。</li>\n<li>老年代收集(Major GC&#x2F;Old GC):指目标只是老年代的垃圾收集。目前只有<code>CMS</code>收集器会有单独收集老年代的行为。</li>\n<li>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有G1收 集器会有这种行为。</li>\n<li>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。</li>\n</ul>\n<p><strong>FullGC触发条件：</strong></p>\n<p>1.Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。</p>\n<p>此时老年代都放不下这些存活对象了，就会发生Handle Promotion Failure的情况，这个时候就会触 发一次Full GC</p>\n<p>如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的 OOM内存溢出了</p>\n<p>2.老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；</p>\n<p>开启空间担保参数，老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；</p>\n<p>3.CMS收集器老年代已经使用的内存空间超过了这个参数<code>-XX:CMSInitiatingOccupancyFaction</code>指定的比例，也会自动触发Full GC</p>\n<p>4.显示调用<code>System.gc</code></p>\n<p>调用<code>System.gc()</code>方法会建议JVM进行Full GC，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI调用<code>System.gc</code>。</p>\n<p>5.Metaspace区内存达到阈值</p>\n<p>Metaspace使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace的大小只与本地内存大小有关。</p>\n<p><code>-XX:MetaspaceSize=21810376B（约为20.8MB</code>）超过这个值就会引发Full GC，这个值不是固定的，是会随着JVM的运行进行动态调整的</p>\n<h1 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h1><p>算法分为<strong>标记和清除</strong>两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>\n<p>标记过程就是对象是否属于垃圾的判定过程。</p>\n<p><strong>它的主要缺点有两个:</strong></p>\n<p>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;</p>\n<p>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n<h1 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h1><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</p>\n<p>当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>\n<p>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>\n<p>这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</p>\n<p><strong>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代。</strong></p>\n<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%(Eden的80%加上一个Survivor的10%)，只有一个Survivor空间，即10%的新生代是会 被浪费的。</p>\n<h1 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h1><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。</p>\n<p>其中的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存。</p>\n<p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整 个程序的吞吐量来看，移动对象会更划算。</p>\n<p>HotSpot虚拟机里面关注吞吐量的<code>Parallel Scavenge</code>收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。</p>\n<h1 id=\"根节点枚举\"><a href=\"#根节点枚举\" class=\"headerlink\" title=\"根节点枚举\"></a>根节点枚举</h1><p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的Stop The World的困扰。</p>\n<p>现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</p>\n<blockquote>\n<p>这里一致性的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。</p>\n</blockquote>\n<p>这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者(几乎)不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p>\n<p>由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</p>\n<ul>\n<li>在HotSpot 的解决方案里，是使用一组称为<code>OopMap</code>的数据结构来达到这个目的。</li>\n</ul>\n<p>一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</p>\n<p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>\n<h1 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h1><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来:</p>\n<ul>\n<li>可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</li>\n</ul>\n<p>实际上HotSpot也的确没有为每条指令都生成OopMap，只是在<strong>特定的位置</strong>记录了这些信息，这些位置被称为安全点(Safep oint)。</p>\n<p>有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。</p>\n<p>因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。</p>\n<blockquote>\n<p>安全点位置的选取基本上是以<strong>是否具有让程序长时间执行的特征</strong>为标准进行选定的</p>\n</blockquote>\n<p>因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，长时间执行的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>\n<p>对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程(这里其实不包括执行JNI调用的线程)都跑到最近的安全点，然后停顿下来。</p>\n<p><strong>这里有两种方案可供选择:</strong></p>\n<p><strong>抢先式中断 (Preemptive Suspension)和主动式中断(Voluntary Suspension)</strong></p>\n<p>抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地 方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>\n<p>现在几乎没有虚 拟机实现采用抢先式中断来暂停线程响应GC事件。</p>\n<p>而<strong>主动式中断</strong>的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p>\n<p>轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p>\n<p>由于轮询操作在代码中会频繁出现，这要求它必须足够高效。</p>\n<p>HotSpot使用<strong>内存保护陷阱</strong>的方式， 把轮询操作精简至只有一条汇编指令的程度。</p>\n<h1 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h1><p>使用安全点的设计似乎已经完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态的问题了， 但实际情况却并不一定。</p>\n<p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。</p>\n<p><strong>但是，程序不执行的时候呢?</strong></p>\n<p>所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep 状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>\n<p>对于这种情况，就必须引入**安全区域(Safe Region)**来解决。</p>\n<p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的。</p>\n<p>我们也可以把安全区域看作被扩展拉伸了的安全点。</p>\n<p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</p>\n<p>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的 阶段)，如果完成了，那线程就当作没事发生过，继续执行</p>\n<p>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>\n<h1 id=\"记忆集与卡表\"><a href=\"#记忆集与卡表\" class=\"headerlink\" title=\"记忆集与卡表\"></a>记忆集与卡表</h1><p>分代收集的时候，为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(<code>Remembered Set</code>)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</p>\n<p>事 实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(<code>Partial GC</code>)行为的 垃圾收集器 </p>\n<p>典型的如G1 、 ZGC收集器 ， 都会面临相同的问题 </p>\n<p>记忆集是一种用于记录从<strong>非收集区域指向收集区域</strong>的指针集合的抽象数据结构。</p>\n<p>如果我们不考虑 效率和成本的话，最简单的实现可以用<strong>非收集区域</strong>中所有含跨代引用的对象数组来实现这个数据结构</p>\n<p>卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。</p>\n<h1 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h1><p>我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。</p>\n<p>卡表元素何时变脏的答案是很明确的</p>\n<blockquote>\n<p>有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。</p>\n</blockquote>\n<p>在HotSpot虚拟机里是通过**写屏障(Write Barrier)**技术维护卡表状态的。</p>\n<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与<code>Minor GC</code>时扫描整个老年代的代价相比还是低得多的。</p>\n<p>除了写屏障的开销外，卡表在高并发场景下还面临着**伪共享(False Sharing)**问题。</p>\n<p>伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响(写回、无效化或者同步)而导致性能降低，这就是伪共享问题。</p>\n<p>假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。</p>\n<p>这64个卡表元素对应的卡页总的内存为32KB(64×512字节)，也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。</p>\n<blockquote>\n<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p>\n</blockquote>\n<p>在JDK 7之后，HotSpot虚拟机增加了一个新的参数<code>-XX:+UseCondCardMark</code>，用来决定是否开启卡表更新的条件判断。</p>\n<p>开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损 耗，是否打开要根据应用实际运行情况来进行测试权衡。</p>\n<h1 id=\"并发可达性分析\"><a href=\"#并发可达性分析\" class=\"headerlink\" title=\"并发可达性分析\"></a>并发可达性分析</h1><p>当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能<strong>保障一致性的快照</strong>中才能够进行分析， 这意味着必须全程冻结用户线程的运行。</p>\n<p>在根节点枚举这个步骤中，由于<code>GC Roots</code>相比 起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧(如OopMap)的加持下，它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了。</p>\n<p>可从GC Roots再继续往下遍历对象 图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了:</p>\n<blockquote>\n<p>堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。</p>\n</blockquote>\n<p>如果这个标记阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时 间的话，那收益也将会是系统性的。</p>\n<p>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进 行对象图的遍历?</p>\n<blockquote>\n<p>为了能解释清楚这个问题，我们引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照是否访问过这个条件标记成以下三种颜色:</p>\n</blockquote>\n<ul>\n<li><p>白色:表示对象尚未被垃圾收集器访问过，显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p>\n</li>\n<li><p>黑色:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍，黑色对 象不可能直接(不经过灰色对象)指向某个白色对象。</p>\n</li>\n<li><p>灰色:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</p>\n</li>\n</ul>\n<p>如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。</p>\n<blockquote>\n<p>但如果用户线程与收集器是并发工作呢?</p>\n</blockquote>\n<p>收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果：</p>\n<ul>\n<li><p>一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。</p>\n</li>\n<li><p>另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误</p>\n</li>\n</ul>\n<p><strong>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。</strong></p>\n<p>由此分别产生了两种解决方案:</p>\n<blockquote>\n<p>增量更新(Incremental Update)和原始快照(Snapshot At The Beginning， SAT B ) 。</p>\n</blockquote>\n<p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新 插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫 描一次。</p>\n<p>这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>\n<blockquote>\n<p>原始快照要破坏的是第二个条件</p>\n</blockquote>\n<p>当灰色对象要删除指向白色对象的引用关系时，就将这个要删 除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。</p>\n<p>这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来 进行搜索。</p>\n<p><strong>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。</strong></p>\n<p>在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>假如要现在进行一次只局限于新生代区域内的收集(<code>Minor GC</code>)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。</p>\n<p>遍历整个老年代所有对象 的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。</p>\n<p><strong>跨代引用假说</strong></p>\n<p>跨代引用相对于同代引用来说仅占极少数。</p>\n<p>举个例子，如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。</p>\n<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称为记忆集，<code>Remembered Set</code>)，这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。</p>\n<p>此后当发生<code>Minor GC</code>时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。</p>\n<p>虽然这种方法需要在对象改变引用关)时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>\n<p><strong>部分收集(Partial GC)：</strong></p>\n<p>指目标不是完整收集整个Java堆的垃圾收集，其中又分为:</p>\n<ul>\n<li>新生代收集(Minor GC&#x2F;Young GC):指目标只是新生代的垃圾收集。</li>\n<li>老年代收集(Major GC&#x2F;Old GC):指目标只是老年代的垃圾收集。目前只有<code>CMS</code>收集器会有单独收集老年代的行为。</li>\n<li>混合收集(Mixed GC):指目标是收集整个新生代以及部分老年代的垃圾收集，目前只有G1收 集器会有这种行为。</li>\n<li>整堆收集(Full GC):收集整个Java堆和方法区的垃圾收集。</li>\n</ul>\n<p><strong>FullGC触发条件：</strong></p>\n<p>1.Minor GC过后，剩余的存活对象的大小，大于了Survivor区域的大小，也大于了老年代可用内存的大小。</p>\n<p>此时老年代都放不下这些存活对象了，就会发生Handle Promotion Failure的情况，这个时候就会触 发一次Full GC</p>\n<p>如果要是Full GC过后，老年代还是没有足够的空间存放Minor GC过后的剩余存活对象，那么此时就会导致所谓的 OOM内存溢出了</p>\n<p>2.老年代可用内存小于新生代全部对象的大小，如果没开启空间担保参数，会直接触发Full GC，所以一般空间担保参数都会打开；</p>\n<p>开启空间担保参数，老年代可用内存小于历次新生代GC后进入老年代的平均对象大小，此时会提前Full GC；</p>\n<p>3.CMS收集器老年代已经使用的内存空间超过了这个参数<code>-XX:CMSInitiatingOccupancyFaction</code>指定的比例，也会自动触发Full GC</p>\n<p>4.显示调用<code>System.gc</code></p>\n<p>调用<code>System.gc()</code>方法会建议JVM进行Full GC，不过在大多数情况下会增加Full GC的次数，导致系统性能下降，一般建议不要手动进行此方法的调用，可以通过<code>-XX:+ DisableExplicitGC</code>来禁止RMI调用<code>System.gc</code>。</p>\n<p>5.Metaspace区内存达到阈值</p>\n<p>Metaspace使用的是本地内存，而不是堆内存，也就是说在默认情况下Metaspace的大小只与本地内存大小有关。</p>\n<p><code>-XX:MetaspaceSize=21810376B（约为20.8MB</code>）超过这个值就会引发Full GC，这个值不是固定的，是会随着JVM的运行进行动态调整的</p>\n<h1 id=\"标记清除算法\"><a href=\"#标记清除算法\" class=\"headerlink\" title=\"标记清除算法\"></a>标记清除算法</h1><p>算法分为<strong>标记和清除</strong>两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>\n<p>标记过程就是对象是否属于垃圾的判定过程。</p>\n<p><strong>它的主要缺点有两个:</strong></p>\n<p>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;</p>\n<p>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>\n<h1 id=\"复制算法\"><a href=\"#复制算法\" class=\"headerlink\" title=\"复制算法\"></a>复制算法</h1><p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。</p>\n<p>当这一块的内存用完了，就将还存活着 的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>\n<p>如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有 空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p>\n<p>这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，空间浪费未免太多了一 点。</p>\n<p><strong>现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代。</strong></p>\n<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%(Eden的80%加上一个Survivor的10%)，只有一个Survivor空间，即10%的新生代是会 被浪费的。</p>\n<h1 id=\"标记整理算法\"><a href=\"#标记整理算法\" class=\"headerlink\" title=\"标记整理算法\"></a>标记整理算法</h1><p>标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。</p>\n<p>其中的标记过程仍然与标记-清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内 存。</p>\n<p>从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整 个程序的吞吐量来看，移动对象会更划算。</p>\n<p>HotSpot虚拟机里面关注吞吐量的<code>Parallel Scavenge</code>收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的。</p>\n<h1 id=\"根节点枚举\"><a href=\"#根节点枚举\" class=\"headerlink\" title=\"根节点枚举\"></a>根节点枚举</h1><p>迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的Stop The World的困扰。</p>\n<p>现在可达性分析算法耗时最长的查找引用链的过程已经可以做到与用户线程一起并发，但根节点枚举始终还是必须在一个能保障一致性的快照中才得以进行</p>\n<blockquote>\n<p>这里一致性的意思是整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况，若这点不能满足的话，分析结果准确性也就无法保证。</p>\n</blockquote>\n<p>这是导致垃圾收集过程必须停顿所有用户线程的其中一个重要原因，即使是号称停顿时间可控，或者(几乎)不会发生停顿的CMS、G1、 ZGC等收集器，枚举根节点时也是必须要停顿的。</p>\n<p>由于目前主流Java虚拟机使用的都是<strong>准确式垃圾收集</strong>，所以当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用的。</p>\n<ul>\n<li>在HotSpot 的解决方案里，是使用一组称为<code>OopMap</code>的数据结构来达到这个目的。</li>\n</ul>\n<p>一旦类加载动作完成的时候， HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。</p>\n<p>这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等GC Roots开始查找。</p>\n<h1 id=\"安全点\"><a href=\"#安全点\" class=\"headerlink\" title=\"安全点\"></a>安全点</h1><p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来:</p>\n<ul>\n<li>可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</li>\n</ul>\n<p>实际上HotSpot也的确没有为每条指令都生成OopMap，只是在<strong>特定的位置</strong>记录了这些信息，这些位置被称为安全点(Safep oint)。</p>\n<p>有了安全点的设定，也就决定了用户程序执行时并非在代码指令流的任意位置都能够停顿下来开始垃圾收集，而是强制要求必须执行到达安全点后才能够暂停。</p>\n<p>因此，安全点的选定既不能太少以至于让收集器等待时间过长，也不能太过频繁以至于过分增大运行时的内存负荷。</p>\n<blockquote>\n<p>安全点位置的选取基本上是以<strong>是否具有让程序长时间执行的特征</strong>为标准进行选定的</p>\n</blockquote>\n<p>因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这样的原因而长时间执行，长时间执行的最明显特征就是指令序列的复用，例如方法调用、循环跳转、异常跳转 等都属于指令序列复用，所以只有具有这些功能的指令才会产生安全点。</p>\n<p>对于安全点，另外一个需要考虑的问题是，如何在垃圾收集发生时让所有线程(这里其实不包括执行JNI调用的线程)都跑到最近的安全点，然后停顿下来。</p>\n<p><strong>这里有两种方案可供选择:</strong></p>\n<p><strong>抢先式中断 (Preemptive Suspension)和主动式中断(Voluntary Suspension)</strong></p>\n<p>抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地 方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>\n<p>现在几乎没有虚 拟机实现采用抢先式中断来暂停线程响应GC事件。</p>\n<p>而<strong>主动式中断</strong>的思想是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一 个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最 近的安全点上主动中断挂起。</p>\n<p>轮询标志的地方和安全点是重合的，另外还要加上所有创建对象和其他需要在Java堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。</p>\n<p>由于轮询操作在代码中会频繁出现，这要求它必须足够高效。</p>\n<p>HotSpot使用<strong>内存保护陷阱</strong>的方式， 把轮询操作精简至只有一条汇编指令的程度。</p>\n<h1 id=\"安全区域\"><a href=\"#安全区域\" class=\"headerlink\" title=\"安全区域\"></a>安全区域</h1><p>使用安全点的设计似乎已经完美解决如何停顿用户线程，让虚拟机进入垃圾回收状态的问题了， 但实际情况却并不一定。</p>\n<p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点。</p>\n<p><strong>但是，程序不执行的时候呢?</strong></p>\n<p>所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于Sleep 状态或者Blocked状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。</p>\n<p>对于这种情况，就必须引入**安全区域(Safe Region)**来解决。</p>\n<p>安全区域是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任 意地方开始垃圾收集都是安全的。</p>\n<p>我们也可以把安全区域看作被扩展拉伸了的安全点。</p>\n<p>当用户线程执行到安全区域里面的代码时，首先会标识自己已经进入了安全区域，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。</p>\n<p>当线程要离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举(或者垃圾收集过程中其他需要暂停用户线程的 阶段)，如果完成了，那线程就当作没事发生过，继续执行</p>\n<p>否则它就必须一直等待，直到收到可以离开安全区域的信号为止。</p>\n<h1 id=\"记忆集与卡表\"><a href=\"#记忆集与卡表\" class=\"headerlink\" title=\"记忆集与卡表\"></a>记忆集与卡表</h1><p>分代收集的时候，为解决对象跨代引用所带来的问题，垃圾收集器在新生代中建立了名为记忆集(<code>Remembered Set</code>)的数据结构，用以避免把整个老年代加进GC Roots扫描范围。</p>\n<p>事 实上并不只是新生代、老年代之间才有跨代引用的问题，所有涉及部分区域收集(<code>Partial GC</code>)行为的 垃圾收集器 </p>\n<p>典型的如G1 、 ZGC收集器 ， 都会面临相同的问题 </p>\n<p>记忆集是一种用于记录从<strong>非收集区域指向收集区域</strong>的指针集合的抽象数据结构。</p>\n<p>如果我们不考虑 效率和成本的话，最简单的实现可以用<strong>非收集区域</strong>中所有含跨代引用的对象数组来实现这个数据结构</p>\n<p>卡表就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。</p>\n<h1 id=\"写屏障\"><a href=\"#写屏障\" class=\"headerlink\" title=\"写屏障\"></a>写屏障</h1><p>我们已经解决了如何使用记忆集来缩减GC Roots扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。</p>\n<p>卡表元素何时变脏的答案是很明确的</p>\n<blockquote>\n<p>有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。</p>\n</blockquote>\n<p>在HotSpot虚拟机里是通过**写屏障(Write Barrier)**技术维护卡表状态的。</p>\n<p>应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与<code>Minor GC</code>时扫描整个老年代的代价相比还是低得多的。</p>\n<p>除了写屏障的开销外，卡表在高并发场景下还面临着**伪共享(False Sharing)**问题。</p>\n<p>伪共享是处 理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影 响(写回、无效化或者同步)而导致性能降低，这就是伪共享问题。</p>\n<p>假设处理器的缓存行大小为64字节，由于一个卡表元素占1个字节，64个卡表元素将共享同一个缓存行。</p>\n<p>这64个卡表元素对应的卡页总的内存为32KB(64×512字节)，也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。</p>\n<blockquote>\n<p>为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏</p>\n</blockquote>\n<p>在JDK 7之后，HotSpot虚拟机增加了一个新的参数<code>-XX:+UseCondCardMark</code>，用来决定是否开启卡表更新的条件判断。</p>\n<p>开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损 耗，是否打开要根据应用实际运行情况来进行测试权衡。</p>\n<h1 id=\"并发可达性分析\"><a href=\"#并发可达性分析\" class=\"headerlink\" title=\"并发可达性分析\"></a>并发可达性分析</h1><p>当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能<strong>保障一致性的快照</strong>中才能够进行分析， 这意味着必须全程冻结用户线程的运行。</p>\n<p>在根节点枚举这个步骤中，由于<code>GC Roots</code>相比 起整个Java堆中全部的对象毕竟还算是极少数，且在各种优化技巧(如OopMap)的加持下，它带来的停顿已经是非常短暂且相对固定(不随堆容量而增长)的了。</p>\n<p>可从GC Roots再继续往下遍历对象 图，这一步骤的停顿时间就必定会与Java堆容量直接成正比例关系了:</p>\n<blockquote>\n<p>堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。</p>\n</blockquote>\n<p>如果这个标记阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时 间的话，那收益也将会是系统性的。</p>\n<p>想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进 行对象图的遍历?</p>\n<blockquote>\n<p>为了能解释清楚这个问题，我们引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照是否访问过这个条件标记成以下三种颜色:</p>\n</blockquote>\n<ul>\n<li><p>白色:表示对象尚未被垃圾收集器访问过，显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。</p>\n</li>\n<li><p>黑色:表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过，黑色的对象代 表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍，黑色对 象不可能直接(不经过灰色对象)指向某个白色对象。</p>\n</li>\n<li><p>灰色:表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。</p>\n</li>\n</ul>\n<p>如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。</p>\n<blockquote>\n<p>但如果用户线程与收集器是并发工作呢?</p>\n</blockquote>\n<p>收集器在对象图上标记颜色，同时用户线程在修改引用 关系——即修改对象图的结构，这样可能出现两种后果：</p>\n<ul>\n<li><p>一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。</p>\n</li>\n<li><p>另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误</p>\n</li>\n</ul>\n<p><strong>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。</strong></p>\n<p>由此分别产生了两种解决方案:</p>\n<blockquote>\n<p>增量更新(Incremental Update)和原始快照(Snapshot At The Beginning， SAT B ) 。</p>\n</blockquote>\n<p>增量更新要破坏的是第一个条件，当黑色对象插入新的指向白色对象的引用关系时，就将这个新 插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫 描一次。</p>\n<p>这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。</p>\n<blockquote>\n<p>原始快照要破坏的是第二个条件</p>\n</blockquote>\n<p>当灰色对象要删除指向白色对象的引用关系时，就将这个要删 除的引用记录下来，在并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根，重新扫描 一次。</p>\n<p>这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来 进行搜索。</p>\n<p><strong>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。</strong></p>\n<p>在 HotSpot虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS是基于增量更新 来做并发标记的，G1、Shenandoah则是用原始快照来实现。</p>\n"},{"title":"类文件结构","_content":"\n**Class类文件的结构**\n\nClass文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。\n\n当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。\n\n根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型\n\n无符号数和表：\n\n* 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。\n\n* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以`_info`结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表\n\n无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的 容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。\n\n**魔数与Class文件的版本**\n\n每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。\n\n紧接着魔数的4个字节存储的是Class文件的版本号\n\n第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。\n\nJava的版本号是从45开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1(JDK 1.0~1.1使用了45.0~45.3的版本号)，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class 文件。\n\n<img src=\"https://img-blog.csdnimg.cn/87774694985d48b3af9db493965107ea.png\" style=\"zoom:25%;\" />\n\n# 常量池\n\n紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。\n\n常量池中主要存放两大类常量:\n\n* 字面量(Literal)和符号引用(Symbolic References)。\n\n字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。\n\n而符号引用则属于编译原理方面的概念，主要包括下面几类常量：\n\n* 类和接口的全限定名(Fully Qualified Name)\n\n* 字段的名称和描述符(Descriptor)\n\n* 方法的名称和描述符\n\nJava代码在进行Javac编译的时候，并不像C和C++那样有连接这一步骤，而是在虚拟机加载Class 文件的时候进行动态连接。\n\n也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。\n\n当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。\n\n# 访问标志\n\n在常量池结束之后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口\n\n是否定义为public类型;是否定义为abstract 类型;如果是类的话，是否被声明为final;等等。\n\n**类索引、父类索引与接口索引集合**\n\n类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。\n\n由于Java语言不允许多 重继承，所以父类索引只有一个，除了`java.lang.Object`之外，所有的Java类都有父类，因此除了 `java.lang.Object`外，所有Java类的父类索引都不为0。\n\n接口索引集合就用来描述这个类实现了哪些接 口，这些被实现的接口将按implements关键字(如果这个Class文件表示的是一个接口，则应当是 extends 关 键 字 ) 后 的 接 口 顺 序 从 左 到 右 排 列 在 接 口 索 引 集 合 中 。\n\n**字段表集合**\n\n字段表用于描述接口或者类中声明的变量。\n\nJava语言中的字段(Field)包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。\n\n**方法表集合**\n\nClass文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descrip tor_index)、属性表集合(attributes)几项。\n\n**属性表集合** \n\nClass文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。\n\n与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。\n\n# 字节码指令\n\nJava虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode) 以及跟随其后的零至多个代表此操作所需的参数(称为操作数，Operand)构成。\n\n由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所 以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。\n\n字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚 拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不能够超过256条\n\n**字节码与数据类型**\n\n在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。\n\n举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。\n\n这两 条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。\n\n# 运行时栈帧结构\n\n Java虚拟机以方法作为最基本的执行单元，栈帧(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。\n\n每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 \n\n在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。\n\n换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。\n\n一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。\n\n而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为当前栈帧(Current Stack Frame)，与这个栈帧所关联的方法被称为当前方法(Current Method)。\n\n执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作\n\n**局部变量表**\n\n局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。\n\n在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。\n\n局部变量表的容量以变量槽(Variable Slot)为最小单位，《Java虚拟机规范》中并没有明确指出 一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储\n\n<img src=\"https://img-blog.csdnimg.cn/6110e923319b481c83d2a7e955c7396c.png\" style=\"zoom:25%;\" />","source":"_posts/深入理解JVM虚拟机/类文件结构.md","raw":"---\ntitle: 类文件结构\ncategories: \n- 深入理解JVM虚拟机\n---\n\n**Class类文件的结构**\n\nClass文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。\n\n当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。\n\n根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型\n\n无符号数和表：\n\n* 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。\n\n* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以`_info`结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表\n\n无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的 容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。\n\n**魔数与Class文件的版本**\n\n每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。\n\n紧接着魔数的4个字节存储的是Class文件的版本号\n\n第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。\n\nJava的版本号是从45开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1(JDK 1.0~1.1使用了45.0~45.3的版本号)，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class 文件。\n\n<img src=\"https://img-blog.csdnimg.cn/87774694985d48b3af9db493965107ea.png\" style=\"zoom:25%;\" />\n\n# 常量池\n\n紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。\n\n常量池中主要存放两大类常量:\n\n* 字面量(Literal)和符号引用(Symbolic References)。\n\n字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。\n\n而符号引用则属于编译原理方面的概念，主要包括下面几类常量：\n\n* 类和接口的全限定名(Fully Qualified Name)\n\n* 字段的名称和描述符(Descriptor)\n\n* 方法的名称和描述符\n\nJava代码在进行Javac编译的时候，并不像C和C++那样有连接这一步骤，而是在虚拟机加载Class 文件的时候进行动态连接。\n\n也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。\n\n当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。\n\n# 访问标志\n\n在常量池结束之后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口\n\n是否定义为public类型;是否定义为abstract 类型;如果是类的话，是否被声明为final;等等。\n\n**类索引、父类索引与接口索引集合**\n\n类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。\n\n由于Java语言不允许多 重继承，所以父类索引只有一个，除了`java.lang.Object`之外，所有的Java类都有父类，因此除了 `java.lang.Object`外，所有Java类的父类索引都不为0。\n\n接口索引集合就用来描述这个类实现了哪些接 口，这些被实现的接口将按implements关键字(如果这个Class文件表示的是一个接口，则应当是 extends 关 键 字 ) 后 的 接 口 顺 序 从 左 到 右 排 列 在 接 口 索 引 集 合 中 。\n\n**字段表集合**\n\n字段表用于描述接口或者类中声明的变量。\n\nJava语言中的字段(Field)包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。\n\n**方法表集合**\n\nClass文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descrip tor_index)、属性表集合(attributes)几项。\n\n**属性表集合** \n\nClass文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。\n\n与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。\n\n# 字节码指令\n\nJava虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode) 以及跟随其后的零至多个代表此操作所需的参数(称为操作数，Operand)构成。\n\n由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所 以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。\n\n字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚 拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不能够超过256条\n\n**字节码与数据类型**\n\n在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。\n\n举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。\n\n这两 条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。\n\n# 运行时栈帧结构\n\n Java虚拟机以方法作为最基本的执行单元，栈帧(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。\n\n每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 \n\n在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。\n\n换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。\n\n一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。\n\n而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为当前栈帧(Current Stack Frame)，与这个栈帧所关联的方法被称为当前方法(Current Method)。\n\n执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作\n\n**局部变量表**\n\n局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。\n\n在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。\n\n局部变量表的容量以变量槽(Variable Slot)为最小单位，《Java虚拟机规范》中并没有明确指出 一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储\n\n<img src=\"https://img-blog.csdnimg.cn/6110e923319b481c83d2a7e955c7396c.png\" style=\"zoom:25%;\" />","slug":"深入理解JVM虚拟机/类文件结构","published":1,"date":"2021-12-26T07:06:42.840Z","updated":"2021-12-26T07:24:34.319Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkm00kefhji5zrm0xbq","content":"<p><strong>Class类文件的结构</strong></p>\n<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p>\n<p>当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。</p>\n<p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型</p>\n<p>无符号数和表：</p>\n<ul>\n<li><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>\n</li>\n<li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</p>\n</li>\n</ul>\n<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的 容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。</p>\n<p><strong>魔数与Class文件的版本</strong></p>\n<p>每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>\n<p>紧接着魔数的4个字节存储的是Class文件的版本号</p>\n<p>第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。</p>\n<p>Java的版本号是从45开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1(JDK 1.0<del>1.1使用了45.0</del>45.3的版本号)，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class 文件。</p>\n<img src=\"https://img-blog.csdnimg.cn/87774694985d48b3af9db493965107ea.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h1><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</p>\n<p>常量池中主要存放两大类常量:</p>\n<ul>\n<li>字面量(Literal)和符号引用(Symbolic References)。</li>\n</ul>\n<p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>\n<p>而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>\n<ul>\n<li><p>类和接口的全限定名(Fully Qualified Name)</p>\n</li>\n<li><p>字段的名称和描述符(Descriptor)</p>\n</li>\n<li><p>方法的名称和描述符</p>\n</li>\n</ul>\n<p>Java代码在进行Javac编译的时候，并不像C和C++那样有连接这一步骤，而是在虚拟机加载Class 文件的时候进行动态连接。</p>\n<p>也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。</p>\n<p>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>\n<h1 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h1><p>在常量池结束之后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口</p>\n<p>是否定义为public类型;是否定义为abstract 类型;如果是类的话，是否被声明为final;等等。</p>\n<p><strong>类索引、父类索引与接口索引集合</strong></p>\n<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>\n<p>由于Java语言不允许多 重继承，所以父类索引只有一个，除了<code>java.lang.Object</code>之外，所有的Java类都有父类，因此除了 <code>java.lang.Object</code>外，所有Java类的父类索引都不为0。</p>\n<p>接口索引集合就用来描述这个类实现了哪些接 口，这些被实现的接口将按implements关键字(如果这个Class文件表示的是一个接口，则应当是 extends 关 键 字 ) 后 的 接 口 顺 序 从 左 到 右 排 列 在 接 口 索 引 集 合 中 。</p>\n<p><strong>字段表集合</strong></p>\n<p>字段表用于描述接口或者类中声明的变量。</p>\n<p>Java语言中的字段(Field)包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>\n<p><strong>方法表集合</strong></p>\n<p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descrip tor_index)、属性表集合(attributes)几项。</p>\n<p><strong>属性表集合</strong> </p>\n<p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>\n<p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。</p>\n<h1 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h1><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode) 以及跟随其后的零至多个代表此操作所需的参数(称为操作数，Operand)构成。</p>\n<p>由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所 以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p>\n<p>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚 拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不能够超过256条</p>\n<p><strong>字节码与数据类型</strong></p>\n<p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。</p>\n<p>举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p>\n<p>这两 条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p>\n<h1 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h1><p> Java虚拟机以方法作为最基本的执行单元，栈帧(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>\n<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 </p>\n<p>在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。</p>\n<p>换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>\n<p>一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。</p>\n<p>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为当前栈帧(Current Stack Frame)，与这个栈帧所关联的方法被称为当前方法(Current Method)。</p>\n<p>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作</p>\n<p><strong>局部变量表</strong></p>\n<p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。</p>\n<p>在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p>\n<p>局部变量表的容量以变量槽(Variable Slot)为最小单位，《Java虚拟机规范》中并没有明确指出 一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储</p>\n<img src=\"https://img-blog.csdnimg.cn/6110e923319b481c83d2a7e955c7396c.png\" style=\"zoom:25%;\" />","site":{"data":{}},"excerpt":"","more":"<p><strong>Class类文件的结构</strong></p>\n<p>Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。</p>\n<p>当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。</p>\n<p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型</p>\n<p>无符号数和表：</p>\n<ul>\n<li><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>\n</li>\n<li><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以<code>_info</code>结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</p>\n</li>\n</ul>\n<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的 容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。</p>\n<p><strong>魔数与Class文件的版本</strong></p>\n<p>每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>\n<p>紧接着魔数的4个字节存储的是Class文件的版本号</p>\n<p>第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。</p>\n<p>Java的版本号是从45开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1(JDK 1.0<del>1.1使用了45.0</del>45.3的版本号)，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class 文件。</p>\n<img src=\"https://img-blog.csdnimg.cn/87774694985d48b3af9db493965107ea.png\" style=\"zoom:25%;\" />\n\n<h1 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h1><p>紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</p>\n<p>常量池中主要存放两大类常量:</p>\n<ul>\n<li>字面量(Literal)和符号引用(Symbolic References)。</li>\n</ul>\n<p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>\n<p>而符号引用则属于编译原理方面的概念，主要包括下面几类常量：</p>\n<ul>\n<li><p>类和接口的全限定名(Fully Qualified Name)</p>\n</li>\n<li><p>字段的名称和描述符(Descriptor)</p>\n</li>\n<li><p>方法的名称和描述符</p>\n</li>\n</ul>\n<p>Java代码在进行Javac编译的时候，并不像C和C++那样有连接这一步骤，而是在虚拟机加载Class 文件的时候进行动态连接。</p>\n<p>也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。</p>\n<p>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>\n<h1 id=\"访问标志\"><a href=\"#访问标志\" class=\"headerlink\" title=\"访问标志\"></a>访问标志</h1><p>在常量池结束之后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口</p>\n<p>是否定义为public类型;是否定义为abstract 类型;如果是类的话，是否被声明为final;等等。</p>\n<p><strong>类索引、父类索引与接口索引集合</strong></p>\n<p>类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。</p>\n<p>由于Java语言不允许多 重继承，所以父类索引只有一个，除了<code>java.lang.Object</code>之外，所有的Java类都有父类，因此除了 <code>java.lang.Object</code>外，所有Java类的父类索引都不为0。</p>\n<p>接口索引集合就用来描述这个类实现了哪些接 口，这些被实现的接口将按implements关键字(如果这个Class文件表示的是一个接口，则应当是 extends 关 键 字 ) 后 的 接 口 顺 序 从 左 到 右 排 列 在 接 口 索 引 集 合 中 。</p>\n<p><strong>字段表集合</strong></p>\n<p>字段表用于描述接口或者类中声明的变量。</p>\n<p>Java语言中的字段(Field)包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。</p>\n<p><strong>方法表集合</strong></p>\n<p>Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descrip tor_index)、属性表集合(attributes)几项。</p>\n<p><strong>属性表集合</strong> </p>\n<p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>\n<p>与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。</p>\n<h1 id=\"字节码指令\"><a href=\"#字节码指令\" class=\"headerlink\" title=\"字节码指令\"></a>字节码指令</h1><p>Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode) 以及跟随其后的零至多个代表此操作所需的参数(称为操作数，Operand)构成。</p>\n<p>由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所 以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。</p>\n<p>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚 拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不能够超过256条</p>\n<p><strong>字节码与数据类型</strong></p>\n<p>在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。</p>\n<p>举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。</p>\n<p>这两 条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p>\n<h1 id=\"运行时栈帧结构\"><a href=\"#运行时栈帧结构\" class=\"headerlink\" title=\"运行时栈帧结构\"></a>运行时栈帧结构</h1><p> Java虚拟机以方法作为最基本的执行单元，栈帧(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>\n<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 </p>\n<p>在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。</p>\n<p>换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。</p>\n<p>一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。</p>\n<p>而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为当前栈帧(Current Stack Frame)，与这个栈帧所关联的方法被称为当前方法(Current Method)。</p>\n<p>执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作</p>\n<p><strong>局部变量表</strong></p>\n<p>局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。</p>\n<p>在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。</p>\n<p>局部变量表的容量以变量槽(Variable Slot)为最小单位，《Java虚拟机规范》中并没有明确指出 一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储</p>\n<img src=\"https://img-blog.csdnimg.cn/6110e923319b481c83d2a7e955c7396c.png\" style=\"zoom:25%;\" />"},{"title":"虚拟机对象","_content":"\n# 对象创建\n\n**在虚拟机中，对象的创建又是怎样一个过程呢?**\n\n* 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。\n\n* 如果没有，那 必须先执行相应的类加载过程。\n\n* 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定 大小的内存块从Java堆中划分出来。\n\n* 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为**指针碰撞(Bump The Pointer)**。\n\n* 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为**空闲列表(Free List)**。\n\n选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理(Compact)**的能力决定。\n\n因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效;\n\n而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。\n\n**除如何划分可用空间之外，还有另外一个需要考虑的问题:**\n\n对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。\n\n> 解决这个问题有两种可选方案:\n\n一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性\n\n另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲`(Thread Local Allocation Buffer，TLAB)`，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定，虚拟机是否使用TLAB，可以通过`-XX:+/-UseTLAB`参数来设定。\n\n* 内存分配完成之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。\n\n这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。\n\n* 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用`Object::hashCode()`方法时才 计算)、对象的GC分代年龄等信息。\n\n这些信息存放在对象的对象头(Object Header)之中。\n\n根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n\n**在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。**\n\n但是从Java程序的视 角看来，对象创建才刚刚开始—构造函数，即Class文件中的`<init>()`方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。\n\n一般来说(由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此)，new指令之后会接着执行`<init>()`方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。\n\n# 内存布局\n\n在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:\n\n**对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。**\n\nHotSpot虚拟机对象的对象头部分包括两类信息。\n\n* 第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它 为`Mark Word`。\n\n对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。\n\n例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态 下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。\n\n<img src=\"https://img-blog.csdnimg.cn/42f2fbef6a1743339a675fb14d6e38c3.png\" style=\"zoom:50%;\" />\n\n* 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。\n\n并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。\n\n此外，如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。\n\n**实例数据**\n\n实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。\n\n如果HotSpot虚拟机的` +XX:CompactFields`参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。\n\n**对齐填充**\n\n对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作 用。\n\n由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以任何对象的大小都必须是8字节的整数倍。\n\n对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。\n\n# 访问定位\n\n创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。\n\n对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有**使用句柄和直接指针**两种:\n\n* 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。\n\n* 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销。\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。\n\n<img src=\"https://img-blog.csdnimg.cn/66caa7af0a4a4b09af0854bd74aaa1d8.png\" style=\"zoom:20%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/6aaefa96db264beeab0036991946de25.png\" style=\"zoom:50%;\" />\n\n使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本\n\n虚拟 机`HotSpot`而言，它主要使用第二种方式进行对象访问(有例外情况，如果使用了`Shenandoah`收集器的 话也会有一次额外的转发)，但从整个软件开发的范围来看，在各种语言、框架中 使用句柄来访问的情况也十分常见。","source":"_posts/深入理解JVM虚拟机/虚拟机对象.md","raw":"---\ntitle: 虚拟机对象\ncategories: \n- 深入理解JVM虚拟机\n---\n\n# 对象创建\n\n**在虚拟机中，对象的创建又是怎样一个过程呢?**\n\n* 当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。\n\n* 如果没有，那 必须先执行相应的类加载过程。\n\n* 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定 大小的内存块从Java堆中划分出来。\n\n* 假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为**指针碰撞(Bump The Pointer)**。\n\n* 但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为**空闲列表(Free List)**。\n\n选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理(Compact)**的能力决定。\n\n因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效;\n\n而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。\n\n**除如何划分可用空间之外，还有另外一个需要考虑的问题:**\n\n对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。\n\n> 解决这个问题有两种可选方案:\n\n一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性\n\n另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲`(Thread Local Allocation Buffer，TLAB)`，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定，虚拟机是否使用TLAB，可以通过`-XX:+/-UseTLAB`参数来设定。\n\n* 内存分配完成之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。\n\n这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。\n\n* 接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用`Object::hashCode()`方法时才 计算)、对象的GC分代年龄等信息。\n\n这些信息存放在对象的对象头(Object Header)之中。\n\n根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n\n**在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。**\n\n但是从Java程序的视 角看来，对象创建才刚刚开始—构造函数，即Class文件中的`<init>()`方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。\n\n一般来说(由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此)，new指令之后会接着执行`<init>()`方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。\n\n# 内存布局\n\n在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:\n\n**对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。**\n\nHotSpot虚拟机对象的对象头部分包括两类信息。\n\n* 第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它 为`Mark Word`。\n\n对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。\n\n例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态 下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。\n\n<img src=\"https://img-blog.csdnimg.cn/42f2fbef6a1743339a675fb14d6e38c3.png\" style=\"zoom:50%;\" />\n\n* 对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。\n\n并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。\n\n此外，如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。\n\n**实例数据**\n\n实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。\n\n如果HotSpot虚拟机的` +XX:CompactFields`参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。\n\n**对齐填充**\n\n对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作 用。\n\n由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以任何对象的大小都必须是8字节的整数倍。\n\n对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。\n\n# 访问定位\n\n创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。\n\n对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有**使用句柄和直接指针**两种:\n\n* 如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。\n\n* 如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销。\n\n这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。\n\n<img src=\"https://img-blog.csdnimg.cn/66caa7af0a4a4b09af0854bd74aaa1d8.png\" style=\"zoom:20%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/6aaefa96db264beeab0036991946de25.png\" style=\"zoom:50%;\" />\n\n使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本\n\n虚拟 机`HotSpot`而言，它主要使用第二种方式进行对象访问(有例外情况，如果使用了`Shenandoah`收集器的 话也会有一次额外的转发)，但从整个软件开发的范围来看，在各种语言、框架中 使用句柄来访问的情况也十分常见。","slug":"深入理解JVM虚拟机/虚拟机对象","published":1,"date":"2021-12-25T11:22:33.603Z","updated":"2021-12-25T11:29:40.144Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkn00khfhji799bf45y","content":"<h1 id=\"对象创建\"><a href=\"#对象创建\" class=\"headerlink\" title=\"对象创建\"></a>对象创建</h1><p><strong>在虚拟机中，对象的创建又是怎样一个过程呢?</strong></p>\n<ul>\n<li><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。</p>\n</li>\n<li><p>如果没有，那 必须先执行相应的类加载过程。</p>\n</li>\n<li><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定 大小的内存块从Java堆中划分出来。</p>\n</li>\n<li><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为**指针碰撞(Bump The Pointer)**。</p>\n</li>\n<li><p>但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为**空闲列表(Free List)**。</p>\n</li>\n</ul>\n<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理(Compact)**的能力决定。</p>\n<p>因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效;</p>\n<p>而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p>\n<p><strong>除如何划分可用空间之外，还有另外一个需要考虑的问题:</strong></p>\n<p>对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>\n<blockquote>\n<p>解决这个问题有两种可选方案:</p>\n</blockquote>\n<p>一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</p>\n<p>另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲<code>(Thread Local Allocation Buffer，TLAB)</code>，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定，虚拟机是否使用TLAB，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</p>\n<ul>\n<li>内存分配完成之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。</li>\n</ul>\n<p>这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>\n<ul>\n<li>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用<code>Object::hashCode()</code>方法时才 计算)、对象的GC分代年龄等信息。</li>\n</ul>\n<p>这些信息存放在对象的对象头(Object Header)之中。</p>\n<p>根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>\n<p><strong>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。</strong></p>\n<p>但是从Java程序的视 角看来，对象创建才刚刚开始—构造函数，即Class文件中的<code>&lt;init&gt;()</code>方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。</p>\n<p>一般来说(由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此)，new指令之后会接着执行<code>&lt;init&gt;()</code>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>\n<h1 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h1><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:</p>\n<p><strong>对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</strong></p>\n<p>HotSpot虚拟机对象的对象头部分包括两类信息。</p>\n<ul>\n<li>第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它 为<code>Mark Word</code>。</li>\n</ul>\n<p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>\n<p>例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态 下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。</p>\n<img src=\"https://img-blog.csdnimg.cn/42f2fbef6a1743339a675fb14d6e38c3.png\" style=\"zoom:50%;\" />\n\n<ul>\n<li>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。</li>\n</ul>\n<p>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</p>\n<p>此外，如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p>\n<p><strong>实例数据</strong></p>\n<p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>\n<p>如果HotSpot虚拟机的<code> +XX:CompactFields</code>参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p>\n<p><strong>对齐填充</strong></p>\n<p>对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作 用。</p>\n<p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以任何对象的大小都必须是8字节的整数倍。</p>\n<p>对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>\n<h1 id=\"访问定位\"><a href=\"#访问定位\" class=\"headerlink\" title=\"访问定位\"></a>访问定位</h1><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。</p>\n<p>对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有<strong>使用句柄和直接指针</strong>两种:</p>\n<ul>\n<li><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>\n</li>\n<li><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销。</p>\n</li>\n</ul>\n<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。</p>\n<img src=\"https://img-blog.csdnimg.cn/66caa7af0a4a4b09af0854bd74aaa1d8.png\" style=\"zoom:20%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/6aaefa96db264beeab0036991946de25.png\" style=\"zoom:50%;\" />\n\n<p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本</p>\n<p>虚拟 机<code>HotSpot</code>而言，它主要使用第二种方式进行对象访问(有例外情况，如果使用了<code>Shenandoah</code>收集器的 话也会有一次额外的转发)，但从整个软件开发的范围来看，在各种语言、框架中 使用句柄来访问的情况也十分常见。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"对象创建\"><a href=\"#对象创建\" class=\"headerlink\" title=\"对象创建\"></a>对象创建</h1><p><strong>在虚拟机中，对象的创建又是怎样一个过程呢?</strong></p>\n<ul>\n<li><p>当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。</p>\n</li>\n<li><p>如果没有，那 必须先执行相应的类加载过程。</p>\n</li>\n<li><p>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定 大小的内存块从Java堆中划分出来。</p>\n</li>\n<li><p>假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那 个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为**指针碰撞(Bump The Pointer)**。</p>\n</li>\n<li><p>但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那 就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称 为**空闲列表(Free List)**。</p>\n</li>\n</ul>\n<p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有**空间压缩整理(Compact)**的能力决定。</p>\n<p>因此，当使用Serial、ParNew等带压缩整理过程的收集器时，系统采用的分配算法是指针碰撞，既简单又高效;</p>\n<p>而当使用CMS这种基于清除(Sweep)算法的收集器时，理论上就只能采用较为复杂的空闲列表来分配内存。</p>\n<p><strong>除如何划分可用空间之外，还有另外一个需要考虑的问题:</strong></p>\n<p>对象创建在虚拟机中是非常频繁的行 为，即使仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p>\n<blockquote>\n<p>解决这个问题有两种可选方案:</p>\n</blockquote>\n<p>一种是对分配内存空间的动作进行同步处理——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性</p>\n<p>另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲<code>(Thread Local Allocation Buffer，TLAB)</code>，哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定，虚拟机是否使用TLAB，可以通过<code>-XX:+/-UseTLAB</code>参数来设定。</p>\n<ul>\n<li>内存分配完成之后，虚拟机必须将分配到的内存空间(但不包括对象头)都初始化为零值，如果使用了TLAB的话，这一项工作也可以提前至TLAB分配时顺便进行。</li>\n</ul>\n<p>这步操作保证了对象的实例字段 在Java代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>\n<ul>\n<li>接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码(实际上对象的哈希码会延后到真正调用<code>Object::hashCode()</code>方法时才 计算)、对象的GC分代年龄等信息。</li>\n</ul>\n<p>这些信息存放在对象的对象头(Object Header)之中。</p>\n<p>根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>\n<p><strong>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了。</strong></p>\n<p>但是从Java程序的视 角看来，对象创建才刚刚开始—构造函数，即Class文件中的<code>&lt;init&gt;()</code>方法还没有执行，所有的字段都为默认的零值，对象需要的其他资源和状态信息也还没有按照预定的意图构造好。</p>\n<p>一般来说(由字节码流中new指令后面是否跟随invokespecial指令所决定，Java编译器会在遇到new关键字的地方同时生成这两条字节码指令，但如果直接通过其他方式产生的则不一定如此)，new指令之后会接着执行<code>&lt;init&gt;()</code>方法，按照程序员的意愿对对象进行初始化，这样一个真正可用的对象才算完全被构造出来。</p>\n<h1 id=\"内存布局\"><a href=\"#内存布局\" class=\"headerlink\" title=\"内存布局\"></a>内存布局</h1><p>在HotSpot虚拟机里，对象在堆内存中的存储布局可以划分为三个部分:</p>\n<p><strong>对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。</strong></p>\n<p>HotSpot虚拟机对象的对象头部分包括两类信息。</p>\n<ul>\n<li>第一类是用于存储对象自身的运行时数据，如哈希码(HashCode)、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机(未开启压缩指针)中分别为32个比特和64个比特，官方称它 为<code>Mark Word</code>。</li>\n</ul>\n<p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。</p>\n<p>例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态 下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。</p>\n<img src=\"https://img-blog.csdnimg.cn/42f2fbef6a1743339a675fb14d6e38c3.png\" style=\"zoom:50%;\" />\n\n<ul>\n<li>对象头的另外一部分是类型指针，即对象指向它的类型元数据的指针，Java虚拟机通过这个指针 来确定该对象是哪个类的实例。</li>\n</ul>\n<p>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。</p>\n<p>此外，如果对 象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。</p>\n<p><strong>实例数据</strong></p>\n<p>实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字 段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。</p>\n<p>如果HotSpot虚拟机的<code> +XX:CompactFields</code>参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p>\n<p><strong>对齐填充</strong></p>\n<p>对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作 用。</p>\n<p>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以任何对象的大小都必须是8字节的整数倍。</p>\n<p>对象头部分已经被精心设计成正好是8字节的倍数(1倍或者 2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>\n<h1 id=\"访问定位\"><a href=\"#访问定位\" class=\"headerlink\" title=\"访问定位\"></a>访问定位</h1><p>创建对象自然是为了后续使用该对象，我们的Java程序会通过栈上的reference数据来操作堆上的具体对象。</p>\n<p>对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有<strong>使用句柄和直接指针</strong>两种:</p>\n<ul>\n<li><p>如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就 是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。</p>\n</li>\n<li><p>如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关 信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问 的开销。</p>\n</li>\n</ul>\n<p>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而 reference本身不需要被修改。</p>\n<img src=\"https://img-blog.csdnimg.cn/66caa7af0a4a4b09af0854bd74aaa1d8.png\" style=\"zoom:20%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/6aaefa96db264beeab0036991946de25.png\" style=\"zoom:50%;\" />\n\n<p>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本</p>\n<p>虚拟 机<code>HotSpot</code>而言，它主要使用第二种方式进行对象访问(有例外情况，如果使用了<code>Shenandoah</code>收集器的 话也会有一次额外的转发)，但从整个软件开发的范围来看，在各种语言、框架中 使用句柄来访问的情况也十分常见。</p>\n"},{"title":"反向代理","_content":"\n**正向代理的概念：**\n\n正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。\n\n这个过程当中客户端需要知道代理服务器地址，并配置连接。\n\n<img src=\"https://img-blog.csdnimg.cn/6198e2da1f40435d839367ed28973d41.png\" style=\"zoom:25%;\" />\n\n**反向代理的概念：**\n\n反向代理是指客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。\n\n<img src=\"https://img-blog.csdnimg.cn/d4623f169f7140e2bd213a2c609bda74.png\" style=\"zoom:25%;\" />\n\n这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。\n\n* 正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；\n\n* 而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见\n\n|                | **正向代理**                                               | **反向代理**                         |\n| -------------- | ---------------------------------------------------------- | ------------------------------------ |\n| 代理服务器位置 | 客户端与服务都能连接的们位置                               | 目标服务器内部                       |\n| 主要作用       | 屏蔽客户端IP、集中式缓存、解决客户端不能直连服务端的问题。 | 屏蔽服务端内部实现、负载均衡、缓存。 |\n| 应用场景       | 爬虫、翻墙、maven 的nexus 服务                             | Nginx 、Apache负载均衡应             |","source":"_posts/深入理解Nginx/反向代理.md","raw":"---\ntitle: 反向代理\ncategories: \n- 深入理解Nginx\n---\n\n**正向代理的概念：**\n\n正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。\n\n这个过程当中客户端需要知道代理服务器地址，并配置连接。\n\n<img src=\"https://img-blog.csdnimg.cn/6198e2da1f40435d839367ed28973d41.png\" style=\"zoom:25%;\" />\n\n**反向代理的概念：**\n\n反向代理是指客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。\n\n<img src=\"https://img-blog.csdnimg.cn/d4623f169f7140e2bd213a2c609bda74.png\" style=\"zoom:25%;\" />\n\n这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。\n\n* 正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；\n\n* 而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见\n\n|                | **正向代理**                                               | **反向代理**                         |\n| -------------- | ---------------------------------------------------------- | ------------------------------------ |\n| 代理服务器位置 | 客户端与服务都能连接的们位置                               | 目标服务器内部                       |\n| 主要作用       | 屏蔽客户端IP、集中式缓存、解决客户端不能直连服务端的问题。 | 屏蔽服务端内部实现、负载均衡、缓存。 |\n| 应用场景       | 爬虫、翻墙、maven 的nexus 服务                             | Nginx 、Apache负载均衡应             |","slug":"深入理解Nginx/反向代理","published":1,"date":"2022-02-02T03:52:41.983Z","updated":"2022-02-12T12:58:49.522Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwko00kifhjie463123i","content":"<p><strong>正向代理的概念：</strong></p>\n<p>正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。</p>\n<p>这个过程当中客户端需要知道代理服务器地址，并配置连接。</p>\n<img src=\"https://img-blog.csdnimg.cn/6198e2da1f40435d839367ed28973d41.png\" style=\"zoom:25%;\" />\n\n<p><strong>反向代理的概念：</strong></p>\n<p>反向代理是指客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。</p>\n<img src=\"https://img-blog.csdnimg.cn/d4623f169f7140e2bd213a2c609bda74.png\" style=\"zoom:25%;\" />\n\n<p>这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。</p>\n<ul>\n<li><p>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；</p>\n</li>\n<li><p>而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><strong>正向代理</strong></th>\n<th><strong>反向代理</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>代理服务器位置</td>\n<td>客户端与服务都能连接的们位置</td>\n<td>目标服务器内部</td>\n</tr>\n<tr>\n<td>主要作用</td>\n<td>屏蔽客户端IP、集中式缓存、解决客户端不能直连服务端的问题。</td>\n<td>屏蔽服务端内部实现、负载均衡、缓存。</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>爬虫、翻墙、maven 的nexus 服务</td>\n<td>Nginx 、Apache负载均衡应</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>正向代理的概念：</strong></p>\n<p>正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。</p>\n<p>这个过程当中客户端需要知道代理服务器地址，并配置连接。</p>\n<img src=\"https://img-blog.csdnimg.cn/6198e2da1f40435d839367ed28973d41.png\" style=\"zoom:25%;\" />\n\n<p><strong>反向代理的概念：</strong></p>\n<p>反向代理是指客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。</p>\n<img src=\"https://img-blog.csdnimg.cn/d4623f169f7140e2bd213a2c609bda74.png\" style=\"zoom:25%;\" />\n\n<p>这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。</p>\n<ul>\n<li><p>正向代理是代理客户端，为客户端收发请求，使真实客户端对服务器不可见；</p>\n</li>\n<li><p>而反向代理是代理服务器端，为服务器收发请求，使真实服务器对客户端不可见</p>\n</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th></th>\n<th><strong>正向代理</strong></th>\n<th><strong>反向代理</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>代理服务器位置</td>\n<td>客户端与服务都能连接的们位置</td>\n<td>目标服务器内部</td>\n</tr>\n<tr>\n<td>主要作用</td>\n<td>屏蔽客户端IP、集中式缓存、解决客户端不能直连服务端的问题。</td>\n<td>屏蔽服务端内部实现、负载均衡、缓存。</td>\n</tr>\n<tr>\n<td>应用场景</td>\n<td>爬虫、翻墙、maven 的nexus 服务</td>\n<td>Nginx 、Apache负载均衡应</td>\n</tr>\n</tbody></table>\n"},{"title":"基础知识","_content":"\nNginx是一个高性能的HTTP和反向代理Web服务器，同时也提供了 IMAP/POP3/SMTP服务，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。\n\n**高性能原因**\n\nNginx采用了Linux的Epoll模型，Epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入Epoll队列中，这个过程是异步的，Worker只需要从Epoll队列循环处理即可。\n\n> CPU亲和\n\n* 有双cpu每个cpu4个核心 ，然后我们把8个工作进程绑定到不同的cpu上，相当于每个cpu处理一个work这样 。\n\n* 减少切换cpu带来的性能损失，一用这种cpu亲和的绑定方式可以减少额外的性能损失，提升工作效率。\n\n> SengFile零拷贝的传输模式\n\n**Master和Worker模式**\n\nNginx在启动后以daemon的方式在后台运行，会有一个master进程和多个worker进程\n\n* master进程：主要用来管理worker进程，包括：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。\n\n* worker进程：处理基本的网络事件了，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的，一个请求，只可能在一个worker进程中处理，一个worker进程不可能处理其它进程的请求。\n\n* worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，或者直接设置参数`worker_processes auto`\n\n**当我们输入./nginx -s reload，就是来重启nginx，./nginx -s stop，就是来停止nginx的运行，这里面是如何做到的**\n\n* 执行命令时，我们是启动一个新的nginx进程，而新的nginx进程在解析到reload参数后，就知道我们的目的是控制nginx来重新加载配置文件了，它会向master进程发送信号。\n\n* master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。\n\n* 新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出，所以使用上面命令重启Nginx的时候服务是不中断的。\n\n","source":"_posts/深入理解Nginx/基础知识.md","raw":"---\ntitle: 基础知识\ncategories: \n- 深入理解Nginx\n---\n\nNginx是一个高性能的HTTP和反向代理Web服务器，同时也提供了 IMAP/POP3/SMTP服务，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。\n\n**高性能原因**\n\nNginx采用了Linux的Epoll模型，Epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入Epoll队列中，这个过程是异步的，Worker只需要从Epoll队列循环处理即可。\n\n> CPU亲和\n\n* 有双cpu每个cpu4个核心 ，然后我们把8个工作进程绑定到不同的cpu上，相当于每个cpu处理一个work这样 。\n\n* 减少切换cpu带来的性能损失，一用这种cpu亲和的绑定方式可以减少额外的性能损失，提升工作效率。\n\n> SengFile零拷贝的传输模式\n\n**Master和Worker模式**\n\nNginx在启动后以daemon的方式在后台运行，会有一个master进程和多个worker进程\n\n* master进程：主要用来管理worker进程，包括：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。\n\n* worker进程：处理基本的网络事件了，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的，一个请求，只可能在一个worker进程中处理，一个worker进程不可能处理其它进程的请求。\n\n* worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，或者直接设置参数`worker_processes auto`\n\n**当我们输入./nginx -s reload，就是来重启nginx，./nginx -s stop，就是来停止nginx的运行，这里面是如何做到的**\n\n* 执行命令时，我们是启动一个新的nginx进程，而新的nginx进程在解析到reload参数后，就知道我们的目的是控制nginx来重新加载配置文件了，它会向master进程发送信号。\n\n* master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。\n\n* 新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出，所以使用上面命令重启Nginx的时候服务是不中断的。\n\n","slug":"深入理解Nginx/基础知识","published":1,"date":"2022-02-02T03:51:57.082Z","updated":"2022-02-12T13:01:18.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwko00klfhji6q8c4w4j","content":"<p>Nginx是一个高性能的HTTP和反向代理Web服务器，同时也提供了 IMAP&#x2F;POP3&#x2F;SMTP服务，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p>\n<p><strong>高性能原因</strong></p>\n<p>Nginx采用了Linux的Epoll模型，Epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入Epoll队列中，这个过程是异步的，Worker只需要从Epoll队列循环处理即可。</p>\n<blockquote>\n<p>CPU亲和</p>\n</blockquote>\n<ul>\n<li><p>有双cpu每个cpu4个核心 ，然后我们把8个工作进程绑定到不同的cpu上，相当于每个cpu处理一个work这样 。</p>\n</li>\n<li><p>减少切换cpu带来的性能损失，一用这种cpu亲和的绑定方式可以减少额外的性能损失，提升工作效率。</p>\n</li>\n</ul>\n<blockquote>\n<p>SengFile零拷贝的传输模式</p>\n</blockquote>\n<p><strong>Master和Worker模式</strong></p>\n<p>Nginx在启动后以daemon的方式在后台运行，会有一个master进程和多个worker进程</p>\n<ul>\n<li><p>master进程：主要用来管理worker进程，包括：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</p>\n</li>\n<li><p>worker进程：处理基本的网络事件了，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的，一个请求，只可能在一个worker进程中处理，一个worker进程不可能处理其它进程的请求。</p>\n</li>\n<li><p>worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，或者直接设置参数<code>worker_processes auto</code></p>\n</li>\n</ul>\n<p><strong>当我们输入.&#x2F;nginx -s reload，就是来重启nginx，.&#x2F;nginx -s stop，就是来停止nginx的运行，这里面是如何做到的</strong></p>\n<ul>\n<li><p>执行命令时，我们是启动一个新的nginx进程，而新的nginx进程在解析到reload参数后，就知道我们的目的是控制nginx来重新加载配置文件了，它会向master进程发送信号。</p>\n</li>\n<li><p>master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。</p>\n</li>\n<li><p>新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出，所以使用上面命令重启Nginx的时候服务是不中断的。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Nginx是一个高性能的HTTP和反向代理Web服务器，同时也提供了 IMAP&#x2F;POP3&#x2F;SMTP服务，由于它的内存占用少，启动极快，高并发能力强，在互联网项目中广泛应用。</p>\n<p><strong>高性能原因</strong></p>\n<p>Nginx采用了Linux的Epoll模型，Epoll模型基于事件驱动机制，它可以监控多个事件是否准备完毕，如果OK，那么放入Epoll队列中，这个过程是异步的，Worker只需要从Epoll队列循环处理即可。</p>\n<blockquote>\n<p>CPU亲和</p>\n</blockquote>\n<ul>\n<li><p>有双cpu每个cpu4个核心 ，然后我们把8个工作进程绑定到不同的cpu上，相当于每个cpu处理一个work这样 。</p>\n</li>\n<li><p>减少切换cpu带来的性能损失，一用这种cpu亲和的绑定方式可以减少额外的性能损失，提升工作效率。</p>\n</li>\n</ul>\n<blockquote>\n<p>SengFile零拷贝的传输模式</p>\n</blockquote>\n<p><strong>Master和Worker模式</strong></p>\n<p>Nginx在启动后以daemon的方式在后台运行，会有一个master进程和多个worker进程</p>\n<ul>\n<li><p>master进程：主要用来管理worker进程，包括：接收来自外界的信号，向各worker进程发送信号，监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。</p>\n</li>\n<li><p>worker进程：处理基本的网络事件了，多个worker进程之间是对等的，他们同等竞争来自客户端的请求，各进程互相之间是独立的，一个请求，只可能在一个worker进程中处理，一个worker进程不可能处理其它进程的请求。</p>\n</li>\n<li><p>worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致，或者直接设置参数<code>worker_processes auto</code></p>\n</li>\n</ul>\n<p><strong>当我们输入.&#x2F;nginx -s reload，就是来重启nginx，.&#x2F;nginx -s stop，就是来停止nginx的运行，这里面是如何做到的</strong></p>\n<ul>\n<li><p>执行命令时，我们是启动一个新的nginx进程，而新的nginx进程在解析到reload参数后，就知道我们的目的是控制nginx来重新加载配置文件了，它会向master进程发送信号。</p>\n</li>\n<li><p>master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。</p>\n</li>\n<li><p>新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出，所以使用上面命令重启Nginx的时候服务是不中断的。</p>\n</li>\n</ul>\n"},{"title":"负载均衡","_content":"\n负载均衡是指如何将网络请求派发到集群中的一个或多个节点上处理，一般来说，传统的负载均衡可以分为硬件负载均衡和软件负载均衡\n\n* 硬件负载均衡，就是通过专门的硬件来实现负载均衡，比如常见的 `F5` 设备\n\n* 软件负载均衡则是通过负载均衡软件实现，常见的就是 Nginx\n\n**四层/七层负载均衡**\n\n四层/七层负载均衡指的是将均衡负载的操作在OSI网络模型的第四层（传输层）/第七层（应用层）进行。\n\n- 四层负载均衡技术：在域名服务商处对外提供的目标地址是服务器的VIP（Virtual IP，虚拟IP）而并不是服务器的真实IP地址，在传输层根据请求报文中的源地址、目标地址、端口依据一定的负载均衡策略将请求报文的目标地址（VIP）用合适的服务器真实IP地址替换，完成服务器真实IP地址和VIP的映射，从而达到负载均衡的目的（更像是**转发**）。\n- 七层负载均衡技术：在应用层根据请求报文中的应用层内容（如HTTP头部），依据一定的负载均衡策略选择合适的服务器，从而达到负载均衡的目的（更像是**代理**）。\n\n**分布式服务中负载均衡如何实现**\n\n在分布式服务调用中，根据负载均衡实现的位置不同，可以分为**服务端负载均衡和客户端负载均衡**\n\n* 在服务器端负载均衡中，请求先发送到负载均衡服务器，然后通过负载均衡算法，在众多可用的服务器之中选择一个来处理请求\n\n* 在客户端负载均衡中，不需要额外的负载均衡软件，客户端自己维护服务器地址列表，自己选择请求的地址，通过负载均衡算法将请求发送至该服务器\n\n**Nginx负载均衡策略**\n\n> 轮询策略（默认）\n\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除\n\n```nginx\nupstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n```\n\n> 加权轮询\n\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况\n\n```nginx\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n```\n\n> 随机策略\n\n随机策略和轮询相似，从列表中随机的取一个，最好不要应用随机策略，可能会导致请求不均匀\n\n> 最小响应时间\n\n这个主要是在一些对请求延时敏感的场景中，在进行路由时，会优先发送给响应时间最小的节点。\n\n```nginx\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n```\n\n* **fair**按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 `nginx-upstream-fair`，需要先安装；\n\n**url_hash（第三方）**\n\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n\n```nginx\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n> 最小并发数策略\n\n最小并发策略会记录当前时刻每个节点正在处理的事务数，在路由时选择并发最小的节点，最小并发策略可以比较好地反应服务器运行情况，适用于对系统负载较为敏感的场景\n\n> ip_hash\n\n如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器\n\n* 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题\n\n```nginx\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n```\n","source":"_posts/深入理解Nginx/负载均衡.md","raw":"---\ntitle: 负载均衡\ncategories: \n- 深入理解Nginx\n---\n\n负载均衡是指如何将网络请求派发到集群中的一个或多个节点上处理，一般来说，传统的负载均衡可以分为硬件负载均衡和软件负载均衡\n\n* 硬件负载均衡，就是通过专门的硬件来实现负载均衡，比如常见的 `F5` 设备\n\n* 软件负载均衡则是通过负载均衡软件实现，常见的就是 Nginx\n\n**四层/七层负载均衡**\n\n四层/七层负载均衡指的是将均衡负载的操作在OSI网络模型的第四层（传输层）/第七层（应用层）进行。\n\n- 四层负载均衡技术：在域名服务商处对外提供的目标地址是服务器的VIP（Virtual IP，虚拟IP）而并不是服务器的真实IP地址，在传输层根据请求报文中的源地址、目标地址、端口依据一定的负载均衡策略将请求报文的目标地址（VIP）用合适的服务器真实IP地址替换，完成服务器真实IP地址和VIP的映射，从而达到负载均衡的目的（更像是**转发**）。\n- 七层负载均衡技术：在应用层根据请求报文中的应用层内容（如HTTP头部），依据一定的负载均衡策略选择合适的服务器，从而达到负载均衡的目的（更像是**代理**）。\n\n**分布式服务中负载均衡如何实现**\n\n在分布式服务调用中，根据负载均衡实现的位置不同，可以分为**服务端负载均衡和客户端负载均衡**\n\n* 在服务器端负载均衡中，请求先发送到负载均衡服务器，然后通过负载均衡算法，在众多可用的服务器之中选择一个来处理请求\n\n* 在客户端负载均衡中，不需要额外的负载均衡软件，客户端自己维护服务器地址列表，自己选择请求的地址，通过负载均衡算法将请求发送至该服务器\n\n**Nginx负载均衡策略**\n\n> 轮询策略（默认）\n\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除\n\n```nginx\nupstream backserver {\n    server 192.168.0.14;\n    server 192.168.0.15;\n}\n```\n\n> 加权轮询\n\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况\n\n```nginx\nupstream backserver {\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n}\n```\n\n> 随机策略\n\n随机策略和轮询相似，从列表中随机的取一个，最好不要应用随机策略，可能会导致请求不均匀\n\n> 最小响应时间\n\n这个主要是在一些对请求延时敏感的场景中，在进行路由时，会优先发送给响应时间最小的节点。\n\n```nginx\nupstream backserver {\n    server server1;\n    server server2;\n    fair;\n}\n```\n\n* **fair**按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 `nginx-upstream-fair`，需要先安装；\n\n**url_hash（第三方）**\n\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效\n\n```nginx\nupstream backserver {\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n}\n```\n\n> 最小并发数策略\n\n最小并发策略会记录当前时刻每个节点正在处理的事务数，在路由时选择并发最小的节点，最小并发策略可以比较好地反应服务器运行情况，适用于对系统负载较为敏感的场景\n\n> ip_hash\n\n如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器\n\n* 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题\n\n```nginx\nupstream backserver {\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n}\n```\n","slug":"深入理解Nginx/负载均衡","published":1,"date":"2022-02-02T03:50:34.385Z","updated":"2022-02-12T12:48:50.889Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkp00kmfhjif98rbpr1","content":"<p>负载均衡是指如何将网络请求派发到集群中的一个或多个节点上处理，一般来说，传统的负载均衡可以分为硬件负载均衡和软件负载均衡</p>\n<ul>\n<li><p>硬件负载均衡，就是通过专门的硬件来实现负载均衡，比如常见的 <code>F5</code> 设备</p>\n</li>\n<li><p>软件负载均衡则是通过负载均衡软件实现，常见的就是 Nginx</p>\n</li>\n</ul>\n<p><strong>四层&#x2F;七层负载均衡</strong></p>\n<p>四层&#x2F;七层负载均衡指的是将均衡负载的操作在OSI网络模型的第四层（传输层）&#x2F;第七层（应用层）进行。</p>\n<ul>\n<li>四层负载均衡技术：在域名服务商处对外提供的目标地址是服务器的VIP（Virtual IP，虚拟IP）而并不是服务器的真实IP地址，在传输层根据请求报文中的源地址、目标地址、端口依据一定的负载均衡策略将请求报文的目标地址（VIP）用合适的服务器真实IP地址替换，完成服务器真实IP地址和VIP的映射，从而达到负载均衡的目的（更像是<strong>转发</strong>）。</li>\n<li>七层负载均衡技术：在应用层根据请求报文中的应用层内容（如HTTP头部），依据一定的负载均衡策略选择合适的服务器，从而达到负载均衡的目的（更像是<strong>代理</strong>）。</li>\n</ul>\n<p><strong>分布式服务中负载均衡如何实现</strong></p>\n<p>在分布式服务调用中，根据负载均衡实现的位置不同，可以分为<strong>服务端负载均衡和客户端负载均衡</strong></p>\n<ul>\n<li><p>在服务器端负载均衡中，请求先发送到负载均衡服务器，然后通过负载均衡算法，在众多可用的服务器之中选择一个来处理请求</p>\n</li>\n<li><p>在客户端负载均衡中，不需要额外的负载均衡软件，客户端自己维护服务器地址列表，自己选择请求的地址，通过负载均衡算法将请求发送至该服务器</p>\n</li>\n</ul>\n<p><strong>Nginx负载均衡策略</strong></p>\n<blockquote>\n<p>轮询策略（默认）</p>\n</blockquote>\n<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server 192.168.0.14;\n    server 192.168.0.15;\n&#125;\n</code></pre>\n<blockquote>\n<p>加权轮询</p>\n</blockquote>\n<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n&#125;\n</code></pre>\n<blockquote>\n<p>随机策略</p>\n</blockquote>\n<p>随机策略和轮询相似，从列表中随机的取一个，最好不要应用随机策略，可能会导致请求不均匀</p>\n<blockquote>\n<p>最小响应时间</p>\n</blockquote>\n<p>这个主要是在一些对请求延时敏感的场景中，在进行路由时，会优先发送给响应时间最小的节点。</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server server1;\n    server server2;\n    fair;\n&#125;\n</code></pre>\n<ul>\n<li><strong>fair</strong>按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 <code>nginx-upstream-fair</code>，需要先安装；</li>\n</ul>\n<p><strong>url_hash（第三方）</strong></p>\n<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n&#125;\n</code></pre>\n<blockquote>\n<p>最小并发数策略</p>\n</blockquote>\n<p>最小并发策略会记录当前时刻每个节点正在处理的事务数，在路由时选择并发最小的节点，最小并发策略可以比较好地反应服务器运行情况，适用于对系统负载较为敏感的场景</p>\n<blockquote>\n<p>ip_hash</p>\n</blockquote>\n<p>如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器</p>\n<ul>\n<li>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</li>\n</ul>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n&#125;\n</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<p>负载均衡是指如何将网络请求派发到集群中的一个或多个节点上处理，一般来说，传统的负载均衡可以分为硬件负载均衡和软件负载均衡</p>\n<ul>\n<li><p>硬件负载均衡，就是通过专门的硬件来实现负载均衡，比如常见的 <code>F5</code> 设备</p>\n</li>\n<li><p>软件负载均衡则是通过负载均衡软件实现，常见的就是 Nginx</p>\n</li>\n</ul>\n<p><strong>四层&#x2F;七层负载均衡</strong></p>\n<p>四层&#x2F;七层负载均衡指的是将均衡负载的操作在OSI网络模型的第四层（传输层）&#x2F;第七层（应用层）进行。</p>\n<ul>\n<li>四层负载均衡技术：在域名服务商处对外提供的目标地址是服务器的VIP（Virtual IP，虚拟IP）而并不是服务器的真实IP地址，在传输层根据请求报文中的源地址、目标地址、端口依据一定的负载均衡策略将请求报文的目标地址（VIP）用合适的服务器真实IP地址替换，完成服务器真实IP地址和VIP的映射，从而达到负载均衡的目的（更像是<strong>转发</strong>）。</li>\n<li>七层负载均衡技术：在应用层根据请求报文中的应用层内容（如HTTP头部），依据一定的负载均衡策略选择合适的服务器，从而达到负载均衡的目的（更像是<strong>代理</strong>）。</li>\n</ul>\n<p><strong>分布式服务中负载均衡如何实现</strong></p>\n<p>在分布式服务调用中，根据负载均衡实现的位置不同，可以分为<strong>服务端负载均衡和客户端负载均衡</strong></p>\n<ul>\n<li><p>在服务器端负载均衡中，请求先发送到负载均衡服务器，然后通过负载均衡算法，在众多可用的服务器之中选择一个来处理请求</p>\n</li>\n<li><p>在客户端负载均衡中，不需要额外的负载均衡软件，客户端自己维护服务器地址列表，自己选择请求的地址，通过负载均衡算法将请求发送至该服务器</p>\n</li>\n</ul>\n<p><strong>Nginx负载均衡策略</strong></p>\n<blockquote>\n<p>轮询策略（默认）</p>\n</blockquote>\n<p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server 192.168.0.14;\n    server 192.168.0.15;\n&#125;\n</code></pre>\n<blockquote>\n<p>加权轮询</p>\n</blockquote>\n<p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server 192.168.0.14 weight=3;\n    server 192.168.0.15 weight=7;\n&#125;\n</code></pre>\n<blockquote>\n<p>随机策略</p>\n</blockquote>\n<p>随机策略和轮询相似，从列表中随机的取一个，最好不要应用随机策略，可能会导致请求不均匀</p>\n<blockquote>\n<p>最小响应时间</p>\n</blockquote>\n<p>这个主要是在一些对请求延时敏感的场景中，在进行路由时，会优先发送给响应时间最小的节点。</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server server1;\n    server server2;\n    fair;\n&#125;\n</code></pre>\n<ul>\n<li><strong>fair</strong>按后端服务器的响应时间分配，响应时间短的优先分配，依赖第三方插件 <code>nginx-upstream-fair</code>，需要先安装；</li>\n</ul>\n<p><strong>url_hash（第三方）</strong></p>\n<p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效</p>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    server squid1:3128;\n    server squid2:3128;\n    hash $request_uri;\n    hash_method crc32;\n&#125;\n</code></pre>\n<blockquote>\n<p>最小并发数策略</p>\n</blockquote>\n<p>最小并发策略会记录当前时刻每个节点正在处理的事务数，在路由时选择并发最小的节点，最小并发策略可以比较好地反应服务器运行情况，适用于对系统负载较为敏感的场景</p>\n<blockquote>\n<p>ip_hash</p>\n</blockquote>\n<p>如果客户已经访问了某个服务器，当用户再次访问时，会将该请求通过哈希算法，自动定位到该服务器</p>\n<ul>\n<li>每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题</li>\n</ul>\n<pre><code class=\"nginx\">upstream backserver &#123;\n    ip_hash;\n    server 192.168.0.14:88;\n    server 192.168.0.15:80;\n&#125;\n</code></pre>\n"},{"title":"为什么要用金字塔结构","_content":"\n**为什么要使用金字塔结构**\n\n1. 站在读者角度，他们去了解你的文章或者演讲，如果文章写的没有条理，他们需要在各种句子之间去寻找它们之间的逻辑关系，前后反复思考，就会导致这是一件复杂的任务，如果文章结构呈现金字塔型，从顶部向下逐渐展开，对于读者来说是一件很容易的事情\n2. 从人类思维的角度，大脑会将事务以某种相关性组合起来，大脑的短期记忆无法一次性容纳**7个以上**的记忆项目\n\n**归类分组将思想组织成金字塔**\n\n找出逻辑关系抽象概括\n\n<img src=\"https://img-blog.csdnimg.cn/2290ee75fb3d4769ba221aa54a26fe9c.png\" style=\"zoom:25%;\" />\n\n研究表明最有效的表达方法是：先提出总的概念，再列出具体项目，即要自上而下的表达思想\n\n**自上而下表达，结论先行**\n\n由于受众的知识背景和理解能力千差万别，如果不提前声明总结性概括，受众很可能会理解偏差，结论先行就能让他按照自己的思维框架进行理解\n\n**自下而上思考，总结概括**\n\n思考是自下而上的，由底层逻辑到上层思想，再有上层思想到中心思想、核心观念，不断地高度归纳、概括；\n\n<img src=\"https://img-blog.csdnimg.cn/c938af8a9beb4e91a678486c4595e712.png\" style=\"zoom:25%;\" />\n\n同一组思想的上层思想是对这一组思想的概括，这一组思想则是对上一层的思想的解释和支撑\n\n1. 纵向：文章任一层次上的思想必须是其下一层次思想的概括\n2. 横向：每组中的思想必须按照**逻辑顺序**组织\n3. 横向：每组中的思想必须属于统一逻辑范畴\n\n**逻辑顺序**表现了你在组织思想时的分析过程，组织思想基本上有这样四种逻辑顺序\n\n1. 演绎顺序：大前提，小前提，结论\n2. 时间顺序（步骤）：第一，第二，第三\n3. 结构顺序（空间）：北京，深圳，上海\n4. 程度顺序（重要性）：最重要、次重要，等等\n\n**总结：**\n\n1. 金字塔思维是一套科学的，符合人类大脑功能的思维方式，掌握金字塔思维可以给自己的阅读写作带来极大的提升\n2. 金字塔思维的锻炼是一个长期的过程，需要坚持使用下来，进行系统性的逻辑思考再进行搭建金字塔","source":"_posts/金字塔原理/为什么要用金字塔结构.md","raw":"---\ntitle: 为什么要用金字塔结构\ncategories: \n- 金字塔原理\n---\n\n**为什么要使用金字塔结构**\n\n1. 站在读者角度，他们去了解你的文章或者演讲，如果文章写的没有条理，他们需要在各种句子之间去寻找它们之间的逻辑关系，前后反复思考，就会导致这是一件复杂的任务，如果文章结构呈现金字塔型，从顶部向下逐渐展开，对于读者来说是一件很容易的事情\n2. 从人类思维的角度，大脑会将事务以某种相关性组合起来，大脑的短期记忆无法一次性容纳**7个以上**的记忆项目\n\n**归类分组将思想组织成金字塔**\n\n找出逻辑关系抽象概括\n\n<img src=\"https://img-blog.csdnimg.cn/2290ee75fb3d4769ba221aa54a26fe9c.png\" style=\"zoom:25%;\" />\n\n研究表明最有效的表达方法是：先提出总的概念，再列出具体项目，即要自上而下的表达思想\n\n**自上而下表达，结论先行**\n\n由于受众的知识背景和理解能力千差万别，如果不提前声明总结性概括，受众很可能会理解偏差，结论先行就能让他按照自己的思维框架进行理解\n\n**自下而上思考，总结概括**\n\n思考是自下而上的，由底层逻辑到上层思想，再有上层思想到中心思想、核心观念，不断地高度归纳、概括；\n\n<img src=\"https://img-blog.csdnimg.cn/c938af8a9beb4e91a678486c4595e712.png\" style=\"zoom:25%;\" />\n\n同一组思想的上层思想是对这一组思想的概括，这一组思想则是对上一层的思想的解释和支撑\n\n1. 纵向：文章任一层次上的思想必须是其下一层次思想的概括\n2. 横向：每组中的思想必须按照**逻辑顺序**组织\n3. 横向：每组中的思想必须属于统一逻辑范畴\n\n**逻辑顺序**表现了你在组织思想时的分析过程，组织思想基本上有这样四种逻辑顺序\n\n1. 演绎顺序：大前提，小前提，结论\n2. 时间顺序（步骤）：第一，第二，第三\n3. 结构顺序（空间）：北京，深圳，上海\n4. 程度顺序（重要性）：最重要、次重要，等等\n\n**总结：**\n\n1. 金字塔思维是一套科学的，符合人类大脑功能的思维方式，掌握金字塔思维可以给自己的阅读写作带来极大的提升\n2. 金字塔思维的锻炼是一个长期的过程，需要坚持使用下来，进行系统性的逻辑思考再进行搭建金字塔","slug":"金字塔原理/为什么要用金字塔结构","published":1,"date":"2021-12-29T08:52:30.316Z","updated":"2022-02-01T08:07:58.753Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkp00kpfhjiarfq1kit","content":"<p><strong>为什么要使用金字塔结构</strong></p>\n<ol>\n<li>站在读者角度，他们去了解你的文章或者演讲，如果文章写的没有条理，他们需要在各种句子之间去寻找它们之间的逻辑关系，前后反复思考，就会导致这是一件复杂的任务，如果文章结构呈现金字塔型，从顶部向下逐渐展开，对于读者来说是一件很容易的事情</li>\n<li>从人类思维的角度，大脑会将事务以某种相关性组合起来，大脑的短期记忆无法一次性容纳<strong>7个以上</strong>的记忆项目</li>\n</ol>\n<p><strong>归类分组将思想组织成金字塔</strong></p>\n<p>找出逻辑关系抽象概括</p>\n<img src=\"https://img-blog.csdnimg.cn/2290ee75fb3d4769ba221aa54a26fe9c.png\" style=\"zoom:25%;\" />\n\n<p>研究表明最有效的表达方法是：先提出总的概念，再列出具体项目，即要自上而下的表达思想</p>\n<p><strong>自上而下表达，结论先行</strong></p>\n<p>由于受众的知识背景和理解能力千差万别，如果不提前声明总结性概括，受众很可能会理解偏差，结论先行就能让他按照自己的思维框架进行理解</p>\n<p><strong>自下而上思考，总结概括</strong></p>\n<p>思考是自下而上的，由底层逻辑到上层思想，再有上层思想到中心思想、核心观念，不断地高度归纳、概括；</p>\n<img src=\"https://img-blog.csdnimg.cn/c938af8a9beb4e91a678486c4595e712.png\" style=\"zoom:25%;\" />\n\n<p>同一组思想的上层思想是对这一组思想的概括，这一组思想则是对上一层的思想的解释和支撑</p>\n<ol>\n<li>纵向：文章任一层次上的思想必须是其下一层次思想的概括</li>\n<li>横向：每组中的思想必须按照<strong>逻辑顺序</strong>组织</li>\n<li>横向：每组中的思想必须属于统一逻辑范畴</li>\n</ol>\n<p><strong>逻辑顺序</strong>表现了你在组织思想时的分析过程，组织思想基本上有这样四种逻辑顺序</p>\n<ol>\n<li>演绎顺序：大前提，小前提，结论</li>\n<li>时间顺序（步骤）：第一，第二，第三</li>\n<li>结构顺序（空间）：北京，深圳，上海</li>\n<li>程度顺序（重要性）：最重要、次重要，等等</li>\n</ol>\n<p><strong>总结：</strong></p>\n<ol>\n<li>金字塔思维是一套科学的，符合人类大脑功能的思维方式，掌握金字塔思维可以给自己的阅读写作带来极大的提升</li>\n<li>金字塔思维的锻炼是一个长期的过程，需要坚持使用下来，进行系统性的逻辑思考再进行搭建金字塔</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p><strong>为什么要使用金字塔结构</strong></p>\n<ol>\n<li>站在读者角度，他们去了解你的文章或者演讲，如果文章写的没有条理，他们需要在各种句子之间去寻找它们之间的逻辑关系，前后反复思考，就会导致这是一件复杂的任务，如果文章结构呈现金字塔型，从顶部向下逐渐展开，对于读者来说是一件很容易的事情</li>\n<li>从人类思维的角度，大脑会将事务以某种相关性组合起来，大脑的短期记忆无法一次性容纳<strong>7个以上</strong>的记忆项目</li>\n</ol>\n<p><strong>归类分组将思想组织成金字塔</strong></p>\n<p>找出逻辑关系抽象概括</p>\n<img src=\"https://img-blog.csdnimg.cn/2290ee75fb3d4769ba221aa54a26fe9c.png\" style=\"zoom:25%;\" />\n\n<p>研究表明最有效的表达方法是：先提出总的概念，再列出具体项目，即要自上而下的表达思想</p>\n<p><strong>自上而下表达，结论先行</strong></p>\n<p>由于受众的知识背景和理解能力千差万别，如果不提前声明总结性概括，受众很可能会理解偏差，结论先行就能让他按照自己的思维框架进行理解</p>\n<p><strong>自下而上思考，总结概括</strong></p>\n<p>思考是自下而上的，由底层逻辑到上层思想，再有上层思想到中心思想、核心观念，不断地高度归纳、概括；</p>\n<img src=\"https://img-blog.csdnimg.cn/c938af8a9beb4e91a678486c4595e712.png\" style=\"zoom:25%;\" />\n\n<p>同一组思想的上层思想是对这一组思想的概括，这一组思想则是对上一层的思想的解释和支撑</p>\n<ol>\n<li>纵向：文章任一层次上的思想必须是其下一层次思想的概括</li>\n<li>横向：每组中的思想必须按照<strong>逻辑顺序</strong>组织</li>\n<li>横向：每组中的思想必须属于统一逻辑范畴</li>\n</ol>\n<p><strong>逻辑顺序</strong>表现了你在组织思想时的分析过程，组织思想基本上有这样四种逻辑顺序</p>\n<ol>\n<li>演绎顺序：大前提，小前提，结论</li>\n<li>时间顺序（步骤）：第一，第二，第三</li>\n<li>结构顺序（空间）：北京，深圳，上海</li>\n<li>程度顺序（重要性）：最重要、次重要，等等</li>\n</ol>\n<p><strong>总结：</strong></p>\n<ol>\n<li>金字塔思维是一套科学的，符合人类大脑功能的思维方式，掌握金字塔思维可以给自己的阅读写作带来极大的提升</li>\n<li>金字塔思维的锻炼是一个长期的过程，需要坚持使用下来，进行系统性的逻辑思考再进行搭建金字塔</li>\n</ol>\n"},{"title":"如何构建金字塔","_content":"\n**自上而下法**\n\n自上而下地构建金字塔结构通常容易一些，因为你开始思考的是你最容易确定的事情，即文章的主题，以及读者对该主题的了解情况（你将在文章的序言中引导读者重温其了解的情况）。\n\n但是，你还不能现在就坐下来开始写序言。你应当先利用序言的结构，将头脑中的观点、论点、想法逐个梳理出来。\n\n为了做到这点，建议你遵循下图的流程。\n\n<img src=\"https://img-blog.csdnimg.cn/df26c53353304b4984d685516f1245a7.png\" style=\"zoom:25%;\" />\n\n**自上而下法构建金字塔的步骤：**\n\n1．提出主题思想。\n\n2．设想受众的主要疑问。\n\n3．写序言：背景-冲突-疑问-回答。\n\n4．与受众进行疑问/回答式对话。\n\n5．对受众的新疑问，重复进行疑问/回答式对话。\n\n**自下而上法**\n\n很多时候你会发现你还没想清楚，无法构建金字塔结构的顶部。\n\n譬如，有时你无法准确确定要讨论的主题，有时尚不清楚读者头脑中的疑问，有时则无法确定读者了解什么、不了解什么。\n\n遇到这些情况时，可向下移动一个层次，从关键句层次上着手。\n\n如果你能够确定任何关键句要点，那很好；但多数情况下你可能无法确定。\n\n别着急，你可以按照以下\"三步走\"的步骤自下而上地组织你的思想。\n\n**自下而上思考：**\n\n1.列出你想表达的所有思想要点。\n\n2.找出各要点之间的逻辑关系。\n\n3.得出结论。\n\n**初学者注意事项**\n\n以下是我对金字塔原理的初学者常问问题的回答：\n\n1．一定先搭结构，先尝试自上而下法\n\n2．序言先写背景，将背景作为序言的起点\n\n一旦你知道自己想在序言的主体部分说什么——背景、冲突、疑问和回答，你就可以根据你希望产生的效果，按任何顺序写出这些内容。\n\n3．先多花时间思考序言，不要省略\n\n4．将历史背景放在序言中\n\n你不应该在文章的正文部分才告诉读者过去发生的事情。\n\n正文部分应当只包括思想（即：因能够为读者提供新思维而引起读者疑问的表述），思想只能以逻辑方式互相联系。\n\n也就是说，只有在描述一些通过分析发现的因果关系时，你才可以在正文部分列举读者已知的信息。\n\n> 5．序言仅涉及读者不会对其真实性提出质疑的内容\n\n序言的目的只是告诉读者一些他们已经知道的信息。\n\n当然，有时你并不知道读者是否确实知道某些信息；有时你则可以肯定读者不知道某些信息。\n\n如果所表达的信息能够很容易地由客观的第三方进行检验和证实，那就可以假定你的读者知道该信息，因为读者不会对其真实性提出质疑。\n\n同时，注意不要在序言中涉及任何读者不知道的信息，因为这样的信息可能导致读者提出非你所愿的疑问。\n\n**反之亦然，不要在金字塔结构中涉及任何读者已经知道的信息。**\n\n如果你利用读者已经知道的信息，回答金字塔结构中较低层次上的问题，就说明你在序言中遗漏了重要的信息。\n\n如果在序言中提供该信息的话，也许读者会提出不同的疑问。\n\n> 6．在关键句层次上，更宜选择归纳推理法而非演绎论证法\n\n在关键句层次上使用归纳推理比使用演绎推理更容易使读者接受，因为归纳法更容易被人理解。\n\n人们的倾向是按照思维发展的顺序表达自己的思想，而思维发展的顺序通常都是演绎的顺序。\n\n但是，以演绎的顺序发展的思想并不一定要以演绎的顺序表达出来。\n\n在大多数情况下，你都可以将以演绎法发展的思想用归纳法的形式表达出来。\n\n**例子：假设你建议某人购买一座库房，你根据以下的演绎推论支持对方购买库房**\n\n<img src=\"https://img-blog.csdnimg.cn/96ddc04a040844ffb2905de7b22144c8.png\" style=\"zoom:25%;\" />","source":"_posts/金字塔原理/如何构建金字塔.md","raw":"---\ntitle: 如何构建金字塔\ncategories: \n- 金字塔原理\n---\n\n**自上而下法**\n\n自上而下地构建金字塔结构通常容易一些，因为你开始思考的是你最容易确定的事情，即文章的主题，以及读者对该主题的了解情况（你将在文章的序言中引导读者重温其了解的情况）。\n\n但是，你还不能现在就坐下来开始写序言。你应当先利用序言的结构，将头脑中的观点、论点、想法逐个梳理出来。\n\n为了做到这点，建议你遵循下图的流程。\n\n<img src=\"https://img-blog.csdnimg.cn/df26c53353304b4984d685516f1245a7.png\" style=\"zoom:25%;\" />\n\n**自上而下法构建金字塔的步骤：**\n\n1．提出主题思想。\n\n2．设想受众的主要疑问。\n\n3．写序言：背景-冲突-疑问-回答。\n\n4．与受众进行疑问/回答式对话。\n\n5．对受众的新疑问，重复进行疑问/回答式对话。\n\n**自下而上法**\n\n很多时候你会发现你还没想清楚，无法构建金字塔结构的顶部。\n\n譬如，有时你无法准确确定要讨论的主题，有时尚不清楚读者头脑中的疑问，有时则无法确定读者了解什么、不了解什么。\n\n遇到这些情况时，可向下移动一个层次，从关键句层次上着手。\n\n如果你能够确定任何关键句要点，那很好；但多数情况下你可能无法确定。\n\n别着急，你可以按照以下\"三步走\"的步骤自下而上地组织你的思想。\n\n**自下而上思考：**\n\n1.列出你想表达的所有思想要点。\n\n2.找出各要点之间的逻辑关系。\n\n3.得出结论。\n\n**初学者注意事项**\n\n以下是我对金字塔原理的初学者常问问题的回答：\n\n1．一定先搭结构，先尝试自上而下法\n\n2．序言先写背景，将背景作为序言的起点\n\n一旦你知道自己想在序言的主体部分说什么——背景、冲突、疑问和回答，你就可以根据你希望产生的效果，按任何顺序写出这些内容。\n\n3．先多花时间思考序言，不要省略\n\n4．将历史背景放在序言中\n\n你不应该在文章的正文部分才告诉读者过去发生的事情。\n\n正文部分应当只包括思想（即：因能够为读者提供新思维而引起读者疑问的表述），思想只能以逻辑方式互相联系。\n\n也就是说，只有在描述一些通过分析发现的因果关系时，你才可以在正文部分列举读者已知的信息。\n\n> 5．序言仅涉及读者不会对其真实性提出质疑的内容\n\n序言的目的只是告诉读者一些他们已经知道的信息。\n\n当然，有时你并不知道读者是否确实知道某些信息；有时你则可以肯定读者不知道某些信息。\n\n如果所表达的信息能够很容易地由客观的第三方进行检验和证实，那就可以假定你的读者知道该信息，因为读者不会对其真实性提出质疑。\n\n同时，注意不要在序言中涉及任何读者不知道的信息，因为这样的信息可能导致读者提出非你所愿的疑问。\n\n**反之亦然，不要在金字塔结构中涉及任何读者已经知道的信息。**\n\n如果你利用读者已经知道的信息，回答金字塔结构中较低层次上的问题，就说明你在序言中遗漏了重要的信息。\n\n如果在序言中提供该信息的话，也许读者会提出不同的疑问。\n\n> 6．在关键句层次上，更宜选择归纳推理法而非演绎论证法\n\n在关键句层次上使用归纳推理比使用演绎推理更容易使读者接受，因为归纳法更容易被人理解。\n\n人们的倾向是按照思维发展的顺序表达自己的思想，而思维发展的顺序通常都是演绎的顺序。\n\n但是，以演绎的顺序发展的思想并不一定要以演绎的顺序表达出来。\n\n在大多数情况下，你都可以将以演绎法发展的思想用归纳法的形式表达出来。\n\n**例子：假设你建议某人购买一座库房，你根据以下的演绎推论支持对方购买库房**\n\n<img src=\"https://img-blog.csdnimg.cn/96ddc04a040844ffb2905de7b22144c8.png\" style=\"zoom:25%;\" />","slug":"金字塔原理/如何构建金字塔","published":1,"date":"2022-01-01T09:22:36.791Z","updated":"2022-02-01T08:08:04.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkq00kqfhjid9fm18nv","content":"<p><strong>自上而下法</strong></p>\n<p>自上而下地构建金字塔结构通常容易一些，因为你开始思考的是你最容易确定的事情，即文章的主题，以及读者对该主题的了解情况（你将在文章的序言中引导读者重温其了解的情况）。</p>\n<p>但是，你还不能现在就坐下来开始写序言。你应当先利用序言的结构，将头脑中的观点、论点、想法逐个梳理出来。</p>\n<p>为了做到这点，建议你遵循下图的流程。</p>\n<img src=\"https://img-blog.csdnimg.cn/df26c53353304b4984d685516f1245a7.png\" style=\"zoom:25%;\" />\n\n<p><strong>自上而下法构建金字塔的步骤：</strong></p>\n<p>1．提出主题思想。</p>\n<p>2．设想受众的主要疑问。</p>\n<p>3．写序言：背景-冲突-疑问-回答。</p>\n<p>4．与受众进行疑问&#x2F;回答式对话。</p>\n<p>5．对受众的新疑问，重复进行疑问&#x2F;回答式对话。</p>\n<p><strong>自下而上法</strong></p>\n<p>很多时候你会发现你还没想清楚，无法构建金字塔结构的顶部。</p>\n<p>譬如，有时你无法准确确定要讨论的主题，有时尚不清楚读者头脑中的疑问，有时则无法确定读者了解什么、不了解什么。</p>\n<p>遇到这些情况时，可向下移动一个层次，从关键句层次上着手。</p>\n<p>如果你能够确定任何关键句要点，那很好；但多数情况下你可能无法确定。</p>\n<p>别着急，你可以按照以下”三步走”的步骤自下而上地组织你的思想。</p>\n<p><strong>自下而上思考：</strong></p>\n<p>1.列出你想表达的所有思想要点。</p>\n<p>2.找出各要点之间的逻辑关系。</p>\n<p>3.得出结论。</p>\n<p><strong>初学者注意事项</strong></p>\n<p>以下是我对金字塔原理的初学者常问问题的回答：</p>\n<p>1．一定先搭结构，先尝试自上而下法</p>\n<p>2．序言先写背景，将背景作为序言的起点</p>\n<p>一旦你知道自己想在序言的主体部分说什么——背景、冲突、疑问和回答，你就可以根据你希望产生的效果，按任何顺序写出这些内容。</p>\n<p>3．先多花时间思考序言，不要省略</p>\n<p>4．将历史背景放在序言中</p>\n<p>你不应该在文章的正文部分才告诉读者过去发生的事情。</p>\n<p>正文部分应当只包括思想（即：因能够为读者提供新思维而引起读者疑问的表述），思想只能以逻辑方式互相联系。</p>\n<p>也就是说，只有在描述一些通过分析发现的因果关系时，你才可以在正文部分列举读者已知的信息。</p>\n<blockquote>\n<p>5．序言仅涉及读者不会对其真实性提出质疑的内容</p>\n</blockquote>\n<p>序言的目的只是告诉读者一些他们已经知道的信息。</p>\n<p>当然，有时你并不知道读者是否确实知道某些信息；有时你则可以肯定读者不知道某些信息。</p>\n<p>如果所表达的信息能够很容易地由客观的第三方进行检验和证实，那就可以假定你的读者知道该信息，因为读者不会对其真实性提出质疑。</p>\n<p>同时，注意不要在序言中涉及任何读者不知道的信息，因为这样的信息可能导致读者提出非你所愿的疑问。</p>\n<p><strong>反之亦然，不要在金字塔结构中涉及任何读者已经知道的信息。</strong></p>\n<p>如果你利用读者已经知道的信息，回答金字塔结构中较低层次上的问题，就说明你在序言中遗漏了重要的信息。</p>\n<p>如果在序言中提供该信息的话，也许读者会提出不同的疑问。</p>\n<blockquote>\n<p>6．在关键句层次上，更宜选择归纳推理法而非演绎论证法</p>\n</blockquote>\n<p>在关键句层次上使用归纳推理比使用演绎推理更容易使读者接受，因为归纳法更容易被人理解。</p>\n<p>人们的倾向是按照思维发展的顺序表达自己的思想，而思维发展的顺序通常都是演绎的顺序。</p>\n<p>但是，以演绎的顺序发展的思想并不一定要以演绎的顺序表达出来。</p>\n<p>在大多数情况下，你都可以将以演绎法发展的思想用归纳法的形式表达出来。</p>\n<p><strong>例子：假设你建议某人购买一座库房，你根据以下的演绎推论支持对方购买库房</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/96ddc04a040844ffb2905de7b22144c8.png\" style=\"zoom:25%;\" />","site":{"data":{}},"excerpt":"","more":"<p><strong>自上而下法</strong></p>\n<p>自上而下地构建金字塔结构通常容易一些，因为你开始思考的是你最容易确定的事情，即文章的主题，以及读者对该主题的了解情况（你将在文章的序言中引导读者重温其了解的情况）。</p>\n<p>但是，你还不能现在就坐下来开始写序言。你应当先利用序言的结构，将头脑中的观点、论点、想法逐个梳理出来。</p>\n<p>为了做到这点，建议你遵循下图的流程。</p>\n<img src=\"https://img-blog.csdnimg.cn/df26c53353304b4984d685516f1245a7.png\" style=\"zoom:25%;\" />\n\n<p><strong>自上而下法构建金字塔的步骤：</strong></p>\n<p>1．提出主题思想。</p>\n<p>2．设想受众的主要疑问。</p>\n<p>3．写序言：背景-冲突-疑问-回答。</p>\n<p>4．与受众进行疑问&#x2F;回答式对话。</p>\n<p>5．对受众的新疑问，重复进行疑问&#x2F;回答式对话。</p>\n<p><strong>自下而上法</strong></p>\n<p>很多时候你会发现你还没想清楚，无法构建金字塔结构的顶部。</p>\n<p>譬如，有时你无法准确确定要讨论的主题，有时尚不清楚读者头脑中的疑问，有时则无法确定读者了解什么、不了解什么。</p>\n<p>遇到这些情况时，可向下移动一个层次，从关键句层次上着手。</p>\n<p>如果你能够确定任何关键句要点，那很好；但多数情况下你可能无法确定。</p>\n<p>别着急，你可以按照以下”三步走”的步骤自下而上地组织你的思想。</p>\n<p><strong>自下而上思考：</strong></p>\n<p>1.列出你想表达的所有思想要点。</p>\n<p>2.找出各要点之间的逻辑关系。</p>\n<p>3.得出结论。</p>\n<p><strong>初学者注意事项</strong></p>\n<p>以下是我对金字塔原理的初学者常问问题的回答：</p>\n<p>1．一定先搭结构，先尝试自上而下法</p>\n<p>2．序言先写背景，将背景作为序言的起点</p>\n<p>一旦你知道自己想在序言的主体部分说什么——背景、冲突、疑问和回答，你就可以根据你希望产生的效果，按任何顺序写出这些内容。</p>\n<p>3．先多花时间思考序言，不要省略</p>\n<p>4．将历史背景放在序言中</p>\n<p>你不应该在文章的正文部分才告诉读者过去发生的事情。</p>\n<p>正文部分应当只包括思想（即：因能够为读者提供新思维而引起读者疑问的表述），思想只能以逻辑方式互相联系。</p>\n<p>也就是说，只有在描述一些通过分析发现的因果关系时，你才可以在正文部分列举读者已知的信息。</p>\n<blockquote>\n<p>5．序言仅涉及读者不会对其真实性提出质疑的内容</p>\n</blockquote>\n<p>序言的目的只是告诉读者一些他们已经知道的信息。</p>\n<p>当然，有时你并不知道读者是否确实知道某些信息；有时你则可以肯定读者不知道某些信息。</p>\n<p>如果所表达的信息能够很容易地由客观的第三方进行检验和证实，那就可以假定你的读者知道该信息，因为读者不会对其真实性提出质疑。</p>\n<p>同时，注意不要在序言中涉及任何读者不知道的信息，因为这样的信息可能导致读者提出非你所愿的疑问。</p>\n<p><strong>反之亦然，不要在金字塔结构中涉及任何读者已经知道的信息。</strong></p>\n<p>如果你利用读者已经知道的信息，回答金字塔结构中较低层次上的问题，就说明你在序言中遗漏了重要的信息。</p>\n<p>如果在序言中提供该信息的话，也许读者会提出不同的疑问。</p>\n<blockquote>\n<p>6．在关键句层次上，更宜选择归纳推理法而非演绎论证法</p>\n</blockquote>\n<p>在关键句层次上使用归纳推理比使用演绎推理更容易使读者接受，因为归纳法更容易被人理解。</p>\n<p>人们的倾向是按照思维发展的顺序表达自己的思想，而思维发展的顺序通常都是演绎的顺序。</p>\n<p>但是，以演绎的顺序发展的思想并不一定要以演绎的顺序表达出来。</p>\n<p>在大多数情况下，你都可以将以演绎法发展的思想用归纳法的形式表达出来。</p>\n<p><strong>例子：假设你建议某人购买一座库房，你根据以下的演绎推论支持对方购买库房</strong></p>\n<img src=\"https://img-blog.csdnimg.cn/96ddc04a040844ffb2905de7b22144c8.png\" style=\"zoom:25%;\" />"},{"title":"金字塔内部结构","_content":"\n\n<img src=\"https://img-blog.csdnimg.cn/b3868747c69646d999328687d5cb917c.png\" style=\"zoom:25%;\" />\n\n自己的思想还只有模糊的想法时，不要幻想一下子就能将思想组织成金字塔，需要进行思想的梳理，以下可以加快梳理过程\n\n1. 主题与子主题之间的纵向关系\n2. 各子主题之间的横向关系\n3. 序言的叙述方式\n\n**纵向关系：**\n\n能够较好的吸引读者的注意力，引导一种疑问、回答式的对话，有助于表达思路进展；\n\n为了向受众传递新的信息而作的表述，必然会使对方就其逻辑性产生疑问，例如，\"为什么会这样\"、\"怎样才能这样\"，或\"为什么你这样说\"\n\n你的每一个表述都应当引发读者的疑问，而你也必须在这一表述下的横向结构层次上逐个回答读者的疑问。\n\n<img src=\"https://img-blog.csdnimg.cn/c1fafb4807474fa58af6ae9bd2b65a76.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/55f77fba79af4cc1aa8e5d24be766a24.png\" style=\"zoom:25%;\" />\n\n**横向关系：**\n\n当考虑在下一结构层次上如何表述时，必须保证你的表述能回答在其上一个层次上的表述引起的疑问，同时还必须保证表述符合逻辑。\n\n也就是说，表述必须具有明确的归纳或演绎关系，但不可同时既具有归纳关系，又具有演绎关系。\n\n在组织思想时，归纳和演绎是仅有的两种可能的逻辑关系。\n\n> 演绎性思想\n\n演绎性思想组合是由几个承前启后的论述组成的。\n\n第一个思想是对当今世界上的某种现象的表述；第二个思想是对该句子的主语或谓语所作的表述；第三个思想则说明了以上两种表述同时在世界上存在时所具有的隐含意义。\n\n因此，演绎性思想组合具有以下形式：\n\n● 所有的人都会死。\n\n● 苏格拉底是一个人。\n\n● 因此苏格拉底会死。\n\n> 归纳性思想\n\n你可以用同一个名词表示组中所有思想，如支持的原因、反对的原因、步骤、问题，等等。\n\n归纳性论述的形式是：\n\n● 法国坦克已抵达波兰边境。\n\n● 德国坦克已抵达波兰边境。\n\n● 俄国坦克已抵达波兰边境。\n\n为了提高一个抽象层次，你需要识别以上句子的共同点（即：都是针对波兰的战争行为），并得出一个推论。\n\n你的推论可能是\"波兰将受到坦克入侵\"或类似的思想。\n\n如果你选择以演绎法回答由某个思想引起的疑问，你就必须进行3段论式的论述。\n\n> 根据亚里士多德的论述，三段式演绎法包含大前提、小前提和结论三部分。\n>\n>  如果大前提和小前提都是真的，那么结论不可能为假，必然是真的。\n>\n> 比如，\"人终 有一死\"是大前提，\"苏格拉底是个人\"是小前提，那么\"苏格拉底必有一死\"就是结论。\n\n其中，第二个思想是对第一个思想的主语或谓语作出的表述，而第三个思想则从以上两个思想中得出推论。\n\n如果你选择以归纳法回答由某个思想引起的疑问，你就必须保证该组思想在逻辑上具有共同点，并且可以用同一个名词表示。\n\n**序言的结构：**\n\n通过讲故事的形式，引发读者的阅读兴趣\n\n1. 背景（situation）\n2. 冲突(complication)\n3. 疑问（question）\n4. 回答 （answer）\n\n序言的开头应向读者说明\"背景\"（situation）的时间和地点。\n\n在这一背景中应当发生了某件事情，可称为\"冲突\"（complication），使读者提出（或将使读者提出）你的文章将要\"回答\"（answer）的\"疑问\"（question）。\n\n| S    | 结构化思维是清晰地思考和表达的必要能力。                     |\n| :--- | ------------------------------------------------------------ |\n| C    | 工作中，相信每个人都曾遇到发觉自己思路不够清晰，导致思考不全面、表达没条理，进而损害了工作效率的情况。 |\n| Q    | 这时，聪明的孩子就会积极去向同事、网络寻求令自己的逻辑更清晰的方法论。\"使用金字塔原理展现你的思路吧！\"这是他们经常能得到的一种回答。可金字塔原理究竟是什么，又是怎么做的呢？ |\n| A    | 这其中的奥妙就在于它遵循两条人类理解事物的基本需求：第一是人脑一次性能理解的思想是有限的；第二是人脑会将同时出现的事物联系起来，并试图找出其中的逻辑关系。基于这两个需求，金字塔原理定义了三种用于组织思想的子结构，包括纵向的疑问-回答式对话、横向的演绎或归纳推理和讲故事式的序言；然后利用它们将思想构建为看起来像金字塔的树形拓扑结构，使得思考和表达清晰易懂。 |\n\n**总结：**\n\n这3种子结构（即纵向的疑问/回答式对话、横向的演绎或归纳推理、讲故事式的序言）能够帮助你找到构建金字塔所需的思想。\n\n<img src=\"https://img-blog.csdnimg.cn/266e0470f5064b3982dd1a4e078fe89d.png\" style=\"zoom:25%;\" />","source":"_posts/金字塔原理/金字塔内部结构.md","raw":"---\ntitle: 金字塔内部结构\ncategories: \n- 金字塔原理\n---\n\n\n<img src=\"https://img-blog.csdnimg.cn/b3868747c69646d999328687d5cb917c.png\" style=\"zoom:25%;\" />\n\n自己的思想还只有模糊的想法时，不要幻想一下子就能将思想组织成金字塔，需要进行思想的梳理，以下可以加快梳理过程\n\n1. 主题与子主题之间的纵向关系\n2. 各子主题之间的横向关系\n3. 序言的叙述方式\n\n**纵向关系：**\n\n能够较好的吸引读者的注意力，引导一种疑问、回答式的对话，有助于表达思路进展；\n\n为了向受众传递新的信息而作的表述，必然会使对方就其逻辑性产生疑问，例如，\"为什么会这样\"、\"怎样才能这样\"，或\"为什么你这样说\"\n\n你的每一个表述都应当引发读者的疑问，而你也必须在这一表述下的横向结构层次上逐个回答读者的疑问。\n\n<img src=\"https://img-blog.csdnimg.cn/c1fafb4807474fa58af6ae9bd2b65a76.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/55f77fba79af4cc1aa8e5d24be766a24.png\" style=\"zoom:25%;\" />\n\n**横向关系：**\n\n当考虑在下一结构层次上如何表述时，必须保证你的表述能回答在其上一个层次上的表述引起的疑问，同时还必须保证表述符合逻辑。\n\n也就是说，表述必须具有明确的归纳或演绎关系，但不可同时既具有归纳关系，又具有演绎关系。\n\n在组织思想时，归纳和演绎是仅有的两种可能的逻辑关系。\n\n> 演绎性思想\n\n演绎性思想组合是由几个承前启后的论述组成的。\n\n第一个思想是对当今世界上的某种现象的表述；第二个思想是对该句子的主语或谓语所作的表述；第三个思想则说明了以上两种表述同时在世界上存在时所具有的隐含意义。\n\n因此，演绎性思想组合具有以下形式：\n\n● 所有的人都会死。\n\n● 苏格拉底是一个人。\n\n● 因此苏格拉底会死。\n\n> 归纳性思想\n\n你可以用同一个名词表示组中所有思想，如支持的原因、反对的原因、步骤、问题，等等。\n\n归纳性论述的形式是：\n\n● 法国坦克已抵达波兰边境。\n\n● 德国坦克已抵达波兰边境。\n\n● 俄国坦克已抵达波兰边境。\n\n为了提高一个抽象层次，你需要识别以上句子的共同点（即：都是针对波兰的战争行为），并得出一个推论。\n\n你的推论可能是\"波兰将受到坦克入侵\"或类似的思想。\n\n如果你选择以演绎法回答由某个思想引起的疑问，你就必须进行3段论式的论述。\n\n> 根据亚里士多德的论述，三段式演绎法包含大前提、小前提和结论三部分。\n>\n>  如果大前提和小前提都是真的，那么结论不可能为假，必然是真的。\n>\n> 比如，\"人终 有一死\"是大前提，\"苏格拉底是个人\"是小前提，那么\"苏格拉底必有一死\"就是结论。\n\n其中，第二个思想是对第一个思想的主语或谓语作出的表述，而第三个思想则从以上两个思想中得出推论。\n\n如果你选择以归纳法回答由某个思想引起的疑问，你就必须保证该组思想在逻辑上具有共同点，并且可以用同一个名词表示。\n\n**序言的结构：**\n\n通过讲故事的形式，引发读者的阅读兴趣\n\n1. 背景（situation）\n2. 冲突(complication)\n3. 疑问（question）\n4. 回答 （answer）\n\n序言的开头应向读者说明\"背景\"（situation）的时间和地点。\n\n在这一背景中应当发生了某件事情，可称为\"冲突\"（complication），使读者提出（或将使读者提出）你的文章将要\"回答\"（answer）的\"疑问\"（question）。\n\n| S    | 结构化思维是清晰地思考和表达的必要能力。                     |\n| :--- | ------------------------------------------------------------ |\n| C    | 工作中，相信每个人都曾遇到发觉自己思路不够清晰，导致思考不全面、表达没条理，进而损害了工作效率的情况。 |\n| Q    | 这时，聪明的孩子就会积极去向同事、网络寻求令自己的逻辑更清晰的方法论。\"使用金字塔原理展现你的思路吧！\"这是他们经常能得到的一种回答。可金字塔原理究竟是什么，又是怎么做的呢？ |\n| A    | 这其中的奥妙就在于它遵循两条人类理解事物的基本需求：第一是人脑一次性能理解的思想是有限的；第二是人脑会将同时出现的事物联系起来，并试图找出其中的逻辑关系。基于这两个需求，金字塔原理定义了三种用于组织思想的子结构，包括纵向的疑问-回答式对话、横向的演绎或归纳推理和讲故事式的序言；然后利用它们将思想构建为看起来像金字塔的树形拓扑结构，使得思考和表达清晰易懂。 |\n\n**总结：**\n\n这3种子结构（即纵向的疑问/回答式对话、横向的演绎或归纳推理、讲故事式的序言）能够帮助你找到构建金字塔所需的思想。\n\n<img src=\"https://img-blog.csdnimg.cn/266e0470f5064b3982dd1a4e078fe89d.png\" style=\"zoom:25%;\" />","slug":"金字塔原理/金字塔内部结构","published":1,"date":"2021-12-30T05:50:46.210Z","updated":"2022-02-01T08:08:08.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwkq00ktfhji0vlg40or","content":"<img src=\"https://img-blog.csdnimg.cn/b3868747c69646d999328687d5cb917c.png\" style=\"zoom:25%;\" />\n\n<p>自己的思想还只有模糊的想法时，不要幻想一下子就能将思想组织成金字塔，需要进行思想的梳理，以下可以加快梳理过程</p>\n<ol>\n<li>主题与子主题之间的纵向关系</li>\n<li>各子主题之间的横向关系</li>\n<li>序言的叙述方式</li>\n</ol>\n<p><strong>纵向关系：</strong></p>\n<p>能够较好的吸引读者的注意力，引导一种疑问、回答式的对话，有助于表达思路进展；</p>\n<p>为了向受众传递新的信息而作的表述，必然会使对方就其逻辑性产生疑问，例如，”为什么会这样”、”怎样才能这样”，或”为什么你这样说”</p>\n<p>你的每一个表述都应当引发读者的疑问，而你也必须在这一表述下的横向结构层次上逐个回答读者的疑问。</p>\n<img src=\"https://img-blog.csdnimg.cn/c1fafb4807474fa58af6ae9bd2b65a76.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/55f77fba79af4cc1aa8e5d24be766a24.png\" style=\"zoom:25%;\" />\n\n<p><strong>横向关系：</strong></p>\n<p>当考虑在下一结构层次上如何表述时，必须保证你的表述能回答在其上一个层次上的表述引起的疑问，同时还必须保证表述符合逻辑。</p>\n<p>也就是说，表述必须具有明确的归纳或演绎关系，但不可同时既具有归纳关系，又具有演绎关系。</p>\n<p>在组织思想时，归纳和演绎是仅有的两种可能的逻辑关系。</p>\n<blockquote>\n<p>演绎性思想</p>\n</blockquote>\n<p>演绎性思想组合是由几个承前启后的论述组成的。</p>\n<p>第一个思想是对当今世界上的某种现象的表述；第二个思想是对该句子的主语或谓语所作的表述；第三个思想则说明了以上两种表述同时在世界上存在时所具有的隐含意义。</p>\n<p>因此，演绎性思想组合具有以下形式：</p>\n<p>● 所有的人都会死。</p>\n<p>● 苏格拉底是一个人。</p>\n<p>● 因此苏格拉底会死。</p>\n<blockquote>\n<p>归纳性思想</p>\n</blockquote>\n<p>你可以用同一个名词表示组中所有思想，如支持的原因、反对的原因、步骤、问题，等等。</p>\n<p>归纳性论述的形式是：</p>\n<p>● 法国坦克已抵达波兰边境。</p>\n<p>● 德国坦克已抵达波兰边境。</p>\n<p>● 俄国坦克已抵达波兰边境。</p>\n<p>为了提高一个抽象层次，你需要识别以上句子的共同点（即：都是针对波兰的战争行为），并得出一个推论。</p>\n<p>你的推论可能是”波兰将受到坦克入侵”或类似的思想。</p>\n<p>如果你选择以演绎法回答由某个思想引起的疑问，你就必须进行3段论式的论述。</p>\n<blockquote>\n<p>根据亚里士多德的论述，三段式演绎法包含大前提、小前提和结论三部分。</p>\n<p> 如果大前提和小前提都是真的，那么结论不可能为假，必然是真的。</p>\n<p>比如，”人终 有一死”是大前提，”苏格拉底是个人”是小前提，那么”苏格拉底必有一死”就是结论。</p>\n</blockquote>\n<p>其中，第二个思想是对第一个思想的主语或谓语作出的表述，而第三个思想则从以上两个思想中得出推论。</p>\n<p>如果你选择以归纳法回答由某个思想引起的疑问，你就必须保证该组思想在逻辑上具有共同点，并且可以用同一个名词表示。</p>\n<p><strong>序言的结构：</strong></p>\n<p>通过讲故事的形式，引发读者的阅读兴趣</p>\n<ol>\n<li>背景（situation）</li>\n<li>冲突(complication)</li>\n<li>疑问（question）</li>\n<li>回答 （answer）</li>\n</ol>\n<p>序言的开头应向读者说明”背景”（situation）的时间和地点。</p>\n<p>在这一背景中应当发生了某件事情，可称为”冲突”（complication），使读者提出（或将使读者提出）你的文章将要”回答”（answer）的”疑问”（question）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">S</th>\n<th>结构化思维是清晰地思考和表达的必要能力。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C</td>\n<td>工作中，相信每个人都曾遇到发觉自己思路不够清晰，导致思考不全面、表达没条理，进而损害了工作效率的情况。</td>\n</tr>\n<tr>\n<td align=\"left\">Q</td>\n<td>这时，聪明的孩子就会积极去向同事、网络寻求令自己的逻辑更清晰的方法论。”使用金字塔原理展现你的思路吧！”这是他们经常能得到的一种回答。可金字塔原理究竟是什么，又是怎么做的呢？</td>\n</tr>\n<tr>\n<td align=\"left\">A</td>\n<td>这其中的奥妙就在于它遵循两条人类理解事物的基本需求：第一是人脑一次性能理解的思想是有限的；第二是人脑会将同时出现的事物联系起来，并试图找出其中的逻辑关系。基于这两个需求，金字塔原理定义了三种用于组织思想的子结构，包括纵向的疑问-回答式对话、横向的演绎或归纳推理和讲故事式的序言；然后利用它们将思想构建为看起来像金字塔的树形拓扑结构，使得思考和表达清晰易懂。</td>\n</tr>\n</tbody></table>\n<p><strong>总结：</strong></p>\n<p>这3种子结构（即纵向的疑问&#x2F;回答式对话、横向的演绎或归纳推理、讲故事式的序言）能够帮助你找到构建金字塔所需的思想。</p>\n<img src=\"https://img-blog.csdnimg.cn/266e0470f5064b3982dd1a4e078fe89d.png\" style=\"zoom:25%;\" />","site":{"data":{}},"excerpt":"","more":"<img src=\"https://img-blog.csdnimg.cn/b3868747c69646d999328687d5cb917c.png\" style=\"zoom:25%;\" />\n\n<p>自己的思想还只有模糊的想法时，不要幻想一下子就能将思想组织成金字塔，需要进行思想的梳理，以下可以加快梳理过程</p>\n<ol>\n<li>主题与子主题之间的纵向关系</li>\n<li>各子主题之间的横向关系</li>\n<li>序言的叙述方式</li>\n</ol>\n<p><strong>纵向关系：</strong></p>\n<p>能够较好的吸引读者的注意力，引导一种疑问、回答式的对话，有助于表达思路进展；</p>\n<p>为了向受众传递新的信息而作的表述，必然会使对方就其逻辑性产生疑问，例如，”为什么会这样”、”怎样才能这样”，或”为什么你这样说”</p>\n<p>你的每一个表述都应当引发读者的疑问，而你也必须在这一表述下的横向结构层次上逐个回答读者的疑问。</p>\n<img src=\"https://img-blog.csdnimg.cn/c1fafb4807474fa58af6ae9bd2b65a76.png\" style=\"zoom:25%;\" />\n\n<img src=\"https://img-blog.csdnimg.cn/55f77fba79af4cc1aa8e5d24be766a24.png\" style=\"zoom:25%;\" />\n\n<p><strong>横向关系：</strong></p>\n<p>当考虑在下一结构层次上如何表述时，必须保证你的表述能回答在其上一个层次上的表述引起的疑问，同时还必须保证表述符合逻辑。</p>\n<p>也就是说，表述必须具有明确的归纳或演绎关系，但不可同时既具有归纳关系，又具有演绎关系。</p>\n<p>在组织思想时，归纳和演绎是仅有的两种可能的逻辑关系。</p>\n<blockquote>\n<p>演绎性思想</p>\n</blockquote>\n<p>演绎性思想组合是由几个承前启后的论述组成的。</p>\n<p>第一个思想是对当今世界上的某种现象的表述；第二个思想是对该句子的主语或谓语所作的表述；第三个思想则说明了以上两种表述同时在世界上存在时所具有的隐含意义。</p>\n<p>因此，演绎性思想组合具有以下形式：</p>\n<p>● 所有的人都会死。</p>\n<p>● 苏格拉底是一个人。</p>\n<p>● 因此苏格拉底会死。</p>\n<blockquote>\n<p>归纳性思想</p>\n</blockquote>\n<p>你可以用同一个名词表示组中所有思想，如支持的原因、反对的原因、步骤、问题，等等。</p>\n<p>归纳性论述的形式是：</p>\n<p>● 法国坦克已抵达波兰边境。</p>\n<p>● 德国坦克已抵达波兰边境。</p>\n<p>● 俄国坦克已抵达波兰边境。</p>\n<p>为了提高一个抽象层次，你需要识别以上句子的共同点（即：都是针对波兰的战争行为），并得出一个推论。</p>\n<p>你的推论可能是”波兰将受到坦克入侵”或类似的思想。</p>\n<p>如果你选择以演绎法回答由某个思想引起的疑问，你就必须进行3段论式的论述。</p>\n<blockquote>\n<p>根据亚里士多德的论述，三段式演绎法包含大前提、小前提和结论三部分。</p>\n<p> 如果大前提和小前提都是真的，那么结论不可能为假，必然是真的。</p>\n<p>比如，”人终 有一死”是大前提，”苏格拉底是个人”是小前提，那么”苏格拉底必有一死”就是结论。</p>\n</blockquote>\n<p>其中，第二个思想是对第一个思想的主语或谓语作出的表述，而第三个思想则从以上两个思想中得出推论。</p>\n<p>如果你选择以归纳法回答由某个思想引起的疑问，你就必须保证该组思想在逻辑上具有共同点，并且可以用同一个名词表示。</p>\n<p><strong>序言的结构：</strong></p>\n<p>通过讲故事的形式，引发读者的阅读兴趣</p>\n<ol>\n<li>背景（situation）</li>\n<li>冲突(complication)</li>\n<li>疑问（question）</li>\n<li>回答 （answer）</li>\n</ol>\n<p>序言的开头应向读者说明”背景”（situation）的时间和地点。</p>\n<p>在这一背景中应当发生了某件事情，可称为”冲突”（complication），使读者提出（或将使读者提出）你的文章将要”回答”（answer）的”疑问”（question）。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\">S</th>\n<th>结构化思维是清晰地思考和表达的必要能力。</th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">C</td>\n<td>工作中，相信每个人都曾遇到发觉自己思路不够清晰，导致思考不全面、表达没条理，进而损害了工作效率的情况。</td>\n</tr>\n<tr>\n<td align=\"left\">Q</td>\n<td>这时，聪明的孩子就会积极去向同事、网络寻求令自己的逻辑更清晰的方法论。”使用金字塔原理展现你的思路吧！”这是他们经常能得到的一种回答。可金字塔原理究竟是什么，又是怎么做的呢？</td>\n</tr>\n<tr>\n<td align=\"left\">A</td>\n<td>这其中的奥妙就在于它遵循两条人类理解事物的基本需求：第一是人脑一次性能理解的思想是有限的；第二是人脑会将同时出现的事物联系起来，并试图找出其中的逻辑关系。基于这两个需求，金字塔原理定义了三种用于组织思想的子结构，包括纵向的疑问-回答式对话、横向的演绎或归纳推理和讲故事式的序言；然后利用它们将思想构建为看起来像金字塔的树形拓扑结构，使得思考和表达清晰易懂。</td>\n</tr>\n</tbody></table>\n<p><strong>总结：</strong></p>\n<p>这3种子结构（即纵向的疑问&#x2F;回答式对话、横向的演绎或归纳推理、讲故事式的序言）能够帮助你找到构建金字塔所需的思想。</p>\n<img src=\"https://img-blog.csdnimg.cn/266e0470f5064b3982dd1a4e078fe89d.png\" style=\"zoom:25%;\" />"},{"title":"OOP规约","_content":"\n1.避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。\n\n2.相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 \n\n> 说明:可变参数必须放置在参数列表的最后。(提倡同学们尽量不用可变参数编程)\n\n3.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。\n\n> 接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。\n\n4.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 \n\n```java\n正例:\"test\".equals(object);\n反例:object.equals(\"test\");\n```\n\n> 说明:推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。\n\n5.所有整型包装类对象之间值的比较，全部使用equals方法比较。\n\n6.任何货币金额，均以最小货币单位且整型类型来进行存储。\n\n**7.浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。**\n\n反例：\n\n```java\nfloat a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nif (a == b) {\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 a==b 的结果为 false\n}\nFloat x = Float.valueOf(a);\nFloat y = Float.valueOf(b);\nif (x.equals(y)) {\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 equals 的结果为 false\n}\n```\n\n正例：\n\n```java\n//(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。\nfloat a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nfloat diff = 1e-6F;\nif (Math.abs(a - b) < diff) {\n\tSystem.out.println(\"true\");\n}\n//(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nBigDecimal x = a.subtract(b);\nBigDecimal y = b.subtract(c);\nif (x.equals(y)) {\n  System.out.println(\"true\");\n}\n```\n\n8.定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。\n\n> 正例:数据库字段的 bigint 必须与类属性的 Long 类型相对应。\n>\n> 反例:某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。\n\n9.禁止使用构造方法 `BigDecimal(double)`的方式把 double 值转化为 BigDecimal 对象。 \n\n> 说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。\n>\n> 正例:优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了\n\n```java\n BigDecimal recommend1 = new BigDecimal(\"0.1\");\n BigDecimal recommend2 = BigDecimal.valueOf(0.1);\n```\n\n10.所有的 POJO 类属性必须使用包装数据类型。\n\n> 正例:数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。 \n\n11.RPC 方法的返回值和参数必须使用包装数据类型。 \n\n> 包装数据类型 的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。\n\n12.所有的局部变量使用基本数据类型。\n\n13.定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。\n\n14.序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败;\n\n如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。\n\n> 说明:注意 serialVersionUID 不一致会抛出序列化运行时异常。\n\n15.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。\n\n16.POJO 类必须写 toString 方法。\n\n> 说明:在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。\n\n17.POJO类中禁止存在对应属性xxx的isXxx()和getXxx()方法。\n\n> 框架在调用属性xxx的提取方法时，并不能确定哪个方法一定是被优先调用到。\n\n18.使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有IndexOutOfBoundsException 的风险。\n\n```java\nString str = \"a,b,c,,\";\nString[] ary = str.split(\",\");\n// 预期大于 3，结果是 3 \nSystem.out.println(ary.length);\n```\n\n19.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便 于阅读。\n\n20.类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter 方法。\n\n21.在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。\n\n22.循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。","source":"_posts/阿里Java开发手册/编程规约/OOP规约.md","raw":"---\ntitle: OOP规约\ncategories: \n- 阿里Java开发手册\n- 编程规约\n---\n\n1.避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。\n\n2.相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 \n\n> 说明:可变参数必须放置在参数列表的最后。(提倡同学们尽量不用可变参数编程)\n\n3.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。\n\n> 接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。\n\n4.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 \n\n```java\n正例:\"test\".equals(object);\n反例:object.equals(\"test\");\n```\n\n> 说明:推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。\n\n5.所有整型包装类对象之间值的比较，全部使用equals方法比较。\n\n6.任何货币金额，均以最小货币单位且整型类型来进行存储。\n\n**7.浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。**\n\n反例：\n\n```java\nfloat a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nif (a == b) {\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 a==b 的结果为 false\n}\nFloat x = Float.valueOf(a);\nFloat y = Float.valueOf(b);\nif (x.equals(y)) {\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 equals 的结果为 false\n}\n```\n\n正例：\n\n```java\n//(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。\nfloat a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nfloat diff = 1e-6F;\nif (Math.abs(a - b) < diff) {\n\tSystem.out.println(\"true\");\n}\n//(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。\nBigDecimal a = new BigDecimal(\"1.0\");\nBigDecimal b = new BigDecimal(\"0.9\");\nBigDecimal c = new BigDecimal(\"0.8\");\nBigDecimal x = a.subtract(b);\nBigDecimal y = b.subtract(c);\nif (x.equals(y)) {\n  System.out.println(\"true\");\n}\n```\n\n8.定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。\n\n> 正例:数据库字段的 bigint 必须与类属性的 Long 类型相对应。\n>\n> 反例:某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。\n\n9.禁止使用构造方法 `BigDecimal(double)`的方式把 double 值转化为 BigDecimal 对象。 \n\n> 说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。\n>\n> 正例:优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了\n\n```java\n BigDecimal recommend1 = new BigDecimal(\"0.1\");\n BigDecimal recommend2 = BigDecimal.valueOf(0.1);\n```\n\n10.所有的 POJO 类属性必须使用包装数据类型。\n\n> 正例:数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。 \n\n11.RPC 方法的返回值和参数必须使用包装数据类型。 \n\n> 包装数据类型 的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。\n\n12.所有的局部变量使用基本数据类型。\n\n13.定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。\n\n14.序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败;\n\n如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。\n\n> 说明:注意 serialVersionUID 不一致会抛出序列化运行时异常。\n\n15.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。\n\n16.POJO 类必须写 toString 方法。\n\n> 说明:在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。\n\n17.POJO类中禁止存在对应属性xxx的isXxx()和getXxx()方法。\n\n> 框架在调用属性xxx的提取方法时，并不能确定哪个方法一定是被优先调用到。\n\n18.使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有IndexOutOfBoundsException 的风险。\n\n```java\nString str = \"a,b,c,,\";\nString[] ary = str.split(\",\");\n// 预期大于 3，结果是 3 \nSystem.out.println(ary.length);\n```\n\n19.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便 于阅读。\n\n20.类内方法定义的顺序依次是：公有方法或保护方法 > 私有方法 > getter / setter 方法。\n\n21.在getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。\n\n22.循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。","slug":"阿里Java开发手册/编程规约/OOP规约","published":1,"date":"2022-03-15T05:33:06.160Z","updated":"2022-03-15T05:56:31.829Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwli00nffhjiccaqarml","content":"<p>1.避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p>\n<p>2.相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 </p>\n<blockquote>\n<p>说明:可变参数必须放置在参数列表的最后。(提倡同学们尽量不用可变参数编程)</p>\n</blockquote>\n<p>3.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。</p>\n<blockquote>\n<p>接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p>\n</blockquote>\n<p>4.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 </p>\n<pre><code class=\"java\">正例:&quot;test&quot;.equals(object);\n反例:object.equals(&quot;test&quot;);\n</code></pre>\n<blockquote>\n<p>说明:推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。</p>\n</blockquote>\n<p>5.所有整型包装类对象之间值的比较，全部使用equals方法比较。</p>\n<p>6.任何货币金额，均以最小货币单位且整型类型来进行存储。</p>\n<p><strong>7.浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals 来判断。</strong></p>\n<p>反例：</p>\n<pre><code class=\"java\">float a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nif (a == b) &#123;\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 a==b 的结果为 false\n&#125;\nFloat x = Float.valueOf(a);\nFloat y = Float.valueOf(b);\nif (x.equals(y)) &#123;\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 equals 的结果为 false\n&#125;\n</code></pre>\n<p>正例：</p>\n<pre><code class=\"java\">//(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。\nfloat a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nfloat diff = 1e-6F;\nif (Math.abs(a - b) &lt; diff) &#123;\n    System.out.println(&quot;true&quot;);\n&#125;\n//(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。\nBigDecimal a = new BigDecimal(&quot;1.0&quot;);\nBigDecimal b = new BigDecimal(&quot;0.9&quot;);\nBigDecimal c = new BigDecimal(&quot;0.8&quot;);\nBigDecimal x = a.subtract(b);\nBigDecimal y = b.subtract(c);\nif (x.equals(y)) &#123;\n  System.out.println(&quot;true&quot;);\n&#125;\n</code></pre>\n<p>8.定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。</p>\n<blockquote>\n<p>正例:数据库字段的 bigint 必须与类属性的 Long 类型相对应。</p>\n<p>反例:某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。</p>\n</blockquote>\n<p>9.禁止使用构造方法 <code>BigDecimal(double)</code>的方式把 double 值转化为 BigDecimal 对象。 </p>\n<blockquote>\n<p>说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。</p>\n<p>正例:优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了</p>\n</blockquote>\n<pre><code class=\"java\"> BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;);\n BigDecimal recommend2 = BigDecimal.valueOf(0.1);\n</code></pre>\n<p>10.所有的 POJO 类属性必须使用包装数据类型。</p>\n<blockquote>\n<p>正例:数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。 </p>\n</blockquote>\n<p>11.RPC 方法的返回值和参数必须使用包装数据类型。 </p>\n<blockquote>\n<p>包装数据类型 的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p>\n</blockquote>\n<p>12.所有的局部变量使用基本数据类型。</p>\n<p>13.定义 DO&#x2F;DTO&#x2F;VO 等 POJO 类时，不要设定任何属性默认值。</p>\n<p>14.序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败;</p>\n<p>如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p>\n<blockquote>\n<p>说明:注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>\n</blockquote>\n<p>15.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p>\n<p>16.POJO 类必须写 toString 方法。</p>\n<blockquote>\n<p>说明:在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p>\n</blockquote>\n<p>17.POJO类中禁止存在对应属性xxx的isXxx()和getXxx()方法。</p>\n<blockquote>\n<p>框架在调用属性xxx的提取方法时，并不能确定哪个方法一定是被优先调用到。</p>\n</blockquote>\n<p>18.使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有IndexOutOfBoundsException 的风险。</p>\n<pre><code class=\"java\">String str = &quot;a,b,c,,&quot;;\nString[] ary = str.split(&quot;,&quot;);\n// 预期大于 3，结果是 3 \nSystem.out.println(ary.length);\n</code></pre>\n<p>19.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便 于阅读。</p>\n<p>20.类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter 方法。</p>\n<p>21.在getter&#x2F;setter 方法中，不要增加业务逻辑，增加排查问题的难度。</p>\n<p>22.循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p>\n<p>2.相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。 </p>\n<blockquote>\n<p>说明:可变参数必须放置在参数列表的最后。(提倡同学们尽量不用可变参数编程)</p>\n</blockquote>\n<p>3.外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生 影响。</p>\n<blockquote>\n<p>接口过时必须加@Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。</p>\n</blockquote>\n<p>4.Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 </p>\n<pre><code class=\"java\">正例:&quot;test&quot;.equals(object);\n反例:object.equals(&quot;test&quot;);\n</code></pre>\n<blockquote>\n<p>说明:推荐使用 java.util.Objects#equals(JDK7 引入的工具类)。</p>\n</blockquote>\n<p>5.所有整型包装类对象之间值的比较，全部使用equals方法比较。</p>\n<p>6.任何货币金额，均以最小货币单位且整型类型来进行存储。</p>\n<p><strong>7.浮点数之间的等值判断，基本数据类型不能用&#x3D;&#x3D;来比较，包装数据类型不能用 equals 来判断。</strong></p>\n<p>反例：</p>\n<pre><code class=\"java\">float a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nif (a == b) &#123;\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 a==b 的结果为 false\n&#125;\nFloat x = Float.valueOf(a);\nFloat y = Float.valueOf(b);\nif (x.equals(y)) &#123;\n// 预期进入此代码块，执行其它业务逻辑\n// 但事实上 equals 的结果为 false\n&#125;\n</code></pre>\n<p>正例：</p>\n<pre><code class=\"java\">//(1) 指定一个误差范围，两个浮点数的差值在此范围之内，则认为是相等的。\nfloat a = 1.0F - 0.9F;\nfloat b = 0.9F - 0.8F;\nfloat diff = 1e-6F;\nif (Math.abs(a - b) &lt; diff) &#123;\n    System.out.println(&quot;true&quot;);\n&#125;\n//(2) 使用 BigDecimal 来定义值，再进行浮点数的运算操作。\nBigDecimal a = new BigDecimal(&quot;1.0&quot;);\nBigDecimal b = new BigDecimal(&quot;0.9&quot;);\nBigDecimal c = new BigDecimal(&quot;0.8&quot;);\nBigDecimal x = a.subtract(b);\nBigDecimal y = b.subtract(c);\nif (x.equals(y)) &#123;\n  System.out.println(&quot;true&quot;);\n&#125;\n</code></pre>\n<p>8.定义数据对象 DO 类时，属性类型要与数据库字段类型相匹配。</p>\n<blockquote>\n<p>正例:数据库字段的 bigint 必须与类属性的 Long 类型相对应。</p>\n<p>反例:某个案例的数据库表 id 字段定义类型 bigint unsigned，实际类对象属性为 Integer，随着 id 越来 越大，超过 Integer 的表示范围而溢出成为负数。</p>\n</blockquote>\n<p>9.禁止使用构造方法 <code>BigDecimal(double)</code>的方式把 double 值转化为 BigDecimal 对象。 </p>\n<blockquote>\n<p>说明:BigDecimal(double)存在精度损失风险，在精确计算或值比较的场景中可能会导致业务逻辑异常。</p>\n<p>正例:优先推荐入参为 String 的构造方法，或使用 BigDecimal 的 valueOf 方法，此方法内部其实执行了</p>\n</blockquote>\n<pre><code class=\"java\"> BigDecimal recommend1 = new BigDecimal(&quot;0.1&quot;);\n BigDecimal recommend2 = BigDecimal.valueOf(0.1);\n</code></pre>\n<p>10.所有的 POJO 类属性必须使用包装数据类型。</p>\n<blockquote>\n<p>正例:数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。 </p>\n</blockquote>\n<p>11.RPC 方法的返回值和参数必须使用包装数据类型。 </p>\n<blockquote>\n<p>包装数据类型 的 null 值，能够表示额外的信息，如:远程调用失败，异常退出。</p>\n</blockquote>\n<p>12.所有的局部变量使用基本数据类型。</p>\n<p>13.定义 DO&#x2F;DTO&#x2F;VO 等 POJO 类时，不要设定任何属性默认值。</p>\n<p>14.序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败;</p>\n<p>如果 完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。</p>\n<blockquote>\n<p>说明:注意 serialVersionUID 不一致会抛出序列化运行时异常。</p>\n</blockquote>\n<p>15.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。</p>\n<p>16.POJO 类必须写 toString 方法。</p>\n<blockquote>\n<p>说明:在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。</p>\n</blockquote>\n<p>17.POJO类中禁止存在对应属性xxx的isXxx()和getXxx()方法。</p>\n<blockquote>\n<p>框架在调用属性xxx的提取方法时，并不能确定哪个方法一定是被优先调用到。</p>\n</blockquote>\n<p>18.使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有IndexOutOfBoundsException 的风险。</p>\n<pre><code class=\"java\">String str = &quot;a,b,c,,&quot;;\nString[] ary = str.split(&quot;,&quot;);\n// 预期大于 3，结果是 3 \nSystem.out.println(ary.length);\n</code></pre>\n<p>19.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便 于阅读。</p>\n<p>20.类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter &#x2F; setter 方法。</p>\n<p>21.在getter&#x2F;setter 方法中，不要增加业务逻辑，增加排查问题的难度。</p>\n<p>22.循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。</p>\n"},{"title":"命名风格","_content":"\n1.代码中的命名均不能以下划线或美元符号开始，也不能以 **下划线或美元符号** 结束。\n\n2.所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。\n\n3.类名使用 UpperCamelCase 风格，但这些例外：DO / BO / DTO / VO / AO / PO / UID 等。\n\n```\n正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion\n反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion\n```\n\n4.方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。\n\n```\n正例： localValue / getHttpMessage() / inputUserId\n```\n\n5.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n\n```\n正例： MAX_STOCK_COUNT / CACHE_EXPIRED_TIME\n反例： MAX_COUNT / EXPIRED_TIME\n```\n\n6.抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。\n\n7.POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n\n> 定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时候，误以为对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。\n\n8.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n\n> 正例： 应 用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）\n\n9.避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。\n\n10.在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。\n\n```\n正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT\n反例： startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD\n```\n\n11.如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n\n```java\n正例： public class OrderFactory;\npublic class LoginProxy;\npublic class ResourceObserver;\n```\n\n12.接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。\n\n尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。\n\n```java\n正例： 接口方法签名 void commit();\n接口基础常量 String COMPANY = \"alibaba\";\n反例： 接口方法定义 public abstract void f();\n```\n\n16.接口和实现类的命名有两套规则：\n\n对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。\n\n> 正例： CacheServiceImpl 实现 CacheService 接口。\n\n如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。\n\n> 正例： AbstractTranslator 实现 Translatable 接口。\n\n17.枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n\n> 说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n\n> 正例： 枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。\n\n18.各层命名规约：\n\nService/DAO 层方法命名规约：\n\n* 获取单个对象的方法用 get 做前缀。\n\n* 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。\n\n* 获取统计值的方法用 count 做前缀。\n\n* 插入的方法用 save/insert 做前缀。\n\n* 删除的方法用 remove/delete 做前缀。\n\n* 修改的方法用 update 做前缀。\n\n领域模型命名规约：\n\n* 数据对象：xxxDO，xxx 即为数据表名。\n\n* 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n\n* 展示对象：xxxVO，xxx 一般为网页名称。\n\n* POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n\n\n\n","source":"_posts/阿里Java开发手册/编程规约/命名风格.md","raw":"---\ntitle: 命名风格\ncategories: \n- 阿里Java开发手册\n- 编程规约\n---\n\n1.代码中的命名均不能以下划线或美元符号开始，也不能以 **下划线或美元符号** 结束。\n\n2.所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。\n\n3.类名使用 UpperCamelCase 风格，但这些例外：DO / BO / DTO / VO / AO / PO / UID 等。\n\n```\n正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion\n反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion\n```\n\n4.方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。\n\n```\n正例： localValue / getHttpMessage() / inputUserId\n```\n\n5.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。\n\n```\n正例： MAX_STOCK_COUNT / CACHE_EXPIRED_TIME\n反例： MAX_COUNT / EXPIRED_TIME\n```\n\n6.抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。\n\n7.POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n\n> 定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时候，误以为对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。\n\n8.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。\n\n> 正例： 应 用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）\n\n9.避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。\n\n10.在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。\n\n```\n正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT\n反例： startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD\n```\n\n11.如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n\n```java\n正例： public class OrderFactory;\npublic class LoginProxy;\npublic class ResourceObserver;\n```\n\n12.接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。\n\n尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。\n\n```java\n正例： 接口方法签名 void commit();\n接口基础常量 String COMPANY = \"alibaba\";\n反例： 接口方法定义 public abstract void f();\n```\n\n16.接口和实现类的命名有两套规则：\n\n对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。\n\n> 正例： CacheServiceImpl 实现 CacheService 接口。\n\n如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。\n\n> 正例： AbstractTranslator 实现 Translatable 接口。\n\n17.枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。\n\n> 说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。\n\n> 正例： 枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS / UNKNOWN_REASON。\n\n18.各层命名规约：\n\nService/DAO 层方法命名规约：\n\n* 获取单个对象的方法用 get 做前缀。\n\n* 获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。\n\n* 获取统计值的方法用 count 做前缀。\n\n* 插入的方法用 save/insert 做前缀。\n\n* 删除的方法用 remove/delete 做前缀。\n\n* 修改的方法用 update 做前缀。\n\n领域模型命名规约：\n\n* 数据对象：xxxDO，xxx 即为数据表名。\n\n* 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。\n\n* 展示对象：xxxVO，xxx 一般为网页名称。\n\n* POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。\n\n\n\n","slug":"阿里Java开发手册/编程规约/命名风格","published":1,"date":"2022-03-15T01:59:20.723Z","updated":"2022-03-15T02:03:35.731Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwlj00nifhji7gkd8tvg","content":"<p>1.代码中的命名均不能以下划线或美元符号开始，也不能以 <strong>下划线或美元符号</strong> 结束。</p>\n<p>2.所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p>\n<p>3.类名使用 UpperCamelCase 风格，但这些例外：DO &#x2F; BO &#x2F; DTO &#x2F; VO &#x2F; AO &#x2F; PO &#x2F; UID 等。</p>\n<pre><code>正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion\n反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion\n</code></pre>\n<p>4.方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。</p>\n<pre><code>正例： localValue / getHttpMessage() / inputUserId\n</code></pre>\n<p>5.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p>\n<pre><code>正例： MAX_STOCK_COUNT / CACHE_EXPIRED_TIME\n反例： MAX_COUNT / EXPIRED_TIME\n</code></pre>\n<p>6.抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p>\n<p>7.POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p>\n<blockquote>\n<p>定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时候，误以为对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p>\n</blockquote>\n<p>8.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</p>\n<blockquote>\n<p>正例： 应 用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</p>\n</blockquote>\n<p>9.避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。</p>\n<p>10.在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p>\n<pre><code>正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT\n反例： startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD\n</code></pre>\n<p>11.如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>\n<pre><code class=\"java\">正例： public class OrderFactory;\npublic class LoginProxy;\npublic class ResourceObserver;\n</code></pre>\n<p>12.接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。</p>\n<p>尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。</p>\n<pre><code class=\"java\">正例： 接口方法签名 void commit();\n接口基础常量 String COMPANY = &quot;alibaba&quot;;\n反例： 接口方法定义 public abstract void f();\n</code></pre>\n<p>16.接口和实现类的命名有两套规则：</p>\n<p>对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。</p>\n<blockquote>\n<p>正例： CacheServiceImpl 实现 CacheService 接口。</p>\n</blockquote>\n<p>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。</p>\n<blockquote>\n<p>正例： AbstractTranslator 实现 Translatable 接口。</p>\n</blockquote>\n<p>17.枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p>\n<blockquote>\n<p>说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p>\n</blockquote>\n<blockquote>\n<p>正例： 枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS &#x2F; UNKNOWN_REASON。</p>\n</blockquote>\n<p>18.各层命名规约：</p>\n<p>Service&#x2F;DAO 层方法命名规约：</p>\n<ul>\n<li><p>获取单个对象的方法用 get 做前缀。</p>\n</li>\n<li><p>获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。</p>\n</li>\n<li><p>获取统计值的方法用 count 做前缀。</p>\n</li>\n<li><p>插入的方法用 save&#x2F;insert 做前缀。</p>\n</li>\n<li><p>删除的方法用 remove&#x2F;delete 做前缀。</p>\n</li>\n<li><p>修改的方法用 update 做前缀。</p>\n</li>\n</ul>\n<p>领域模型命名规约：</p>\n<ul>\n<li><p>数据对象：xxxDO，xxx 即为数据表名。</p>\n</li>\n<li><p>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p>\n</li>\n<li><p>展示对象：xxxVO，xxx 一般为网页名称。</p>\n</li>\n<li><p>POJO 是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称，禁止命名成 xxxPOJO。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>1.代码中的命名均不能以下划线或美元符号开始，也不能以 <strong>下划线或美元符号</strong> 结束。</p>\n<p>2.所有编程相关的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p>\n<p>3.类名使用 UpperCamelCase 风格，但这些例外：DO &#x2F; BO &#x2F; DTO &#x2F; VO &#x2F; AO &#x2F; PO &#x2F; UID 等。</p>\n<pre><code>正例： ForceCode / UserDO / HtmlDTO / XmlService / TcpUdpDeal / TaPromotion\n反例： forcecode / UserDo / HTMLDto / XMLService / TCPUDPDeal / TAPromotion\n</code></pre>\n<p>4.方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格。</p>\n<pre><code>正例： localValue / getHttpMessage() / inputUserId\n</code></pre>\n<p>5.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p>\n<pre><code>正例： MAX_STOCK_COUNT / CACHE_EXPIRED_TIME\n反例： MAX_COUNT / EXPIRED_TIME\n</code></pre>\n<p>6.抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。</p>\n<p>7.POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p>\n<blockquote>\n<p>定义为基本数据类型 Boolean isDeleted 的属性，它的方法也是 isDeleted()，框架在反向解析的时候，误以为对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。</p>\n</blockquote>\n<p>8.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词，包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</p>\n<blockquote>\n<p>正例： 应 用工具类包名为 com.alibaba.ei.kunlun.aap.util、类名为 MessageUtils（此规则参考 spring 的框架结构）</p>\n</blockquote>\n<p>9.避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。</p>\n<p>10.在常量与变量的命名时，表示类型的名词放在词尾，以提升辨识度。</p>\n<pre><code>正例： startTime / workQueue / nameList / TERMINATED_THREAD_COUNT\n反例： startedAt / QueueOfWork / listName / COUNT_TERMINATED_THREAD\n</code></pre>\n<p>11.如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>\n<pre><code class=\"java\">正例： public class OrderFactory;\npublic class LoginProxy;\npublic class ResourceObserver;\n</code></pre>\n<p>12.接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。</p>\n<p>尽量不要在接口里定义变量，如果一定要定义变量，确定与接口方法相关，并且是整个应用的基础常量。</p>\n<pre><code class=\"java\">正例： 接口方法签名 void commit();\n接口基础常量 String COMPANY = &quot;alibaba&quot;;\n反例： 接口方法定义 public abstract void f();\n</code></pre>\n<p>16.接口和实现类的命名有两套规则：</p>\n<p>对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用Impl 的后缀与接口区别。</p>\n<blockquote>\n<p>正例： CacheServiceImpl 实现 CacheService 接口。</p>\n</blockquote>\n<p>如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able 的形容词）。</p>\n<blockquote>\n<p>正例： AbstractTranslator 实现 Translatable 接口。</p>\n</blockquote>\n<p>17.枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。</p>\n<blockquote>\n<p>说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。</p>\n</blockquote>\n<blockquote>\n<p>正例： 枚举名字为 ProcessStatusEnum 的成员名称：SUCCESS &#x2F; UNKNOWN_REASON。</p>\n</blockquote>\n<p>18.各层命名规约：</p>\n<p>Service&#x2F;DAO 层方法命名规约：</p>\n<ul>\n<li><p>获取单个对象的方法用 get 做前缀。</p>\n</li>\n<li><p>获取多个对象的方法用 list 做前缀，复数结尾，如：listObjects。</p>\n</li>\n<li><p>获取统计值的方法用 count 做前缀。</p>\n</li>\n<li><p>插入的方法用 save&#x2F;insert 做前缀。</p>\n</li>\n<li><p>删除的方法用 remove&#x2F;delete 做前缀。</p>\n</li>\n<li><p>修改的方法用 update 做前缀。</p>\n</li>\n</ul>\n<p>领域模型命名规约：</p>\n<ul>\n<li><p>数据对象：xxxDO，xxx 即为数据表名。</p>\n</li>\n<li><p>数据传输对象：xxxDTO，xxx 为业务领域相关的名称。</p>\n</li>\n<li><p>展示对象：xxxVO，xxx 一般为网页名称。</p>\n</li>\n<li><p>POJO 是 DO&#x2F;DTO&#x2F;BO&#x2F;VO 的统称，禁止命名成 xxxPOJO。</p>\n</li>\n</ul>\n"},{"title":"常量定义","_content":"\n1.不允许任何魔法值 （ 即未经预先定义的常量 ） 直接出现在代码中。\n\n2.在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字混淆，造成误解。\n\n> 说明： Long a = 2l; 写的是数字的 21，还是 Long 型的 2。\n\n3.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。\n\n> 正例： 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。\n\n4.常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。\n\n* 跨应用共享常量：放置在二方库中，通常是 `client.jar` 中的 constant 目录下。\n\n* 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。\n\n* 子工程内部共享常量：即在当前子工程的 constant 目录下。\n\n* 包内共享常量：即在当前包下单独的 constant 目录下。\n\n* 类内共享常量：直接在类内部 private static final 定义。\n\n5.如果变量值仅在一个固定范围内变化用 enum 类型来定义。","source":"_posts/阿里Java开发手册/编程规约/常量定义.md","raw":"---\ntitle: 常量定义\ncategories: \n- 阿里Java开发手册\n- 编程规约\n---\n\n1.不允许任何魔法值 （ 即未经预先定义的常量 ） 直接出现在代码中。\n\n2.在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字混淆，造成误解。\n\n> 说明： Long a = 2l; 写的是数字的 21，还是 Long 型的 2。\n\n3.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。\n\n> 正例： 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。\n\n4.常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。\n\n* 跨应用共享常量：放置在二方库中，通常是 `client.jar` 中的 constant 目录下。\n\n* 应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。\n\n* 子工程内部共享常量：即在当前子工程的 constant 目录下。\n\n* 包内共享常量：即在当前包下单独的 constant 目录下。\n\n* 类内共享常量：直接在类内部 private static final 定义。\n\n5.如果变量值仅在一个固定范围内变化用 enum 类型来定义。","slug":"阿里Java开发手册/编程规约/常量定义","published":1,"date":"2022-03-15T05:29:58.028Z","updated":"2022-03-15T05:30:27.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwlk00njfhjifc1120f0","content":"<p>1.不允许任何魔法值 （ 即未经预先定义的常量 ） 直接出现在代码中。</p>\n<p>2.在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字混淆，造成误解。</p>\n<blockquote>\n<p>说明： Long a &#x3D; 2l; 写的是数字的 21，还是 Long 型的 2。</p>\n</blockquote>\n<p>3.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p>\n<blockquote>\n<p>正例： 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。</p>\n</blockquote>\n<p>4.常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p>\n<ul>\n<li><p>跨应用共享常量：放置在二方库中，通常是 <code>client.jar</code> 中的 constant 目录下。</p>\n</li>\n<li><p>应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。</p>\n</li>\n<li><p>子工程内部共享常量：即在当前子工程的 constant 目录下。</p>\n</li>\n<li><p>包内共享常量：即在当前包下单独的 constant 目录下。</p>\n</li>\n<li><p>类内共享常量：直接在类内部 private static final 定义。</p>\n</li>\n</ul>\n<p>5.如果变量值仅在一个固定范围内变化用 enum 类型来定义。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.不允许任何魔法值 （ 即未经预先定义的常量 ） 直接出现在代码中。</p>\n<p>2.在 long 或者 Long 赋值时，数值后使用大写的 L，不能是小写的 l，小写容易跟数字混淆，造成误解。</p>\n<blockquote>\n<p>说明： Long a &#x3D; 2l; 写的是数字的 21，还是 Long 型的 2。</p>\n</blockquote>\n<p>3.不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p>\n<blockquote>\n<p>正例： 缓存相关常量放在类 CacheConsts 下；系统配置相关常量放在类 ConfigConsts 下。</p>\n</blockquote>\n<p>4.常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。</p>\n<ul>\n<li><p>跨应用共享常量：放置在二方库中，通常是 <code>client.jar</code> 中的 constant 目录下。</p>\n</li>\n<li><p>应用内共享常量：放置在一方库中，通常是子模块中的 constant 目录下。</p>\n</li>\n<li><p>子工程内部共享常量：即在当前子工程的 constant 目录下。</p>\n</li>\n<li><p>包内共享常量：即在当前包下单独的 constant 目录下。</p>\n</li>\n<li><p>类内共享常量：直接在类内部 private static final 定义。</p>\n</li>\n</ul>\n<p>5.如果变量值仅在一个固定范围内变化用 enum 类型来定义。</p>\n"},{"title":"并发处理","_content":"\n1.获取单例对象需要保证线程安全，其中的方法也要保证线程安全。\n\n> 说明：资源驱动类、工具类、单例工厂类都需要注意。\n\n2.创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。\n\n> 正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给whatFeatureOfGroup\n\n```java\npublic class UserThreadFactory implements ThreadFactory {\n   private final String namePrefix;\n   private final AtomicInteger nextId = new AtomicInteger(1);\n  // 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助\n   UserThreadFactory(String whatFeatureOfGroup) {\n    namePrefix = \"From UserThreadFactory's \" + whatFeatureOfGroup + \"-Worker-\";\n }\n @Override\n public Thread newThread(Runnable task) {\n    String name = namePrefix + nextId.getAndIncrement();\n    Thread thread = new Thread(null, task, name, 0, false);\n    System.out.println(thread.getName());\n    return thread;\n }\n}\n```\n\n3.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n\n> 如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题。\n\n4.线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n> FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n>\n> CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n5.SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。\n\n> 正例：注意线程安全，使用 DateUtils。亦推荐如下处理：\n\n```java\nprivate static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {\n @Override\n protected DateFormat initialValue() {\n return new SimpleDateFormat(\"yyyy-MM-dd\");\n }\n};\n```\n\n> 说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替SimpleDateFormat。\n\n6.必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。\n\n正例：\n\n```java\nobjectThreadLocal.set(userInfo);\ntry {\n // ...\n} finally {\n objectThreadLocal.remove();\n}\n```\n\n7.高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。\n\n> 说明：尽可能使加锁的代码块工作量尽可能的小，**避免在锁代码块中调用 RPC 方法**。\n\n8.对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。\n\n> 说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。\n\n9.在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。\n\n> 说明一：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。\n>\n> 说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock对未加锁的对象解锁，它会调用 AQS 的tryRelease 方法（取决于具体实现类），抛出IllegalMonitorStateException 异常。\n>\n> 说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。\n\n```java\n正例：\nLock lock = new XxxLock();\n// ...\nlock.lock();\ntry {\n doSomething();\n doOthers();\n} finally {\n lock.unlock();\n}\n反例：\nLock lock = new XxxLock();\ntry {\n // 如果此处抛出异常，则直接执行 finally 代码块\n doSomething();\n // 无论加锁是否成功，finally 代码块都会执行\n lock.lock();\n doOthers();\n} finally {\n lock.unlock();\n}\n```\n\n10.在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。\n\n> 说明：Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 IllegalMonitorStateException 异常。\n\n```java\n正例：\nLock lock = new XxxLock();\n// ...\nboolean isLocked = lock.tryLock();\nif (isLocked) {\n try {\n doSomething();\n doOthers();\n } finally {\n lock.unlock();\n }\n}\n```\n\n11.并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。\n\n> 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次。\n\n12.多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。\n\n13.资金相关的金融敏感信息，使用悲观锁策略。\n\n> 说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。\n\n> 正例：悲观锁遵循一锁、二判、三更新、四释放的原则。\n\n14.使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至await 方法，直到超时才返回结果。\n\n15.避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。\n\n> 说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。\n>\n> 正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个单独的 Random 实例。\n\n16.volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。\n\n> 说明：如果是 count++操作，使用如下类实现：\n\n```java\nAtomicInteger count = new AtomicInteger();\ncount.addAndGet(1); \n```\n\n> 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。\n\n17.HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。\n\n18.ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。\n\n> 说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。","source":"_posts/阿里Java开发手册/编程规约/并发处理.md","raw":"---\ntitle: 并发处理\ncategories: \n- 阿里Java开发手册\n- 编程规约\n---\n\n1.获取单例对象需要保证线程安全，其中的方法也要保证线程安全。\n\n> 说明：资源驱动类、工具类、单例工厂类都需要注意。\n\n2.创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。\n\n> 正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给whatFeatureOfGroup\n\n```java\npublic class UserThreadFactory implements ThreadFactory {\n   private final String namePrefix;\n   private final AtomicInteger nextId = new AtomicInteger(1);\n  // 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助\n   UserThreadFactory(String whatFeatureOfGroup) {\n    namePrefix = \"From UserThreadFactory's \" + whatFeatureOfGroup + \"-Worker-\";\n }\n @Override\n public Thread newThread(Runnable task) {\n    String name = namePrefix + nextId.getAndIncrement();\n    Thread thread = new Thread(null, task, name, 0, false);\n    System.out.println(thread.getName());\n    return thread;\n }\n}\n```\n\n3.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。\n\n> 如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题。\n\n4.线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。\n\n> FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。\n>\n> CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。\n\n5.SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。\n\n> 正例：注意线程安全，使用 DateUtils。亦推荐如下处理：\n\n```java\nprivate static final ThreadLocal<DateFormat> df = new ThreadLocal<DateFormat>() {\n @Override\n protected DateFormat initialValue() {\n return new SimpleDateFormat(\"yyyy-MM-dd\");\n }\n};\n```\n\n> 说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替SimpleDateFormat。\n\n6.必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。\n\n正例：\n\n```java\nobjectThreadLocal.set(userInfo);\ntry {\n // ...\n} finally {\n objectThreadLocal.remove();\n}\n```\n\n7.高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。\n\n> 说明：尽可能使加锁的代码块工作量尽可能的小，**避免在锁代码块中调用 RPC 方法**。\n\n8.对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。\n\n> 说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。\n\n9.在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。\n\n> 说明一：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。\n>\n> 说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock对未加锁的对象解锁，它会调用 AQS 的tryRelease 方法（取决于具体实现类），抛出IllegalMonitorStateException 异常。\n>\n> 说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。\n\n```java\n正例：\nLock lock = new XxxLock();\n// ...\nlock.lock();\ntry {\n doSomething();\n doOthers();\n} finally {\n lock.unlock();\n}\n反例：\nLock lock = new XxxLock();\ntry {\n // 如果此处抛出异常，则直接执行 finally 代码块\n doSomething();\n // 无论加锁是否成功，finally 代码块都会执行\n lock.lock();\n doOthers();\n} finally {\n lock.unlock();\n}\n```\n\n10.在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。\n\n> 说明：Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 IllegalMonitorStateException 异常。\n\n```java\n正例：\nLock lock = new XxxLock();\n// ...\nboolean isLocked = lock.tryLock();\nif (isLocked) {\n try {\n doSomething();\n doOthers();\n } finally {\n lock.unlock();\n }\n}\n```\n\n11.并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。\n\n> 说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次。\n\n12.多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。\n\n13.资金相关的金融敏感信息，使用悲观锁策略。\n\n> 说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。\n\n> 正例：悲观锁遵循一锁、二判、三更新、四释放的原则。\n\n14.使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至await 方法，直到超时才返回结果。\n\n15.避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。\n\n> 说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。\n>\n> 正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个单独的 Random 实例。\n\n16.volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。\n\n> 说明：如果是 count++操作，使用如下类实现：\n\n```java\nAtomicInteger count = new AtomicInteger();\ncount.addAndGet(1); \n```\n\n> 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。\n\n17.HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。\n\n18.ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。\n\n> 说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。","slug":"阿里Java开发手册/编程规约/并发处理","published":1,"date":"2022-03-16T01:19:02.169Z","updated":"2022-03-16T01:41:24.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwlk00nmfhji54rjbqnv","content":"<p>1.获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p>\n<blockquote>\n<p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p>\n</blockquote>\n<p>2.创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p>\n<blockquote>\n<p>正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给whatFeatureOfGroup</p>\n</blockquote>\n<pre><code class=\"java\">public class UserThreadFactory implements ThreadFactory &#123;\n   private final String namePrefix;\n   private final AtomicInteger nextId = new AtomicInteger(1);\n  // 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助\n   UserThreadFactory(String whatFeatureOfGroup) &#123;\n    namePrefix = &quot;From UserThreadFactory&#39;s &quot; + whatFeatureOfGroup + &quot;-Worker-&quot;;\n &#125;\n @Override\n public Thread newThread(Runnable task) &#123;\n    String name = namePrefix + nextId.getAndIncrement();\n    Thread thread = new Thread(null, task, name, 0, false);\n    System.out.println(thread.getName());\n    return thread;\n &#125;\n&#125;\n</code></pre>\n<p>3.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>\n<blockquote>\n<p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题。</p>\n</blockquote>\n<p>4.线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>\n<blockquote>\n<p>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p>\n<p>CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>\n</blockquote>\n<p>5.SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</p>\n<blockquote>\n<p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：</p>\n</blockquote>\n<pre><code class=\"java\">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123;\n @Override\n protected DateFormat initialValue() &#123;\n return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\n &#125;\n&#125;;\n</code></pre>\n<blockquote>\n<p>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替SimpleDateFormat。</p>\n</blockquote>\n<p>6.必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。</p>\n<p>正例：</p>\n<pre><code class=\"java\">objectThreadLocal.set(userInfo);\ntry &#123;\n // ...\n&#125; finally &#123;\n objectThreadLocal.remove();\n&#125;\n</code></pre>\n<p>7.高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p>\n<blockquote>\n<p>说明：尽可能使加锁的代码块工作量尽可能的小，<strong>避免在锁代码块中调用 RPC 方法</strong>。</p>\n</blockquote>\n<p>8.对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p>\n<blockquote>\n<p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。</p>\n</blockquote>\n<p>9.在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</p>\n<blockquote>\n<p>说明一：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。</p>\n<p>说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock对未加锁的对象解锁，它会调用 AQS 的tryRelease 方法（取决于具体实现类），抛出IllegalMonitorStateException 异常。</p>\n<p>说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。</p>\n</blockquote>\n<pre><code class=\"java\">正例：\nLock lock = new XxxLock();\n// ...\nlock.lock();\ntry &#123;\n doSomething();\n doOthers();\n&#125; finally &#123;\n lock.unlock();\n&#125;\n反例：\nLock lock = new XxxLock();\ntry &#123;\n // 如果此处抛出异常，则直接执行 finally 代码块\n doSomething();\n // 无论加锁是否成功，finally 代码块都会执行\n lock.lock();\n doOthers();\n&#125; finally &#123;\n lock.unlock();\n&#125;\n</code></pre>\n<p>10.在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。</p>\n<blockquote>\n<p>说明：Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 IllegalMonitorStateException 异常。</p>\n</blockquote>\n<pre><code class=\"java\">正例：\nLock lock = new XxxLock();\n// ...\nboolean isLocked = lock.tryLock();\nif (isLocked) &#123;\n try &#123;\n doSomething();\n doOthers();\n &#125; finally &#123;\n lock.unlock();\n &#125;\n&#125;\n</code></pre>\n<p>11.并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</p>\n<blockquote>\n<p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次。</p>\n</blockquote>\n<p>12.多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</p>\n<p>13.资金相关的金融敏感信息，使用悲观锁策略。</p>\n<blockquote>\n<p>说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</p>\n</blockquote>\n<blockquote>\n<p>正例：悲观锁遵循一锁、二判、三更新、四释放的原则。</p>\n</blockquote>\n<p>14.使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至await 方法，直到超时才返回结果。</p>\n<p>15.避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。</p>\n<blockquote>\n<p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。</p>\n<p>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个单独的 Random 实例。</p>\n</blockquote>\n<p>16.volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</p>\n<blockquote>\n<p>说明：如果是 count++操作，使用如下类实现：</p>\n</blockquote>\n<pre><code class=\"java\">AtomicInteger count = new AtomicInteger();\ncount.addAndGet(1); \n</code></pre>\n<blockquote>\n<p>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p>\n</blockquote>\n<p>17.HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</p>\n<p>18.ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。</p>\n<blockquote>\n<p>说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>1.获取单例对象需要保证线程安全，其中的方法也要保证线程安全。</p>\n<blockquote>\n<p>说明：资源驱动类、工具类、单例工厂类都需要注意。</p>\n</blockquote>\n<p>2.创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。</p>\n<blockquote>\n<p>正例：自定义线程工厂，并且根据外部特征进行分组，比如，来自同一机房的调用，把机房编号赋值给whatFeatureOfGroup</p>\n</blockquote>\n<pre><code class=\"java\">public class UserThreadFactory implements ThreadFactory &#123;\n   private final String namePrefix;\n   private final AtomicInteger nextId = new AtomicInteger(1);\n  // 定义线程组名称，在利用 jstack 来排查问题时，非常有帮助\n   UserThreadFactory(String whatFeatureOfGroup) &#123;\n    namePrefix = &quot;From UserThreadFactory&#39;s &quot; + whatFeatureOfGroup + &quot;-Worker-&quot;;\n &#125;\n @Override\n public Thread newThread(Runnable task) &#123;\n    String name = namePrefix + nextId.getAndIncrement();\n    Thread thread = new Thread(null, task, name, 0, false);\n    System.out.println(thread.getName());\n    return thread;\n &#125;\n&#125;\n</code></pre>\n<p>3.线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。</p>\n<blockquote>\n<p>如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过度切换的问题。</p>\n</blockquote>\n<p>4.线程池不允许使用 Executors 去创建，而是通过ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p>\n<blockquote>\n<p>FixedThreadPool 和 SingleThreadPool：允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p>\n<p>CachedThreadPool：允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p>\n</blockquote>\n<p>5.SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。</p>\n<blockquote>\n<p>正例：注意线程安全，使用 DateUtils。亦推荐如下处理：</p>\n</blockquote>\n<pre><code class=\"java\">private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() &#123;\n @Override\n protected DateFormat initialValue() &#123;\n return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);\n &#125;\n&#125;;\n</code></pre>\n<blockquote>\n<p>说明：如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替SimpleDateFormat。</p>\n</blockquote>\n<p>6.必须回收自定义的 ThreadLocal 变量，尤其在线程池场景下，线程经常会被复用，如果不清理自定义的 ThreadLocal 变量，可能会影响后续业务逻辑和造成内存泄露等问题。尽量在代理中使用 try-finally 块进行回收。</p>\n<p>正例：</p>\n<pre><code class=\"java\">objectThreadLocal.set(userInfo);\ntry &#123;\n // ...\n&#125; finally &#123;\n objectThreadLocal.remove();\n&#125;\n</code></pre>\n<p>7.高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p>\n<blockquote>\n<p>说明：尽可能使加锁的代码块工作量尽可能的小，<strong>避免在锁代码块中调用 RPC 方法</strong>。</p>\n</blockquote>\n<p>8.对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。</p>\n<blockquote>\n<p>说明：线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。</p>\n</blockquote>\n<p>9.在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。</p>\n<blockquote>\n<p>说明一：如果在 lock 方法与 try 代码块之间的方法调用抛出异常，那么无法解锁，造成其它线程无法成功获取锁。</p>\n<p>说明二：如果 lock 方法在 try 代码块之内，可能由于其它方法抛出异常，导致在 finally 代码块中，unlock对未加锁的对象解锁，它会调用 AQS 的tryRelease 方法（取决于具体实现类），抛出IllegalMonitorStateException 异常。</p>\n<p>说明三：在 Lock 对象的 lock 方法实现中可能抛出 unchecked 异常，产生的后果与说明二相同。</p>\n</blockquote>\n<pre><code class=\"java\">正例：\nLock lock = new XxxLock();\n// ...\nlock.lock();\ntry &#123;\n doSomething();\n doOthers();\n&#125; finally &#123;\n lock.unlock();\n&#125;\n反例：\nLock lock = new XxxLock();\ntry &#123;\n // 如果此处抛出异常，则直接执行 finally 代码块\n doSomething();\n // 无论加锁是否成功，finally 代码块都会执行\n lock.lock();\n doOthers();\n&#125; finally &#123;\n lock.unlock();\n&#125;\n</code></pre>\n<p>10.在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。</p>\n<blockquote>\n<p>说明：Lock 对象的 unlock 方法在执行时，它会调用 AQS 的 tryRelease 方法（取决于具体实现类），如果当前线程不持有锁，则抛出 IllegalMonitorStateException 异常。</p>\n</blockquote>\n<pre><code class=\"java\">正例：\nLock lock = new XxxLock();\n// ...\nboolean isLocked = lock.tryLock();\nif (isLocked) &#123;\n try &#123;\n doSomething();\n doOthers();\n &#125; finally &#123;\n lock.unlock();\n &#125;\n&#125;\n</code></pre>\n<p>11.并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。</p>\n<blockquote>\n<p>说明：如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3 次。</p>\n</blockquote>\n<p>12.多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</p>\n<p>13.资金相关的金融敏感信息，使用悲观锁策略。</p>\n<blockquote>\n<p>说明：乐观锁在获得锁的同时已经完成了更新操作，校验逻辑容易出现漏洞，另外，乐观锁对冲突的解决策略有较复杂的要求，处理不当容易造成系统压力或数据异常，所以资金相关的金融敏感信息不建议使用乐观锁更新。</p>\n</blockquote>\n<blockquote>\n<p>正例：悲观锁遵循一锁、二判、三更新、四释放的原则。</p>\n</blockquote>\n<p>14.使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法被执行到，避免主线程无法执行至await 方法，直到超时才返回结果。</p>\n<p>15.避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed导致的性能下降。</p>\n<blockquote>\n<p>说明：Random 实例包括 java.util.Random 的实例或者 Math.random()的方式。</p>\n<p>正例：在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个单独的 Random 实例。</p>\n</blockquote>\n<p>16.volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。</p>\n<blockquote>\n<p>说明：如果是 count++操作，使用如下类实现：</p>\n</blockquote>\n<pre><code class=\"java\">AtomicInteger count = new AtomicInteger();\ncount.addAndGet(1); \n</code></pre>\n<blockquote>\n<p>如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。</p>\n</blockquote>\n<p>17.HashMap 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中注意规避此风险。</p>\n<p>18.ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。</p>\n<blockquote>\n<p>说明：这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p>\n</blockquote>\n"},{"title":"集合处理","_content":"\n1.关于hashCode和equals的处理，遵循如下规则:\n\n* 只要重写 equals，就必须重写 hashCode。\n\n* 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写 这两个方法。\n\n* 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。\n\n2.判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是`size()==0`的方式。\n\n> 说明:前者的时间复杂度为 O(1)，而且可读性更好。\n\n3.在使用 `java.util.stream.Collectors` 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为mergeFunction 的方法，否则当出现相同 key值时会抛出 IllegalStateException 异常。\n\n> 说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。\n\n正例：\n\n```java\nList<Pair<String, Double>> pairArrayList = new ArrayList<>(3);\npairArrayList.add(new Pair<>(\"version\", 12.10));\npairArrayList.add(new Pair<>(\"version\", 12.19));\npairArrayList.add(new Pair<>(\"version\", 6.28));\nMap<String, Double> map = pairArrayList.stream().collect(\n// 生成的 map 集合中只有一个键值对：{version=6.28}\nCollectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));\n\nMap<Integer, String> map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName,(oldValue, newValue) -> newValue));\n```\n\n反例：\n\n```java\nString[] departments = new String[] {\"iERP\", \"iERP\", \"EIBU\"};\n// 抛出 IllegalStateException 异常\nMap<Integer, String> map = Arrays.stream(departments)\n .collect(Collectors.toMap(String::hashCode, str -> str));\n```\n\n4.在使用 `java.util.stream.Collectors `类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。\n\n5.ArrayList 的 subList （截取一部分列表）结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常。\n\n> 说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于 SubList 的所有操作最终会反映到原列表上。\n\n6.使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行添加元素操作，否则会抛出UnsupportedOperationException 异常。\n\n7.Collections 类返回的对象，如：**emptyList()/singletonList()等都是 immutable list**，不可对其进行添加或者删除元素的操作。\n\n> 反例：如果查询无结果，返回 Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就会触发 UnsupportedOperationException 异常。\n\n8.在 subList 场景中，**高度注意对父集合元素**的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。\n\n9.使用集合转数组的方法，必须使用集合的` toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。\n\n> 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。\n\n正例：\n\n10.在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行NPE 判断。\n\n11.使用工具类 `Arrays.asList()`把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。\n\n> 说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。\n\nArrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n```java\n String[] str = new String[] { \"chen\", \"yang\", \"hao\" };\n List list = Arrays.asList(str);\n```\n\n- 第一种情况`：list.add(\"tianmaolin\");` 运行时异常。\n- 第二种情况：`str[0] = \"change\";` 也会随之修改，反之亦然。\n\n12.泛型通配符`<? extends T>`来接收返回的数据，此写法的泛型集合不能使用 add 方法，而`<? super T>`不能使用 get 方法，两者在接口调用赋值的场景中容易出错。\n\n14.不要在 foreach 循环里进行元素的 `remove/add` 操作。\n\nremove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。\n\n```java\n正例：\nList<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n String item = iterator.next();\n if (删除元素的条件) {\n \t\titerator.remove();\n }\n}\n\n反例：\nfor (String item : list) {\n if (\"1\".equals(item)) {\n \t\tlist.remove(item);\n }\n}\n```\n\n15.集合初始化时，指定集合初始值大小。\n\n> 说明：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。\n\n> 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。\n\n> 注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。\n\n16.使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。\n\n17.高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：\n\n![](https://img-blog.csdnimg.cn/619a4dc1039f4dfca3a7d1c81e001a76.png)\n\n18.利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains()进行遍历去重或者判断包含操作。","source":"_posts/阿里Java开发手册/编程规约/集合处理.md","raw":"---\ntitle: 集合处理\ncategories: \n- 阿里Java开发手册\n- 编程规约\n---\n\n1.关于hashCode和equals的处理，遵循如下规则:\n\n* 只要重写 equals，就必须重写 hashCode。\n\n* 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写 这两个方法。\n\n* 如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。\n\n2.判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是`size()==0`的方式。\n\n> 说明:前者的时间复杂度为 O(1)，而且可读性更好。\n\n3.在使用 `java.util.stream.Collectors` 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为mergeFunction 的方法，否则当出现相同 key值时会抛出 IllegalStateException 异常。\n\n> 说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。\n\n正例：\n\n```java\nList<Pair<String, Double>> pairArrayList = new ArrayList<>(3);\npairArrayList.add(new Pair<>(\"version\", 12.10));\npairArrayList.add(new Pair<>(\"version\", 12.19));\npairArrayList.add(new Pair<>(\"version\", 6.28));\nMap<String, Double> map = pairArrayList.stream().collect(\n// 生成的 map 集合中只有一个键值对：{version=6.28}\nCollectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -> v2));\n\nMap<Integer, String> map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName,(oldValue, newValue) -> newValue));\n```\n\n反例：\n\n```java\nString[] departments = new String[] {\"iERP\", \"iERP\", \"EIBU\"};\n// 抛出 IllegalStateException 异常\nMap<Integer, String> map = Arrays.stream(departments)\n .collect(Collectors.toMap(String::hashCode, str -> str));\n```\n\n4.在使用 `java.util.stream.Collectors `类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。\n\n5.ArrayList 的 subList （截取一部分列表）结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常。\n\n> 说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于 SubList 的所有操作最终会反映到原列表上。\n\n6.使用 Map 的方法 keySet()/values()/entrySet()返回集合对象时，不可以对其进行添加元素操作，否则会抛出UnsupportedOperationException 异常。\n\n7.Collections 类返回的对象，如：**emptyList()/singletonList()等都是 immutable list**，不可对其进行添加或者删除元素的操作。\n\n> 反例：如果查询无结果，返回 Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就会触发 UnsupportedOperationException 异常。\n\n8.在 subList 场景中，**高度注意对父集合元素**的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。\n\n9.使用集合转数组的方法，必须使用集合的` toArray(T[] array)`，传入的是类型完全一致、长度为 0 的空数组。\n\n> 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。\n\n正例：\n\n10.在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行NPE 判断。\n\n11.使用工具类 `Arrays.asList()`把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。\n\n> 说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。\n\nArrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。\n\n```java\n String[] str = new String[] { \"chen\", \"yang\", \"hao\" };\n List list = Arrays.asList(str);\n```\n\n- 第一种情况`：list.add(\"tianmaolin\");` 运行时异常。\n- 第二种情况：`str[0] = \"change\";` 也会随之修改，反之亦然。\n\n12.泛型通配符`<? extends T>`来接收返回的数据，此写法的泛型集合不能使用 add 方法，而`<? super T>`不能使用 get 方法，两者在接口调用赋值的场景中容易出错。\n\n14.不要在 foreach 循环里进行元素的 `remove/add` 操作。\n\nremove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。\n\n```java\n正例：\nList<String> list = new ArrayList<>();\nlist.add(\"1\");\nlist.add(\"2\");\nIterator<String> iterator = list.iterator();\nwhile (iterator.hasNext()) {\n String item = iterator.next();\n if (删除元素的条件) {\n \t\titerator.remove();\n }\n}\n\n反例：\nfor (String item : list) {\n if (\"1\".equals(item)) {\n \t\tlist.remove(item);\n }\n}\n```\n\n15.集合初始化时，指定集合初始值大小。\n\n> 说明：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。\n\n> 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。\n\n> 注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。\n\n16.使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。\n\n17.高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：\n\n![](https://img-blog.csdnimg.cn/619a4dc1039f4dfca3a7d1c81e001a76.png)\n\n18.利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains()进行遍历去重或者判断包含操作。","slug":"阿里Java开发手册/编程规约/集合处理","published":1,"date":"2022-03-15T06:05:37.610Z","updated":"2022-03-15T06:33:29.199Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0trzwll00nnfhjies2mhaqm","content":"<p>1.关于hashCode和equals的处理，遵循如下规则:</p>\n<ul>\n<li><p>只要重写 equals，就必须重写 hashCode。</p>\n</li>\n<li><p>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写 这两个方法。</p>\n</li>\n<li><p>如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。</p>\n</li>\n</ul>\n<p>2.判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是<code>size()==0</code>的方式。</p>\n<blockquote>\n<p>说明:前者的时间复杂度为 O(1)，而且可读性更好。</p>\n</blockquote>\n<p>3.在使用 <code>java.util.stream.Collectors</code> 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为mergeFunction 的方法，否则当出现相同 key值时会抛出 IllegalStateException 异常。</p>\n<blockquote>\n<p>说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。</p>\n</blockquote>\n<p>正例：</p>\n<pre><code class=\"java\">List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList = new ArrayList&lt;&gt;(3);\npairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 12.10));\npairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 12.19));\npairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 6.28));\nMap&lt;String, Double&gt; map = pairArrayList.stream().collect(\n// 生成的 map 集合中只有一个键值对：&#123;version=6.28&#125;\nCollectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -&gt; v2));\n\nMap&lt;Integer, String&gt; map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName,(oldValue, newValue) -&gt; newValue));\n</code></pre>\n<p>反例：</p>\n<pre><code class=\"java\">String[] departments = new String[] &#123;&quot;iERP&quot;, &quot;iERP&quot;, &quot;EIBU&quot;&#125;;\n// 抛出 IllegalStateException 异常\nMap&lt;Integer, String&gt; map = Arrays.stream(departments)\n .collect(Collectors.toMap(String::hashCode, str -&gt; str));\n</code></pre>\n<p>4.在使用 <code>java.util.stream.Collectors </code>类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p>\n<p>5.ArrayList 的 subList （截取一部分列表）结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常。</p>\n<blockquote>\n<p>说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于 SubList 的所有操作最终会反映到原列表上。</p>\n</blockquote>\n<p>6.使用 Map 的方法 keySet()&#x2F;values()&#x2F;entrySet()返回集合对象时，不可以对其进行添加元素操作，否则会抛出UnsupportedOperationException 异常。</p>\n<p>7.Collections 类返回的对象，如：<strong>emptyList()&#x2F;singletonList()等都是 immutable list</strong>，不可对其进行添加或者删除元素的操作。</p>\n<blockquote>\n<p>反例：如果查询无结果，返回 Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就会触发 UnsupportedOperationException 异常。</p>\n</blockquote>\n<p>8.在 subList 场景中，<strong>高度注意对父集合元素</strong>的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p>\n<p>9.使用集合转数组的方法，必须使用集合的<code> toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</p>\n<blockquote>\n<p>直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。</p>\n</blockquote>\n<p>正例：</p>\n<p>10.在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行NPE 判断。</p>\n<p>11.使用工具类 <code>Arrays.asList()</code>把数组转换成集合时，不能使用其修改集合相关的方法，它的 add&#x2F;remove&#x2F;clear 方法会抛出 UnsupportedOperationException 异常。</p>\n<blockquote>\n<p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。</p>\n</blockquote>\n<p>Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>\n<pre><code class=\"java\"> String[] str = new String[] &#123; &quot;chen&quot;, &quot;yang&quot;, &quot;hao&quot; &#125;;\n List list = Arrays.asList(str);\n</code></pre>\n<ul>\n<li>第一种情况<code>：list.add(&quot;tianmaolin&quot;);</code> 运行时异常。</li>\n<li>第二种情况：<code>str[0] = &quot;change&quot;;</code> 也会随之修改，反之亦然。</li>\n</ul>\n<p>12.泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据，此写法的泛型集合不能使用 add 方法，而<code>&lt;? super T&gt;</code>不能使用 get 方法，两者在接口调用赋值的场景中容易出错。</p>\n<p>14.不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。</p>\n<p>remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。</p>\n<pre><code class=\"java\">正例：\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nIterator&lt;String&gt; iterator = list.iterator();\nwhile (iterator.hasNext()) &#123;\n String item = iterator.next();\n if (删除元素的条件) &#123;\n         iterator.remove();\n &#125;\n&#125;\n\n反例：\nfor (String item : list) &#123;\n if (&quot;1&quot;.equals(item)) &#123;\n         list.remove(item);\n &#125;\n&#125;\n</code></pre>\n<p>15.集合初始化时，指定集合初始值大小。</p>\n<blockquote>\n<p>说明：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。</p>\n</blockquote>\n<blockquote>\n<p>正例：initialCapacity &#x3D; (需要存储的元素个数 &#x2F; 负载因子) + 1。</p>\n</blockquote>\n<blockquote>\n<p>注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。</p>\n</blockquote>\n<p>16.使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</p>\n<p>17.高度注意 Map 类集合 K&#x2F;V 能不能存储 null 值的情况，如下表格：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/619a4dc1039f4dfca3a7d1c81e001a76.png\"></p>\n<p>18.利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains()进行遍历去重或者判断包含操作。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.关于hashCode和equals的处理，遵循如下规则:</p>\n<ul>\n<li><p>只要重写 equals，就必须重写 hashCode。</p>\n</li>\n<li><p>因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写 这两个方法。</p>\n</li>\n<li><p>如果自定义对象作为 Map 的键，那么必须覆写 hashCode 和 equals。</p>\n</li>\n</ul>\n<p>2.判断所有集合内部的元素是否为空，使用isEmpty()方法，而不是<code>size()==0</code>的方式。</p>\n<blockquote>\n<p>说明:前者的时间复杂度为 O(1)，而且可读性更好。</p>\n</blockquote>\n<p>3.在使用 <code>java.util.stream.Collectors</code> 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为mergeFunction 的方法，否则当出现相同 key值时会抛出 IllegalStateException 异常。</p>\n<blockquote>\n<p>说明：参数 mergeFunction 的作用是当出现 key 重复时，自定义对 value 的处理策略。</p>\n</blockquote>\n<p>正例：</p>\n<pre><code class=\"java\">List&lt;Pair&lt;String, Double&gt;&gt; pairArrayList = new ArrayList&lt;&gt;(3);\npairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 12.10));\npairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 12.19));\npairArrayList.add(new Pair&lt;&gt;(&quot;version&quot;, 6.28));\nMap&lt;String, Double&gt; map = pairArrayList.stream().collect(\n// 生成的 map 集合中只有一个键值对：&#123;version=6.28&#125;\nCollectors.toMap(Pair::getKey, Pair::getValue, (v1, v2) -&gt; v2));\n\nMap&lt;Integer, String&gt; map = list.stream().collect(Collectors.toMap(Person::getId, Person::getName,(oldValue, newValue) -&gt; newValue));\n</code></pre>\n<p>反例：</p>\n<pre><code class=\"java\">String[] departments = new String[] &#123;&quot;iERP&quot;, &quot;iERP&quot;, &quot;EIBU&quot;&#125;;\n// 抛出 IllegalStateException 异常\nMap&lt;Integer, String&gt; map = Arrays.stream(departments)\n .collect(Collectors.toMap(String::hashCode, str -&gt; str));\n</code></pre>\n<p>4.在使用 <code>java.util.stream.Collectors </code>类的 toMap()方法转为 Map 集合时，一定要注意当 value 为 null 时会抛 NPE 异常。</p>\n<p>5.ArrayList 的 subList （截取一部分列表）结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常。</p>\n<blockquote>\n<p>说明：subList()返回的是 ArrayList 的内部类 SubList，并不是 ArrayList 本身，而是 ArrayList 的一个视图，对于 SubList 的所有操作最终会反映到原列表上。</p>\n</blockquote>\n<p>6.使用 Map 的方法 keySet()&#x2F;values()&#x2F;entrySet()返回集合对象时，不可以对其进行添加元素操作，否则会抛出UnsupportedOperationException 异常。</p>\n<p>7.Collections 类返回的对象，如：<strong>emptyList()&#x2F;singletonList()等都是 immutable list</strong>，不可对其进行添加或者删除元素的操作。</p>\n<blockquote>\n<p>反例：如果查询无结果，返回 Collections.emptyList()空集合对象，调用方一旦进行了添加元素的操作，就会触发 UnsupportedOperationException 异常。</p>\n</blockquote>\n<p>8.在 subList 场景中，<strong>高度注意对父集合元素</strong>的增加或删除，均会导致子列表的遍历、增加、删除产生 ConcurrentModificationException 异常。</p>\n<p>9.使用集合转数组的方法，必须使用集合的<code> toArray(T[] array)</code>，传入的是类型完全一致、长度为 0 的空数组。</p>\n<blockquote>\n<p>直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现ClassCastException 错误。</p>\n</blockquote>\n<p>正例：</p>\n<p>10.在使用 Collection 接口任何实现类的 addAll()方法时，都要对输入的集合参数进行NPE 判断。</p>\n<p>11.使用工具类 <code>Arrays.asList()</code>把数组转换成集合时，不能使用其修改集合相关的方法，它的 add&#x2F;remove&#x2F;clear 方法会抛出 UnsupportedOperationException 异常。</p>\n<blockquote>\n<p>说明：asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。</p>\n</blockquote>\n<p>Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p>\n<pre><code class=\"java\"> String[] str = new String[] &#123; &quot;chen&quot;, &quot;yang&quot;, &quot;hao&quot; &#125;;\n List list = Arrays.asList(str);\n</code></pre>\n<ul>\n<li>第一种情况<code>：list.add(&quot;tianmaolin&quot;);</code> 运行时异常。</li>\n<li>第二种情况：<code>str[0] = &quot;change&quot;;</code> 也会随之修改，反之亦然。</li>\n</ul>\n<p>12.泛型通配符<code>&lt;? extends T&gt;</code>来接收返回的数据，此写法的泛型集合不能使用 add 方法，而<code>&lt;? super T&gt;</code>不能使用 get 方法，两者在接口调用赋值的场景中容易出错。</p>\n<p>14.不要在 foreach 循环里进行元素的 <code>remove/add</code> 操作。</p>\n<p>remove 元素请使用 Iterator方式，如果并发操作，需要对 Iterator 对象加锁。</p>\n<pre><code class=\"java\">正例：\nList&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(&quot;1&quot;);\nlist.add(&quot;2&quot;);\nIterator&lt;String&gt; iterator = list.iterator();\nwhile (iterator.hasNext()) &#123;\n String item = iterator.next();\n if (删除元素的条件) &#123;\n         iterator.remove();\n &#125;\n&#125;\n\n反例：\nfor (String item : list) &#123;\n if (&quot;1&quot;.equals(item)) &#123;\n         list.remove(item);\n &#125;\n&#125;\n</code></pre>\n<p>15.集合初始化时，指定集合初始值大小。</p>\n<blockquote>\n<p>说明：HashMap 使用 HashMap(int initialCapacity) 初始化，如果暂时无法确定集合大小，那么指定默认值（16）即可。</p>\n</blockquote>\n<blockquote>\n<p>正例：initialCapacity &#x3D; (需要存储的元素个数 &#x2F; 负载因子) + 1。</p>\n</blockquote>\n<blockquote>\n<p>注意负载因子（即 loader factor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16（即默认值）。</p>\n</blockquote>\n<p>16.使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。</p>\n<p>17.高度注意 Map 类集合 K&#x2F;V 能不能存储 null 值的情况，如下表格：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/619a4dc1039f4dfca3a7d1c81e001a76.png\"></p>\n<p>18.利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的contains()进行遍历去重或者判断包含操作。</p>\n"},{"_content":"### 为什么要使用数据库\n\n**数据保存在内存**\n\n优点： 存取速度快\n\n缺点： 数据不能永久保存\n\n**数据保存在文件**\n\n优点： 数据永久保存\n\n缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便\n\n**数据保存在数据库**\n\n1）数据永久保存\n\n2）使用SQL语句，查询方便效率高。\n\n3）管理数据方便\n\n### 什么是SQL？\n\n结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。\n\n作用：用于存取数据、查询、更新和管理关系数据库系统。\n\n### 什么是MySQL?\n\nMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。\n\n### 数据库三大范式是什么\n\n第一范式：每个列都不可以再拆分。\n\n第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。\n\n第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。\n\n在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。\n\n### mysql有关权限的表都有哪几个\n\nMySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：\n\n- user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n- db权限表：记录各个帐号在各个数据库上的操作权限。\n- table_priv权限表：记录数据表级的操作权限。\n- columns_priv权限表：记录数据列级的操作权限。\n- host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。\n\n### MySQL的binlog有有几种录入格式？分别有什么区别？\n\n有三种格式，statement，row和mixed。\n\n- statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。\n- row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。\n- mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。\n\n此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。\n\n## 数据类型\n\n### mysql有哪些数据类型\n\n| **分类**             | **类型名称** | **说明**                                                     |\n| :------------------- | :----------- | :----------------------------------------------------------- |\n| **整数类型**         | tinyInt      | 很小的整数(8位二进制)                                        |\n|                      | smallint     | 小的整数(16位二进制)                                         |\n|                      | mediumint    | 中等大小的整数(24位二进制)                                   |\n|                      | int(integer) | 普通大小的整数(32位二进制)                                   |\n| **小数类型**         | float        | 单精度浮点数                                                 |\n|                      | double       | 双精度浮点数                                                 |\n|                      | decimal(m,d) | 压缩严格的定点数                                             |\n| **日期类型**         | year         | YYYY 1901~2155                                               |\n|                      | time         | HH:MM:SS -838:59:59~838:59:59                                |\n|                      | date         | YYYY-MM-DD 1000-01-01~9999-12-3                              |\n|                      | datetime     | YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59 |\n|                      | timestamp    | YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC |\n| **文本、二进制类型** | CHAR(M)      | M为0~255之间的整数                                           |\n|                      | VARCHAR(M)   | M为0~65535之间的整数                                         |\n|                      | TINYBLOB     | 允许长度0~255字节                                            |\n|                      | BLOB         | 允许长度0~65535字节                                          |\n|                      | MEDIUMBLOB   | 允许长度0~167772150字节                                      |\n|                      | LONGBLOB     | 允许长度0~4294967295字节                                     |\n|                      | TINYTEXT     | 允许长度0~255字节                                            |\n|                      | TEXT         | 允许长度0~65535字节                                          |\n|                      | MEDIUMTEXT   | 允许长度0~167772150字节                                      |\n|                      | LONGTEXT     | 允许长度0~4294967295字节                                     |\n|                      | VARBINARY(M) | 允许长度0~M个字节的变长字节字符串                            |\n|                      | BINARY(M)    | 允许长度0~M个字节的定长字节字符串                            |\n\n \n\n- 1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。\n  长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。\n  例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。\n\n- 2、实数类型，包括FLOAT、DOUBLE、DECIMAL。\n  DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。\n  而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。\n  计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。\n\n- 3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB\n  VARCHAR用于存储可变长字符串，它比定长类型更节省空间。\n  VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。\n  VARCHAR存储的内容超出设置的长度时，内容会被截断。\n  CHAR是定长的，根据定义的字符串长度分配足够的空间。\n  CHAR会根据需要使用空格进行填充方便比较。\n  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。\n  CHAR存储的内容超出设置的长度时，内容同样会被截断。\n\n  **使用策略：**\n  对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。\n  对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。\n  使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。\n  尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。\n\n- 4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。\n  有时可以使用ENUM代替常用的字符串类型。\n  ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。\n  ENUM在内部存储时，其实存的是整数。\n  尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。\n  排序是按照内部存储的整数\n\n- 5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，\n  用整数保存时间戳通常不方便处理。\n  如果需要存储微妙，可以使用bigint存储。\n  看到这里，这道真题是不是就比较容易回答了。\n\n## 引擎\n\n### MySQL存储引擎MyISAM与InnoDB区别\n\n存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。\n\n常用的存储引擎有以下：\n\n- **Innodb引擎**：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。\n- **MyIASM引擎**(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。\n- **MEMORY引擎**：所有的数据都在内存中，数据的处理速度快，但是安全性不高。\n\n**MyISAM与InnoDB区别**\n\n|                                                              | **MyISAM**                                                   | **Innodb**                                                   |\n| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| 存储结构                                                     | 每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB |\n| 存储空间                                                     | MyISAM可被压缩，存储空间较小                                 | InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 |\n| 可移植性、备份及恢复                                         | 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 |\n| 文件格式                                                     | 数据和索引是分别存储的，数据.MYD，索引.MYI                   | 数据和索引是集中存储的，.ibd                                 |\n| 记录存储顺序                                                 | 按记录插入顺序保存                                           | 按主键大小有序插入                                           |\n| 外键                                                         | 不支持                                                       | 支持                                                         |\n| 事务                                                         | 不支持                                                       | 支持                                                         |\n| 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） | 表级锁定                                                     | 行级锁定、表级锁定，锁定力度小并发能力高                     |\n| SELECT                                                       | MyISAM更优                                                   |                                                              |\n| INSERT、UPDATE、DELETE                                       |                                                              | InnoDB更优                                                   |\n| select count(*)                                              | myisam更快，因为myisam内部维护了一个计数器，可以直接调取。   |                                                              |\n| 索引的实现方式                                               | B+树索引，myisam 是堆表                                      | B+树索引，Innodb 是索引组织表                                |\n| 哈希索引                                                     | 不支持                                                       | 支持                                                         |\n| 全文索引                                                     | 支持                                                         | 不支持                                                       |\n\n### MyISAM索引与InnoDB索引的区别？\n\n- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。\n- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。\n- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。\n- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。\n\n### InnoDB引擎的4大特性\n\n- 插入缓冲（insert buffer)\n- 二次写(double write)\n- 自适应哈希索引(ahi)\n- 预读(read ahead)\n\n### 存储引擎选择\n\n如果没有特别的需求，使用默认的Innodb即可。\n\nMyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。\n\nInnodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。\n\n## 索引\n\n### 什么是索引？\n\n索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。\n\n索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。\n\n更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。\n\n### 索引有哪些优缺点？\n\n索引的优点\n\n- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\n- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。\n\n索引的缺点\n\n- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；\n- 空间方面：索引需要占物理空间。\n\n### 索引使用场景（重点）\n\nwhere\n\n![](https://img-blog.csdnimg.cn/0bd245252090436dbd84297a3be0d304.png)\n\n上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。\n\n-- 增加一个没有建立索引的字段 alter table innodb1 add sex char(1); -- 按sex检索时可选的索引为null EXPLAIN SELECT * from innodb1 where sex='男';\n\n![](https://img-blog.csdnimg.cn/191753c4800e4ba28295a4257bbc57f7.png)\n\n> 可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。\n\norder by\n\n当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。\n\n但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用**取出索引表某个范围内的索引对应的数据**，而不用像上述那**取出所有数据**进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）\n\njoin\n\n> 对join语句匹配关系（on）涉及的字段建立索引能够提高效率\n\n索引覆盖\n\n如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。\n\n这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。\n\n### 索引有哪几种类型？\n\n**主键索引:** 数据列不允许重复，不允许为NULL，一个表只能有一个主键。\n\n**唯一索引:** 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。\n\n- 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引\n- 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引\n\n**普通索引:** 基本的索引类型，没有唯一性的限制，允许为NULL值。\n\n- 可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引\n- 可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引\n\n**全文索引：** 是目前搜索引擎使用的一种关键技术。\n\n- 可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引\n\n### 索引的数据结构（b树，hash）\n\n索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有**Hash索引**，**B+树索引**等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。\n\n1）B树索引\n\nmysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）\n\n![](https://img-blog.csdnimg.cn/1cbeb7fd870e48b3aa2f8399577b13bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n查询方式：\n\n主键索引区:PI(关联保存的时数据的地址)按主键查询,\n\n普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快\n\nB+tree性质：\n\n1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。\n\n2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。\n\n3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。\n\n4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。\n\n5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。\n\n2）哈希索引\n\n简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。\n\n![](https://img-blog.csdnimg.cn/0336f3cd247249a6af5a4be815d791e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_15,color_FFFFFF,t_70,g_se,x_16)\n\n### 索引的基本原理\n\n索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。\n\n索引的原理很简单，就是把无序的数据变成有序的查询\n\n1. 把创建了索引的列的内容进行排序\n2. 对排序结果生成倒排表\n3. 在倒排表内容上拼上数据地址链\n4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据\n\n### 索引算法有哪些？\n\n索引算法有 BTree算法和Hash算法\n\n**BTree算法**\n\nBTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：\n\n-- 只要它的查询条件是一个不以通配符开头的常量 select * from user where name like 'jack%'; -- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like '%jack';\n\n**Hash算法**\n\nHash Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。\n\n### 索引设计的原则？\n\n1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列\n2. 基数较小的类，索引效果较差，没有必要在此列建立索引\n3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间\n4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。\n\n### 创建索引的原则（重中之重）\n\n索引虽好，但也不是无限制的使用，最好符合一下几个原则\n\n1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\n\n2）较频繁作为查询条件的字段才去创建索引\n\n3）更新频繁字段不适合创建索引\n\n4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)\n\n5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。\n\n6）定义有外键的数据列一定要建立索引。\n\n7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。\n\n8）对于定义为text、image和bit的数据类型的列不要建立索引。\n\n### 创建索引的三种方式，删除索引\n\n第一种方式：在执行CREATE TABLE时创建索引\n\nCREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );\n\n第二种方式：使用ALTER TABLE命令去增加索引\n\nALTER TABLE table_name ADD INDEX index_name (column_list);\n\nALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。\n\n其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。\n\n索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。\n\n第三种方式：使用CREATE INDEX命令创建\n\nCREATE INDEX index_name ON table_name (column_list);\n\nCREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）\n\n删除索引\n\n根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名\n\nalter table user_index drop KEY name; alter table user_index drop KEY id_card; alter table user_index drop KEY information;\n\n删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：\n\n![](https://img-blog.csdnimg.cn/fae6723844de418cb597facb6497d2c7.png)\n\n需要取消自增长再行删除：\n\nalter table user_index -- 重新定义字段 MODIFY id int, drop PRIMARY KEY\n\n但通常不会删除主键，因为设计主键一定与业务逻辑无关。\n\n### 创建索引时需要注意什么？\n\n- 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；\n- 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；\n- 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。\n\n### 使用索引查询一定能提高查询的性能吗？为什么\n\n通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。\n\n- 索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:\n- 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%\n- 基于非唯一性索引的检索\n\n### 百万级别或以上的数据如何删除\n\n关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。\n\n1. 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）\n2. 然后删除其中无用数据（此过程需要不到两分钟）\n3. 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。\n4. 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。\n\n### 前缀索引\n\n语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。\n\n前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。\n\n实操的难度：在于前缀截取的长度。\n\n我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）\n\n### 什么是最左前缀原则？什么是最左匹配原则\n\n- 顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。\n- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\n- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式\n\n### B树和B+树的区别\n\n- 在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。\n\n- B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。\n\n  ![](https://img-blog.csdnimg.cn/3cf2b460c14745fcae0c390859d74324.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### 使用B树的好处\n\nB树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。\n\n### 使用B+树的好处\n\n由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间\n\n### Hash索引和B+树所有有什么区别或者说优劣呢?\n\n首先要知道Hash索引和B+树索引的底层实现原理：\n\nhash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。\n\n那么可以看出他们有以下的不同：\n\n- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。\n\n因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。\n\n- hash索引不支持使用索引进行排序，原理同上。\n- hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。\n- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。\n- hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。\n\n因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。\n\n### 数据库为什么使用B+树而不是B树\n\n- B树只适合随机检索，而B+树同时支持随机检索和顺序检索；\n- B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；\n- B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。\n- B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。\n- 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。\n\n### B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\n\n在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。\n\n当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。\n\n### 什么是聚簇索引？何时使用聚簇索引与非聚簇索引\n\n- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据\n- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因\n\n澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值\n\n何时使用聚簇索引与非聚簇索引\n\n![](https://img-blog.csdnimg.cn/54d88ff9fc2c48588d04ca76611f8ecc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### 非聚簇索引一定会回表查询吗？\n\n不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。\n\n举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。\n\n### 联合索引是什么？为什么需要注意联合索引中的顺序？\n\nMySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。\n\n具体原因为:\n\nMySQL使用索引时需要索引有序，假设现在建立了\"name，age，school\"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。\n\n当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。\n\n## 事务\n\n### 什么是数据库事务？\n\n事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。\n\n事务最经典也经常被拿出来说例子就是转账了。\n\n假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n### 事物的四大特性(ACID)介绍一下?\n\n关系性数据库需要遵循ACID规则，具体内容如下：\n\n![](https://img-blog.csdnimg.cn/9a1d7c93ca874557911ae2cb578dcb4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_10,color_FFFFFF,t_70,g_se,x_16)\n\n1. **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n\n2. **一致性：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\n\n3. **隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/9a95f01f0e8c41a88e210e387a98da47.png)\n\n   \n\n4. **持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n### 什么是脏读？幻读？不可重复读？\n\n- 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。\n- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。\n- 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。\n\n### 什么是事务的隔离级别？MySQL的默认隔离级别是什么？\n\n为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。\n\n**隔离级别****脏读****不可重复读****幻影读**READ-UNCOMMITTED√√√READ-COMMITTED×√√REPEATABLE-READ××√SERIALIZABLE×××\n\n**SQL 标准定义了四个隔离级别：**\n\n- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。\n- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。\n- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。\n\n这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别\n\n事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。\n\n因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。\n\n## 锁\n\n### 对MySQL的锁了解吗\n\n当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。\n\n就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。\n\n### 隔离级别与锁的关系\n\n在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突\n\n在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；\n\n在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。\n\nSERIALIZABLE 是限制性最强的隔离级别，因为该级别**锁定整个范围的键**，并一直持有锁，直到事务完成。\n\n### 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\n\n在关系型数据库中，可以**按照锁的粒度把数据库锁分**为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。\n\n**MyISAM和InnoDB存储引擎使用的锁：**\n\n- MyISAM采用表级锁(table-level locking)。\n- InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁\n\n行级锁，表级锁和页级锁对比\n\n**行级锁** 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。\n\n特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n**表级锁** 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。\n\n特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。\n\n**页级锁** 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。\n\n特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般\n\n### 从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\n\n**从锁的类别上来讲**，有共享锁和排他锁。\n\n共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\n\n排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\n\n用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。\n\n锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。\n\n他们的加锁开销从大到小，并发能力也是从大到小。\n\n### MySQL中InnoDB引擎的行锁是怎么实现的？\n\n答：InnoDB是基于索引来完成行锁\n\n例: select * from tab_with_index where id = 1 for update;\n\nfor update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起\n\n### InnoDB存储引擎的锁的算法有三种\n\n- Record lock：单个行记录上的锁\n- Gap lock：间隙锁，锁定一个范围，不包括记录本身\n- Next-key lock：record+gap 锁定一个范围，包含记录本身\n\n**相关知识点：**\n\n1. innodb对于行的查询使用next-key lock\n2. Next-locking keying为了解决Phantom Problem幻读问题\n3. 当查询的索引含有唯一属性时，将next-key lock降级为record key\n4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生\n5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1\n\n### 什么是死锁？怎么解决？\n\n死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。\n\n常见的解决死锁的方法\n\n1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。\n\n2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\n\n3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；\n\n如果业务处理不好可以用分布式事务锁或者使用乐观锁\n\n### 数据库的乐观锁和悲观锁是什么？怎么实现的？\n\n数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。\n\n**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制\n\n**乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。\n\n**两种锁的使用场景**\n\n从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。\n\n但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**\n\n## 视图\n\n### 为什么要使用视图？什么是视图？\n\n为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。\n\n视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。\n\n### 视图有哪些特点？\n\n视图的特点如下:\n\n- 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。\n- 视图是由基本表(实表)产生的表(虚表)。\n- 视图的建立和删除不影响基本表。\n- 对视图内容的更新(添加，删除和修改)直接影响基本表。\n- 当视图来自多个基本表时，不允许添加和删除数据。\n\n视图的操作包括创建视图，查看视图，删除视图和修改视图。\n\n### 视图的使用场景有哪些？\n\n视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。\n\n下面是视图的常见使用场景：\n\n- 重用SQL语句；\n- 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；\n- 使用表的组成部分而不是整个表；\n- 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；\n- 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。\n\n### 视图的优点\n\n1. 查询简单化。视图能简化用户的操作\n2. 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护\n3. 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性\n\n### 视图的缺点\n\n1. 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。\n\n2. 修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的\n\n   这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\\SUM\\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）\n\n### 什么是游标？\n\n游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。\n\n## 存储过程与函数\n\n### 什么是存储过程？有哪些优缺点？\n\n存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。\n\n**优点**\n\n1）存储过程是预编译过的，执行效率高。\n\n2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。\n\n3）安全性高，执行存储过程需要有一定权限的用户。\n\n4）存储过程可以重复使用，减少数据库开发人员的工作量。\n\n**缺点**\n\n1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。\n\n2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。\n\n3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。\n\n4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。\n\n## 触发器\n\n### 什么是触发器？触发器的使用场景有哪些？\n\n触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。\n\n使用场景\n\n- 可以通过数据库中的相关表实现级联更改。\n- 实时监控某张表中的某个字段的更改而需要做出相应的处理。\n- 例如可以生成某些业务的编号。\n- 注意不要滥用，否则会造成数据库及应用程序的维护困难。\n- 大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。\n\n### MySQL中都有哪些触发器？\n\n在MySQL数据库中有如下六种触发器：\n\n- Before Insert\n- After Insert\n- Before Update\n- After Update\n- Before Delete\n- After Delete\n\n## 常用SQL语句\n\n### SQL语句主要分为哪几类\n\n数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER\n\n主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。\n\n数据查询语言DQL（Data Query Language）SELECT\n\n这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。\n\n数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE\n\n主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。\n\n数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK\n\n主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。\n\n### 超键、候选键、主键、外键分别是什么？\n\n- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。\n- 候选键：是最小超键，即没有冗余元素的超键。\n- 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。\n- 外键：在一个表中存在的另一个表的主键称此表的外键。\n\n### SQL 约束有哪几种？\n\n> SQL 约束有哪几种？\n\n- NOT NULL: 用于控制字段的内容一定不能为空（NULL）。\n- UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。\n- PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。\n- FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。\n- CHECK: 用于控制字段的值范围。\n\n### 六种关联查询\n\n- 交叉连接（CROSS JOIN）\n- 内连接（INNER JOIN）\n- 外连接（LEFT JOIN/RIGHT JOIN）\n- 联合查询（UNION与UNION ALL）\n- 全连接（FULL JOIN）\n- 交叉连接（CROSS JOIN）\n\nSELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN\n\n内连接分为三类\n\n- 等值连接：ON A.id=B.id\n- 不等值连接：ON A.id > B.id\n- 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid\n\n外连接（LEFT JOIN/RIGHT JOIN）\n\n- 左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN\n- 右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN\n\n联合查询（UNION与UNION ALL）\n\nSELECT * FROM A UNION SELECT * FROM B UNION ...\n\n- 就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并\n- 如果使用UNION ALL，不会合并重复的记录行\n- 效率 UNION 高于 UNION ALL\n\n全连接（FULL JOIN）\n\n- MySQL不支持全连接\n- 可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用\n\nSELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id\n\n表连接面试题\n\n有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。\n\nR表\n\n| **A** | **B** | **C** |\n| :---- | :---- | :---- |\n| a1    | b1    | c1    |\n| a2    | b2    | c2    |\n| a3    | b3    | c3    |\n\nS表\n\n| **C** | **D** |\n| :---- | :---- |\n| c1    | d1    |\n| c2    | d2    |\n| c4    | d3    |\n\n \n\n1. 交叉连接(笛卡尔积):\n\nselect r.*,s.* from r,s\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c1    | d1    |\n| a3    | b3    | c3    | c1    | d1    |\n| a1    | b1    | c1    | c2    | d2    |\n| a2    | b2    | c2    | c2    | d2    |\n| a3    | b3    | c3    | c2    | d2    |\n| a1    | b1    | c1    | c4    | d3    |\n| a2    | b2    | c2    | c4    | d3    |\n| a3    | b3    | c3    | c4    | d3    |\n\n \n\n1. 内连接结果：\n\n   select r.*,s.* from r inner join s on r.c=s.c\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c2    | d2    |\n\n \n\n1. 左连接结果：\n\n   select r.*,s.* from r left join s on r.c=s.c\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c2    | d2    |\n| a3    | b3    | c3    |       |       |\n\n \n\n1. 右连接结果：\n\n   select r.*,s.* from r right join s on r.c=s.c\n\n|      |      |      |      |      |\n| :--- | :--- | :--- | :--- | :--- |\n| A    | B    | C    | C    | D    |\n| a1   | b1   | c1   | c1   | d1   |\n| a2   | b2   | c2   | c2   | d2   |\n|      |      |      | c4   | d3   |\n\n \n\n1. 全表连接的结果（MySql不支持，Oracle支持）：\n\n   select r.*,s.* from r full join s on r.c=s.c\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c2    | d2    |\n| a3    | b3    | c3    |       |       |\n|       |       |       | c4    | d3    |\n\n \n\n### 什么是子查询\n\n1. 条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果\n2. 嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。\n\n### 子查询的三种情况\n\n1. 子查询是单行单列的情况：结果集是一个值，父查询使用：=、 <、 > 等运算符\n\n-- 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);\n\n1. 子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符\n\n-- 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);\n\n1. 子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表\n\n-- 1) 查询出2011年以后入职的员工信息 -- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。 select * from dept d, (select * from employee where join_date > '2011-1-1') e where e.dept_id = d.id; -- 使用表连接： select d.*, e.* from dept d inner join employee e on d.id = e.dept_id where e.join_date > '2011-1-1'\n\n### mysql中 in 和 exists 区别\n\nmysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。\n\n1. 如果查询的两个表大小相当，那么用in和exists差别不大。\n2. 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。\n3. not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。\n\n### varchar与char的区别\n\n**char的特点**\n\n- char表示定长字符串，长度是固定的；\n- 如果插入数据的长度小于char的固定长度时，则用空格填充；\n- 因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；\n- 对于char来说，最多能存放的字符个数为255，和编码无关\n\n**varchar的特点**\n\n- varchar表示可变长字符串，长度是可变的；\n- 插入的数据是多长，就按照多长来存储；\n- varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；\n- 对于varchar来说，最多能存放的字符个数为65532\n\n总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。\n\n### varchar(50)中50的涵义\n\n最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。\n\n### int(20)中20的涵义\n\n是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；\n\n不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示\n\n### mysql为什么这么设计\n\n对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；\n\n### mysql中int(10)和char(10)以及varchar(10)的区别\n\n- int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。\n\n  int(10) 10位的数据长度 9999999999，占32个字节，int型4位\n  char(10) 10位固定字符串，不足补空格 最多10个字符\n  varchar(10) 10位可变字符串，不足补空格 最多10个字符\n\n- char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间\n\n- varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符\n\n### FLOAT和DOUBLE的区别是什么？\n\n- FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。\n- DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。\n\n### drop、delete与truncate的区别\n\n三者都表示删除，但是三者有一些差别：\n\n|          | **Delete**                               | **Truncate**                   | **Drop**                                             |\n| :------- | :--------------------------------------- | :----------------------------- | :--------------------------------------------------- |\n| 类型     | 属于DML                                  | 属于DDL                        | 属于DDL                                              |\n| 回滚     | 可回滚                                   | 不可回滚                       | 不可回滚                                             |\n| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 | 从数据库中删除表，所有的数据行，索引和权限也会被删除 |\n| 删除速度 | 删除速度慢，需要逐行删除                 | 删除速度快                     | 删除速度最快                                         |\n\n \n\n因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。\n\n### UNION与UNION ALL的区别？\n\n- 如果使用UNION ALL，不会合并重复的记录行\n- 效率 UNION 高于 UNION ALL\n\n## SQL优化\n\n### 如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？\n\n对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，**对于查询语句，最重要的优化方式就是使用索引**。 而**执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等**。\n\n![](https://img-blog.csdnimg.cn/3762f1f867ab421aa5a4e3e8328e0b8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n执行计划包含的信息 **id** 有一组数字组成。表示一个查询中各个子查询的执行顺序;\n\n- id相同执行顺序由上至下。\n- id不同，id值越大优先级越高，越先被执行。\n- id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。\n\n**select_type** 每个子查询的查询类型，一些常见的查询类型。\n\n| **id** | **select_type** | **description**                           |\n| :----- | :-------------- | :---------------------------------------- |\n| 1      | SIMPLE          | 不包含任何子查询或union等查询             |\n| 2      | PRIMARY         | 包含子查询最外层查询就显示为 PRIMARY      |\n| 3      | SUBQUERY        | 在select或 where字句中包含的查询          |\n| 4      | DERIVED         | from字句中包含的查询                      |\n| 5      | UNION           | 出现在union后的查询语句中                 |\n| 6      | UNION RESULT    | 从UNION中获取结果集，例如上文的第三个例子 |\n\n \n\n**table** 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id **partitions** 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：\n\ncreate table tmp ( id int unsigned not null AUTO_INCREMENT, name varchar(255), PRIMARY KEY (id) ) engine = innodb partition by key (id) partitions 5;\n\n**type**(非常重要，可以看到有没有走索引) 访问类型\n\n- ALL 扫描全表数据\n- index 遍历索引\n- range 索引范围查找\n- index_subquery 在子查询中使用 ref\n- unique_subquery 在子查询中使用 eq_ref\n- ref_or_null 对Null进行索引的优化的 ref\n- fulltext 使用全文索引\n- ref 使用非唯一索引查找数据\n- eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。\n\n**possible_keys** 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。\n\n**key** 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。\n\n**TIPS**:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中\n\n**key_length** 索引长度\n\n**ref** 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值\n\n**rows** 返回估算的结果集数目，并不是一个准确的值。\n\n**extra** 的信息非常丰富，常见的有：\n\n1. Using index 使用覆盖索引\n2. Using where 使用了用where子句来过滤结果集\n3. Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。\n4. Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册\n\n【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。\n\n### SQL的生命周期？\n\n1. 应用服务器与数据库服务器建立一个连接\n\n2. 数据库进程拿到请求sql\n\n3. 解析并生成执行计划，执行\n\n4. 读取数据到内存并进行逻辑处理\n\n5. 通过步骤一的连接，发送结果到客户端\n\n6. 关掉连接，释放资源\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/86be8bfa609d4a909568f3b64ec891d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### 大表数据查询，怎么优化\n\n1. 优化shema、sql语句+索引；\n2. 第二加缓存，memcached, redis；\n3. 主从复制，读写分离；\n4. 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；\n5. 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；\n\n### 超大分页怎么处理？\n\n超大的分页一般从两个方向上来解决.\n\n- 数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.\n- 从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.\n\n解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.\n\n在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.\n\n【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id\n\n### mysql 分页\n\nLIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)\n\nmysql> SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15\n\n为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：\n\nmysql> SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.\n\n如果只给定一个参数，它表示返回最大的记录行数目：\n\nmysql> SELECT * FROM table LIMIT 5; //检索前 5 个记录行\n\n换句话说，LIMIT n 等价于 LIMIT 0,n。\n\n### 慢查询日志\n\n> 用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。\n\n开启慢查询日志\n\n配置项：slow_query_log\n\n可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。\n\n设置临界时间\n\n配置项：long_query_time\n\n查看：show VARIABLES like 'long_query_time'，单位秒\n\n设置：set long_query_time=0.5\n\n实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉\n\n查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中\n\n### 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\n\n在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。\n\n慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？\n\n所以优化也是针对这三个方向来的，\n\n- 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。\n- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。\n- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。\n\n### 为什么要尽量设定一个主键？\n\n主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。\n\n### 主键使用自增ID还是UUID？\n\n推荐使用自增ID，不要使用UUID。\n\n因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。\n\n总之，在数据量大一些的情况下，用自增主键性能会好一些。\n\n关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。\n\n### 字段为什么要求定义为not null？\n\nnull值会占用更多的字节，且会在程序中造成很多与预期不符的情况。\n\n### 如果要存储用户的密码散列，应该使用什么字段进行存储？\n\n密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。\n\n### 优化查询过程中的数据访问\n\n- 访问数据太多导致查询性能下降\n- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列\n- 确认MySQL服务器是否在分析大量不必要的数据行\n- 避免犯如下SQL语句错误\n- 查询不需要的数据。解决办法：使用limit解决\n- 多表关联返回全部列。解决办法：指定列名\n- 总是返回全部列。解决办法：避免使用SELECT *\n- 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存\n- 是否在扫描额外的记录。解决办法：\n- 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：\n- 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。\n- 改变数据库和表的结构，修改数据表范式\n- 重写SQL语句，让优化器可以以更优的方式执行查询。\n\n### 优化长难的查询语句\n\n- 一个复杂查询还是多个简单查询\n- MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多\n- 使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。\n- 切分查询\n- 将一个大的查询分为多个小的相同的查询\n- 一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。\n- 分解关联查询，让缓存的效率更高。\n- 执行单个查询可以减少锁的竞争。\n- 在应用层做关联更容易对数据库进行拆分。\n- 查询效率会有大幅提升。\n- 较少冗余记录的查询。\n\n### 优化特定类型的查询语句\n\n- count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)\n- MyISAM中，没有任何where条件的count(*)非常快。\n- 当有where条件时，MyISAM的count统计不一定比其它引擎快。\n- 可以使用explain查询近似值，用近似值替代count(*)\n- 增加汇总表\n- 使用缓存\n\n### 优化关联查询\n\n- 确定ON或者USING子句中是否有索引。\n- 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。\n\n### 优化子查询\n\n- 用关联查询替代\n- 优化GROUP BY和DISTINCT\n- 这两种查询据可以使用索引来优化，是最有效的优化方法\n- 关联查询中，使用标识列分组的效率更高\n- 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。\n- WITH ROLLUP超级聚合，可以挪到应用程序处理\n\n### 优化LIMIT分页\n\n- LIMIT偏移量大的时候，查询效率较低\n- 可以记录上次查询的最大ID，下次查询时直接根据该ID来查询\n\n### 优化UNION查询\n\n- UNION ALL的效率高于UNION\n\n### 优化WHERE子句\n\n解题方法\n\n对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。\n\nSQL语句优化的一些方法？\n\n- 1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\n- 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n\nselect id from t where num is null -- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=\n\n- 3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。\n- 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：\n\nselect id from t where num=10 or num=20 -- 可以这样查询： select id from t where num=10 union all select id from t where num=20\n\n- 5.in 和 not in 也要慎用，否则会导致全表扫描，如：\n\nselect id from t where num in(1,2,3) -- 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3\n\n- 6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。\n- 7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：\n\nselect id from t where num=@num -- 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num\n\n- 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n\nselect id from t where num/2=100 -- 应改为: select id from t where num=100*2\n\n- 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n\nselect id from t where substring(name,1,3)=’abc’ -- name以abc开头的id应改为: select id from t where name like ‘abc%’\n\n- 10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n\n## 数据库优化\n\n### 为什么要优化\n\n- 系统的吞吐量瓶颈往往出现在数据库的访问速度上\n- 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢\n- 数据是存放在磁盘上的，读写速度无法和内存相比\n\n优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。\n\n### 数据库结构优化\n\n一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。\n\n需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。\n\n**将字段很多的表分解成多个表**\n\n对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。\n\n因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。\n\n**增加中间表**\n\n对于需要经常联合查询的表，可以建立中间表以提高查询效率。\n\n通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。\n\n**增加冗余字段**\n\n设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。\n\n表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。\n\n**注意：**\n\n**冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。**\n\n### MySQL数据库cpu飙升到500%的话他怎么处理？\n\n当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。\n\n如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。\n\n一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。\n\n也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等\n\n### 大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\n\n当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n\n1. **限定数据的范围：** 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；\n2. **读/写分离：** 经典的数据库拆分方案，主库负责写，从库负责读；\n3. **缓存：** 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；\n\n还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表\n\n1. **垂直分区：**\n\n   **根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n   **简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。\n\n   \n\n   **垂直拆分的优点：** 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。\n\n   **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；\n\n   #### **垂直分表**\n\n   把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/8ac8af7d9dc343f193e7217671ca6ef1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n   ##### **适用场景**\n\n   - 1、如果一个表中某些列常用，另外一些列不常用\n   - 2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数\n\n   ##### **缺点**\n\n   - 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差\n   - 对于应用层来说，逻辑算法增加开发成本\n   - 管理冗余列，查询所有数据需要join操作\n\n2. **水平分区：**\n\n   **保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n   水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/6f84ed35e4f146e5b701af08889a6230.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n   水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。\n\n   水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨界点Join性能较差，逻辑复杂。\n\n   《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n\n   #### **水平分表：**\n\n   表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/27dc54f85984461ab2cd23d8e3cb3c21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n   ##### **适用场景**\n\n   - 1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。\n   - 2、需要把数据存放在多个介质上。\n\n   ##### **水平切分的缺点**\n\n   - 1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作\n   - 2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数\n\n   **下面补充一下数据库分片的两种常见方案：**\n\n   - **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\n   - **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\n\n**分库分表后面临的问题**\n\n- **事务支持** 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。\n\n- **跨库join**\n\n  只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品\n\n- **跨节点的count,order by,group by以及聚合函数问题** 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。\n\n- **数据迁移，容量规划，扩容等问题** 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。\n\n- **ID问题**\n\n- 一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略\n\n**UUID** 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 **Twitter的分布式自增ID算法Snowflake** 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。\n\n- 跨分片的排序分页\n\n  般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/ef858f4fba43491e986e67a4da939a65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### MySQL的复制原理以及流程\n\n主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。\n\n**主从复制的作用**\n\n1. 主数据库出现问题，可以切换到从数据库。\n2. 可以进行数据库层面的读写分离。\n3. 可以在从数据库上进行日常备份。\n\n**MySQL主从复制解决的问题**\n\n- 数据分布：随意开始或停止复制，并在不同地理位置分布数据备份\n- 负载均衡：降低单个服务器的压力\n- 高可用和故障切换：帮助应用程序避免单点失败\n- 升级测试：可以用更高版本的MySQL作为从库\n\n**MySQL主从复制工作原理**\n\n- 在主库上把数据更高记录到二进制日志\n- 从库将主库的日志复制到自己的中继日志\n- 从库读取中继日志的事件，将其重放到从库数据中\n\n**基本原理流程，3个线程以及之间的关联**\n\n**主**：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；\n\n**从**：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；\n\n**从**：sql执行线程——执行relay log中的语句；\n\n**复制过程**\n\n![](https://img-blog.csdnimg.cn/87fc1db60bec45fa916ebd6b6cd421b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\nBinary log：主数据库的二进制日志\n\nRelay log：从服务器的中继日志\n\n第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。\n\n第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。\n\n第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。\n\n### 读写分离有哪些解决方案？\n\n读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。\n\n**方案一**\n\n使用mysql-proxy代理\n\n优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用\n\n缺点：降低性能， 不支持事务\n\n**方案二**\n\n使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。\n如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。\n\n**方案三**\n\n使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.\n\n缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。\n\n### 备份计划，mysqldump以及xtranbackup的实现原理\n\n**(1)备份计划**\n\n视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。\n\n100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。\n\n**(2)备份恢复时间**\n\n物理备份恢复快，逻辑备份恢复慢\n\n这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考\n\n20G的2分钟（mysqldump）\n\n80G的30分钟(mysqldump)\n\n111G的30分钟（mysqldump)\n\n288G的3小时（xtra)\n\n3T的4小时（xtra)\n\n逻辑导入时间一般是备份时间的5倍以上\n\n**(3)备份恢复失败如何处理**\n\n首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。\n\n**(4)mysqldump和xtrabackup实现原理**\n\nmysqldump\n\nmysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务\n\nXtrabackup:\n\nxtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交\n\n概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事\n\n情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。\n\n### 数据表损坏的修复方式有哪些？\n\n使用 myisamchk 来修复，具体步骤：\n\n- 1）修复前将mysql服务停止。\n- 2）打开命令行方式，然后进入到mysql的/bin目录。\n- 3）执行myisamchk –recover 数据库所在路径/*.MYI\n\n使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）","source":"_posts/MySQL/MySQL面试题.md","raw":"### 为什么要使用数据库\n\n**数据保存在内存**\n\n优点： 存取速度快\n\n缺点： 数据不能永久保存\n\n**数据保存在文件**\n\n优点： 数据永久保存\n\n缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便\n\n**数据保存在数据库**\n\n1）数据永久保存\n\n2）使用SQL语句，查询方便效率高。\n\n3）管理数据方便\n\n### 什么是SQL？\n\n结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。\n\n作用：用于存取数据、查询、更新和管理关系数据库系统。\n\n### 什么是MySQL?\n\nMySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。\n\n### 数据库三大范式是什么\n\n第一范式：每个列都不可以再拆分。\n\n第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。\n\n第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。\n\n在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。\n\n### mysql有关权限的表都有哪几个\n\nMySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：\n\n- user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。\n- db权限表：记录各个帐号在各个数据库上的操作权限。\n- table_priv权限表：记录数据表级的操作权限。\n- columns_priv权限表：记录数据列级的操作权限。\n- host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。\n\n### MySQL的binlog有有几种录入格式？分别有什么区别？\n\n有三种格式，statement，row和mixed。\n\n- statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。\n- row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。\n- mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。\n\n此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。\n\n## 数据类型\n\n### mysql有哪些数据类型\n\n| **分类**             | **类型名称** | **说明**                                                     |\n| :------------------- | :----------- | :----------------------------------------------------------- |\n| **整数类型**         | tinyInt      | 很小的整数(8位二进制)                                        |\n|                      | smallint     | 小的整数(16位二进制)                                         |\n|                      | mediumint    | 中等大小的整数(24位二进制)                                   |\n|                      | int(integer) | 普通大小的整数(32位二进制)                                   |\n| **小数类型**         | float        | 单精度浮点数                                                 |\n|                      | double       | 双精度浮点数                                                 |\n|                      | decimal(m,d) | 压缩严格的定点数                                             |\n| **日期类型**         | year         | YYYY 1901~2155                                               |\n|                      | time         | HH:MM:SS -838:59:59~838:59:59                                |\n|                      | date         | YYYY-MM-DD 1000-01-01~9999-12-3                              |\n|                      | datetime     | YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59 |\n|                      | timestamp    | YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC |\n| **文本、二进制类型** | CHAR(M)      | M为0~255之间的整数                                           |\n|                      | VARCHAR(M)   | M为0~65535之间的整数                                         |\n|                      | TINYBLOB     | 允许长度0~255字节                                            |\n|                      | BLOB         | 允许长度0~65535字节                                          |\n|                      | MEDIUMBLOB   | 允许长度0~167772150字节                                      |\n|                      | LONGBLOB     | 允许长度0~4294967295字节                                     |\n|                      | TINYTEXT     | 允许长度0~255字节                                            |\n|                      | TEXT         | 允许长度0~65535字节                                          |\n|                      | MEDIUMTEXT   | 允许长度0~167772150字节                                      |\n|                      | LONGTEXT     | 允许长度0~4294967295字节                                     |\n|                      | VARBINARY(M) | 允许长度0~M个字节的变长字节字符串                            |\n|                      | BINARY(M)    | 允许长度0~M个字节的定长字节字符串                            |\n\n \n\n- 1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。\n  长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。\n  例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。\n\n- 2、实数类型，包括FLOAT、DOUBLE、DECIMAL。\n  DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。\n  而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。\n  计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。\n\n- 3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB\n  VARCHAR用于存储可变长字符串，它比定长类型更节省空间。\n  VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。\n  VARCHAR存储的内容超出设置的长度时，内容会被截断。\n  CHAR是定长的，根据定义的字符串长度分配足够的空间。\n  CHAR会根据需要使用空格进行填充方便比较。\n  CHAR适合存储很短的字符串，或者所有值都接近同一个长度。\n  CHAR存储的内容超出设置的长度时，内容同样会被截断。\n\n  **使用策略：**\n  对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。\n  对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。\n  使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。\n  尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。\n\n- 4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。\n  有时可以使用ENUM代替常用的字符串类型。\n  ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。\n  ENUM在内部存储时，其实存的是整数。\n  尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。\n  排序是按照内部存储的整数\n\n- 5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，\n  用整数保存时间戳通常不方便处理。\n  如果需要存储微妙，可以使用bigint存储。\n  看到这里，这道真题是不是就比较容易回答了。\n\n## 引擎\n\n### MySQL存储引擎MyISAM与InnoDB区别\n\n存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。\n\n常用的存储引擎有以下：\n\n- **Innodb引擎**：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。\n- **MyIASM引擎**(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。\n- **MEMORY引擎**：所有的数据都在内存中，数据的处理速度快，但是安全性不高。\n\n**MyISAM与InnoDB区别**\n\n|                                                              | **MyISAM**                                                   | **Innodb**                                                   |\n| :----------------------------------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |\n| 存储结构                                                     | 每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件 | 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB |\n| 存储空间                                                     | MyISAM可被压缩，存储空间较小                                 | InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 |\n| 可移植性、备份及恢复                                         | 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 | 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 |\n| 文件格式                                                     | 数据和索引是分别存储的，数据.MYD，索引.MYI                   | 数据和索引是集中存储的，.ibd                                 |\n| 记录存储顺序                                                 | 按记录插入顺序保存                                           | 按主键大小有序插入                                           |\n| 外键                                                         | 不支持                                                       | 支持                                                         |\n| 事务                                                         | 不支持                                                       | 支持                                                         |\n| 锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的） | 表级锁定                                                     | 行级锁定、表级锁定，锁定力度小并发能力高                     |\n| SELECT                                                       | MyISAM更优                                                   |                                                              |\n| INSERT、UPDATE、DELETE                                       |                                                              | InnoDB更优                                                   |\n| select count(*)                                              | myisam更快，因为myisam内部维护了一个计数器，可以直接调取。   |                                                              |\n| 索引的实现方式                                               | B+树索引，myisam 是堆表                                      | B+树索引，Innodb 是索引组织表                                |\n| 哈希索引                                                     | 不支持                                                       | 支持                                                         |\n| 全文索引                                                     | 支持                                                         | 不支持                                                       |\n\n### MyISAM索引与InnoDB索引的区别？\n\n- InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。\n- InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。\n- MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。\n- InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。\n\n### InnoDB引擎的4大特性\n\n- 插入缓冲（insert buffer)\n- 二次写(double write)\n- 自适应哈希索引(ahi)\n- 预读(read ahead)\n\n### 存储引擎选择\n\n如果没有特别的需求，使用默认的Innodb即可。\n\nMyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。\n\nInnodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。\n\n## 索引\n\n### 什么是索引？\n\n索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。\n\n索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。\n\n更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。\n\n### 索引有哪些优缺点？\n\n索引的优点\n\n- 可以大大加快数据的检索速度，这也是创建索引的最主要的原因。\n- 通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。\n\n索引的缺点\n\n- 时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；\n- 空间方面：索引需要占物理空间。\n\n### 索引使用场景（重点）\n\nwhere\n\n![](https://img-blog.csdnimg.cn/0bd245252090436dbd84297a3be0d304.png)\n\n上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。\n\n-- 增加一个没有建立索引的字段 alter table innodb1 add sex char(1); -- 按sex检索时可选的索引为null EXPLAIN SELECT * from innodb1 where sex='男';\n\n![](https://img-blog.csdnimg.cn/191753c4800e4ba28295a4257bbc57f7.png)\n\n> 可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。\n\norder by\n\n当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。\n\n但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用**取出索引表某个范围内的索引对应的数据**，而不用像上述那**取出所有数据**进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）\n\njoin\n\n> 对join语句匹配关系（on）涉及的字段建立索引能够提高效率\n\n索引覆盖\n\n如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。\n\n这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。\n\n### 索引有哪几种类型？\n\n**主键索引:** 数据列不允许重复，不允许为NULL，一个表只能有一个主键。\n\n**唯一索引:** 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。\n\n- 可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引\n- 可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引\n\n**普通索引:** 基本的索引类型，没有唯一性的限制，允许为NULL值。\n\n- 可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引\n- 可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引\n\n**全文索引：** 是目前搜索引擎使用的一种关键技术。\n\n- 可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引\n\n### 索引的数据结构（b树，hash）\n\n索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有**Hash索引**，**B+树索引**等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。\n\n1）B树索引\n\nmysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）\n\n![](https://img-blog.csdnimg.cn/1cbeb7fd870e48b3aa2f8399577b13bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n查询方式：\n\n主键索引区:PI(关联保存的时数据的地址)按主键查询,\n\n普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快\n\nB+tree性质：\n\n1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。\n\n2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。\n\n3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。\n\n4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。\n\n5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。\n\n2）哈希索引\n\n简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。\n\n![](https://img-blog.csdnimg.cn/0336f3cd247249a6af5a4be815d791e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_15,color_FFFFFF,t_70,g_se,x_16)\n\n### 索引的基本原理\n\n索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。\n\n索引的原理很简单，就是把无序的数据变成有序的查询\n\n1. 把创建了索引的列的内容进行排序\n2. 对排序结果生成倒排表\n3. 在倒排表内容上拼上数据地址链\n4. 在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据\n\n### 索引算法有哪些？\n\n索引算法有 BTree算法和Hash算法\n\n**BTree算法**\n\nBTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,>,>=,<,<=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：\n\n-- 只要它的查询条件是一个不以通配符开头的常量 select * from user where name like 'jack%'; -- 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like '%jack';\n\n**Hash算法**\n\nHash Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。\n\n### 索引设计的原则？\n\n1. 适合索引的列是出现在where子句中的列，或者连接子句中指定的列\n2. 基数较小的类，索引效果较差，没有必要在此列建立索引\n3. 使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间\n4. 不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。\n\n### 创建索引的原则（重中之重）\n\n索引虽好，但也不是无限制的使用，最好符合一下几个原则\n\n1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\n\n2）较频繁作为查询条件的字段才去创建索引\n\n3）更新频繁字段不适合创建索引\n\n4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)\n\n5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。\n\n6）定义有外键的数据列一定要建立索引。\n\n7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。\n\n8）对于定义为text、image和bit的数据类型的列不要建立索引。\n\n### 创建索引的三种方式，删除索引\n\n第一种方式：在执行CREATE TABLE时创建索引\n\nCREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );\n\n第二种方式：使用ALTER TABLE命令去增加索引\n\nALTER TABLE table_name ADD INDEX index_name (column_list);\n\nALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。\n\n其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。\n\n索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。\n\n第三种方式：使用CREATE INDEX命令创建\n\nCREATE INDEX index_name ON table_name (column_list);\n\nCREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）\n\n删除索引\n\n根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名\n\nalter table user_index drop KEY name; alter table user_index drop KEY id_card; alter table user_index drop KEY information;\n\n删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：\n\n![](https://img-blog.csdnimg.cn/fae6723844de418cb597facb6497d2c7.png)\n\n需要取消自增长再行删除：\n\nalter table user_index -- 重新定义字段 MODIFY id int, drop PRIMARY KEY\n\n但通常不会删除主键，因为设计主键一定与业务逻辑无关。\n\n### 创建索引时需要注意什么？\n\n- 非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；\n- 取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；\n- 索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。\n\n### 使用索引查询一定能提高查询的性能吗？为什么\n\n通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。\n\n- 索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:\n- 基于一个范围的检索，一般查询返回结果集小于表中记录数的30%\n- 基于非唯一性索引的检索\n\n### 百万级别或以上的数据如何删除\n\n关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。\n\n1. 所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）\n2. 然后删除其中无用数据（此过程需要不到两分钟）\n3. 删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。\n4. 与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。\n\n### 前缀索引\n\n语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。\n\n前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。\n\n实操的难度：在于前缀截取的长度。\n\n我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）\n\n### 什么是最左前缀原则？什么是最左匹配原则\n\n- 顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。\n- 最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。\n- =和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式\n\n### B树和B+树的区别\n\n- 在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。\n\n- B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。\n\n  ![](https://img-blog.csdnimg.cn/3cf2b460c14745fcae0c390859d74324.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### 使用B树的好处\n\nB树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。\n\n### 使用B+树的好处\n\n由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间\n\n### Hash索引和B+树所有有什么区别或者说优劣呢?\n\n首先要知道Hash索引和B+树索引的底层实现原理：\n\nhash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。\n\n那么可以看出他们有以下的不同：\n\n- hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。\n\n因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。\n\n- hash索引不支持使用索引进行排序，原理同上。\n- hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。\n- hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。\n- hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。\n\n因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。\n\n### 数据库为什么使用B+树而不是B树\n\n- B树只适合随机检索，而B+树同时支持随机检索和顺序检索；\n- B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；\n- B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。\n- B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。\n- 增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。\n\n### B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\n\n在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。\n\n当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。\n\n### 什么是聚簇索引？何时使用聚簇索引与非聚簇索引\n\n- 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据\n- 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因\n\n澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值\n\n何时使用聚簇索引与非聚簇索引\n\n![](https://img-blog.csdnimg.cn/54d88ff9fc2c48588d04ca76611f8ecc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### 非聚簇索引一定会回表查询吗？\n\n不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。\n\n举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age < 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。\n\n### 联合索引是什么？为什么需要注意联合索引中的顺序？\n\nMySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。\n\n具体原因为:\n\nMySQL使用索引时需要索引有序，假设现在建立了\"name，age，school\"的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。\n\n当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。\n\n## 事务\n\n### 什么是数据库事务？\n\n事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。\n\n事务最经典也经常被拿出来说例子就是转账了。\n\n假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n\n### 事物的四大特性(ACID)介绍一下?\n\n关系性数据库需要遵循ACID规则，具体内容如下：\n\n![](https://img-blog.csdnimg.cn/9a1d7c93ca874557911ae2cb578dcb4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_10,color_FFFFFF,t_70,g_se,x_16)\n\n1. **原子性：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n\n2. **一致性：** 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；\n\n3. **隔离性：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/9a95f01f0e8c41a88e210e387a98da47.png)\n\n   \n\n4. **持久性：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n### 什么是脏读？幻读？不可重复读？\n\n- 脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。\n- 不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。\n- 幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。\n\n### 什么是事务的隔离级别？MySQL的默认隔离级别是什么？\n\n为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。\n\n**隔离级别****脏读****不可重复读****幻影读**READ-UNCOMMITTED√√√READ-COMMITTED×√√REPEATABLE-READ××√SERIALIZABLE×××\n\n**SQL 标准定义了四个隔离级别：**\n\n- **READ-UNCOMMITTED(读取未提交)：** 最低的隔离级别，允许读取尚未提交的数据变更，**可能会导致脏读、幻读或不可重复读**。\n- **READ-COMMITTED(读取已提交)：** 允许读取并发事务已经提交的数据，**可以阻止脏读，但是幻读或不可重复读仍有可能发生**。\n- **REPEATABLE-READ(可重复读)：** 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，**可以阻止脏读和不可重复读，但幻读仍有可能发生**。\n- **SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，**该级别可以防止脏读、不可重复读以及幻读**。\n\n这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别\n\n事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。\n\n因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。\n\nInnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。\n\n## 锁\n\n### 对MySQL的锁了解吗\n\n当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。\n\n就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。\n\n### 隔离级别与锁的关系\n\n在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突\n\n在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；\n\n在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。\n\nSERIALIZABLE 是限制性最强的隔离级别，因为该级别**锁定整个范围的键**，并一直持有锁，直到事务完成。\n\n### 按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\n\n在关系型数据库中，可以**按照锁的粒度把数据库锁分**为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。\n\n**MyISAM和InnoDB存储引擎使用的锁：**\n\n- MyISAM采用表级锁(table-level locking)。\n- InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁\n\n行级锁，表级锁和页级锁对比\n\n**行级锁** 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。\n\n特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。\n\n**表级锁** 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。\n\n特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。\n\n**页级锁** 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。\n\n特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般\n\n### 从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\n\n**从锁的类别上来讲**，有共享锁和排他锁。\n\n共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。\n\n排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。\n\n用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。\n\n锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。\n\n他们的加锁开销从大到小，并发能力也是从大到小。\n\n### MySQL中InnoDB引擎的行锁是怎么实现的？\n\n答：InnoDB是基于索引来完成行锁\n\n例: select * from tab_with_index where id = 1 for update;\n\nfor update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起\n\n### InnoDB存储引擎的锁的算法有三种\n\n- Record lock：单个行记录上的锁\n- Gap lock：间隙锁，锁定一个范围，不包括记录本身\n- Next-key lock：record+gap 锁定一个范围，包含记录本身\n\n**相关知识点：**\n\n1. innodb对于行的查询使用next-key lock\n2. Next-locking keying为了解决Phantom Problem幻读问题\n3. 当查询的索引含有唯一属性时，将next-key lock降级为record key\n4. Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生\n5. 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1\n\n### 什么是死锁？怎么解决？\n\n死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。\n\n常见的解决死锁的方法\n\n1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。\n\n2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；\n\n3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；\n\n如果业务处理不好可以用分布式事务锁或者使用乐观锁\n\n### 数据库的乐观锁和悲观锁是什么？怎么实现的？\n\n数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。\n\n**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制\n\n**乐观锁**：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。\n\n**两种锁的使用场景**\n\n从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。\n\n但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**\n\n## 视图\n\n### 为什么要使用视图？什么是视图？\n\n为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。\n\n视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。\n\n### 视图有哪些特点？\n\n视图的特点如下:\n\n- 视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。\n- 视图是由基本表(实表)产生的表(虚表)。\n- 视图的建立和删除不影响基本表。\n- 对视图内容的更新(添加，删除和修改)直接影响基本表。\n- 当视图来自多个基本表时，不允许添加和删除数据。\n\n视图的操作包括创建视图，查看视图，删除视图和修改视图。\n\n### 视图的使用场景有哪些？\n\n视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。\n\n下面是视图的常见使用场景：\n\n- 重用SQL语句；\n- 简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；\n- 使用表的组成部分而不是整个表；\n- 保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；\n- 更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。\n\n### 视图的优点\n\n1. 查询简单化。视图能简化用户的操作\n2. 数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护\n3. 逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性\n\n### 视图的缺点\n\n1. 性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。\n\n2. 修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的\n\n   这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\\SUM\\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）\n\n### 什么是游标？\n\n游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。\n\n## 存储过程与函数\n\n### 什么是存储过程？有哪些优缺点？\n\n存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。\n\n**优点**\n\n1）存储过程是预编译过的，执行效率高。\n\n2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。\n\n3）安全性高，执行存储过程需要有一定权限的用户。\n\n4）存储过程可以重复使用，减少数据库开发人员的工作量。\n\n**缺点**\n\n1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。\n\n2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。\n\n3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。\n\n4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。\n\n## 触发器\n\n### 什么是触发器？触发器的使用场景有哪些？\n\n触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。\n\n使用场景\n\n- 可以通过数据库中的相关表实现级联更改。\n- 实时监控某张表中的某个字段的更改而需要做出相应的处理。\n- 例如可以生成某些业务的编号。\n- 注意不要滥用，否则会造成数据库及应用程序的维护困难。\n- 大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。\n\n### MySQL中都有哪些触发器？\n\n在MySQL数据库中有如下六种触发器：\n\n- Before Insert\n- After Insert\n- Before Update\n- After Update\n- Before Delete\n- After Delete\n\n## 常用SQL语句\n\n### SQL语句主要分为哪几类\n\n数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER\n\n主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。\n\n数据查询语言DQL（Data Query Language）SELECT\n\n这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。\n\n数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE\n\n主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。\n\n数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK\n\n主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。\n\n### 超键、候选键、主键、外键分别是什么？\n\n- 超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。\n- 候选键：是最小超键，即没有冗余元素的超键。\n- 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。\n- 外键：在一个表中存在的另一个表的主键称此表的外键。\n\n### SQL 约束有哪几种？\n\n> SQL 约束有哪几种？\n\n- NOT NULL: 用于控制字段的内容一定不能为空（NULL）。\n- UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。\n- PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。\n- FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。\n- CHECK: 用于控制字段的值范围。\n\n### 六种关联查询\n\n- 交叉连接（CROSS JOIN）\n- 内连接（INNER JOIN）\n- 外连接（LEFT JOIN/RIGHT JOIN）\n- 联合查询（UNION与UNION ALL）\n- 全连接（FULL JOIN）\n- 交叉连接（CROSS JOIN）\n\nSELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN\n\n内连接分为三类\n\n- 等值连接：ON A.id=B.id\n- 不等值连接：ON A.id > B.id\n- 自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid\n\n外连接（LEFT JOIN/RIGHT JOIN）\n\n- 左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN\n- 右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN\n\n联合查询（UNION与UNION ALL）\n\nSELECT * FROM A UNION SELECT * FROM B UNION ...\n\n- 就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并\n- 如果使用UNION ALL，不会合并重复的记录行\n- 效率 UNION 高于 UNION ALL\n\n全连接（FULL JOIN）\n\n- MySQL不支持全连接\n- 可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用\n\nSELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id\n\n表连接面试题\n\n有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。\n\nR表\n\n| **A** | **B** | **C** |\n| :---- | :---- | :---- |\n| a1    | b1    | c1    |\n| a2    | b2    | c2    |\n| a3    | b3    | c3    |\n\nS表\n\n| **C** | **D** |\n| :---- | :---- |\n| c1    | d1    |\n| c2    | d2    |\n| c4    | d3    |\n\n \n\n1. 交叉连接(笛卡尔积):\n\nselect r.*,s.* from r,s\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c1    | d1    |\n| a3    | b3    | c3    | c1    | d1    |\n| a1    | b1    | c1    | c2    | d2    |\n| a2    | b2    | c2    | c2    | d2    |\n| a3    | b3    | c3    | c2    | d2    |\n| a1    | b1    | c1    | c4    | d3    |\n| a2    | b2    | c2    | c4    | d3    |\n| a3    | b3    | c3    | c4    | d3    |\n\n \n\n1. 内连接结果：\n\n   select r.*,s.* from r inner join s on r.c=s.c\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c2    | d2    |\n\n \n\n1. 左连接结果：\n\n   select r.*,s.* from r left join s on r.c=s.c\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c2    | d2    |\n| a3    | b3    | c3    |       |       |\n\n \n\n1. 右连接结果：\n\n   select r.*,s.* from r right join s on r.c=s.c\n\n|      |      |      |      |      |\n| :--- | :--- | :--- | :--- | :--- |\n| A    | B    | C    | C    | D    |\n| a1   | b1   | c1   | c1   | d1   |\n| a2   | b2   | c2   | c2   | d2   |\n|      |      |      | c4   | d3   |\n\n \n\n1. 全表连接的结果（MySql不支持，Oracle支持）：\n\n   select r.*,s.* from r full join s on r.c=s.c\n\n| **A** | **B** | **C** | **C** | **D** |\n| :---- | :---- | :---- | :---- | :---- |\n| a1    | b1    | c1    | c1    | d1    |\n| a2    | b2    | c2    | c2    | d2    |\n| a3    | b3    | c3    |       |       |\n|       |       |       | c4    | d3    |\n\n \n\n### 什么是子查询\n\n1. 条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果\n2. 嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。\n\n### 子查询的三种情况\n\n1. 子查询是单行单列的情况：结果集是一个值，父查询使用：=、 <、 > 等运算符\n\n-- 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);\n\n1. 子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符\n\n-- 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);\n\n1. 子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表\n\n-- 1) 查询出2011年以后入职的员工信息 -- 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。 select * from dept d, (select * from employee where join_date > '2011-1-1') e where e.dept_id = d.id; -- 使用表连接： select d.*, e.* from dept d inner join employee e on d.id = e.dept_id where e.join_date > '2011-1-1'\n\n### mysql中 in 和 exists 区别\n\nmysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。\n\n1. 如果查询的两个表大小相当，那么用in和exists差别不大。\n2. 如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。\n3. not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。\n\n### varchar与char的区别\n\n**char的特点**\n\n- char表示定长字符串，长度是固定的；\n- 如果插入数据的长度小于char的固定长度时，则用空格填充；\n- 因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；\n- 对于char来说，最多能存放的字符个数为255，和编码无关\n\n**varchar的特点**\n\n- varchar表示可变长字符串，长度是可变的；\n- 插入的数据是多长，就按照多长来存储；\n- varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；\n- 对于varchar来说，最多能存放的字符个数为65532\n\n总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。\n\n### varchar(50)中50的涵义\n\n最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。\n\n### int(20)中20的涵义\n\n是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；\n\n不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示\n\n### mysql为什么这么设计\n\n对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；\n\n### mysql中int(10)和char(10)以及varchar(10)的区别\n\n- int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。\n\n  int(10) 10位的数据长度 9999999999，占32个字节，int型4位\n  char(10) 10位固定字符串，不足补空格 最多10个字符\n  varchar(10) 10位可变字符串，不足补空格 最多10个字符\n\n- char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间\n\n- varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符\n\n### FLOAT和DOUBLE的区别是什么？\n\n- FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。\n- DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。\n\n### drop、delete与truncate的区别\n\n三者都表示删除，但是三者有一些差别：\n\n|          | **Delete**                               | **Truncate**                   | **Drop**                                             |\n| :------- | :--------------------------------------- | :----------------------------- | :--------------------------------------------------- |\n| 类型     | 属于DML                                  | 属于DDL                        | 属于DDL                                              |\n| 回滚     | 可回滚                                   | 不可回滚                       | 不可回滚                                             |\n| 删除内容 | 表结构还在，删除表的全部或者一部分数据行 | 表结构还在，删除表中的所有数据 | 从数据库中删除表，所有的数据行，索引和权限也会被删除 |\n| 删除速度 | 删除速度慢，需要逐行删除                 | 删除速度快                     | 删除速度最快                                         |\n\n \n\n因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。\n\n### UNION与UNION ALL的区别？\n\n- 如果使用UNION ALL，不会合并重复的记录行\n- 效率 UNION 高于 UNION ALL\n\n## SQL优化\n\n### 如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？\n\n对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，**对于查询语句，最重要的优化方式就是使用索引**。 而**执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等**。\n\n![](https://img-blog.csdnimg.cn/3762f1f867ab421aa5a4e3e8328e0b8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n执行计划包含的信息 **id** 有一组数字组成。表示一个查询中各个子查询的执行顺序;\n\n- id相同执行顺序由上至下。\n- id不同，id值越大优先级越高，越先被执行。\n- id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。\n\n**select_type** 每个子查询的查询类型，一些常见的查询类型。\n\n| **id** | **select_type** | **description**                           |\n| :----- | :-------------- | :---------------------------------------- |\n| 1      | SIMPLE          | 不包含任何子查询或union等查询             |\n| 2      | PRIMARY         | 包含子查询最外层查询就显示为 PRIMARY      |\n| 3      | SUBQUERY        | 在select或 where字句中包含的查询          |\n| 4      | DERIVED         | from字句中包含的查询                      |\n| 5      | UNION           | 出现在union后的查询语句中                 |\n| 6      | UNION RESULT    | 从UNION中获取结果集，例如上文的第三个例子 |\n\n \n\n**table** 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id **partitions** 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：\n\ncreate table tmp ( id int unsigned not null AUTO_INCREMENT, name varchar(255), PRIMARY KEY (id) ) engine = innodb partition by key (id) partitions 5;\n\n**type**(非常重要，可以看到有没有走索引) 访问类型\n\n- ALL 扫描全表数据\n- index 遍历索引\n- range 索引范围查找\n- index_subquery 在子查询中使用 ref\n- unique_subquery 在子查询中使用 eq_ref\n- ref_or_null 对Null进行索引的优化的 ref\n- fulltext 使用全文索引\n- ref 使用非唯一索引查找数据\n- eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。\n\n**possible_keys** 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。\n\n**key** 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。\n\n**TIPS**:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中\n\n**key_length** 索引长度\n\n**ref** 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值\n\n**rows** 返回估算的结果集数目，并不是一个准确的值。\n\n**extra** 的信息非常丰富，常见的有：\n\n1. Using index 使用覆盖索引\n2. Using where 使用了用where子句来过滤结果集\n3. Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。\n4. Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册\n\n【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。\n\n### SQL的生命周期？\n\n1. 应用服务器与数据库服务器建立一个连接\n\n2. 数据库进程拿到请求sql\n\n3. 解析并生成执行计划，执行\n\n4. 读取数据到内存并进行逻辑处理\n\n5. 通过步骤一的连接，发送结果到客户端\n\n6. 关掉连接，释放资源\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/86be8bfa609d4a909568f3b64ec891d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### 大表数据查询，怎么优化\n\n1. 优化shema、sql语句+索引；\n2. 第二加缓存，memcached, redis；\n3. 主从复制，读写分离；\n4. 垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；\n5. 水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；\n\n### 超大分页怎么处理？\n\n超大的分页一般从两个方向上来解决.\n\n- 数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age > 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age > 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id > 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.\n- 从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.\n\n解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.\n\n在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.\n\n【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id\n\n### mysql 分页\n\nLIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)\n\nmysql> SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15\n\n为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：\n\nmysql> SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.\n\n如果只给定一个参数，它表示返回最大的记录行数目：\n\nmysql> SELECT * FROM table LIMIT 5; //检索前 5 个记录行\n\n换句话说，LIMIT n 等价于 LIMIT 0,n。\n\n### 慢查询日志\n\n> 用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。\n\n开启慢查询日志\n\n配置项：slow_query_log\n\n可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。\n\n设置临界时间\n\n配置项：long_query_time\n\n查看：show VARIABLES like 'long_query_time'，单位秒\n\n设置：set long_query_time=0.5\n\n实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉\n\n查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中\n\n### 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\n\n在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。\n\n慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？\n\n所以优化也是针对这三个方向来的，\n\n- 首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。\n- 分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。\n- 如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。\n\n### 为什么要尽量设定一个主键？\n\n主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。\n\n### 主键使用自增ID还是UUID？\n\n推荐使用自增ID，不要使用UUID。\n\n因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。\n\n总之，在数据量大一些的情况下，用自增主键性能会好一些。\n\n关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。\n\n### 字段为什么要求定义为not null？\n\nnull值会占用更多的字节，且会在程序中造成很多与预期不符的情况。\n\n### 如果要存储用户的密码散列，应该使用什么字段进行存储？\n\n密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。\n\n### 优化查询过程中的数据访问\n\n- 访问数据太多导致查询性能下降\n- 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列\n- 确认MySQL服务器是否在分析大量不必要的数据行\n- 避免犯如下SQL语句错误\n- 查询不需要的数据。解决办法：使用limit解决\n- 多表关联返回全部列。解决办法：指定列名\n- 总是返回全部列。解决办法：避免使用SELECT *\n- 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存\n- 是否在扫描额外的记录。解决办法：\n- 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：\n- 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。\n- 改变数据库和表的结构，修改数据表范式\n- 重写SQL语句，让优化器可以以更优的方式执行查询。\n\n### 优化长难的查询语句\n\n- 一个复杂查询还是多个简单查询\n- MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多\n- 使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。\n- 切分查询\n- 将一个大的查询分为多个小的相同的查询\n- 一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。\n- 分解关联查询，让缓存的效率更高。\n- 执行单个查询可以减少锁的竞争。\n- 在应用层做关联更容易对数据库进行拆分。\n- 查询效率会有大幅提升。\n- 较少冗余记录的查询。\n\n### 优化特定类型的查询语句\n\n- count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)\n- MyISAM中，没有任何where条件的count(*)非常快。\n- 当有where条件时，MyISAM的count统计不一定比其它引擎快。\n- 可以使用explain查询近似值，用近似值替代count(*)\n- 增加汇总表\n- 使用缓存\n\n### 优化关联查询\n\n- 确定ON或者USING子句中是否有索引。\n- 确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。\n\n### 优化子查询\n\n- 用关联查询替代\n- 优化GROUP BY和DISTINCT\n- 这两种查询据可以使用索引来优化，是最有效的优化方法\n- 关联查询中，使用标识列分组的效率更高\n- 如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。\n- WITH ROLLUP超级聚合，可以挪到应用程序处理\n\n### 优化LIMIT分页\n\n- LIMIT偏移量大的时候，查询效率较低\n- 可以记录上次查询的最大ID，下次查询时直接根据该ID来查询\n\n### 优化UNION查询\n\n- UNION ALL的效率高于UNION\n\n### 优化WHERE子句\n\n解题方法\n\n对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。\n\nSQL语句优化的一些方法？\n\n- 1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。\n- 2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：\n\nselect id from t where num is null -- 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=\n\n- 3.应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描。\n- 4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：\n\nselect id from t where num=10 or num=20 -- 可以这样查询： select id from t where num=10 union all select id from t where num=20\n\n- 5.in 和 not in 也要慎用，否则会导致全表扫描，如：\n\nselect id from t where num in(1,2,3) -- 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3\n\n- 6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。\n- 7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：\n\nselect id from t where num=@num -- 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num\n\n- 8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n\nselect id from t where num/2=100 -- 应改为: select id from t where num=100*2\n\n- 9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：\n\nselect id from t where substring(name,1,3)=’abc’ -- name以abc开头的id应改为: select id from t where name like ‘abc%’\n\n- 10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。\n\n## 数据库优化\n\n### 为什么要优化\n\n- 系统的吞吐量瓶颈往往出现在数据库的访问速度上\n- 随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢\n- 数据是存放在磁盘上的，读写速度无法和内存相比\n\n优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。\n\n### 数据库结构优化\n\n一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。\n\n需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。\n\n**将字段很多的表分解成多个表**\n\n对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。\n\n因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。\n\n**增加中间表**\n\n对于需要经常联合查询的表，可以建立中间表以提高查询效率。\n\n通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。\n\n**增加冗余字段**\n\n设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。\n\n表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。\n\n**注意：**\n\n**冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。**\n\n### MySQL数据库cpu飙升到500%的话他怎么处理？\n\n当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。\n\n如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。\n\n一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。\n\n也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等\n\n### 大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\n\n当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n\n1. **限定数据的范围：** 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；\n2. **读/写分离：** 经典的数据库拆分方案，主库负责写，从库负责读；\n3. **缓存：** 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；\n\n还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表\n\n1. **垂直分区：**\n\n   **根据数据库里面数据表的相关性进行拆分。** 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。\n\n   **简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。** 如下图所示，这样来说大家应该就更容易理解了。\n\n   \n\n   **垂直拆分的优点：** 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。\n\n   **垂直拆分的缺点：** 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；\n\n   #### **垂直分表**\n\n   把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/8ac8af7d9dc343f193e7217671ca6ef1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n   ##### **适用场景**\n\n   - 1、如果一个表中某些列常用，另外一些列不常用\n   - 2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数\n\n   ##### **缺点**\n\n   - 有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差\n   - 对于应用层来说，逻辑算法增加开发成本\n   - 管理冗余列，查询所有数据需要join操作\n\n2. **水平分区：**\n\n   **保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。**\n\n   水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/6f84ed35e4f146e5b701af08889a6230.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n   水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 **水平拆分最好分库** 。\n\n   水平拆分能够 **支持非常大的数据量存储，应用端改造也少**，但 **分片事务难以解决** ，跨界点Join性能较差，逻辑复杂。\n\n   《Java工程师修炼之道》的作者推荐 **尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度** ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n\n   #### **水平分表：**\n\n   表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数\n\n   ![在这里插入图片描述](https://img-blog.csdnimg.cn/27dc54f85984461ab2cd23d8e3cb3c21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n   ##### **适用场景**\n\n   - 1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。\n   - 2、需要把数据存放在多个介质上。\n\n   ##### **水平切分的缺点**\n\n   - 1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作\n   - 2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数\n\n   **下面补充一下数据库分片的两种常见方案：**\n\n   - **客户端代理：** **分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。** 当当网的 **Sharding-JDBC** 、阿里的TDDL是两种比较常用的实现。\n   - **中间件代理：** **在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。** 我们现在谈的 **Mycat** 、360的Atlas、网易的DDB等等都是这种架构的实现。\n\n**分库分表后面临的问题**\n\n- **事务支持** 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。\n\n- **跨库join**\n\n  只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品\n\n- **跨节点的count,order by,group by以及聚合函数问题** 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。\n\n- **数据迁移，容量规划，扩容等问题** 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。\n\n- **ID问题**\n\n- 一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略\n\n**UUID** 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 **Twitter的分布式自增ID算法Snowflake** 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。\n\n- 跨分片的排序分页\n\n  般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：\n\n  ![在这里插入图片描述](https://img-blog.csdnimg.cn/ef858f4fba43491e986e67a4da939a65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\n### MySQL的复制原理以及流程\n\n主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。\n\n**主从复制的作用**\n\n1. 主数据库出现问题，可以切换到从数据库。\n2. 可以进行数据库层面的读写分离。\n3. 可以在从数据库上进行日常备份。\n\n**MySQL主从复制解决的问题**\n\n- 数据分布：随意开始或停止复制，并在不同地理位置分布数据备份\n- 负载均衡：降低单个服务器的压力\n- 高可用和故障切换：帮助应用程序避免单点失败\n- 升级测试：可以用更高版本的MySQL作为从库\n\n**MySQL主从复制工作原理**\n\n- 在主库上把数据更高记录到二进制日志\n- 从库将主库的日志复制到自己的中继日志\n- 从库读取中继日志的事件，将其重放到从库数据中\n\n**基本原理流程，3个线程以及之间的关联**\n\n**主**：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；\n\n**从**：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；\n\n**从**：sql执行线程——执行relay log中的语句；\n\n**复制过程**\n\n![](https://img-blog.csdnimg.cn/87fc1db60bec45fa916ebd6b6cd421b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16)\n\nBinary log：主数据库的二进制日志\n\nRelay log：从服务器的中继日志\n\n第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。\n\n第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。\n\n第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。\n\n### 读写分离有哪些解决方案？\n\n读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。\n\n**方案一**\n\n使用mysql-proxy代理\n\n优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用\n\n缺点：降低性能， 不支持事务\n\n**方案二**\n\n使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。\n如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。\n\n**方案三**\n\n使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.\n\n缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。\n\n### 备份计划，mysqldump以及xtranbackup的实现原理\n\n**(1)备份计划**\n\n视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。\n\n100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。\n\n**(2)备份恢复时间**\n\n物理备份恢复快，逻辑备份恢复慢\n\n这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考\n\n20G的2分钟（mysqldump）\n\n80G的30分钟(mysqldump)\n\n111G的30分钟（mysqldump)\n\n288G的3小时（xtra)\n\n3T的4小时（xtra)\n\n逻辑导入时间一般是备份时间的5倍以上\n\n**(3)备份恢复失败如何处理**\n\n首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。\n\n**(4)mysqldump和xtrabackup实现原理**\n\nmysqldump\n\nmysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务\n\nXtrabackup:\n\nxtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交\n\n概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事\n\n情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。\n\n### 数据表损坏的修复方式有哪些？\n\n使用 myisamchk 来修复，具体步骤：\n\n- 1）修复前将mysql服务停止。\n- 2）打开命令行方式，然后进入到mysql的/bin目录。\n- 3）执行myisamchk –recover 数据库所在路径/*.MYI\n\n使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）","slug":"MySQL/MySQL面试题","published":1,"date":"2022-03-17T01:26:24.198Z","updated":"2022-03-17T01:26:24.198Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"cl0ubchsx0000rdji87z7530a","content":"<h3 id=\"为什么要使用数据库\"><a href=\"#为什么要使用数据库\" class=\"headerlink\" title=\"为什么要使用数据库\"></a>为什么要使用数据库</h3><p><strong>数据保存在内存</strong></p>\n<p>优点： 存取速度快</p>\n<p>缺点： 数据不能永久保存</p>\n<p><strong>数据保存在文件</strong></p>\n<p>优点： 数据永久保存</p>\n<p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p>\n<p><strong>数据保存在数据库</strong></p>\n<p>1）数据永久保存</p>\n<p>2）使用SQL语句，查询方便效率高。</p>\n<p>3）管理数据方便</p>\n<h3 id=\"什么是SQL？\"><a href=\"#什么是SQL？\" class=\"headerlink\" title=\"什么是SQL？\"></a>什么是SQL？</h3><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p>\n<p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>\n<h3 id=\"什么是MySQL\"><a href=\"#什么是MySQL\" class=\"headerlink\" title=\"什么是MySQL?\"></a>什么是MySQL?</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>\n<h3 id=\"数据库三大范式是什么\"><a href=\"#数据库三大范式是什么\" class=\"headerlink\" title=\"数据库三大范式是什么\"></a>数据库三大范式是什么</h3><p>第一范式：每个列都不可以再拆分。</p>\n<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>\n<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>\n<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>\n<h3 id=\"mysql有关权限的表都有哪几个\"><a href=\"#mysql有关权限的表都有哪几个\" class=\"headerlink\" title=\"mysql有关权限的表都有哪几个\"></a>mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>\n<ul>\n<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>\n<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>\n<li>table_priv权限表：记录数据表级的操作权限。</li>\n<li>columns_priv权限表：记录数据列级的操作权限。</li>\n<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>\n</ul>\n<h3 id=\"MySQL的binlog有有几种录入格式？分别有什么区别？\"><a href=\"#MySQL的binlog有有几种录入格式？分别有什么区别？\" class=\"headerlink\" title=\"MySQL的binlog有有几种录入格式？分别有什么区别？\"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>有三种格式，statement，row和mixed。</p>\n<ul>\n<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>\n<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>\n<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>\n</ul>\n<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"mysql有哪些数据类型\"><a href=\"#mysql有哪些数据类型\" class=\"headerlink\" title=\"mysql有哪些数据类型\"></a>mysql有哪些数据类型</h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>分类</strong></th>\n<th align=\"left\"><strong>类型名称</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>整数类型</strong></td>\n<td align=\"left\">tinyInt</td>\n<td align=\"left\">很小的整数(8位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">smallint</td>\n<td align=\"left\">小的整数(16位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">mediumint</td>\n<td align=\"left\">中等大小的整数(24位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">int(integer)</td>\n<td align=\"left\">普通大小的整数(32位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>小数类型</strong></td>\n<td align=\"left\">float</td>\n<td align=\"left\">单精度浮点数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">double</td>\n<td align=\"left\">双精度浮点数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">decimal(m,d)</td>\n<td align=\"left\">压缩严格的定点数</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>日期类型</strong></td>\n<td align=\"left\">year</td>\n<td align=\"left\">YYYY 1901~2155</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">time</td>\n<td align=\"left\">HH:MM:SS -838:59:59~838:59:59</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">date</td>\n<td align=\"left\">YYYY-MM-DD 1000-01-01~9999-12-3</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">datetime</td>\n<td align=\"left\">YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">timestamp</td>\n<td align=\"left\">YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>文本、二进制类型</strong></td>\n<td align=\"left\">CHAR(M)</td>\n<td align=\"left\">M为0~255之间的整数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">VARCHAR(M)</td>\n<td align=\"left\">M为0~65535之间的整数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">TINYBLOB</td>\n<td align=\"left\">允许长度0~255字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">BLOB</td>\n<td align=\"left\">允许长度0~65535字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">MEDIUMBLOB</td>\n<td align=\"left\">允许长度0~167772150字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">LONGBLOB</td>\n<td align=\"left\">允许长度0~4294967295字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">TINYTEXT</td>\n<td align=\"left\">允许长度0~255字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">TEXT</td>\n<td align=\"left\">允许长度0~65535字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">MEDIUMTEXT</td>\n<td align=\"left\">允许长度0~167772150字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">LONGTEXT</td>\n<td align=\"left\">允许长度0~4294967295字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">VARBINARY(M)</td>\n<td align=\"left\">允许长度0~M个字节的变长字节字符串</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">BINARY(M)</td>\n<td align=\"left\">允许长度0~M个字节的定长字节字符串</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>\n</li>\n<li><p>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>\n</li>\n<li><p>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>\n<p><strong>使用策略：</strong><br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>\n</li>\n<li><p>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>\n</li>\n<li><p>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。<br>看到这里，这道真题是不是就比较容易回答了。</p>\n</li>\n</ul>\n<h2 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h2><h3 id=\"MySQL存储引擎MyISAM与InnoDB区别\"><a href=\"#MySQL存储引擎MyISAM与InnoDB区别\" class=\"headerlink\" title=\"MySQL存储引擎MyISAM与InnoDB区别\"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>\n<p>常用的存储引擎有以下：</p>\n<ul>\n<li><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>\n<li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>\n<li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>\n</ul>\n<p><strong>MyISAM与InnoDB区别</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><strong>MyISAM</strong></th>\n<th align=\"left\"><strong>Innodb</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">存储结构</td>\n<td align=\"left\">每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>\n<td align=\"left\">所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>\n</tr>\n<tr>\n<td align=\"left\">存储空间</td>\n<td align=\"left\">MyISAM可被压缩，存储空间较小</td>\n<td align=\"left\">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>\n</tr>\n<tr>\n<td align=\"left\">可移植性、备份及恢复</td>\n<td align=\"left\">由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>\n<td align=\"left\">免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>\n</tr>\n<tr>\n<td align=\"left\">文件格式</td>\n<td align=\"left\">数据和索引是分别存储的，数据.MYD，索引.MYI</td>\n<td align=\"left\">数据和索引是集中存储的，.ibd</td>\n</tr>\n<tr>\n<td align=\"left\">记录存储顺序</td>\n<td align=\"left\">按记录插入顺序保存</td>\n<td align=\"left\">按主键大小有序插入</td>\n</tr>\n<tr>\n<td align=\"left\">外键</td>\n<td align=\"left\">不支持</td>\n<td align=\"left\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">事务</td>\n<td align=\"left\">不支持</td>\n<td align=\"left\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>\n<td align=\"left\">表级锁定</td>\n<td align=\"left\">行级锁定、表级锁定，锁定力度小并发能力高</td>\n</tr>\n<tr>\n<td align=\"left\">SELECT</td>\n<td align=\"left\">MyISAM更优</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">INSERT、UPDATE、DELETE</td>\n<td align=\"left\"></td>\n<td align=\"left\">InnoDB更优</td>\n</tr>\n<tr>\n<td align=\"left\">select count(*)</td>\n<td align=\"left\">myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">索引的实现方式</td>\n<td align=\"left\">B+树索引，myisam 是堆表</td>\n<td align=\"left\">B+树索引，Innodb 是索引组织表</td>\n</tr>\n<tr>\n<td align=\"left\">哈希索引</td>\n<td align=\"left\">不支持</td>\n<td align=\"left\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">全文索引</td>\n<td align=\"left\">支持</td>\n<td align=\"left\">不支持</td>\n</tr>\n</tbody></table>\n<h3 id=\"MyISAM索引与InnoDB索引的区别？\"><a href=\"#MyISAM索引与InnoDB索引的区别？\" class=\"headerlink\" title=\"MyISAM索引与InnoDB索引的区别？\"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>\n<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>\n<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>\n<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>\n<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>\n</ul>\n<h3 id=\"InnoDB引擎的4大特性\"><a href=\"#InnoDB引擎的4大特性\" class=\"headerlink\" title=\"InnoDB引擎的4大特性\"></a>InnoDB引擎的4大特性</h3><ul>\n<li>插入缓冲（insert buffer)</li>\n<li>二次写(double write)</li>\n<li>自适应哈希索引(ahi)</li>\n<li>预读(read ahead)</li>\n</ul>\n<h3 id=\"存储引擎选择\"><a href=\"#存储引擎选择\" class=\"headerlink\" title=\"存储引擎选择\"></a>存储引擎选择</h3><p>如果没有特别的需求，使用默认的Innodb即可。</p>\n<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>\n<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"什么是索引？\"><a href=\"#什么是索引？\" class=\"headerlink\" title=\"什么是索引？\"></a>什么是索引？</h3><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>\n<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>\n<p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p>\n<h3 id=\"索引有哪些优缺点？\"><a href=\"#索引有哪些优缺点？\" class=\"headerlink\" title=\"索引有哪些优缺点？\"></a>索引有哪些优缺点？</h3><p>索引的优点</p>\n<ul>\n<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>\n</ul>\n<p>索引的缺点</p>\n<ul>\n<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>\n<li>空间方面：索引需要占物理空间。</li>\n</ul>\n<h3 id=\"索引使用场景（重点）\"><a href=\"#索引使用场景（重点）\" class=\"headerlink\" title=\"索引使用场景（重点）\"></a>索引使用场景（重点）</h3><p>where</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0bd245252090436dbd84297a3be0d304.png\"></p>\n<p>上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>\n<p>– 增加一个没有建立索引的字段 alter table innodb1 add sex char(1); – 按sex检索时可选的索引为null EXPLAIN SELECT * from innodb1 where sex=’男’;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/191753c4800e4ba28295a4257bbc57f7.png\"></p>\n<blockquote>\n<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p>\n</blockquote>\n<p>order by</p>\n<p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>\n<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>\n<p>join</p>\n<blockquote>\n<p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</p>\n</blockquote>\n<p>索引覆盖</p>\n<p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</p>\n<p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p>\n<h3 id=\"索引有哪几种类型？\"><a href=\"#索引有哪几种类型？\" class=\"headerlink\" title=\"索引有哪几种类型？\"></a>索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>\n<p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>\n<ul>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</li>\n</ul>\n<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>\n<ul>\n<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>\n<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>\n</ul>\n<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>\n<ul>\n<li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li>\n</ul>\n<h3 id=\"索引的数据结构（b树，hash）\"><a href=\"#索引的数据结构（b树，hash）\" class=\"headerlink\" title=\"索引的数据结构（b树，hash）\"></a>索引的数据结构（b树，hash）</h3><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>\n<p>1）B树索引</p>\n<p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1cbeb7fd870e48b3aa2f8399577b13bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<p>查询方式：</p>\n<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>\n<p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p>\n<p>B+tree性质：</p>\n<p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p>\n<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>\n<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p>\n<p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>\n<p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>\n<p>2）哈希索引</p>\n<p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0336f3cd247249a6af5a4be815d791e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_15,color_FFFFFF,t_70,g_se,x_16\"></p>\n<h3 id=\"索引的基本原理\"><a href=\"#索引的基本原理\" class=\"headerlink\" title=\"索引的基本原理\"></a>索引的基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>\n<p>索引的原理很简单，就是把无序的数据变成有序的查询</p>\n<ol>\n<li>把创建了索引的列的内容进行排序</li>\n<li>对排序结果生成倒排表</li>\n<li>在倒排表内容上拼上数据地址链</li>\n<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>\n</ol>\n<h3 id=\"索引算法有哪些？\"><a href=\"#索引算法有哪些？\" class=\"headerlink\" title=\"索引算法有哪些？\"></a>索引算法有哪些？</h3><p>索引算法有 BTree算法和Hash算法</p>\n<p><strong>BTree算法</strong></p>\n<p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>\n<p>– 只要它的查询条件是一个不以通配符开头的常量 select * from user where name like ‘jack%’; – 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like ‘%jack’;</p>\n<p><strong>Hash算法</strong></p>\n<p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>\n<h3 id=\"索引设计的原则？\"><a href=\"#索引设计的原则？\" class=\"headerlink\" title=\"索引设计的原则？\"></a>索引设计的原则？</h3><ol>\n<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>\n<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>\n<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>\n<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>\n</ol>\n<h3 id=\"创建索引的原则（重中之重）\"><a href=\"#创建索引的原则（重中之重）\" class=\"headerlink\" title=\"创建索引的原则（重中之重）\"></a>创建索引的原则（重中之重）</h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p>\n<p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>\n<p>2）较频繁作为查询条件的字段才去创建索引</p>\n<p>3）更新频繁字段不适合创建索引</p>\n<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>\n<p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>\n<p>6）定义有外键的数据列一定要建立索引。</p>\n<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p>\n<p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p>\n<h3 id=\"创建索引的三种方式，删除索引\"><a href=\"#创建索引的三种方式，删除索引\" class=\"headerlink\" title=\"创建索引的三种方式，删除索引\"></a>创建索引的三种方式，删除索引</h3><p>第一种方式：在执行CREATE TABLE时创建索引</p>\n<p>CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );</p>\n<p>第二种方式：使用ALTER TABLE命令去增加索引</p>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list);</p>\n<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>\n<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>\n<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>\n<p>第三种方式：使用CREATE INDEX命令创建</p>\n<p>CREATE INDEX index_name ON table_name (column_list);</p>\n<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>\n<p>删除索引</p>\n<p>根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p>\n<p>alter table user_index drop KEY name; alter table user_index drop KEY id_card; alter table user_index drop KEY information;</p>\n<p>删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fae6723844de418cb597facb6497d2c7.png\"></p>\n<p>需要取消自增长再行删除：</p>\n<p>alter table user_index – 重新定义字段 MODIFY id int, drop PRIMARY KEY</p>\n<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>\n<h3 id=\"创建索引时需要注意什么？\"><a href=\"#创建索引时需要注意什么？\" class=\"headerlink\" title=\"创建索引时需要注意什么？\"></a>创建索引时需要注意什么？</h3><ul>\n<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>\n<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>\n<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>\n</ul>\n<h3 id=\"使用索引查询一定能提高查询的性能吗？为什么\"><a href=\"#使用索引查询一定能提高查询的性能吗？为什么\" class=\"headerlink\" title=\"使用索引查询一定能提高查询的性能吗？为什么\"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>\n<ul>\n<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>\n<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>\n<li>基于非唯一性索引的检索</li>\n</ul>\n<h3 id=\"百万级别或以上的数据如何删除\"><a href=\"#百万级别或以上的数据如何删除\" class=\"headerlink\" title=\"百万级别或以上的数据如何删除\"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>\n<ol>\n<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>\n<li>然后删除其中无用数据（此过程需要不到两分钟）</li>\n<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>\n<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>\n</ol>\n<h3 id=\"前缀索引\"><a href=\"#前缀索引\" class=\"headerlink\" title=\"前缀索引\"></a>前缀索引</h3><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>\n<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>\n<p>实操的难度：在于前缀截取的长度。</p>\n<p>我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p>\n<h3 id=\"什么是最左前缀原则？什么是最左匹配原则\"><a href=\"#什么是最左前缀原则？什么是最左匹配原则\" class=\"headerlink\" title=\"什么是最左前缀原则？什么是最左匹配原则\"></a>什么是最左前缀原则？什么是最左匹配原则</h3><ul>\n<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>\n<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>\n<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>\n</ul>\n<h3 id=\"B树和B-树的区别\"><a href=\"#B树和B-树的区别\" class=\"headerlink\" title=\"B树和B+树的区别\"></a>B树和B+树的区别</h3><ul>\n<li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>\n</li>\n<li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3cf2b460c14745fcae0c390859d74324.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n</li>\n</ul>\n<h3 id=\"使用B树的好处\"><a href=\"#使用B树的好处\" class=\"headerlink\" title=\"使用B树的好处\"></a>使用B树的好处</h3><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>\n<h3 id=\"使用B-树的好处\"><a href=\"#使用B-树的好处\" class=\"headerlink\" title=\"使用B+树的好处\"></a>使用B+树的好处</h3><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>\n<h3 id=\"Hash索引和B-树所有有什么区别或者说优劣呢\"><a href=\"#Hash索引和B-树所有有什么区别或者说优劣呢\" class=\"headerlink\" title=\"Hash索引和B+树所有有什么区别或者说优劣呢?\"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h3><p>首先要知道Hash索引和B+树索引的底层实现原理：</p>\n<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>\n<p>那么可以看出他们有以下的不同：</p>\n<ul>\n<li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li>\n</ul>\n<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>\n<ul>\n<li>hash索引不支持使用索引进行排序，原理同上。</li>\n<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li>\n<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li>\n<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>\n</ul>\n<p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>\n<h3 id=\"数据库为什么使用B-树而不是B树\"><a href=\"#数据库为什么使用B-树而不是B树\" class=\"headerlink\" title=\"数据库为什么使用B+树而不是B树\"></a>数据库为什么使用B+树而不是B树</h3><ul>\n<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>\n<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>\n<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>\n<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>\n<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>\n</ul>\n<h3 id=\"B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\"><a href=\"#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\" class=\"headerlink\" title=\"B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>\n<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>\n<h3 id=\"什么是聚簇索引？何时使用聚簇索引与非聚簇索引\"><a href=\"#什么是聚簇索引？何时使用聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"什么是聚簇索引？何时使用聚簇索引与非聚簇索引\"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3><ul>\n<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>\n<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>\n</ul>\n<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>\n<p>何时使用聚簇索引与非聚簇索引</p>\n<p><img src=\"https://img-blog.csdnimg.cn/54d88ff9fc2c48588d04ca76611f8ecc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<h3 id=\"非聚簇索引一定会回表查询吗？\"><a href=\"#非聚簇索引一定会回表查询吗？\" class=\"headerlink\" title=\"非聚簇索引一定会回表查询吗？\"></a>非聚簇索引一定会回表查询吗？</h3><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>\n<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>\n<h3 id=\"联合索引是什么？为什么需要注意联合索引中的顺序？\"><a href=\"#联合索引是什么？为什么需要注意联合索引中的顺序？\" class=\"headerlink\" title=\"联合索引是什么？为什么需要注意联合索引中的顺序？\"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>\n<p>具体原因为:</p>\n<p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>\n<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"什么是数据库事务？\"><a href=\"#什么是数据库事务？\" class=\"headerlink\" title=\"什么是数据库事务？\"></a>什么是数据库事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<p>事务最经典也经常被拿出来说例子就是转账了。</p>\n<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"事物的四大特性-ACID-介绍一下\"><a href=\"#事物的四大特性-ACID-介绍一下\" class=\"headerlink\" title=\"事物的四大特性(ACID)介绍一下?\"></a>事物的四大特性(ACID)介绍一下?</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9a1d7c93ca874557911ae2cb578dcb4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_10,color_FFFFFF,t_70,g_se,x_16\"></p>\n<ol>\n<li><p><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>\n</li>\n<li><p><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p>\n</li>\n<li><p><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9a95f01f0e8c41a88e210e387a98da47.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>\n</li>\n</ol>\n<h3 id=\"什么是脏读？幻读？不可重复读？\"><a href=\"#什么是脏读？幻读？不可重复读？\" class=\"headerlink\" title=\"什么是脏读？幻读？不可重复读？\"></a>什么是脏读？幻读？不可重复读？</h3><ul>\n<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>\n<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>\n<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>\n</ul>\n<h3 id=\"什么是事务的隔离级别？MySQL的默认隔离级别是什么？\"><a href=\"#什么是事务的隔离级别？MySQL的默认隔离级别是什么？\" class=\"headerlink\" title=\"什么是事务的隔离级别？MySQL的默认隔离级别是什么？\"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>\n<p><strong>隔离级别<strong><strong>脏读</strong></strong>不可重复读****幻影读</strong>READ-UNCOMMITTED√√√READ-COMMITTED×√√REPEATABLE-READ××√SERIALIZABLE×××</p>\n<p><strong>SQL 标准定义了四个隔离级别：</strong></p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>\n<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>\n<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>\n<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n<p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p>\n<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"对MySQL的锁了解吗\"><a href=\"#对MySQL的锁了解吗\" class=\"headerlink\" title=\"对MySQL的锁了解吗\"></a>对MySQL的锁了解吗</h3><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p>\n<p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p>\n<h3 id=\"隔离级别与锁的关系\"><a href=\"#隔离级别与锁的关系\" class=\"headerlink\" title=\"隔离级别与锁的关系\"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>\n<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>\n<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>\n<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p>\n<h3 id=\"按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\"><a href=\"#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\" class=\"headerlink\" title=\"按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>\n<p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>\n<ul>\n<li>MyISAM采用表级锁(table-level locking)。</li>\n<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>\n</ul>\n<p>行级锁，表级锁和页级锁对比</p>\n<p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>\n<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n<p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>\n<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>\n<p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>\n<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>\n<h3 id=\"从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\"><a href=\"#从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\" class=\"headerlink\" title=\"从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\"></a>从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>\n<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>\n<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>\n<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>\n<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p>\n<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>\n<h3 id=\"MySQL中InnoDB引擎的行锁是怎么实现的？\"><a href=\"#MySQL中InnoDB引擎的行锁是怎么实现的？\" class=\"headerlink\" title=\"MySQL中InnoDB引擎的行锁是怎么实现的？\"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><p>答：InnoDB是基于索引来完成行锁</p>\n<p>例: select * from tab_with_index where id = 1 for update;</p>\n<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p>\n<h3 id=\"InnoDB存储引擎的锁的算法有三种\"><a href=\"#InnoDB存储引擎的锁的算法有三种\" class=\"headerlink\" title=\"InnoDB存储引擎的锁的算法有三种\"></a>InnoDB存储引擎的锁的算法有三种</h3><ul>\n<li>Record lock：单个行记录上的锁</li>\n<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>\n<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>\n</ul>\n<p><strong>相关知识点：</strong></p>\n<ol>\n<li>innodb对于行的查询使用next-key lock</li>\n<li>Next-locking keying为了解决Phantom Problem幻读问题</li>\n<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>\n<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>\n<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>\n</ol>\n<h3 id=\"什么是死锁？怎么解决？\"><a href=\"#什么是死锁？怎么解决？\" class=\"headerlink\" title=\"什么是死锁？怎么解决？\"></a>什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>\n<p>常见的解决死锁的方法</p>\n<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>\n<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>\n<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>\n<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>\n<h3 id=\"数据库的乐观锁和悲观锁是什么？怎么实现的？\"><a href=\"#数据库的乐观锁和悲观锁是什么？怎么实现的？\" class=\"headerlink\" title=\"数据库的乐观锁和悲观锁是什么？怎么实现的？\"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>\n<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>\n<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>\n<p><strong>两种锁的使用场景</strong></p>\n<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>\n<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><h3 id=\"为什么要使用视图？什么是视图？\"><a href=\"#为什么要使用视图？什么是视图？\" class=\"headerlink\" title=\"为什么要使用视图？什么是视图？\"></a>为什么要使用视图？什么是视图？</h3><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>\n<p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>\n<h3 id=\"视图有哪些特点？\"><a href=\"#视图有哪些特点？\" class=\"headerlink\" title=\"视图有哪些特点？\"></a>视图有哪些特点？</h3><p>视图的特点如下:</p>\n<ul>\n<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>\n<li>视图是由基本表(实表)产生的表(虚表)。</li>\n<li>视图的建立和删除不影响基本表。</li>\n<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>\n<li>当视图来自多个基本表时，不允许添加和删除数据。</li>\n</ul>\n<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>\n<h3 id=\"视图的使用场景有哪些？\"><a href=\"#视图的使用场景有哪些？\" class=\"headerlink\" title=\"视图的使用场景有哪些？\"></a>视图的使用场景有哪些？</h3><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>\n<p>下面是视图的常见使用场景：</p>\n<ul>\n<li>重用SQL语句；</li>\n<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>\n<li>使用表的组成部分而不是整个表；</li>\n<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>\n<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>\n</ul>\n<h3 id=\"视图的优点\"><a href=\"#视图的优点\" class=\"headerlink\" title=\"视图的优点\"></a>视图的优点</h3><ol>\n<li>查询简单化。视图能简化用户的操作</li>\n<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>\n<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>\n</ol>\n<h3 id=\"视图的缺点\"><a href=\"#视图的缺点\" class=\"headerlink\" title=\"视图的缺点\"></a>视图的缺点</h3><ol>\n<li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>\n</li>\n<li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p>\n<p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\\SUM\\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p>\n</li>\n</ol>\n<h3 id=\"什么是游标？\"><a href=\"#什么是游标？\" class=\"headerlink\" title=\"什么是游标？\"></a>什么是游标？</h3><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>\n<h2 id=\"存储过程与函数\"><a href=\"#存储过程与函数\" class=\"headerlink\" title=\"存储过程与函数\"></a>存储过程与函数</h2><h3 id=\"什么是存储过程？有哪些优缺点？\"><a href=\"#什么是存储过程？有哪些优缺点？\" class=\"headerlink\" title=\"什么是存储过程？有哪些优缺点？\"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>\n<p><strong>优点</strong></p>\n<p>1）存储过程是预编译过的，执行效率高。</p>\n<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>\n<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>\n<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>\n<p><strong>缺点</strong></p>\n<p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>\n<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>\n<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>\n<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><h3 id=\"什么是触发器？触发器的使用场景有哪些？\"><a href=\"#什么是触发器？触发器的使用场景有哪些？\" class=\"headerlink\" title=\"什么是触发器？触发器的使用场景有哪些？\"></a>什么是触发器？触发器的使用场景有哪些？</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>\n<p>使用场景</p>\n<ul>\n<li>可以通过数据库中的相关表实现级联更改。</li>\n<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>\n<li>例如可以生成某些业务的编号。</li>\n<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>\n<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>\n</ul>\n<h3 id=\"MySQL中都有哪些触发器？\"><a href=\"#MySQL中都有哪些触发器？\" class=\"headerlink\" title=\"MySQL中都有哪些触发器？\"></a>MySQL中都有哪些触发器？</h3><p>在MySQL数据库中有如下六种触发器：</p>\n<ul>\n<li>Before Insert</li>\n<li>After Insert</li>\n<li>Before Update</li>\n<li>After Update</li>\n<li>Before Delete</li>\n<li>After Delete</li>\n</ul>\n<h2 id=\"常用SQL语句\"><a href=\"#常用SQL语句\" class=\"headerlink\" title=\"常用SQL语句\"></a>常用SQL语句</h2><h3 id=\"SQL语句主要分为哪几类\"><a href=\"#SQL语句主要分为哪几类\" class=\"headerlink\" title=\"SQL语句主要分为哪几类\"></a>SQL语句主要分为哪几类</h3><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>\n<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>\n<p>数据查询语言DQL（Data Query Language）SELECT</p>\n<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>\n<p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>\n<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>\n<p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>\n<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>\n<h3 id=\"超键、候选键、主键、外键分别是什么？\"><a href=\"#超键、候选键、主键、外键分别是什么？\" class=\"headerlink\" title=\"超键、候选键、主键、外键分别是什么？\"></a>超键、候选键、主键、外键分别是什么？</h3><ul>\n<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>\n<li>候选键：是最小超键，即没有冗余元素的超键。</li>\n<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>\n<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>\n</ul>\n<h3 id=\"SQL-约束有哪几种？\"><a href=\"#SQL-约束有哪几种？\" class=\"headerlink\" title=\"SQL 约束有哪几种？\"></a>SQL 约束有哪几种？</h3><blockquote>\n<p>SQL 约束有哪几种？</p>\n</blockquote>\n<ul>\n<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>\n<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>\n<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>\n<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>\n<li>CHECK: 用于控制字段的值范围。</li>\n</ul>\n<h3 id=\"六种关联查询\"><a href=\"#六种关联查询\" class=\"headerlink\" title=\"六种关联查询\"></a>六种关联查询</h3><ul>\n<li>交叉连接（CROSS JOIN）</li>\n<li>内连接（INNER JOIN）</li>\n<li>外连接（LEFT JOIN/RIGHT JOIN）</li>\n<li>联合查询（UNION与UNION ALL）</li>\n<li>全连接（FULL JOIN）</li>\n<li>交叉连接（CROSS JOIN）</li>\n</ul>\n<p>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</p>\n<p>内连接分为三类</p>\n<ul>\n<li>等值连接：ON A.id=B.id</li>\n<li>不等值连接：ON A.id &gt; B.id</li>\n<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>\n</ul>\n<p>外连接（LEFT JOIN/RIGHT JOIN）</p>\n<ul>\n<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>\n<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>\n</ul>\n<p>联合查询（UNION与UNION ALL）</p>\n<p>SELECT * FROM A UNION SELECT * FROM B UNION …</p>\n<ul>\n<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>\n<li>如果使用UNION ALL，不会合并重复的记录行</li>\n<li>效率 UNION 高于 UNION ALL</li>\n</ul>\n<p>全连接（FULL JOIN）</p>\n<ul>\n<li>MySQL不支持全连接</li>\n<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>\n</ul>\n<p>SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id</p>\n<p>表连接面试题</p>\n<p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p>\n<p>R表</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n</tr>\n</tbody></table>\n<p>S表</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<ol>\n<li>交叉连接(笛卡尔积):</li>\n</ol>\n<p>select r.<em>,s.</em> from r,s</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>内连接结果：</p>\n<p>select r.<em>,s.</em> from r inner join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>左连接结果：</p>\n<p>select r.<em>,s.</em> from r left join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>右连接结果：</p>\n<p>select r.<em>,s.</em> from r right join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">A</td>\n<td align=\"left\">B</td>\n<td align=\"left\">C</td>\n<td align=\"left\">C</td>\n<td align=\"left\">D</td>\n</tr>\n<tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>全表连接的结果（MySql不支持，Oracle支持）：</p>\n<p>select r.<em>,s.</em> from r full join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<h3 id=\"什么是子查询\"><a href=\"#什么是子查询\" class=\"headerlink\" title=\"什么是子查询\"></a>什么是子查询</h3><ol>\n<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>\n<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>\n</ol>\n<h3 id=\"子查询的三种情况\"><a href=\"#子查询的三种情况\" class=\"headerlink\" title=\"子查询的三种情况\"></a>子查询的三种情况</h3><ol>\n<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>\n</ol>\n<p>– 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);</p>\n<ol>\n<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>\n</ol>\n<p>– 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);</p>\n<ol>\n<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li>\n</ol>\n<p>– 1) 查询出2011年以后入职的员工信息 – 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。 select * from dept d, (select * from employee where join_date &gt; ‘2011-1-1’) e where e.dept_id = d.id; – 使用表连接： select d.<em>, e.</em> from dept d inner join employee e on d.id = e.dept_id where e.join_date &gt; ‘2011-1-1’</p>\n<h3 id=\"mysql中-in-和-exists-区别\"><a href=\"#mysql中-in-和-exists-区别\" class=\"headerlink\" title=\"mysql中 in 和 exists 区别\"></a>mysql中 in 和 exists 区别</h3><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>\n<ol>\n<li>如果查询的两个表大小相当，那么用in和exists差别不大。</li>\n<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>\n<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>\n</ol>\n<h3 id=\"varchar与char的区别\"><a href=\"#varchar与char的区别\" class=\"headerlink\" title=\"varchar与char的区别\"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p>\n<ul>\n<li>char表示定长字符串，长度是固定的；</li>\n<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>\n<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>\n<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>\n</ul>\n<p><strong>varchar的特点</strong></p>\n<ul>\n<li>varchar表示可变长字符串，长度是可变的；</li>\n<li>插入的数据是多长，就按照多长来存储；</li>\n<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>\n<li>对于varchar来说，最多能存放的字符个数为65532</li>\n</ul>\n<p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>\n<h3 id=\"varchar-50-中50的涵义\"><a href=\"#varchar-50-中50的涵义\" class=\"headerlink\" title=\"varchar(50)中50的涵义\"></a>varchar(50)中50的涵义</h3><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>\n<h3 id=\"int-20-中20的涵义\"><a href=\"#int-20-中20的涵义\" class=\"headerlink\" title=\"int(20)中20的涵义\"></a>int(20)中20的涵义</h3><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p>\n<p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>\n<h3 id=\"mysql为什么这么设计\"><a href=\"#mysql为什么这么设计\" class=\"headerlink\" title=\"mysql为什么这么设计\"></a>mysql为什么这么设计</h3><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p>\n<h3 id=\"mysql中int-10-和char-10-以及varchar-10-的区别\"><a href=\"#mysql中int-10-和char-10-以及varchar-10-的区别\" class=\"headerlink\" title=\"mysql中int(10)和char(10)以及varchar(10)的区别\"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul>\n<li><p>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p>\n<p>int(10) 10位的数据长度 9999999999，占32个字节，int型4位<br>char(10) 10位固定字符串，不足补空格 最多10个字符<br>varchar(10) 10位可变字符串，不足补空格 最多10个字符</p>\n</li>\n<li><p>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</p>\n</li>\n<li><p>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p>\n</li>\n</ul>\n<h3 id=\"FLOAT和DOUBLE的区别是什么？\"><a href=\"#FLOAT和DOUBLE的区别是什么？\" class=\"headerlink\" title=\"FLOAT和DOUBLE的区别是什么？\"></a>FLOAT和DOUBLE的区别是什么？</h3><ul>\n<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>\n<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>\n</ul>\n<h3 id=\"drop、delete与truncate的区别\"><a href=\"#drop、delete与truncate的区别\" class=\"headerlink\" title=\"drop、delete与truncate的区别\"></a>drop、delete与truncate的区别</h3><p>三者都表示删除，但是三者有一些差别：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><strong>Delete</strong></th>\n<th align=\"left\"><strong>Truncate</strong></th>\n<th align=\"left\"><strong>Drop</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">类型</td>\n<td align=\"left\">属于DML</td>\n<td align=\"left\">属于DDL</td>\n<td align=\"left\">属于DDL</td>\n</tr>\n<tr>\n<td align=\"left\">回滚</td>\n<td align=\"left\">可回滚</td>\n<td align=\"left\">不可回滚</td>\n<td align=\"left\">不可回滚</td>\n</tr>\n<tr>\n<td align=\"left\">删除内容</td>\n<td align=\"left\">表结构还在，删除表的全部或者一部分数据行</td>\n<td align=\"left\">表结构还在，删除表中的所有数据</td>\n<td align=\"left\">从数据库中删除表，所有的数据行，索引和权限也会被删除</td>\n</tr>\n<tr>\n<td align=\"left\">删除速度</td>\n<td align=\"left\">删除速度慢，需要逐行删除</td>\n<td align=\"left\">删除速度快</td>\n<td align=\"left\">删除速度最快</td>\n</tr>\n</tbody></table>\n<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>\n<h3 id=\"UNION与UNION-ALL的区别？\"><a href=\"#UNION与UNION-ALL的区别？\" class=\"headerlink\" title=\"UNION与UNION ALL的区别？\"></a>UNION与UNION ALL的区别？</h3><ul>\n<li>如果使用UNION ALL，不会合并重复的记录行</li>\n<li>效率 UNION 高于 UNION ALL</li>\n</ul>\n<h2 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h2><h3 id=\"如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？\"><a href=\"#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？\" class=\"headerlink\" title=\"如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？\"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3762f1f867ab421aa5a4e3e8328e0b8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<p>执行计划包含的信息 <strong>id</strong> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>\n<ul>\n<li>id相同执行顺序由上至下。</li>\n<li>id不同，id值越大优先级越高，越先被执行。</li>\n<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>\n</ul>\n<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>id</strong></th>\n<th align=\"left\"><strong>select_type</strong></th>\n<th align=\"left\"><strong>description</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">SIMPLE</td>\n<td align=\"left\">不包含任何子查询或union等查询</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">PRIMARY</td>\n<td align=\"left\">包含子查询最外层查询就显示为 PRIMARY</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">SUBQUERY</td>\n<td align=\"left\">在select或 where字句中包含的查询</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">DERIVED</td>\n<td align=\"left\">from字句中包含的查询</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">UNION</td>\n<td align=\"left\">出现在union后的查询语句中</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">UNION RESULT</td>\n<td align=\"left\">从UNION中获取结果集，例如上文的第三个例子</td>\n</tr>\n</tbody></table>\n<p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>\n<p>create table tmp ( id int unsigned not null AUTO_INCREMENT, name varchar(255), PRIMARY KEY (id) ) engine = innodb partition by key (id) partitions 5;</p>\n<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p>\n<ul>\n<li>ALL 扫描全表数据</li>\n<li>index 遍历索引</li>\n<li>range 索引范围查找</li>\n<li>index_subquery 在子查询中使用 ref</li>\n<li>unique_subquery 在子查询中使用 eq_ref</li>\n<li>ref_or_null 对Null进行索引的优化的 ref</li>\n<li>fulltext 使用全文索引</li>\n<li>ref 使用非唯一索引查找数据</li>\n<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>\n</ul>\n<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>\n<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>\n<p><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p>\n<p><strong>key_length</strong> 索引长度</p>\n<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>\n<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>\n<p><strong>extra</strong> 的信息非常丰富，常见的有：</p>\n<ol>\n<li>Using index 使用覆盖索引</li>\n<li>Using where 使用了用where子句来过滤结果集</li>\n<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li>\n<li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li>\n</ol>\n<p>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p>\n<h3 id=\"SQL的生命周期？\"><a href=\"#SQL的生命周期？\" class=\"headerlink\" title=\"SQL的生命周期？\"></a>SQL的生命周期？</h3><ol>\n<li><p>应用服务器与数据库服务器建立一个连接</p>\n</li>\n<li><p>数据库进程拿到请求sql</p>\n</li>\n<li><p>解析并生成执行计划，执行</p>\n</li>\n<li><p>读取数据到内存并进行逻辑处理</p>\n</li>\n<li><p>通过步骤一的连接，发送结果到客户端</p>\n</li>\n<li><p>关掉连接，释放资源</p>\n<p><img src=\"https://img-blog.csdnimg.cn/86be8bfa609d4a909568f3b64ec891d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ol>\n<h3 id=\"大表数据查询，怎么优化\"><a href=\"#大表数据查询，怎么优化\" class=\"headerlink\" title=\"大表数据查询，怎么优化\"></a>大表数据查询，怎么优化</h3><ol>\n<li>优化shema、sql语句+索引；</li>\n<li>第二加缓存，memcached, redis；</li>\n<li>主从复制，读写分离；</li>\n<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>\n<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>\n</ol>\n<h3 id=\"超大分页怎么处理？\"><a href=\"#超大分页怎么处理？\" class=\"headerlink\" title=\"超大分页怎么处理？\"></a>超大分页怎么处理？</h3><p>超大的分页一般从两个方向上来解决.</p>\n<ul>\n<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>\n<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>\n</ul>\n<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p>\n<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p>\n<p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>\n<h3 id=\"mysql-分页\"><a href=\"#mysql-分页\" class=\"headerlink\" title=\"mysql 分页\"></a>mysql 分页</h3><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>\n<p>mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</p>\n<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>\n<p>mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</p>\n<p>如果只给定一个参数，它表示返回最大的记录行数目：</p>\n<p>mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行</p>\n<p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p>\n<h3 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h3><blockquote>\n<p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p>\n</blockquote>\n<p>开启慢查询日志</p>\n<p>配置项：slow_query_log</p>\n<p>可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p>\n<p>设置临界时间</p>\n<p>配置项：long_query_time</p>\n<p>查看：show VARIABLES like ‘long_query_time’，单位秒</p>\n<p>设置：set long_query_time=0.5</p>\n<p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p>\n<p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p>\n<h3 id=\"关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\"><a href=\"#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\" class=\"headerlink\" title=\"关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>\n<p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p>\n<p>所以优化也是针对这三个方向来的，</p>\n<ul>\n<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>\n<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>\n<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>\n</ul>\n<h3 id=\"为什么要尽量设定一个主键？\"><a href=\"#为什么要尽量设定一个主键？\" class=\"headerlink\" title=\"为什么要尽量设定一个主键？\"></a>为什么要尽量设定一个主键？</h3><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>\n<h3 id=\"主键使用自增ID还是UUID？\"><a href=\"#主键使用自增ID还是UUID？\" class=\"headerlink\" title=\"主键使用自增ID还是UUID？\"></a>主键使用自增ID还是UUID？</h3><p>推荐使用自增ID，不要使用UUID。</p>\n<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>\n<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>\n<p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>\n<h3 id=\"字段为什么要求定义为not-null？\"><a href=\"#字段为什么要求定义为not-null？\" class=\"headerlink\" title=\"字段为什么要求定义为not null？\"></a>字段为什么要求定义为not null？</h3><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>\n<h3 id=\"如果要存储用户的密码散列，应该使用什么字段进行存储？\"><a href=\"#如果要存储用户的密码散列，应该使用什么字段进行存储？\" class=\"headerlink\" title=\"如果要存储用户的密码散列，应该使用什么字段进行存储？\"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p>\n<h3 id=\"优化查询过程中的数据访问\"><a href=\"#优化查询过程中的数据访问\" class=\"headerlink\" title=\"优化查询过程中的数据访问\"></a>优化查询过程中的数据访问</h3><ul>\n<li>访问数据太多导致查询性能下降</li>\n<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>\n<li>确认MySQL服务器是否在分析大量不必要的数据行</li>\n<li>避免犯如下SQL语句错误</li>\n<li>查询不需要的数据。解决办法：使用limit解决</li>\n<li>多表关联返回全部列。解决办法：指定列名</li>\n<li>总是返回全部列。解决办法：避免使用SELECT *</li>\n<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>\n<li>是否在扫描额外的记录。解决办法：</li>\n<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>\n<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>\n<li>改变数据库和表的结构，修改数据表范式</li>\n<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>\n</ul>\n<h3 id=\"优化长难的查询语句\"><a href=\"#优化长难的查询语句\" class=\"headerlink\" title=\"优化长难的查询语句\"></a>优化长难的查询语句</h3><ul>\n<li>一个复杂查询还是多个简单查询</li>\n<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>\n<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>\n<li>切分查询</li>\n<li>将一个大的查询分为多个小的相同的查询</li>\n<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>\n<li>分解关联查询，让缓存的效率更高。</li>\n<li>执行单个查询可以减少锁的竞争。</li>\n<li>在应用层做关联更容易对数据库进行拆分。</li>\n<li>查询效率会有大幅提升。</li>\n<li>较少冗余记录的查询。</li>\n</ul>\n<h3 id=\"优化特定类型的查询语句\"><a href=\"#优化特定类型的查询语句\" class=\"headerlink\" title=\"优化特定类型的查询语句\"></a>优化特定类型的查询语句</h3><ul>\n<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>\n<li>MyISAM中，没有任何where条件的count(*)非常快。</li>\n<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>\n<li>可以使用explain查询近似值，用近似值替代count(*)</li>\n<li>增加汇总表</li>\n<li>使用缓存</li>\n</ul>\n<h3 id=\"优化关联查询\"><a href=\"#优化关联查询\" class=\"headerlink\" title=\"优化关联查询\"></a>优化关联查询</h3><ul>\n<li>确定ON或者USING子句中是否有索引。</li>\n<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>\n</ul>\n<h3 id=\"优化子查询\"><a href=\"#优化子查询\" class=\"headerlink\" title=\"优化子查询\"></a>优化子查询</h3><ul>\n<li>用关联查询替代</li>\n<li>优化GROUP BY和DISTINCT</li>\n<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>\n<li>关联查询中，使用标识列分组的效率更高</li>\n<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>\n<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>\n</ul>\n<h3 id=\"优化LIMIT分页\"><a href=\"#优化LIMIT分页\" class=\"headerlink\" title=\"优化LIMIT分页\"></a>优化LIMIT分页</h3><ul>\n<li>LIMIT偏移量大的时候，查询效率较低</li>\n<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>\n</ul>\n<h3 id=\"优化UNION查询\"><a href=\"#优化UNION查询\" class=\"headerlink\" title=\"优化UNION查询\"></a>优化UNION查询</h3><ul>\n<li>UNION ALL的效率高于UNION</li>\n</ul>\n<h3 id=\"优化WHERE子句\"><a href=\"#优化WHERE子句\" class=\"headerlink\" title=\"优化WHERE子句\"></a>优化WHERE子句</h3><p>解题方法</p>\n<p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p>\n<p>SQL语句优化的一些方法？</p>\n<ul>\n<li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>\n<li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>\n</ul>\n<p>select id from t where num is null – 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=</p>\n<ul>\n<li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>\n<li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>\n</ul>\n<p>select id from t where num=10 or num=20 – 可以这样查询： select id from t where num=10 union all select id from t where num=20</p>\n<ul>\n<li>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li>\n</ul>\n<p>select id from t where num in(1,2,3) – 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3</p>\n<ul>\n<li>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li>\n<li>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li>\n</ul>\n<p>select id from t where num=@num – 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num</p>\n<ul>\n<li>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>\n</ul>\n<p>select id from t where num/2=100 – 应改为: select id from t where num=100*2</p>\n<ul>\n<li>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>\n</ul>\n<p>select id from t where substring(name,1,3)=’abc’ – name以abc开头的id应改为: select id from t where name like ‘abc%’</p>\n<ul>\n<li>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>\n</ul>\n<h2 id=\"数据库优化\"><a href=\"#数据库优化\" class=\"headerlink\" title=\"数据库优化\"></a>数据库优化</h2><h3 id=\"为什么要优化\"><a href=\"#为什么要优化\" class=\"headerlink\" title=\"为什么要优化\"></a>为什么要优化</h3><ul>\n<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>\n<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>\n<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>\n</ul>\n<p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>\n<h3 id=\"数据库结构优化\"><a href=\"#数据库结构优化\" class=\"headerlink\" title=\"数据库结构优化\"></a>数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p>\n<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>\n<p><strong>将字段很多的表分解成多个表</strong></p>\n<p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p>\n<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>\n<p><strong>增加中间表</strong></p>\n<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>\n<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>\n<p><strong>增加冗余字段</strong></p>\n<p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p>\n<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>\n<p><strong>注意：</strong></p>\n<p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p>\n<h3 id=\"MySQL数据库cpu飙升到500-的话他怎么处理？\"><a href=\"#MySQL数据库cpu飙升到500-的话他怎么处理？\" class=\"headerlink\" title=\"MySQL数据库cpu飙升到500%的话他怎么处理？\"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>\n<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>\n<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p>\n<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>\n<h3 id=\"大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\"><a href=\"#大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\" class=\"headerlink\" title=\"大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\"></a>大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>\n<ol>\n<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>\n<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>\n<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>\n</ol>\n<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>\n<ol>\n<li><p><strong>垂直分区：</strong></p>\n<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p>\n<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>\n<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>\n<h4 id=\"垂直分表\"><a href=\"#垂直分表\" class=\"headerlink\" title=\"垂直分表\"></a><strong>垂直分表</strong></h4><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8ac8af7d9dc343f193e7217671ca6ef1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a><strong>适用场景</strong></h5><ul>\n<li>1、如果一个表中某些列常用，另外一些列不常用</li>\n<li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h5><ul>\n<li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li>\n<li>对于应用层来说，逻辑算法增加开发成本</li>\n<li>管理冗余列，查询所有数据需要join操作</li>\n</ul>\n</li>\n<li><p><strong>水平分区：</strong></p>\n<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6f84ed35e4f146e5b701af08889a6230.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p>\n<p>《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>\n<h4 id=\"水平分表：\"><a href=\"#水平分表：\" class=\"headerlink\" title=\"水平分表：\"></a><strong>水平分表：</strong></h4><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>\n<p><img src=\"https://img-blog.csdnimg.cn/27dc54f85984461ab2cd23d8e3cb3c21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a><strong>适用场景</strong></h5><ul>\n<li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>\n<li>2、需要把数据存放在多个介质上。</li>\n</ul>\n<h5 id=\"水平切分的缺点\"><a href=\"#水平切分的缺点\" class=\"headerlink\" title=\"水平切分的缺点\"></a><strong>水平切分的缺点</strong></h5><ul>\n<li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li>\n<li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>\n</ul>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<ul>\n<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>\n<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>\n</ul>\n</li>\n</ol>\n<p><strong>分库分表后面临的问题</strong></p>\n<ul>\n<li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>\n</li>\n<li><p><strong>跨库join</strong></p>\n<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p>\n</li>\n<li><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>\n</li>\n<li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p>\n</li>\n<li><p><strong>ID问题</strong></p>\n</li>\n<li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p>\n</li>\n</ul>\n<p><strong>UUID</strong> 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p>\n<ul>\n<li><p>跨分片的排序分页</p>\n<p>般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ef858f4fba43491e986e67a4da939a65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<h3 id=\"MySQL的复制原理以及流程\"><a href=\"#MySQL的复制原理以及流程\" class=\"headerlink\" title=\"MySQL的复制原理以及流程\"></a>MySQL的复制原理以及流程</h3><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>\n<p><strong>主从复制的作用</strong></p>\n<ol>\n<li>主数据库出现问题，可以切换到从数据库。</li>\n<li>可以进行数据库层面的读写分离。</li>\n<li>可以在从数据库上进行日常备份。</li>\n</ol>\n<p><strong>MySQL主从复制解决的问题</strong></p>\n<ul>\n<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>\n<li>负载均衡：降低单个服务器的压力</li>\n<li>高可用和故障切换：帮助应用程序避免单点失败</li>\n<li>升级测试：可以用更高版本的MySQL作为从库</li>\n</ul>\n<p><strong>MySQL主从复制工作原理</strong></p>\n<ul>\n<li>在主库上把数据更高记录到二进制日志</li>\n<li>从库将主库的日志复制到自己的中继日志</li>\n<li>从库读取中继日志的事件，将其重放到从库数据中</li>\n</ul>\n<p><strong>基本原理流程，3个线程以及之间的关联</strong></p>\n<p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>\n<p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>\n<p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p>\n<p><strong>复制过程</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/87fc1db60bec45fa916ebd6b6cd421b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<p>Binary log：主数据库的二进制日志</p>\n<p>Relay log：从服务器的中继日志</p>\n<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>\n<p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>\n<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>\n<h3 id=\"读写分离有哪些解决方案？\"><a href=\"#读写分离有哪些解决方案？\" class=\"headerlink\" title=\"读写分离有哪些解决方案？\"></a>读写分离有哪些解决方案？</h3><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。</p>\n<p><strong>方案一</strong></p>\n<p>使用mysql-proxy代理</p>\n<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p>\n<p>缺点：降低性能， 不支持事务</p>\n<p><strong>方案二</strong></p>\n<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p>\n<p><strong>方案三</strong></p>\n<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p>\n<p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p>\n<h3 id=\"备份计划，mysqldump以及xtranbackup的实现原理\"><a href=\"#备份计划，mysqldump以及xtranbackup的实现原理\" class=\"headerlink\" title=\"备份计划，mysqldump以及xtranbackup的实现原理\"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><p><strong>(1)备份计划</strong></p>\n<p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>\n<p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>\n<p><strong>(2)备份恢复时间</strong></p>\n<p>物理备份恢复快，逻辑备份恢复慢</p>\n<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>\n<p>20G的2分钟（mysqldump）</p>\n<p>80G的30分钟(mysqldump)</p>\n<p>111G的30分钟（mysqldump)</p>\n<p>288G的3小时（xtra)</p>\n<p>3T的4小时（xtra)</p>\n<p>逻辑导入时间一般是备份时间的5倍以上</p>\n<p><strong>(3)备份恢复失败如何处理</strong></p>\n<p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>\n<p><strong>(4)mysqldump和xtrabackup实现原理</strong></p>\n<p>mysqldump</p>\n<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>\n<p>Xtrabackup:</p>\n<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>\n<p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p>\n<p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>\n<h3 id=\"数据表损坏的修复方式有哪些？\"><a href=\"#数据表损坏的修复方式有哪些？\" class=\"headerlink\" title=\"数据表损坏的修复方式有哪些？\"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p>\n<ul>\n<li>1）修复前将mysql服务停止。</li>\n<li>2）打开命令行方式，然后进入到mysql的/bin目录。</li>\n<li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li>\n</ul>\n<p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要使用数据库\"><a href=\"#为什么要使用数据库\" class=\"headerlink\" title=\"为什么要使用数据库\"></a>为什么要使用数据库</h3><p><strong>数据保存在内存</strong></p>\n<p>优点： 存取速度快</p>\n<p>缺点： 数据不能永久保存</p>\n<p><strong>数据保存在文件</strong></p>\n<p>优点： 数据永久保存</p>\n<p>缺点：1）速度比内存操作慢，频繁的IO操作。2）查询数据不方便</p>\n<p><strong>数据保存在数据库</strong></p>\n<p>1）数据永久保存</p>\n<p>2）使用SQL语句，查询方便效率高。</p>\n<p>3）管理数据方便</p>\n<h3 id=\"什么是SQL？\"><a href=\"#什么是SQL？\" class=\"headerlink\" title=\"什么是SQL？\"></a>什么是SQL？</h3><p>结构化查询语言(Structured Query Language)简称SQL，是一种数据库查询语言。</p>\n<p>作用：用于存取数据、查询、更新和管理关系数据库系统。</p>\n<h3 id=\"什么是MySQL\"><a href=\"#什么是MySQL\" class=\"headerlink\" title=\"什么是MySQL?\"></a>什么是MySQL?</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。</p>\n<h3 id=\"数据库三大范式是什么\"><a href=\"#数据库三大范式是什么\" class=\"headerlink\" title=\"数据库三大范式是什么\"></a>数据库三大范式是什么</h3><p>第一范式：每个列都不可以再拆分。</p>\n<p>第二范式：在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。</p>\n<p>第三范式：在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>\n<p>在设计数据库结构的时候，要尽量遵守三范式，如果不遵守，必须有足够的理由。比如性能。事实上我们经常会为了性能而妥协数据库的设计。</p>\n<h3 id=\"mysql有关权限的表都有哪几个\"><a href=\"#mysql有关权限的表都有哪几个\" class=\"headerlink\" title=\"mysql有关权限的表都有哪几个\"></a>mysql有关权限的表都有哪几个</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：</p>\n<ul>\n<li>user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。</li>\n<li>db权限表：记录各个帐号在各个数据库上的操作权限。</li>\n<li>table_priv权限表：记录数据表级的操作权限。</li>\n<li>columns_priv权限表：记录数据列级的操作权限。</li>\n<li>host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。</li>\n</ul>\n<h3 id=\"MySQL的binlog有有几种录入格式？分别有什么区别？\"><a href=\"#MySQL的binlog有有几种录入格式？分别有什么区别？\" class=\"headerlink\" title=\"MySQL的binlog有有几种录入格式？分别有什么区别？\"></a>MySQL的binlog有有几种录入格式？分别有什么区别？</h3><p>有三种格式，statement，row和mixed。</p>\n<ul>\n<li>statement模式下，每一条会修改数据的sql都会记录在binlog中。不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。由于sql的执行是有上下文的，因此在保存的时候需要保存相关的信息，同时还有一些使用了函数之类的语句无法被记录复制。</li>\n<li>row级别下，不记录sql语句上下文相关信息，仅保存哪条记录被修改。记录单元为每一行的改动，基本是可以全部记下来但是由于很多操作，会导致大量行的改动(比如alter table)，因此这种模式的文件保存的信息太多，日志量太大。</li>\n<li>mixed，一种折中的方案，普通操作使用statement记录，当无法使用statement的时候使用row。</li>\n</ul>\n<p>此外，新版的MySQL中对row级别也做了一些优化，当表结构发生变化的时候，会记录语句而不是逐行记录。</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><h3 id=\"mysql有哪些数据类型\"><a href=\"#mysql有哪些数据类型\" class=\"headerlink\" title=\"mysql有哪些数据类型\"></a>mysql有哪些数据类型</h3><table>\n<thead>\n<tr>\n<th align=\"left\"><strong>分类</strong></th>\n<th align=\"left\"><strong>类型名称</strong></th>\n<th align=\"left\"><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\"><strong>整数类型</strong></td>\n<td align=\"left\">tinyInt</td>\n<td align=\"left\">很小的整数(8位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">smallint</td>\n<td align=\"left\">小的整数(16位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">mediumint</td>\n<td align=\"left\">中等大小的整数(24位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">int(integer)</td>\n<td align=\"left\">普通大小的整数(32位二进制)</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>小数类型</strong></td>\n<td align=\"left\">float</td>\n<td align=\"left\">单精度浮点数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">double</td>\n<td align=\"left\">双精度浮点数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">decimal(m,d)</td>\n<td align=\"left\">压缩严格的定点数</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>日期类型</strong></td>\n<td align=\"left\">year</td>\n<td align=\"left\">YYYY 1901~2155</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">time</td>\n<td align=\"left\">HH:MM:SS -838:59:59~838:59:59</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">date</td>\n<td align=\"left\">YYYY-MM-DD 1000-01-01~9999-12-3</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">datetime</td>\n<td align=\"left\">YYYY-MM-DD HH:MM:SS 1000-01-01 00:00:00~ 9999-12-31 23:59:59</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">timestamp</td>\n<td align=\"left\">YYYY-MM-DD HH:MM:SS 19700101 00:00:01 UTC~2038-01-19 03:14:07UTC</td>\n</tr>\n<tr>\n<td align=\"left\"><strong>文本、二进制类型</strong></td>\n<td align=\"left\">CHAR(M)</td>\n<td align=\"left\">M为0~255之间的整数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">VARCHAR(M)</td>\n<td align=\"left\">M为0~65535之间的整数</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">TINYBLOB</td>\n<td align=\"left\">允许长度0~255字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">BLOB</td>\n<td align=\"left\">允许长度0~65535字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">MEDIUMBLOB</td>\n<td align=\"left\">允许长度0~167772150字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">LONGBLOB</td>\n<td align=\"left\">允许长度0~4294967295字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">TINYTEXT</td>\n<td align=\"left\">允许长度0~255字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">TEXT</td>\n<td align=\"left\">允许长度0~65535字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">MEDIUMTEXT</td>\n<td align=\"left\">允许长度0~167772150字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">LONGTEXT</td>\n<td align=\"left\">允许长度0~4294967295字节</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">VARBINARY(M)</td>\n<td align=\"left\">允许长度0~M个字节的变长字节字符串</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\">BINARY(M)</td>\n<td align=\"left\">允许长度0~M个字节的定长字节字符串</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>1、整数类型，包括TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT，分别表示1字节、2字节、3字节、4字节、8字节整数。任何整数类型都可以加上UNSIGNED属性，表示数据是无符号的，即非负整数。<br>长度：整数类型可以被指定长度，例如：INT(11)表示长度为11的INT类型。长度在大多数场景是没有意义的，它不会限制值的合法范围，只会影响显示字符的个数，而且需要和UNSIGNED ZEROFILL属性配合使用才有意义。<br>例子，假定类型设定为INT(5)，属性为UNSIGNED ZEROFILL，如果用户插入的数据为12的话，那么数据库实际存储数据为00012。</p>\n</li>\n<li><p>2、实数类型，包括FLOAT、DOUBLE、DECIMAL。<br>DECIMAL可以用于存储比BIGINT还大的整型，能存储精确的小数。<br>而FLOAT和DOUBLE是有取值范围的，并支持使用标准的浮点进行近似计算。<br>计算时FLOAT和DOUBLE相比DECIMAL效率更高一些，DECIMAL你可以理解成是用字符串进行处理。</p>\n</li>\n<li><p>3、字符串类型，包括VARCHAR、CHAR、TEXT、BLOB<br>VARCHAR用于存储可变长字符串，它比定长类型更节省空间。<br>VARCHAR使用额外1或2个字节存储字符串长度。列长度小于255字节时，使用1字节表示，否则使用2字节表示。<br>VARCHAR存储的内容超出设置的长度时，内容会被截断。<br>CHAR是定长的，根据定义的字符串长度分配足够的空间。<br>CHAR会根据需要使用空格进行填充方便比较。<br>CHAR适合存储很短的字符串，或者所有值都接近同一个长度。<br>CHAR存储的内容超出设置的长度时，内容同样会被截断。</p>\n<p><strong>使用策略：</strong><br>对于经常变更的数据来说，CHAR比VARCHAR更好，因为CHAR不容易产生碎片。<br>对于非常短的列，CHAR比VARCHAR在存储空间上更有效率。<br>使用时要注意只分配需要的空间，更长的列排序时会消耗更多内存。<br>尽量避免使用TEXT/BLOB类型，查询时会使用临时表，导致严重的性能开销。</p>\n</li>\n<li><p>4、枚举类型（ENUM），把不重复的数据存储为一个预定义的集合。<br>有时可以使用ENUM代替常用的字符串类型。<br>ENUM存储非常紧凑，会把列表值压缩到一个或两个字节。<br>ENUM在内部存储时，其实存的是整数。<br>尽量避免使用数字作为ENUM枚举的常量，因为容易混乱。<br>排序是按照内部存储的整数</p>\n</li>\n<li><p>5、日期和时间类型，尽量使用timestamp，空间效率高于datetime，<br>用整数保存时间戳通常不方便处理。<br>如果需要存储微妙，可以使用bigint存储。<br>看到这里，这道真题是不是就比较容易回答了。</p>\n</li>\n</ul>\n<h2 id=\"引擎\"><a href=\"#引擎\" class=\"headerlink\" title=\"引擎\"></a>引擎</h2><h3 id=\"MySQL存储引擎MyISAM与InnoDB区别\"><a href=\"#MySQL存储引擎MyISAM与InnoDB区别\" class=\"headerlink\" title=\"MySQL存储引擎MyISAM与InnoDB区别\"></a>MySQL存储引擎MyISAM与InnoDB区别</h3><p>存储引擎Storage engine：MySQL中的数据、索引以及其他对象是如何存储的，是一套文件系统的实现。</p>\n<p>常用的存储引擎有以下：</p>\n<ul>\n<li><strong>Innodb引擎</strong>：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。</li>\n<li><strong>MyIASM引擎</strong>(原本Mysql的默认引擎)：不提供事务的支持，也不支持行级锁和外键。</li>\n<li><strong>MEMORY引擎</strong>：所有的数据都在内存中，数据的处理速度快，但是安全性不高。</li>\n</ul>\n<p><strong>MyISAM与InnoDB区别</strong></p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><strong>MyISAM</strong></th>\n<th align=\"left\"><strong>Innodb</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">存储结构</td>\n<td align=\"left\">每张表被存放在三个文件：frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件</td>\n<td align=\"left\">所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB</td>\n</tr>\n<tr>\n<td align=\"left\">存储空间</td>\n<td align=\"left\">MyISAM可被压缩，存储空间较小</td>\n<td align=\"left\">InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引</td>\n</tr>\n<tr>\n<td align=\"left\">可移植性、备份及恢复</td>\n<td align=\"left\">由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作</td>\n<td align=\"left\">免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了</td>\n</tr>\n<tr>\n<td align=\"left\">文件格式</td>\n<td align=\"left\">数据和索引是分别存储的，数据.MYD，索引.MYI</td>\n<td align=\"left\">数据和索引是集中存储的，.ibd</td>\n</tr>\n<tr>\n<td align=\"left\">记录存储顺序</td>\n<td align=\"left\">按记录插入顺序保存</td>\n<td align=\"left\">按主键大小有序插入</td>\n</tr>\n<tr>\n<td align=\"left\">外键</td>\n<td align=\"left\">不支持</td>\n<td align=\"left\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">事务</td>\n<td align=\"left\">不支持</td>\n<td align=\"left\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">锁支持（锁是避免资源争用的一个机制，MySQL锁对用户几乎是透明的）</td>\n<td align=\"left\">表级锁定</td>\n<td align=\"left\">行级锁定、表级锁定，锁定力度小并发能力高</td>\n</tr>\n<tr>\n<td align=\"left\">SELECT</td>\n<td align=\"left\">MyISAM更优</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">INSERT、UPDATE、DELETE</td>\n<td align=\"left\"></td>\n<td align=\"left\">InnoDB更优</td>\n</tr>\n<tr>\n<td align=\"left\">select count(*)</td>\n<td align=\"left\">myisam更快，因为myisam内部维护了一个计数器，可以直接调取。</td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\">索引的实现方式</td>\n<td align=\"left\">B+树索引，myisam 是堆表</td>\n<td align=\"left\">B+树索引，Innodb 是索引组织表</td>\n</tr>\n<tr>\n<td align=\"left\">哈希索引</td>\n<td align=\"left\">不支持</td>\n<td align=\"left\">支持</td>\n</tr>\n<tr>\n<td align=\"left\">全文索引</td>\n<td align=\"left\">支持</td>\n<td align=\"left\">不支持</td>\n</tr>\n</tbody></table>\n<h3 id=\"MyISAM索引与InnoDB索引的区别？\"><a href=\"#MyISAM索引与InnoDB索引的区别？\" class=\"headerlink\" title=\"MyISAM索引与InnoDB索引的区别？\"></a>MyISAM索引与InnoDB索引的区别？</h3><ul>\n<li>InnoDB索引是聚簇索引，MyISAM索引是非聚簇索引。</li>\n<li>InnoDB的主键索引的叶子节点存储着行数据，因此主键索引非常高效。</li>\n<li>MyISAM索引的叶子节点存储的是行数据地址，需要再寻址一次才能得到数据。</li>\n<li>InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询时做到覆盖索引会非常高效。</li>\n</ul>\n<h3 id=\"InnoDB引擎的4大特性\"><a href=\"#InnoDB引擎的4大特性\" class=\"headerlink\" title=\"InnoDB引擎的4大特性\"></a>InnoDB引擎的4大特性</h3><ul>\n<li>插入缓冲（insert buffer)</li>\n<li>二次写(double write)</li>\n<li>自适应哈希索引(ahi)</li>\n<li>预读(read ahead)</li>\n</ul>\n<h3 id=\"存储引擎选择\"><a href=\"#存储引擎选择\" class=\"headerlink\" title=\"存储引擎选择\"></a>存储引擎选择</h3><p>如果没有特别的需求，使用默认的Innodb即可。</p>\n<p>MyISAM：以读写插入为主的应用程序，比如博客系统、新闻门户网站。</p>\n<p>Innodb：更新（删除）操作频率也高，或者要保证数据的完整性；并发量高，支持事务和外键。比如OA自动化办公系统。</p>\n<h2 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h2><h3 id=\"什么是索引？\"><a href=\"#什么是索引？\" class=\"headerlink\" title=\"什么是索引？\"></a>什么是索引？</h3><p>索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有记录的引用指针。</p>\n<p>索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新数据库表中数据。索引的实现通常使用B树及其变种B+树。</p>\n<p>更通俗的说，索引就相当于目录。为了方便查找书中的内容，通过对内容建立索引形成目录。索引是一个文件，它是要占据物理空间的。</p>\n<h3 id=\"索引有哪些优缺点？\"><a href=\"#索引有哪些优缺点？\" class=\"headerlink\" title=\"索引有哪些优缺点？\"></a>索引有哪些优缺点？</h3><p>索引的优点</p>\n<ul>\n<li>可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</li>\n<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</li>\n</ul>\n<p>索引的缺点</p>\n<ul>\n<li>时间方面：创建索引和维护索引要耗费时间，具体地，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低增/改/删的执行效率；</li>\n<li>空间方面：索引需要占物理空间。</li>\n</ul>\n<h3 id=\"索引使用场景（重点）\"><a href=\"#索引使用场景（重点）\" class=\"headerlink\" title=\"索引使用场景（重点）\"></a>索引使用场景（重点）</h3><p>where</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0bd245252090436dbd84297a3be0d304.png\"></p>\n<p>上图中，根据id查询记录，因为id字段仅建立了主键索引，因此此SQL执行可选的索引只有主键索引，如果有多个，最终会选一个较优的作为检索的依据。</p>\n<p>– 增加一个没有建立索引的字段 alter table innodb1 add sex char(1); – 按sex检索时可选的索引为null EXPLAIN SELECT * from innodb1 where sex=’男’;</p>\n<p><img src=\"https://img-blog.csdnimg.cn/191753c4800e4ba28295a4257bbc57f7.png\"></p>\n<blockquote>\n<p>可以尝试在一个字段未建立索引时，根据该字段查询的效率，然后对该字段建立索引（alter table 表名 add index(字段名)），同样的SQL执行的效率，你会发现查询效率会有明显的提升（数据量越大越明显）。</p>\n</blockquote>\n<p>order by</p>\n<p>当我们使用order by将查询结果按照某个字段排序时，如果该字段没有建立索引，那么执行计划会将查询出的所有数据使用外部排序（将数据从硬盘分批读取到内存使用内部排序，最后合并排序结果），这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存（如果单条数据过大或者数据量过多都会降低效率），更无论读到内存之后的排序了。</p>\n<p>但是如果我们对该字段建立索引alter table 表名 add index(字段名)，那么由于索引本身是有序的，因此直接按照索引的顺序和映射关系逐条取出数据即可。而且如果分页的，那么只用<strong>取出索引表某个范围内的索引对应的数据</strong>，而不用像上述那<strong>取出所有数据</strong>进行排序再返回某个范围内的数据。（从磁盘取数据是最影响性能的）</p>\n<p>join</p>\n<blockquote>\n<p>对join语句匹配关系（on）涉及的字段建立索引能够提高效率</p>\n</blockquote>\n<p>索引覆盖</p>\n<p>如果要查询的字段都建立过索引，那么引擎会直接在索引表中查询而不会访问原始数据（否则只要有一个字段没有建立索引就会做全表扫描），这叫索引覆盖。因此我们需要尽可能的在select后只写必要的查询字段，以增加索引覆盖的几率。</p>\n<p>这里值得注意的是不要想着为每个字段建立索引，因为优先使用索引的优势就在于其体积小。</p>\n<h3 id=\"索引有哪几种类型？\"><a href=\"#索引有哪几种类型？\" class=\"headerlink\" title=\"索引有哪几种类型？\"></a>索引有哪几种类型？</h3><p><strong>主键索引:</strong> 数据列不允许重复，不允许为NULL，一个表只能有一个主键。</p>\n<p><strong>唯一索引:</strong> 数据列不允许重复，允许为NULL值，一个表允许多个列创建唯一索引。</p>\n<ul>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column); 创建唯一索引</li>\n<li>可以通过 ALTER TABLE table_name ADD UNIQUE (column1,column2); 创建唯一组合索引</li>\n</ul>\n<p><strong>普通索引:</strong> 基本的索引类型，没有唯一性的限制，允许为NULL值。</p>\n<ul>\n<li>可以通过ALTER TABLE table_name ADD INDEX index_name (column);创建普通索引</li>\n<li>可以通过ALTER TABLE table_name ADD INDEX index_name(column1, column2, column3);创建组合索引</li>\n</ul>\n<p><strong>全文索引：</strong> 是目前搜索引擎使用的一种关键技术。</p>\n<ul>\n<li>可以通过ALTER TABLE table_name ADD FULLTEXT (column);创建全文索引</li>\n</ul>\n<h3 id=\"索引的数据结构（b树，hash）\"><a href=\"#索引的数据结构（b树，hash）\" class=\"headerlink\" title=\"索引的数据结构（b树，hash）\"></a>索引的数据结构（b树，hash）</h3><p>索引的数据结构和具体存储引擎的实现有关，在MySQL中使用较多的索引有<strong>Hash索引</strong>，<strong>B+树索引</strong>等，而我们经常使用的InnoDB存储引擎的默认索引实现为：B+树索引。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。</p>\n<p>1）B树索引</p>\n<p>mysql通过存储引擎取数据，基本上90%的人用的就是InnoDB了，按照实现方式分，InnoDB的索引类型目前只有两种：BTREE（B树）索引和HASH索引。B树索引是Mysql数据库中使用最频繁的索引类型，基本所有存储引擎都支持BTree索引。通常我们说的索引不出意外指的就是（B树）索引（实际是用B+树实现的，因为在查看表索引时，mysql一律打印BTREE，所以简称为B树索引）</p>\n<p><img src=\"https://img-blog.csdnimg.cn/1cbeb7fd870e48b3aa2f8399577b13bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<p>查询方式：</p>\n<p>主键索引区:PI(关联保存的时数据的地址)按主键查询,</p>\n<p>普通索引区:si(关联的id的地址,然后再到达上面的地址)。所以按主键查询,速度最快</p>\n<p>B+tree性质：</p>\n<p>1.）n棵子tree的节点包含n个关键字，不用来保存数据而是保存数据的索引。</p>\n<p>2.）所有的叶子结点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。</p>\n<p>3.）所有的非终端结点可以看成是索引部分，结点中仅含其子树中的最大（或最小）关键字。</p>\n<p>4.）B+ 树中，数据对象的插入和删除仅在叶节点上进行。</p>\n<p>5.）B+树有2个头指针，一个是树的根节点，一个是最小关键码的叶节点。</p>\n<p>2）哈希索引</p>\n<p>简要说下，类似于数据结构中简单实现的HASH表（散列表）一样，当我们在mysql中用哈希索引时，主要就是通过Hash算法（常见的Hash算法有直接定址法、平方取中法、折叠法、除数取余法、随机数法），将数据库字段数据转换成定长的Hash值，与这条数据的行指针一并存入Hash表的对应位置；如果发生Hash碰撞（两个不同关键字的Hash值相同），则在对应Hash键下以链表形式存储。当然这只是简略模拟图。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/0336f3cd247249a6af5a4be815d791e5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_15,color_FFFFFF,t_70,g_se,x_16\"></p>\n<h3 id=\"索引的基本原理\"><a href=\"#索引的基本原理\" class=\"headerlink\" title=\"索引的基本原理\"></a>索引的基本原理</h3><p>索引用来快速地寻找那些具有特定值的记录。如果没有索引，一般来说执行查询时遍历整张表。</p>\n<p>索引的原理很简单，就是把无序的数据变成有序的查询</p>\n<ol>\n<li>把创建了索引的列的内容进行排序</li>\n<li>对排序结果生成倒排表</li>\n<li>在倒排表内容上拼上数据地址链</li>\n<li>在查询的时候，先拿到倒排表内容，再取出数据地址链，从而拿到具体数据</li>\n</ol>\n<h3 id=\"索引算法有哪些？\"><a href=\"#索引算法有哪些？\" class=\"headerlink\" title=\"索引算法有哪些？\"></a>索引算法有哪些？</h3><p>索引算法有 BTree算法和Hash算法</p>\n<p><strong>BTree算法</strong></p>\n<p>BTree是最常用的mysql数据库索引算法，也是mysql默认的算法。因为它不仅可以被用在=,&gt;,&gt;=,&lt;,&lt;=和between这些比较操作符上，而且还可以用于like操作符，只要它的查询条件是一个不以通配符开头的常量， 例如：</p>\n<p>– 只要它的查询条件是一个不以通配符开头的常量 select * from user where name like ‘jack%’; – 如果一通配符开头，或者没有使用常量，则不会使用索引，例如： select * from user where name like ‘%jack’;</p>\n<p><strong>Hash算法</strong></p>\n<p>Hash Hash索引只能用于对等比较，例如=,&lt;=&gt;（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。</p>\n<h3 id=\"索引设计的原则？\"><a href=\"#索引设计的原则？\" class=\"headerlink\" title=\"索引设计的原则？\"></a>索引设计的原则？</h3><ol>\n<li>适合索引的列是出现在where子句中的列，或者连接子句中指定的列</li>\n<li>基数较小的类，索引效果较差，没有必要在此列建立索引</li>\n<li>使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，这样能够节省大量索引空间</li>\n<li>不要过度索引。索引需要额外的磁盘空间，并降低写操作的性能。在修改表内容的时候，索引会进行更新甚至重构，索引列越多，这个时间就会越长。所以只保持需要的索引有利于查询即可。</li>\n</ol>\n<h3 id=\"创建索引的原则（重中之重）\"><a href=\"#创建索引的原则（重中之重）\" class=\"headerlink\" title=\"创建索引的原则（重中之重）\"></a>创建索引的原则（重中之重）</h3><p>索引虽好，但也不是无限制的使用，最好符合一下几个原则</p>\n<p>1） 最左前缀匹配原则，组合索引非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>\n<p>2）较频繁作为查询条件的字段才去创建索引</p>\n<p>3）更新频繁字段不适合创建索引</p>\n<p>4）若是不能有效区分数据的列不适合做索引列(如性别，男女未知，最多也就三种，区分度实在太低)</p>\n<p>5）尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。</p>\n<p>6）定义有外键的数据列一定要建立索引。</p>\n<p>7）对于那些查询中很少涉及的列，重复值比较多的列不要建立索引。</p>\n<p>8）对于定义为text、image和bit的数据类型的列不要建立索引。</p>\n<h3 id=\"创建索引的三种方式，删除索引\"><a href=\"#创建索引的三种方式，删除索引\" class=\"headerlink\" title=\"创建索引的三种方式，删除索引\"></a>创建索引的三种方式，删除索引</h3><p>第一种方式：在执行CREATE TABLE时创建索引</p>\n<p>CREATE TABLE user_index2 ( id INT auto_increment PRIMARY KEY, first_name VARCHAR (16), last_name VARCHAR (16), id_card VARCHAR (18), information text, KEY name (first_name, last_name), FULLTEXT KEY (information), UNIQUE KEY (id_card) );</p>\n<p>第二种方式：使用ALTER TABLE命令去增加索引</p>\n<p>ALTER TABLE table_name ADD INDEX index_name (column_list);</p>\n<p>ALTER TABLE用来创建普通索引、UNIQUE索引或PRIMARY KEY索引。</p>\n<p>其中table_name是要增加索引的表名，column_list指出对哪些列进行索引，多列时各列之间用逗号分隔。</p>\n<p>索引名index_name可自己命名，缺省时，MySQL将根据第一个索引列赋一个名称。另外，ALTER TABLE允许在单个语句中更改多个表，因此可以在同时创建多个索引。</p>\n<p>第三种方式：使用CREATE INDEX命令创建</p>\n<p>CREATE INDEX index_name ON table_name (column_list);</p>\n<p>CREATE INDEX可对表增加普通索引或UNIQUE索引。（但是，不能创建PRIMARY KEY索引）</p>\n<p>删除索引</p>\n<p>根据索引名删除普通索引、唯一索引、全文索引：alter table 表名 drop KEY 索引名</p>\n<p>alter table user_index drop KEY name; alter table user_index drop KEY id_card; alter table user_index drop KEY information;</p>\n<p>删除主键索引：alter table 表名 drop primary key（因为主键只有一个）。这里值得注意的是，如果主键自增长，那么不能直接执行此操作（自增长依赖于主键索引）：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/fae6723844de418cb597facb6497d2c7.png\"></p>\n<p>需要取消自增长再行删除：</p>\n<p>alter table user_index – 重新定义字段 MODIFY id int, drop PRIMARY KEY</p>\n<p>但通常不会删除主键，因为设计主键一定与业务逻辑无关。</p>\n<h3 id=\"创建索引时需要注意什么？\"><a href=\"#创建索引时需要注意什么？\" class=\"headerlink\" title=\"创建索引时需要注意什么？\"></a>创建索引时需要注意什么？</h3><ul>\n<li>非空字段：应该指定列为NOT NULL，除非你想存储NULL。在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值；</li>\n<li>取值离散大的字段：（变量各个取值之间的差异程度）的列放到联合索引的前面，可以通过count()函数查看字段的差异值，返回值越大说明字段的唯一值越多字段的离散程度高；</li>\n<li>索引字段越小越好：数据库的数据存储以页为单位一页存储的数据越多一次IO操作获取的数据越大效率越高。</li>\n</ul>\n<h3 id=\"使用索引查询一定能提高查询的性能吗？为什么\"><a href=\"#使用索引查询一定能提高查询的性能吗？为什么\" class=\"headerlink\" title=\"使用索引查询一定能提高查询的性能吗？为什么\"></a>使用索引查询一定能提高查询的性能吗？为什么</h3><p>通常，通过索引查询数据比全表扫描要快。但是我们也必须注意到它的代价。</p>\n<ul>\n<li>索引需要空间来存储，也需要定期维护， 每当有记录在表中增减或索引列被修改时，索引本身也会被修改。 这意味着每条记录的INSERT，DELETE，UPDATE将为此多付出4，5 次的磁盘I/O。 因为索引需要额外的存储空间和处理，那些不必要的索引反而会使查询反应时间变慢。使用索引查询不一定能提高查询性能，索引范围查询(INDEX RANGE SCAN)适用于两种情况:</li>\n<li>基于一个范围的检索，一般查询返回结果集小于表中记录数的30%</li>\n<li>基于非唯一性索引的检索</li>\n</ul>\n<h3 id=\"百万级别或以上的数据如何删除\"><a href=\"#百万级别或以上的数据如何删除\" class=\"headerlink\" title=\"百万级别或以上的数据如何删除\"></a>百万级别或以上的数据如何删除</h3><p>关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，查询MySQL官方手册得知删除数据的速度和创建的索引数量是成正比的。</p>\n<ol>\n<li>所以我们想要删除百万数据的时候可以先删除索引（此时大概耗时三分多钟）</li>\n<li>然后删除其中无用数据（此过程需要不到两分钟）</li>\n<li>删除完成后重新创建索引(此时数据较少了)创建索引也非常快，约十分钟左右。</li>\n<li>与之前的直接删除绝对是要快速很多，更别说万一删除中断,一切删除会回滚。那更是坑了。</li>\n</ol>\n<h3 id=\"前缀索引\"><a href=\"#前缀索引\" class=\"headerlink\" title=\"前缀索引\"></a>前缀索引</h3><p>语法：index(field(10))，使用字段值的前10个字符建立索引，默认是使用字段的全部内容建立索引。</p>\n<p>前提：前缀的标识度高。比如密码就适合建立前缀索引，因为密码几乎各不相同。</p>\n<p>实操的难度：在于前缀截取的长度。</p>\n<p>我们可以利用select count(*)/count(distinct left(password,prefixLen));，通过从调整prefixLen的值（从1自增）查看不同前缀长度的一个平均匹配度，接近1时就可以了（表示一个密码的前prefixLen个字符几乎能确定唯一一条记录）</p>\n<h3 id=\"什么是最左前缀原则？什么是最左匹配原则\"><a href=\"#什么是最左前缀原则？什么是最左匹配原则\" class=\"headerlink\" title=\"什么是最左前缀原则？什么是最左匹配原则\"></a>什么是最左前缀原则？什么是最左匹配原则</h3><ul>\n<li>顾名思义，就是最左优先，在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</li>\n<li>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</li>\n<li>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式</li>\n</ul>\n<h3 id=\"B树和B-树的区别\"><a href=\"#B树和B-树的区别\" class=\"headerlink\" title=\"B树和B+树的区别\"></a>B树和B+树的区别</h3><ul>\n<li><p>在B树中，你可以将键和值存放在内部节点和叶子节点；但在B+树中，内部节点都是键，没有值，叶子节点同时存放键和值。</p>\n</li>\n<li><p>B+树的叶子节点有一条链相连，而B树的叶子节点各自独立。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3cf2b460c14745fcae0c390859d74324.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n</li>\n</ul>\n<h3 id=\"使用B树的好处\"><a href=\"#使用B树的好处\" class=\"headerlink\" title=\"使用B树的好处\"></a>使用B树的好处</h3><p>B树可以在内部节点同时存储键和值，因此，把频繁访问的数据放在靠近根节点的地方将会大大提高热点数据的查询效率。这种特性使得B树在特定数据重复多次查询的场景中更加高效。</p>\n<h3 id=\"使用B-树的好处\"><a href=\"#使用B-树的好处\" class=\"headerlink\" title=\"使用B+树的好处\"></a>使用B+树的好处</h3><p>由于B+树的内部节点只存放键，不存放值，因此，一次读取，可以在内存页中获取更多的键，有利于更快地缩小查找范围。 B+树的叶节点由一条链相连，因此，当需要进行一次全数据遍历的时候，B+树只需要使用O(logN)时间找到最小的一个节点，然后通过链进行O(N)的顺序遍历即可。而B树则需要对树的每一层进行遍历，这会需要更多的内存置换次数，因此也就需要花费更多的时间</p>\n<h3 id=\"Hash索引和B-树所有有什么区别或者说优劣呢\"><a href=\"#Hash索引和B-树所有有什么区别或者说优劣呢\" class=\"headerlink\" title=\"Hash索引和B+树所有有什么区别或者说优劣呢?\"></a>Hash索引和B+树所有有什么区别或者说优劣呢?</h3><p>首先要知道Hash索引和B+树索引的底层实现原理：</p>\n<p>hash索引底层就是hash表，进行查找时，调用一次hash函数就可以获取到相应的键值，之后进行回表查询获得实际数据。B+树底层实现是多路平衡查找树。对于每一次的查询都是从根节点出发，查找到叶子节点方可以获得所查键值，然后根据查询判断是否需要回表查询数据。</p>\n<p>那么可以看出他们有以下的不同：</p>\n<ul>\n<li>hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。</li>\n</ul>\n<p>因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。</p>\n<ul>\n<li>hash索引不支持使用索引进行排序，原理同上。</li>\n<li>hash索引不支持模糊查询以及多列索引的最左前缀匹配。原理也是因为hash函数的不可预测。AAAA和AAAAB的索引没有相关性。</li>\n<li>hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。</li>\n<li>hash索引虽然在等值查询上较快，但是不稳定。性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。</li>\n</ul>\n<p>因此，在大多数情况下，直接选择B+树索引可以获得稳定且较好的查询速度。而不需要使用hash索引。</p>\n<h3 id=\"数据库为什么使用B-树而不是B树\"><a href=\"#数据库为什么使用B-树而不是B树\" class=\"headerlink\" title=\"数据库为什么使用B+树而不是B树\"></a>数据库为什么使用B+树而不是B树</h3><ul>\n<li>B树只适合随机检索，而B+树同时支持随机检索和顺序检索；</li>\n<li>B+树空间利用率更高，可减少I/O次数，磁盘读写代价更低。一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗。B+树的内部结点并没有指向关键字具体信息的指针，只是作为索引使用，其内部结点比B树小，盘块能容纳的结点中关键字数量更多，一次性读入内存中可以查找的关键字也就越多，相对的，IO读写次数也就降低了。而IO读写次数是影响索引检索效率的最大因素；</li>\n<li>B+树的查询效率更加稳定。B树搜索有可能会在非叶子结点结束，越靠近根节点的记录查找时间越短，只要找到关键字即可确定记录的存在，其性能等价于在关键字全集内做一次二分查找。而在B+树中，顺序检索比较明显，随机检索时，任何关键字的查找都必须走一条从根节点到叶节点的路，所有关键字的查找路径长度相同，导致每一个关键字的查询效率相当。</li>\n<li>B-树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。B+树的叶子节点使用指针顺序连接在一起，只要遍历叶子节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而B树不支持这样的操作。</li>\n<li>增删文件（节点）时，效率更高。因为B+树的叶子节点包含所有关键字，并以有序的链表结构存储，这样可很好提高增删效率。</li>\n</ul>\n<h3 id=\"B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\"><a href=\"#B-树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\" class=\"headerlink\" title=\"B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，\"></a>B+树在满足聚簇索引和覆盖索引的时候不需要回表查询数据，</h3><p>在B+树的索引中，叶子节点可能存储了当前的key值，也可能存储了当前的key值以及整行的数据，这就是聚簇索引和非聚簇索引。 在InnoDB中，只有主键索引是聚簇索引，如果没有主键，则挑选一个唯一键建立聚簇索引。如果没有唯一键，则隐式的生成一个键来建立聚簇索引。</p>\n<p>当查询使用聚簇索引时，在对应的叶子节点，可以获取到整行数据，因此不用再次进行回表查询。</p>\n<h3 id=\"什么是聚簇索引？何时使用聚簇索引与非聚簇索引\"><a href=\"#什么是聚簇索引？何时使用聚簇索引与非聚簇索引\" class=\"headerlink\" title=\"什么是聚簇索引？何时使用聚簇索引与非聚簇索引\"></a>什么是聚簇索引？何时使用聚簇索引与非聚簇索引</h3><ul>\n<li>聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据</li>\n<li>非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因</li>\n</ul>\n<p>澄清一个概念：innodb中，在聚簇索引之上创建的索引称之为辅助索引，辅助索引访问数据总是需要二次查找，非聚簇索引都是辅助索引，像复合索引、前缀索引、唯一索引，辅助索引叶子节点存储的不再是行的物理位置，而是主键值</p>\n<p>何时使用聚簇索引与非聚簇索引</p>\n<p><img src=\"https://img-blog.csdnimg.cn/54d88ff9fc2c48588d04ca76611f8ecc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<h3 id=\"非聚簇索引一定会回表查询吗？\"><a href=\"#非聚簇索引一定会回表查询吗？\" class=\"headerlink\" title=\"非聚簇索引一定会回表查询吗？\"></a>非聚簇索引一定会回表查询吗？</h3><p>不一定，这涉及到查询语句所要求的字段是否全部命中了索引，如果全部命中了索引，那么就不必再进行回表查询。</p>\n<p>举个简单的例子，假设我们在员工表的年龄上建立了索引，那么当进行select age from employee where age &lt; 20的查询时，在索引的叶子节点上，已经包含了age信息，不会再次进行回表查询。</p>\n<h3 id=\"联合索引是什么？为什么需要注意联合索引中的顺序？\"><a href=\"#联合索引是什么？为什么需要注意联合索引中的顺序？\" class=\"headerlink\" title=\"联合索引是什么？为什么需要注意联合索引中的顺序？\"></a>联合索引是什么？为什么需要注意联合索引中的顺序？</h3><p>MySQL可以使用多个字段同时建立一个索引，叫做联合索引。在联合索引中，如果想要命中索引，需要按照建立索引时的字段顺序挨个使用，否则无法命中索引。</p>\n<p>具体原因为:</p>\n<p>MySQL使用索引时需要索引有序，假设现在建立了”name，age，school”的联合索引，那么索引的排序为: 先按照name排序，如果name相同，则按照age排序，如果age的值也相等，则按照school进行排序。</p>\n<p>当进行查询时，此时索引仅仅按照name严格有序，因此必须首先使用name字段进行等值查询，之后对于匹配到的列而言，其按照age字段严格有序，此时可以使用age字段用做索引查找，以此类推。因此在建立联合索引的时候应该注意索引列的顺序，一般情况下，将查询需求频繁或者字段选择性高的列放在前面。此外可以根据特例的查询或者表结构进行单独的调整。</p>\n<h2 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h2><h3 id=\"什么是数据库事务？\"><a href=\"#什么是数据库事务？\" class=\"headerlink\" title=\"什么是数据库事务？\"></a>什么是数据库事务？</h3><p>事务是一个不可分割的数据库操作序列，也是数据库并发控制的基本单位，其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p>\n<p>事务最经典也经常被拿出来说例子就是转账了。</p>\n<p>假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>\n<h3 id=\"事物的四大特性-ACID-介绍一下\"><a href=\"#事物的四大特性-ACID-介绍一下\" class=\"headerlink\" title=\"事物的四大特性(ACID)介绍一下?\"></a>事物的四大特性(ACID)介绍一下?</h3><p>关系性数据库需要遵循ACID规则，具体内容如下：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9a1d7c93ca874557911ae2cb578dcb4a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_10,color_FFFFFF,t_70,g_se,x_16\"></p>\n<ol>\n<li><p><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>\n</li>\n<li><p><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</p>\n</li>\n<li><p><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p>\n<p><img src=\"https://img-blog.csdnimg.cn/9a95f01f0e8c41a88e210e387a98da47.png\" alt=\"在这里插入图片描述\"></p>\n</li>\n<li><p><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>\n</li>\n</ol>\n<h3 id=\"什么是脏读？幻读？不可重复读？\"><a href=\"#什么是脏读？幻读？不可重复读？\" class=\"headerlink\" title=\"什么是脏读？幻读？不可重复读？\"></a>什么是脏读？幻读？不可重复读？</h3><ul>\n<li>脏读(Drity Read)：某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个RollBack了操作，则后一个事务所读取的数据就会是不正确的。</li>\n<li>不可重复读(Non-repeatable read):在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。</li>\n<li>幻读(Phantom Read):在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。</li>\n</ul>\n<h3 id=\"什么是事务的隔离级别？MySQL的默认隔离级别是什么？\"><a href=\"#什么是事务的隔离级别？MySQL的默认隔离级别是什么？\" class=\"headerlink\" title=\"什么是事务的隔离级别？MySQL的默认隔离级别是什么？\"></a>什么是事务的隔离级别？MySQL的默认隔离级别是什么？</h3><p>为了达到事务的四大特性，数据库定义了4种不同的事务隔离级别，由低到高依次为Read uncommitted、Read committed、Repeatable read、Serializable，这四个级别可以逐个解决脏读、不可重复读、幻读这几类问题。</p>\n<p><strong>隔离级别<strong><strong>脏读</strong></strong>不可重复读****幻影读</strong>READ-UNCOMMITTED√√√READ-COMMITTED×√√REPEATABLE-READ××√SERIALIZABLE×××</p>\n<p><strong>SQL 标准定义了四个隔离级别：</strong></p>\n<ul>\n<li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li>\n<li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li>\n<li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li>\n<li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li>\n</ul>\n<p>这里需要注意的是：Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</p>\n<p>事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。</p>\n<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p>\n<p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"对MySQL的锁了解吗\"><a href=\"#对MySQL的锁了解吗\" class=\"headerlink\" title=\"对MySQL的锁了解吗\"></a>对MySQL的锁了解吗</h3><p>当数据库有并发事务的时候，可能会产生数据的不一致，这时候需要一些机制来保证访问的次序，锁机制就是这样的一个机制。</p>\n<p>就像酒店的房间，如果大家随意进出，就会出现多人抢夺同一个房间的情况，而在房间上装上锁，申请到钥匙的人才可以入住并且将房间锁起来，其他人只有等他使用完毕才可以再次使用。</p>\n<h3 id=\"隔离级别与锁的关系\"><a href=\"#隔离级别与锁的关系\" class=\"headerlink\" title=\"隔离级别与锁的关系\"></a>隔离级别与锁的关系</h3><p>在Read Uncommitted级别下，读取数据不需要加共享锁，这样就不会跟被修改的数据上的排他锁冲突</p>\n<p>在Read Committed级别下，读操作需要加共享锁，但是在语句执行完以后释放共享锁；</p>\n<p>在Repeatable Read级别下，读操作需要加共享锁，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁。</p>\n<p>SERIALIZABLE 是限制性最强的隔离级别，因为该级别<strong>锁定整个范围的键</strong>，并一直持有锁，直到事务完成。</p>\n<h3 id=\"按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\"><a href=\"#按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\" class=\"headerlink\" title=\"按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法\"></a>按照锁的粒度分数据库锁有哪些？锁机制与InnoDB锁算法</h3><p>在关系型数据库中，可以<strong>按照锁的粒度把数据库锁分</strong>为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。</p>\n<p><strong>MyISAM和InnoDB存储引擎使用的锁：</strong></p>\n<ul>\n<li>MyISAM采用表级锁(table-level locking)。</li>\n<li>InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁</li>\n</ul>\n<p>行级锁，表级锁和页级锁对比</p>\n<p><strong>行级锁</strong> 行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。</p>\n<p>特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p>\n<p><strong>表级锁</strong> 表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。</p>\n<p>特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p>\n<p><strong>页级锁</strong> 页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。</p>\n<p>特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般</p>\n<h3 id=\"从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\"><a href=\"#从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\" class=\"headerlink\" title=\"从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了\"></a>从锁的类别上分MySQL都有哪些锁呢？像上面那样子进行锁定岂不是有点阻碍并发效率了</h3><p><strong>从锁的类别上来讲</strong>，有共享锁和排他锁。</p>\n<p>共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。</p>\n<p>排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。</p>\n<p>用上面的例子来说就是用户的行为有两种，一种是来看房，多个用户一起看房是可以接受的。 一种是真正的入住一晚，在这期间，无论是想入住的还是想看房的都不可以。</p>\n<p>锁的粒度取决于具体的存储引擎，InnoDB实现了行级锁，页级锁，表级锁。</p>\n<p>他们的加锁开销从大到小，并发能力也是从大到小。</p>\n<h3 id=\"MySQL中InnoDB引擎的行锁是怎么实现的？\"><a href=\"#MySQL中InnoDB引擎的行锁是怎么实现的？\" class=\"headerlink\" title=\"MySQL中InnoDB引擎的行锁是怎么实现的？\"></a>MySQL中InnoDB引擎的行锁是怎么实现的？</h3><p>答：InnoDB是基于索引来完成行锁</p>\n<p>例: select * from tab_with_index where id = 1 for update;</p>\n<p>for update 可以根据条件来完成行锁锁定，并且 id 是有索引键的列，如果 id 不是索引键那么InnoDB将完成表锁，并发将无从谈起</p>\n<h3 id=\"InnoDB存储引擎的锁的算法有三种\"><a href=\"#InnoDB存储引擎的锁的算法有三种\" class=\"headerlink\" title=\"InnoDB存储引擎的锁的算法有三种\"></a>InnoDB存储引擎的锁的算法有三种</h3><ul>\n<li>Record lock：单个行记录上的锁</li>\n<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>\n<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>\n</ul>\n<p><strong>相关知识点：</strong></p>\n<ol>\n<li>innodb对于行的查询使用next-key lock</li>\n<li>Next-locking keying为了解决Phantom Problem幻读问题</li>\n<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>\n<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>\n<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>\n</ol>\n<h3 id=\"什么是死锁？怎么解决？\"><a href=\"#什么是死锁？怎么解决？\" class=\"headerlink\" title=\"什么是死锁？怎么解决？\"></a>什么是死锁？怎么解决？</h3><p>死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。</p>\n<p>常见的解决死锁的方法</p>\n<p>1、如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。</p>\n<p>2、在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；</p>\n<p>3、对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；</p>\n<p>如果业务处理不好可以用分布式事务锁或者使用乐观锁</p>\n<h3 id=\"数据库的乐观锁和悲观锁是什么？怎么实现的？\"><a href=\"#数据库的乐观锁和悲观锁是什么？怎么实现的？\" class=\"headerlink\" title=\"数据库的乐观锁和悲观锁是什么？怎么实现的？\"></a>数据库的乐观锁和悲观锁是什么？怎么实现的？</h3><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。乐观并发控制（乐观锁）和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。</p>\n<p><strong>悲观锁</strong>：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制</p>\n<p><strong>乐观锁</strong>：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。</p>\n<p><strong>两种锁的使用场景</strong></p>\n<p>从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像<strong>乐观锁适用于写比较少的情况下（多读场景）</strong>，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。</p>\n<p>但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以<strong>一般多写的场景下用悲观锁就比较合适。</strong></p>\n<h2 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h2><h3 id=\"为什么要使用视图？什么是视图？\"><a href=\"#为什么要使用视图？什么是视图？\" class=\"headerlink\" title=\"为什么要使用视图？什么是视图？\"></a>为什么要使用视图？什么是视图？</h3><p>为了提高复杂SQL语句的复用性和表操作的安全性，MySQL数据库管理系统提供了视图特性。所谓视图，本质上是一种虚拟表，在物理上是不存在的，其内容与真实的表相似，包含一系列带有名称的列和行数据。但是，视图并不在数据库中以储存的数据值形式存在。行和列数据来自定义视图的查询所引用基本表，并且在具体引用视图时动态生成。</p>\n<p>视图使开发者只关心感兴趣的某些特定数据和所负责的特定任务，只能看到视图中所定义的数据，而不是视图所引用表中的数据，从而提高了数据库中数据的安全性。</p>\n<h3 id=\"视图有哪些特点？\"><a href=\"#视图有哪些特点？\" class=\"headerlink\" title=\"视图有哪些特点？\"></a>视图有哪些特点？</h3><p>视图的特点如下:</p>\n<ul>\n<li>视图的列可以来自不同的表，是表的抽象和在逻辑意义上建立的新关系。</li>\n<li>视图是由基本表(实表)产生的表(虚表)。</li>\n<li>视图的建立和删除不影响基本表。</li>\n<li>对视图内容的更新(添加，删除和修改)直接影响基本表。</li>\n<li>当视图来自多个基本表时，不允许添加和删除数据。</li>\n</ul>\n<p>视图的操作包括创建视图，查看视图，删除视图和修改视图。</p>\n<h3 id=\"视图的使用场景有哪些？\"><a href=\"#视图的使用场景有哪些？\" class=\"headerlink\" title=\"视图的使用场景有哪些？\"></a>视图的使用场景有哪些？</h3><p>视图根本用途：简化sql查询，提高开发效率。如果说还有另外一个用途那就是兼容老的表结构。</p>\n<p>下面是视图的常见使用场景：</p>\n<ul>\n<li>重用SQL语句；</li>\n<li>简化复杂的SQL操作。在编写查询后，可以方便的重用它而不必知道它的基本查询细节；</li>\n<li>使用表的组成部分而不是整个表；</li>\n<li>保护数据。可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；</li>\n<li>更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。</li>\n</ul>\n<h3 id=\"视图的优点\"><a href=\"#视图的优点\" class=\"headerlink\" title=\"视图的优点\"></a>视图的优点</h3><ol>\n<li>查询简单化。视图能简化用户的操作</li>\n<li>数据安全性。视图使用户能以多种角度看待同一数据，能够对机密数据提供安全保护</li>\n<li>逻辑数据独立性。视图对重构数据库提供了一定程度的逻辑独立性</li>\n</ol>\n<h3 id=\"视图的缺点\"><a href=\"#视图的缺点\" class=\"headerlink\" title=\"视图的缺点\"></a>视图的缺点</h3><ol>\n<li><p>性能。数据库必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，即使是视图的一个简单查询，数据库也把它变成一个复杂的结合体，需要花费一定的时间。</p>\n</li>\n<li><p>修改限制。当用户试图修改视图的某些行时，数据库必须把它转化为对基本表的某些行的修改。事实上，当从视图中插入或者删除时，情况也是这样。对于简单视图来说，这是很方便的，但是，对于比较复杂的视图，可能是不可修改的</p>\n<p>这些视图有如下特征：1.有UNIQUE等集合操作符的视图。2.有GROUP BY子句的视图。3.有诸如AVG\\SUM\\MAX等聚合函数的视图。 4.使用DISTINCT关键字的视图。5.连接表的视图（其中有些例外）</p>\n</li>\n</ol>\n<h3 id=\"什么是游标？\"><a href=\"#什么是游标？\" class=\"headerlink\" title=\"什么是游标？\"></a>什么是游标？</h3><p>游标是系统为用户开设的一个数据缓冲区，存放SQL语句的执行结果，每个游标区都有一个名字。用户可以通过游标逐一获取记录并赋给主变量，交由主语言进一步处理。</p>\n<h2 id=\"存储过程与函数\"><a href=\"#存储过程与函数\" class=\"headerlink\" title=\"存储过程与函数\"></a>存储过程与函数</h2><h3 id=\"什么是存储过程？有哪些优缺点？\"><a href=\"#什么是存储过程？有哪些优缺点？\" class=\"headerlink\" title=\"什么是存储过程？有哪些优缺点？\"></a>什么是存储过程？有哪些优缺点？</h3><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需要创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p>\n<p><strong>优点</strong></p>\n<p>1）存储过程是预编译过的，执行效率高。</p>\n<p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p>\n<p>3）安全性高，执行存储过程需要有一定权限的用户。</p>\n<p>4）存储过程可以重复使用，减少数据库开发人员的工作量。</p>\n<p><strong>缺点</strong></p>\n<p>1）调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。</p>\n<p>2）移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。</p>\n<p>3）重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。</p>\n<p>4）如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的，维护起来更麻烦。</p>\n<h2 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h2><h3 id=\"什么是触发器？触发器的使用场景有哪些？\"><a href=\"#什么是触发器？触发器的使用场景有哪些？\" class=\"headerlink\" title=\"什么是触发器？触发器的使用场景有哪些？\"></a>什么是触发器？触发器的使用场景有哪些？</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊的存储过程。触发器是指一段代码，当触发某个事件时，自动执行这些代码。</p>\n<p>使用场景</p>\n<ul>\n<li>可以通过数据库中的相关表实现级联更改。</li>\n<li>实时监控某张表中的某个字段的更改而需要做出相应的处理。</li>\n<li>例如可以生成某些业务的编号。</li>\n<li>注意不要滥用，否则会造成数据库及应用程序的维护困难。</li>\n<li>大家需要牢记以上基础知识点，重点是理解数据类型CHAR和VARCHAR的差异，表存储引擎InnoDB和MyISAM的区别。</li>\n</ul>\n<h3 id=\"MySQL中都有哪些触发器？\"><a href=\"#MySQL中都有哪些触发器？\" class=\"headerlink\" title=\"MySQL中都有哪些触发器？\"></a>MySQL中都有哪些触发器？</h3><p>在MySQL数据库中有如下六种触发器：</p>\n<ul>\n<li>Before Insert</li>\n<li>After Insert</li>\n<li>Before Update</li>\n<li>After Update</li>\n<li>Before Delete</li>\n<li>After Delete</li>\n</ul>\n<h2 id=\"常用SQL语句\"><a href=\"#常用SQL语句\" class=\"headerlink\" title=\"常用SQL语句\"></a>常用SQL语句</h2><h3 id=\"SQL语句主要分为哪几类\"><a href=\"#SQL语句主要分为哪几类\" class=\"headerlink\" title=\"SQL语句主要分为哪几类\"></a>SQL语句主要分为哪几类</h3><p>数据定义语言DDL（Data Ddefinition Language）CREATE，DROP，ALTER</p>\n<p>主要为以上操作 即对逻辑结构等有操作的，其中包括表结构，视图和索引。</p>\n<p>数据查询语言DQL（Data Query Language）SELECT</p>\n<p>这个较为好理解 即查询操作，以select关键字。各种简单查询，连接查询等 都属于DQL。</p>\n<p>数据操纵语言DML（Data Manipulation Language）INSERT，UPDATE，DELETE</p>\n<p>主要为以上操作 即对数据进行操作的，对应上面所说的查询操作 DQL与DML共同构建了多数初级程序员常用的增删改查操作。而查询是较为特殊的一种 被划分到DQL中。</p>\n<p>数据控制功能DCL（Data Control Language）GRANT，REVOKE，COMMIT，ROLLBACK</p>\n<p>主要为以上操作 即对数据库安全性完整性等有操作的，可以简单的理解为权限控制等。</p>\n<h3 id=\"超键、候选键、主键、外键分别是什么？\"><a href=\"#超键、候选键、主键、外键分别是什么？\" class=\"headerlink\" title=\"超键、候选键、主键、外键分别是什么？\"></a>超键、候选键、主键、外键分别是什么？</h3><ul>\n<li>超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li>\n<li>候选键：是最小超键，即没有冗余元素的超键。</li>\n<li>主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</li>\n<li>外键：在一个表中存在的另一个表的主键称此表的外键。</li>\n</ul>\n<h3 id=\"SQL-约束有哪几种？\"><a href=\"#SQL-约束有哪几种？\" class=\"headerlink\" title=\"SQL 约束有哪几种？\"></a>SQL 约束有哪几种？</h3><blockquote>\n<p>SQL 约束有哪几种？</p>\n</blockquote>\n<ul>\n<li>NOT NULL: 用于控制字段的内容一定不能为空（NULL）。</li>\n<li>UNIQUE: 控件字段内容不能重复，一个表允许有多个 Unique 约束。</li>\n<li>PRIMARY KEY: 也是用于控件字段内容不能重复，但它在一个表只允许出现一个。</li>\n<li>FOREIGN KEY: 用于预防破坏表之间连接的动作，也能防止非法数据插入外键列，因为它必须是它指向的那个表中的值之一。</li>\n<li>CHECK: 用于控制字段的值范围。</li>\n</ul>\n<h3 id=\"六种关联查询\"><a href=\"#六种关联查询\" class=\"headerlink\" title=\"六种关联查询\"></a>六种关联查询</h3><ul>\n<li>交叉连接（CROSS JOIN）</li>\n<li>内连接（INNER JOIN）</li>\n<li>外连接（LEFT JOIN/RIGHT JOIN）</li>\n<li>联合查询（UNION与UNION ALL）</li>\n<li>全连接（FULL JOIN）</li>\n<li>交叉连接（CROSS JOIN）</li>\n</ul>\n<p>SELECT * FROM A,B(,C)或者SELECT * FROM A CROSS JOIN B (CROSS JOIN C)#没有任何关联条件，结果是笛卡尔积，结果集会很大，没有意义，很少使用内连接（INNER JOIN）SELECT * FROM A,B WHERE A.id=B.id或者SELECT * FROM A INNER JOIN B ON A.id=B.id多表中同时符合某种条件的数据记录的集合，INNER JOIN可以缩写为JOIN</p>\n<p>内连接分为三类</p>\n<ul>\n<li>等值连接：ON A.id=B.id</li>\n<li>不等值连接：ON A.id &gt; B.id</li>\n<li>自连接：SELECT * FROM A T1 INNER JOIN A T2 ON T1.id=T2.pid</li>\n</ul>\n<p>外连接（LEFT JOIN/RIGHT JOIN）</p>\n<ul>\n<li>左外连接：LEFT OUTER JOIN, 以左表为主，先查询出左表，按照ON后的关联条件匹配右表，没有匹配到的用NULL填充，可以简写成LEFT JOIN</li>\n<li>右外连接：RIGHT OUTER JOIN, 以右表为主，先查询出右表，按照ON后的关联条件匹配左表，没有匹配到的用NULL填充，可以简写成RIGHT JOIN</li>\n</ul>\n<p>联合查询（UNION与UNION ALL）</p>\n<p>SELECT * FROM A UNION SELECT * FROM B UNION …</p>\n<ul>\n<li>就是把多个结果集集中在一起，UNION前的结果为基准，需要注意的是联合查询的列数要相等，相同的记录行会合并</li>\n<li>如果使用UNION ALL，不会合并重复的记录行</li>\n<li>效率 UNION 高于 UNION ALL</li>\n</ul>\n<p>全连接（FULL JOIN）</p>\n<ul>\n<li>MySQL不支持全连接</li>\n<li>可以使用LEFT JOIN 和UNION和RIGHT JOIN联合使用</li>\n</ul>\n<p>SELECT * FROM A LEFT JOIN B ON A.id=B.id UNIONSELECT * FROM A RIGHT JOIN B ON A.id=B.id</p>\n<p>表连接面试题</p>\n<p>有2张表，1张R、1张S，R表有ABC三列，S表有CD两列，表中各有三条记录。</p>\n<p>R表</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n</tr>\n</tbody></table>\n<p>S表</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<ol>\n<li>交叉连接(笛卡尔积):</li>\n</ol>\n<p>select r.<em>,s.</em> from r,s</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>内连接结果：</p>\n<p>select r.<em>,s.</em> from r inner join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>左连接结果：</p>\n<p>select r.<em>,s.</em> from r left join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>右连接结果：</p>\n<p>select r.<em>,s.</em> from r right join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n<th align=\"left\"></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">A</td>\n<td align=\"left\">B</td>\n<td align=\"left\">C</td>\n<td align=\"left\">C</td>\n<td align=\"left\">D</td>\n</tr>\n<tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<ol>\n<li><p>全表连接的结果（MySql不支持，Oracle支持）：</p>\n<p>select r.<em>,s.</em> from r full join s on r.c=s.c</p>\n</li>\n</ol>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>A</strong></th>\n<th align=\"left\"><strong>B</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>C</strong></th>\n<th align=\"left\"><strong>D</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">a1</td>\n<td align=\"left\">b1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">c1</td>\n<td align=\"left\">d1</td>\n</tr>\n<tr>\n<td align=\"left\">a2</td>\n<td align=\"left\">b2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">c2</td>\n<td align=\"left\">d2</td>\n</tr>\n<tr>\n<td align=\"left\">a3</td>\n<td align=\"left\">b3</td>\n<td align=\"left\">c3</td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n</tr>\n<tr>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\"></td>\n<td align=\"left\">c4</td>\n<td align=\"left\">d3</td>\n</tr>\n</tbody></table>\n<h3 id=\"什么是子查询\"><a href=\"#什么是子查询\" class=\"headerlink\" title=\"什么是子查询\"></a>什么是子查询</h3><ol>\n<li>条件：一条SQL语句的查询结果做为另一条查询语句的条件或查询结果</li>\n<li>嵌套：多条SQL语句嵌套使用，内部的SQL查询语句称为子查询。</li>\n</ol>\n<h3 id=\"子查询的三种情况\"><a href=\"#子查询的三种情况\" class=\"headerlink\" title=\"子查询的三种情况\"></a>子查询的三种情况</h3><ol>\n<li>子查询是单行单列的情况：结果集是一个值，父查询使用：=、 &lt;、 &gt; 等运算符</li>\n</ol>\n<p>– 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);</p>\n<ol>\n<li>子查询是多行单列的情况：结果集类似于一个数组，父查询使用：in 运算符</li>\n</ol>\n<p>– 查询工资最高的员工是谁？ select * from employee where salary=(select max(salary) from employee);</p>\n<ol>\n<li>子查询是多行多列的情况：结果集类似于一张虚拟表，不能用于where条件，用于select子句中做为子表</li>\n</ol>\n<p>– 1) 查询出2011年以后入职的员工信息 – 2) 查询所有的部门信息，与上面的虚拟表中的信息比对，找出所有部门ID相等的员工。 select * from dept d, (select * from employee where join_date &gt; ‘2011-1-1’) e where e.dept_id = d.id; – 使用表连接： select d.<em>, e.</em> from dept d inner join employee e on d.id = e.dept_id where e.join_date &gt; ‘2011-1-1’</p>\n<h3 id=\"mysql中-in-和-exists-区别\"><a href=\"#mysql中-in-和-exists-区别\" class=\"headerlink\" title=\"mysql中 in 和 exists 区别\"></a>mysql中 in 和 exists 区别</h3><p>mysql中的in语句是把外表和内表作hash 连接，而exists语句是对外表作loop循环，每次loop循环再对内表进行查询。一直大家都认为exists比in语句的效率要高，这种说法其实是不准确的。这个是要区分环境的。</p>\n<ol>\n<li>如果查询的两个表大小相当，那么用in和exists差别不大。</li>\n<li>如果两个表中一个较小，一个是大表，则子查询表大的用exists，子查询表小的用in。</li>\n<li>not in 和not exists：如果查询语句使用了not in，那么内外表都进行全表扫描，没有用到索引；而not extsts的子查询依然能用到表上的索引。所以无论那个表大，用not exists都比not in要快。</li>\n</ol>\n<h3 id=\"varchar与char的区别\"><a href=\"#varchar与char的区别\" class=\"headerlink\" title=\"varchar与char的区别\"></a>varchar与char的区别</h3><p><strong>char的特点</strong></p>\n<ul>\n<li>char表示定长字符串，长度是固定的；</li>\n<li>如果插入数据的长度小于char的固定长度时，则用空格填充；</li>\n<li>因为长度固定，所以存取速度要比varchar快很多，甚至能快50%，但正因为其长度固定，所以会占据多余的空间，是空间换时间的做法；</li>\n<li>对于char来说，最多能存放的字符个数为255，和编码无关</li>\n</ul>\n<p><strong>varchar的特点</strong></p>\n<ul>\n<li>varchar表示可变长字符串，长度是可变的；</li>\n<li>插入的数据是多长，就按照多长来存储；</li>\n<li>varchar在存取方面与char相反，它存取慢，因为长度不固定，但正因如此，不占据多余的空间，是时间换空间的做法；</li>\n<li>对于varchar来说，最多能存放的字符个数为65532</li>\n</ul>\n<p>总之，结合性能角度（char更快）和节省磁盘空间角度（varchar更小），具体情况还需具体来设计数据库才是妥当的做法。</p>\n<h3 id=\"varchar-50-中50的涵义\"><a href=\"#varchar-50-中50的涵义\" class=\"headerlink\" title=\"varchar(50)中50的涵义\"></a>varchar(50)中50的涵义</h3><p>最多存放50个字符，varchar(50)和(200)存储hello所占空间一样，但后者在排序时会消耗更多内存，因为order by col采用fixed_length计算col长度(memory引擎也一样)。在早期 MySQL 版本中， 50 代表字节数，现在代表字符数。</p>\n<h3 id=\"int-20-中20的涵义\"><a href=\"#int-20-中20的涵义\" class=\"headerlink\" title=\"int(20)中20的涵义\"></a>int(20)中20的涵义</h3><p>是指显示字符的长度。20表示最大显示宽度为20，但仍占4字节存储，存储范围不变；</p>\n<p>不影响内部存储，只是影响带 zerofill 定义的 int 时，前面补多少个 0，易于报表展示</p>\n<h3 id=\"mysql为什么这么设计\"><a href=\"#mysql为什么这么设计\" class=\"headerlink\" title=\"mysql为什么这么设计\"></a>mysql为什么这么设计</h3><p>对大多数应用没有意义，只是规定一些工具用来显示字符的个数；int(1)和int(20)存储和计算均一样；</p>\n<h3 id=\"mysql中int-10-和char-10-以及varchar-10-的区别\"><a href=\"#mysql中int-10-和char-10-以及varchar-10-的区别\" class=\"headerlink\" title=\"mysql中int(10)和char(10)以及varchar(10)的区别\"></a>mysql中int(10)和char(10)以及varchar(10)的区别</h3><ul>\n<li><p>int(10)的10表示显示的数据的长度，不是存储数据的大小；chart(10)和varchar(10)的10表示存储数据的大小，即表示存储多少个字符。</p>\n<p>int(10) 10位的数据长度 9999999999，占32个字节，int型4位<br>char(10) 10位固定字符串，不足补空格 最多10个字符<br>varchar(10) 10位可变字符串，不足补空格 最多10个字符</p>\n</li>\n<li><p>char(10)表示存储定长的10个字符，不足10个就用空格补齐，占用更多的存储空间</p>\n</li>\n<li><p>varchar(10)表示存储10个变长的字符，存储多少个就是多少个，空格也按一个字符存储，这一点是和char(10)的空格不同的，char(10)的空格表示占位不算一个字符</p>\n</li>\n</ul>\n<h3 id=\"FLOAT和DOUBLE的区别是什么？\"><a href=\"#FLOAT和DOUBLE的区别是什么？\" class=\"headerlink\" title=\"FLOAT和DOUBLE的区别是什么？\"></a>FLOAT和DOUBLE的区别是什么？</h3><ul>\n<li>FLOAT类型数据可以存储至多8位十进制数，并在内存中占4字节。</li>\n<li>DOUBLE类型数据可以存储至多18位十进制数，并在内存中占8字节。</li>\n</ul>\n<h3 id=\"drop、delete与truncate的区别\"><a href=\"#drop、delete与truncate的区别\" class=\"headerlink\" title=\"drop、delete与truncate的区别\"></a>drop、delete与truncate的区别</h3><p>三者都表示删除，但是三者有一些差别：</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"></th>\n<th align=\"left\"><strong>Delete</strong></th>\n<th align=\"left\"><strong>Truncate</strong></th>\n<th align=\"left\"><strong>Drop</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">类型</td>\n<td align=\"left\">属于DML</td>\n<td align=\"left\">属于DDL</td>\n<td align=\"left\">属于DDL</td>\n</tr>\n<tr>\n<td align=\"left\">回滚</td>\n<td align=\"left\">可回滚</td>\n<td align=\"left\">不可回滚</td>\n<td align=\"left\">不可回滚</td>\n</tr>\n<tr>\n<td align=\"left\">删除内容</td>\n<td align=\"left\">表结构还在，删除表的全部或者一部分数据行</td>\n<td align=\"left\">表结构还在，删除表中的所有数据</td>\n<td align=\"left\">从数据库中删除表，所有的数据行，索引和权限也会被删除</td>\n</tr>\n<tr>\n<td align=\"left\">删除速度</td>\n<td align=\"left\">删除速度慢，需要逐行删除</td>\n<td align=\"left\">删除速度快</td>\n<td align=\"left\">删除速度最快</td>\n</tr>\n</tbody></table>\n<p>因此，在不再需要一张表的时候，用drop；在想删除部分数据行时候，用delete；在保留表而删除所有数据的时候用truncate。</p>\n<h3 id=\"UNION与UNION-ALL的区别？\"><a href=\"#UNION与UNION-ALL的区别？\" class=\"headerlink\" title=\"UNION与UNION ALL的区别？\"></a>UNION与UNION ALL的区别？</h3><ul>\n<li>如果使用UNION ALL，不会合并重复的记录行</li>\n<li>效率 UNION 高于 UNION ALL</li>\n</ul>\n<h2 id=\"SQL优化\"><a href=\"#SQL优化\" class=\"headerlink\" title=\"SQL优化\"></a>SQL优化</h2><h3 id=\"如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？\"><a href=\"#如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到-或者说怎么才可以知道这条语句运行很慢的原因？\" class=\"headerlink\" title=\"如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？\"></a>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到?或者说怎么才可以知道这条语句运行很慢的原因？</h3><p>对于低性能的SQL语句的定位，最重要也是最有效的方法就是使用执行计划，MySQL提供了explain命令来查看语句的执行计划。 我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化，<strong>对于查询语句，最重要的优化方式就是使用索引</strong>。 而<strong>执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等</strong>。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/3762f1f867ab421aa5a4e3e8328e0b8c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<p>执行计划包含的信息 <strong>id</strong> 有一组数字组成。表示一个查询中各个子查询的执行顺序;</p>\n<ul>\n<li>id相同执行顺序由上至下。</li>\n<li>id不同，id值越大优先级越高，越先被执行。</li>\n<li>id为null时表示一个结果集，不需要使用它查询，常出现在包含union等查询语句中。</li>\n</ul>\n<p><strong>select_type</strong> 每个子查询的查询类型，一些常见的查询类型。</p>\n<table>\n<thead>\n<tr>\n<th align=\"left\"><strong>id</strong></th>\n<th align=\"left\"><strong>select_type</strong></th>\n<th align=\"left\"><strong>description</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td align=\"left\">1</td>\n<td align=\"left\">SIMPLE</td>\n<td align=\"left\">不包含任何子查询或union等查询</td>\n</tr>\n<tr>\n<td align=\"left\">2</td>\n<td align=\"left\">PRIMARY</td>\n<td align=\"left\">包含子查询最外层查询就显示为 PRIMARY</td>\n</tr>\n<tr>\n<td align=\"left\">3</td>\n<td align=\"left\">SUBQUERY</td>\n<td align=\"left\">在select或 where字句中包含的查询</td>\n</tr>\n<tr>\n<td align=\"left\">4</td>\n<td align=\"left\">DERIVED</td>\n<td align=\"left\">from字句中包含的查询</td>\n</tr>\n<tr>\n<td align=\"left\">5</td>\n<td align=\"left\">UNION</td>\n<td align=\"left\">出现在union后的查询语句中</td>\n</tr>\n<tr>\n<td align=\"left\">6</td>\n<td align=\"left\">UNION RESULT</td>\n<td align=\"left\">从UNION中获取结果集，例如上文的第三个例子</td>\n</tr>\n</tbody></table>\n<p><strong>table</strong> 查询的数据表，当从衍生表中查数据时会显示 x 表示对应的执行计划id <strong>partitions</strong> 表分区、表创建的时候可以指定通过那个列进行表分区。 举个例子：</p>\n<p>create table tmp ( id int unsigned not null AUTO_INCREMENT, name varchar(255), PRIMARY KEY (id) ) engine = innodb partition by key (id) partitions 5;</p>\n<p><strong>type</strong>(非常重要，可以看到有没有走索引) 访问类型</p>\n<ul>\n<li>ALL 扫描全表数据</li>\n<li>index 遍历索引</li>\n<li>range 索引范围查找</li>\n<li>index_subquery 在子查询中使用 ref</li>\n<li>unique_subquery 在子查询中使用 eq_ref</li>\n<li>ref_or_null 对Null进行索引的优化的 ref</li>\n<li>fulltext 使用全文索引</li>\n<li>ref 使用非唯一索引查找数据</li>\n<li>eq_ref 在join查询中使用PRIMARY KEYorUNIQUE NOT NULL索引关联。</li>\n</ul>\n<p><strong>possible_keys</strong> 可能使用的索引，注意不一定会使用。查询涉及到的字段上若存在索引，则该索引将被列出来。当该列为 NULL时就要考虑当前的SQL是否需要优化了。</p>\n<p><strong>key</strong> 显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL。</p>\n<p><strong>TIPS</strong>:查询中若使用了覆盖索引(覆盖索引：索引的数据覆盖了需要查询的所有数据)，则该索引仅出现在key列表中</p>\n<p><strong>key_length</strong> 索引长度</p>\n<p><strong>ref</strong> 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</p>\n<p><strong>rows</strong> 返回估算的结果集数目，并不是一个准确的值。</p>\n<p><strong>extra</strong> 的信息非常丰富，常见的有：</p>\n<ol>\n<li>Using index 使用覆盖索引</li>\n<li>Using where 使用了用where子句来过滤结果集</li>\n<li>Using filesort 使用文件排序，使用非索引列进行排序时出现，非常消耗性能，尽量优化。</li>\n<li>Using temporary 使用了临时表 sql优化的目标可以参考阿里开发手册</li>\n</ol>\n<p>【推荐】SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p>\n<h3 id=\"SQL的生命周期？\"><a href=\"#SQL的生命周期？\" class=\"headerlink\" title=\"SQL的生命周期？\"></a>SQL的生命周期？</h3><ol>\n<li><p>应用服务器与数据库服务器建立一个连接</p>\n</li>\n<li><p>数据库进程拿到请求sql</p>\n</li>\n<li><p>解析并生成执行计划，执行</p>\n</li>\n<li><p>读取数据到内存并进行逻辑处理</p>\n</li>\n<li><p>通过步骤一的连接，发送结果到客户端</p>\n</li>\n<li><p>关掉连接，释放资源</p>\n<p><img src=\"https://img-blog.csdnimg.cn/86be8bfa609d4a909568f3b64ec891d3.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ol>\n<h3 id=\"大表数据查询，怎么优化\"><a href=\"#大表数据查询，怎么优化\" class=\"headerlink\" title=\"大表数据查询，怎么优化\"></a>大表数据查询，怎么优化</h3><ol>\n<li>优化shema、sql语句+索引；</li>\n<li>第二加缓存，memcached, redis；</li>\n<li>主从复制，读写分离；</li>\n<li>垂直拆分，根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；</li>\n<li>水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key, 为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表；</li>\n</ol>\n<h3 id=\"超大分页怎么处理？\"><a href=\"#超大分页怎么处理？\" class=\"headerlink\" title=\"超大分页怎么处理？\"></a>超大分页怎么处理？</h3><p>超大的分页一般从两个方向上来解决.</p>\n<ul>\n<li>数据库层面,这也是我们主要集中关注的(虽然收效没那么大),类似于select * from table where age &gt; 20 limit 1000000,10这种查询其实也是有可以优化的余地的. 这条语句需要load1000000数据然后基本上全部丢弃,只取10条当然比较慢. 当时我们可以修改为select * from table where id in (select id from table where age &gt; 20 limit 1000000,10).这样虽然也load了一百万的数据,但是由于索引覆盖,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,我们还可以select * from table where id &gt; 1000000 limit 10,效率也是不错的,优化的可能性有许多种,但是核心思想都一样,就是减少load的数据.</li>\n<li>从需求的角度减少这种请求…主要是不做类似的需求(直接跳转到几百万页之后的具体某一页.只允许逐页查看或者按照给定的路线走,这样可预测,可缓存)以及防止ID泄漏且连续被人恶意攻击.</li>\n</ul>\n<p>解决超大分页,其实主要是靠缓存,可预测性的提前查到内容,缓存至redis等k-V数据库中,直接返回即可.</p>\n<p>在阿里巴巴《Java开发手册》中,对超大分页的解决办法是类似于上面提到的第一种.</p>\n<p>【推荐】利用延迟关联或者子查询优化超多分页场景。 说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>\n<h3 id=\"mysql-分页\"><a href=\"#mysql-分页\" class=\"headerlink\" title=\"mysql 分页\"></a>mysql 分页</h3><p>LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)</p>\n<p>mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15</p>\n<p>为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：</p>\n<p>mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.</p>\n<p>如果只给定一个参数，它表示返回最大的记录行数目：</p>\n<p>mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行</p>\n<p>换句话说，LIMIT n 等价于 LIMIT 0,n。</p>\n<h3 id=\"慢查询日志\"><a href=\"#慢查询日志\" class=\"headerlink\" title=\"慢查询日志\"></a>慢查询日志</h3><blockquote>\n<p>用于记录执行时间超过某个临界值的SQL日志，用于快速定位慢查询，为我们的优化做参考。</p>\n</blockquote>\n<p>开启慢查询日志</p>\n<p>配置项：slow_query_log</p>\n<p>可以使用show variables like ‘slov_query_log’查看是否开启，如果状态值为OFF，可以使用set GLOBAL slow_query_log = on来开启，它会在datadir下产生一个xxx-slow.log的文件。</p>\n<p>设置临界时间</p>\n<p>配置项：long_query_time</p>\n<p>查看：show VARIABLES like ‘long_query_time’，单位秒</p>\n<p>设置：set long_query_time=0.5</p>\n<p>实操时应该从长时间设置到短的时间，即将最慢的SQL优化掉</p>\n<p>查看日志，一旦SQL超过了我们设置的临界时间就会被记录到xxx-slow.log中</p>\n<h3 id=\"关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\"><a href=\"#关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\" class=\"headerlink\" title=\"关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？\"></a>关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？</h3><p>在业务系统中，除了使用主键进行的查询，其他的我都会在测试库上测试其耗时，慢查询的统计主要由运维在做，会定期将业务中的慢查询反馈给我们。</p>\n<p>慢查询的优化首先要搞明白慢的原因是什么？ 是查询条件没有命中索引？是load了不需要的数据列？还是数据量太大？</p>\n<p>所以优化也是针对这三个方向来的，</p>\n<ul>\n<li>首先分析语句，看看是否load了额外的数据，可能是查询了多余的行并且抛弃掉了，可能是加载了许多结果中并不需要的列，对语句进行分析以及重写。</li>\n<li>分析语句的执行计划，然后获得其使用索引的情况，之后修改语句或者修改索引，使得语句可以尽可能的命中索引。</li>\n<li>如果对语句的优化已经无法进行，可以考虑表中的数据量是否太大，如果是的话可以进行横向或者纵向的分表。</li>\n</ul>\n<h3 id=\"为什么要尽量设定一个主键？\"><a href=\"#为什么要尽量设定一个主键？\" class=\"headerlink\" title=\"为什么要尽量设定一个主键？\"></a>为什么要尽量设定一个主键？</h3><p>主键是数据库确保数据行在整张表唯一性的保障，即使业务上本张表没有主键，也建议添加一个自增长的ID列作为主键。设定了主键之后，在后续的删改查的时候可能更加快速以及确保操作数据范围安全。</p>\n<h3 id=\"主键使用自增ID还是UUID？\"><a href=\"#主键使用自增ID还是UUID？\" class=\"headerlink\" title=\"主键使用自增ID还是UUID？\"></a>主键使用自增ID还是UUID？</h3><p>推荐使用自增ID，不要使用UUID。</p>\n<p>因为在InnoDB存储引擎中，主键索引是作为聚簇索引存在的，也就是说，主键索引的B+树叶子节点上存储了主键索引以及全部的数据(按照顺序)，如果主键索引是自增ID，那么只需要不断向后排列即可，如果是UUID，由于到来的ID与原来的大小不确定，会造成非常多的数据插入，数据移动，然后导致产生很多的内存碎片，进而造成插入性能的下降。</p>\n<p>总之，在数据量大一些的情况下，用自增主键性能会好一些。</p>\n<p>关于主键是聚簇索引，如果没有主键，InnoDB会选择一个唯一键来作为聚簇索引，如果没有唯一键，会生成一个隐式的主键。</p>\n<h3 id=\"字段为什么要求定义为not-null？\"><a href=\"#字段为什么要求定义为not-null？\" class=\"headerlink\" title=\"字段为什么要求定义为not null？\"></a>字段为什么要求定义为not null？</h3><p>null值会占用更多的字节，且会在程序中造成很多与预期不符的情况。</p>\n<h3 id=\"如果要存储用户的密码散列，应该使用什么字段进行存储？\"><a href=\"#如果要存储用户的密码散列，应该使用什么字段进行存储？\" class=\"headerlink\" title=\"如果要存储用户的密码散列，应该使用什么字段进行存储？\"></a>如果要存储用户的密码散列，应该使用什么字段进行存储？</h3><p>密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。</p>\n<h3 id=\"优化查询过程中的数据访问\"><a href=\"#优化查询过程中的数据访问\" class=\"headerlink\" title=\"优化查询过程中的数据访问\"></a>优化查询过程中的数据访问</h3><ul>\n<li>访问数据太多导致查询性能下降</li>\n<li>确定应用程序是否在检索大量超过需要的数据，可能是太多行或列</li>\n<li>确认MySQL服务器是否在分析大量不必要的数据行</li>\n<li>避免犯如下SQL语句错误</li>\n<li>查询不需要的数据。解决办法：使用limit解决</li>\n<li>多表关联返回全部列。解决办法：指定列名</li>\n<li>总是返回全部列。解决办法：避免使用SELECT *</li>\n<li>重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存</li>\n<li>是否在扫描额外的记录。解决办法：</li>\n<li>使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：</li>\n<li>使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。</li>\n<li>改变数据库和表的结构，修改数据表范式</li>\n<li>重写SQL语句，让优化器可以以更优的方式执行查询。</li>\n</ul>\n<h3 id=\"优化长难的查询语句\"><a href=\"#优化长难的查询语句\" class=\"headerlink\" title=\"优化长难的查询语句\"></a>优化长难的查询语句</h3><ul>\n<li>一个复杂查询还是多个简单查询</li>\n<li>MySQL内部每秒能扫描内存中上百万行数据，相比之下，响应数据给客户端就要慢得多</li>\n<li>使用尽可能小的查询是好的，但是有时将一个大的查询分解为多个小的查询是很有必要的。</li>\n<li>切分查询</li>\n<li>将一个大的查询分为多个小的相同的查询</li>\n<li>一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销。</li>\n<li>分解关联查询，让缓存的效率更高。</li>\n<li>执行单个查询可以减少锁的竞争。</li>\n<li>在应用层做关联更容易对数据库进行拆分。</li>\n<li>查询效率会有大幅提升。</li>\n<li>较少冗余记录的查询。</li>\n</ul>\n<h3 id=\"优化特定类型的查询语句\"><a href=\"#优化特定类型的查询语句\" class=\"headerlink\" title=\"优化特定类型的查询语句\"></a>优化特定类型的查询语句</h3><ul>\n<li>count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名)</li>\n<li>MyISAM中，没有任何where条件的count(*)非常快。</li>\n<li>当有where条件时，MyISAM的count统计不一定比其它引擎快。</li>\n<li>可以使用explain查询近似值，用近似值替代count(*)</li>\n<li>增加汇总表</li>\n<li>使用缓存</li>\n</ul>\n<h3 id=\"优化关联查询\"><a href=\"#优化关联查询\" class=\"headerlink\" title=\"优化关联查询\"></a>优化关联查询</h3><ul>\n<li>确定ON或者USING子句中是否有索引。</li>\n<li>确保GROUP BY和ORDER BY只有一个表中的列，这样MySQL才有可能使用索引。</li>\n</ul>\n<h3 id=\"优化子查询\"><a href=\"#优化子查询\" class=\"headerlink\" title=\"优化子查询\"></a>优化子查询</h3><ul>\n<li>用关联查询替代</li>\n<li>优化GROUP BY和DISTINCT</li>\n<li>这两种查询据可以使用索引来优化，是最有效的优化方法</li>\n<li>关联查询中，使用标识列分组的效率更高</li>\n<li>如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。</li>\n<li>WITH ROLLUP超级聚合，可以挪到应用程序处理</li>\n</ul>\n<h3 id=\"优化LIMIT分页\"><a href=\"#优化LIMIT分页\" class=\"headerlink\" title=\"优化LIMIT分页\"></a>优化LIMIT分页</h3><ul>\n<li>LIMIT偏移量大的时候，查询效率较低</li>\n<li>可以记录上次查询的最大ID，下次查询时直接根据该ID来查询</li>\n</ul>\n<h3 id=\"优化UNION查询\"><a href=\"#优化UNION查询\" class=\"headerlink\" title=\"优化UNION查询\"></a>优化UNION查询</h3><ul>\n<li>UNION ALL的效率高于UNION</li>\n</ul>\n<h3 id=\"优化WHERE子句\"><a href=\"#优化WHERE子句\" class=\"headerlink\" title=\"优化WHERE子句\"></a>优化WHERE子句</h3><p>解题方法</p>\n<p>对于此类考题，先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，先从索引着手，如果索引没有问题，考虑以上几个方面，数据访问的问题，长难查询句的问题还是一些特定类型优化的问题，逐一回答。</p>\n<p>SQL语句优化的一些方法？</p>\n<ul>\n<li>1.对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</li>\n<li>2.应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>\n</ul>\n<p>select id from t where num is null – 可以在num上设置默认值0，确保表中num列没有null值，然后这样查询： select id from t where num=</p>\n<ul>\n<li>3.应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则引擎将放弃使用索引而进行全表扫描。</li>\n<li>4.应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</li>\n</ul>\n<p>select id from t where num=10 or num=20 – 可以这样查询： select id from t where num=10 union all select id from t where num=20</p>\n<ul>\n<li>5.in 和 not in 也要慎用，否则会导致全表扫描，如：</li>\n</ul>\n<p>select id from t where num in(1,2,3) – 对于连续的数值，能用 between 就不要用 in 了： select id from t where num between 1 and 3</p>\n<ul>\n<li>6.下面的查询也将导致全表扫描：select id from t where name like ‘%李%’若要提高效率，可以考虑全文检索。</li>\n<li>7.如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然 而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</li>\n</ul>\n<p>select id from t where num=@num – 可以改为强制查询使用索引： select id from t with(index(索引名)) where num=@num</p>\n<ul>\n<li>8.应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>\n</ul>\n<p>select id from t where num/2=100 – 应改为: select id from t where num=100*2</p>\n<ul>\n<li>9.应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</li>\n</ul>\n<p>select id from t where substring(name,1,3)=’abc’ – name以abc开头的id应改为: select id from t where name like ‘abc%’</p>\n<ul>\n<li>10.不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</li>\n</ul>\n<h2 id=\"数据库优化\"><a href=\"#数据库优化\" class=\"headerlink\" title=\"数据库优化\"></a>数据库优化</h2><h3 id=\"为什么要优化\"><a href=\"#为什么要优化\" class=\"headerlink\" title=\"为什么要优化\"></a>为什么要优化</h3><ul>\n<li>系统的吞吐量瓶颈往往出现在数据库的访问速度上</li>\n<li>随着应用程序的运行，数据库的中的数据会越来越多，处理时间会相应变慢</li>\n<li>数据是存放在磁盘上的，读写速度无法和内存相比</li>\n</ul>\n<p>优化原则：减少系统瓶颈，减少资源占用，增加系统的反应速度。</p>\n<h3 id=\"数据库结构优化\"><a href=\"#数据库结构优化\" class=\"headerlink\" title=\"数据库结构优化\"></a>数据库结构优化</h3><p>一个好的数据库设计方案对于数据库的性能往往会起到事半功倍的效果。</p>\n<p>需要考虑数据冗余、查询和更新的速度、字段的数据类型是否合理等多方面的内容。</p>\n<p><strong>将字段很多的表分解成多个表</strong></p>\n<p>对于字段较多的表，如果有些字段的使用频率很低，可以将这些字段分离出来形成新表。</p>\n<p>因为当一个表的数据量很大时，会由于使用频率低的字段的存在而变慢。</p>\n<p><strong>增加中间表</strong></p>\n<p>对于需要经常联合查询的表，可以建立中间表以提高查询效率。</p>\n<p>通过建立中间表，将需要通过联合查询的数据插入到中间表中，然后将原来的联合查询改为对中间表的查询。</p>\n<p><strong>增加冗余字段</strong></p>\n<p>设计数据表时应尽量遵循范式理论的规约，尽可能的减少冗余字段，让数据库设计看起来精致、优雅。但是，合理的加入冗余字段可以提高查询速度。</p>\n<p>表的规范化程度越高，表和表之间的关系越多，需要连接查询的情况也就越多，性能也就越差。</p>\n<p><strong>注意：</strong></p>\n<p><strong>冗余字段的值在一个表中修改了，就要想办法在其他表中更新，否则就会导致数据不一致的问题。</strong></p>\n<h3 id=\"MySQL数据库cpu飙升到500-的话他怎么处理？\"><a href=\"#MySQL数据库cpu飙升到500-的话他怎么处理？\" class=\"headerlink\" title=\"MySQL数据库cpu飙升到500%的话他怎么处理？\"></a>MySQL数据库cpu飙升到500%的话他怎么处理？</h3><p>当 cpu 飙升到 500%时，先用操作系统命令 top 命令观察是不是 mysqld 占用导致的，如果不是，找出占用高的进程，并进行相关处理。</p>\n<p>如果是 mysqld 造成的， show processlist，看看里面跑的 session 情况，是不是有消耗资源的 sql 在运行。找出消耗高的 sql，看看执行计划是否准确， index 是否缺失，或者实在是数据量太大造成。</p>\n<p>一般来说，肯定要 kill 掉这些线程(同时观察 cpu 使用率是否下降)，等进行相应的调整(比如说加索引、改 sql、改内存参数)之后，再重新跑这些 SQL。</p>\n<p>也有可能是每个 sql 消耗资源并不多，但是突然之间，有大量的 session 连进来导致 cpu 飙升，这种情况就需要跟应用一起来分析为何连接数会激增，再做出相应的调整，比如说限制连接数等</p>\n<h3 id=\"大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\"><a href=\"#大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\" class=\"headerlink\" title=\"大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？\"></a>大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？分库分表了是怎么做的？分表分库了有什么问题？有用到中间件么？他们的原理知道么？</h3><p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>\n<ol>\n<li><strong>限定数据的范围：</strong> 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内。；</li>\n<li><strong>读/写分离：</strong> 经典的数据库拆分方案，主库负责写，从库负责读；</li>\n<li><strong>缓存：</strong> 使用MySQL的缓存，另外对重量级、更新少的数据可以考虑使用应用级别的缓存；</li>\n</ol>\n<p>还有就是通过分库分表的方式进行优化，主要有垂直分表和水平分表</p>\n<ol>\n<li><p><strong>垂直分区：</strong></p>\n<p><strong>根据数据库里面数据表的相关性进行拆分。</strong> 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。</p>\n<p><strong>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。</strong> 如下图所示，这样来说大家应该就更容易理解了。</p>\n<p><strong>垂直拆分的优点：</strong> 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。</p>\n<p><strong>垂直拆分的缺点：</strong> 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>\n<h4 id=\"垂直分表\"><a href=\"#垂直分表\" class=\"headerlink\" title=\"垂直分表\"></a><strong>垂直分表</strong></h4><p>把主键和一些列放在一个表，然后把主键和另外的列放在另一个表中</p>\n<p><img src=\"https://img-blog.csdnimg.cn/8ac8af7d9dc343f193e7217671ca6ef1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"适用场景\"><a href=\"#适用场景\" class=\"headerlink\" title=\"适用场景\"></a><strong>适用场景</strong></h5><ul>\n<li>1、如果一个表中某些列常用，另外一些列不常用</li>\n<li>2、可以使数据行变小，一个数据页能存储更多数据，查询时减少I/O次数</li>\n</ul>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a><strong>缺点</strong></h5><ul>\n<li>有些分表的策略基于应用层的逻辑算法，一旦逻辑算法改变，整个分表逻辑都会改变，扩展性较差</li>\n<li>对于应用层来说，逻辑算法增加开发成本</li>\n<li>管理冗余列，查询所有数据需要join操作</li>\n</ul>\n</li>\n<li><p><strong>水平分区：</strong></p>\n<p><strong>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。</strong></p>\n<p>水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/6f84ed35e4f146e5b701af08889a6230.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<p>水品拆分可以支持非常大的数据量。需要注意的一点是:分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 <strong>水平拆分最好分库</strong> 。</p>\n<p>水平拆分能够 <strong>支持非常大的数据量存储，应用端改造也少</strong>，但 <strong>分片事务难以解决</strong> ，跨界点Join性能较差，逻辑复杂。</p>\n<p>《Java工程师修炼之道》的作者推荐 <strong>尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度</strong> ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>\n<h4 id=\"水平分表：\"><a href=\"#水平分表：\" class=\"headerlink\" title=\"水平分表：\"></a><strong>水平分表：</strong></h4><p>表很大，分割后可以降低在查询时需要读的数据和索引的页数，同时也降低了索引的层数，提高查询次数</p>\n<p><img src=\"https://img-blog.csdnimg.cn/27dc54f85984461ab2cd23d8e3cb3c21.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n<h5 id=\"适用场景-1\"><a href=\"#适用场景-1\" class=\"headerlink\" title=\"适用场景\"></a><strong>适用场景</strong></h5><ul>\n<li>1、表中的数据本身就有独立性，例如表中分表记录各个地区的数据或者不同时期的数据，特别是有些数据常用，有些不常用。</li>\n<li>2、需要把数据存放在多个介质上。</li>\n</ul>\n<h5 id=\"水平切分的缺点\"><a href=\"#水平切分的缺点\" class=\"headerlink\" title=\"水平切分的缺点\"></a><strong>水平切分的缺点</strong></h5><ul>\n<li>1、给应用增加复杂度，通常查询时需要多个表名，查询所有数据都需UNION操作</li>\n<li>2、在许多数据库应用中，这种复杂度会超过它带来的优点，查询时会增加读一个索引层的磁盘次数</li>\n</ul>\n<p><strong>下面补充一下数据库分片的两种常见方案：</strong></p>\n<ul>\n<li><strong>客户端代理：</strong> <strong>分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。</strong> 当当网的 <strong>Sharding-JDBC</strong> 、阿里的TDDL是两种比较常用的实现。</li>\n<li><strong>中间件代理：</strong> <strong>在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。</strong> 我们现在谈的 <strong>Mycat</strong> 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>\n</ul>\n</li>\n</ol>\n<p><strong>分库分表后面临的问题</strong></p>\n<ul>\n<li><p><strong>事务支持</strong> 分库分表后，就成了分布式事务了。如果依赖数据库本身的分布式事务管理功能去执行事务，将付出高昂的性能代价； 如果由应用程序去协助控制，形成程序逻辑上的事务，又会造成编程方面的负担。</p>\n</li>\n<li><p><strong>跨库join</strong></p>\n<p>只要是进行切分，跨节点Join的问题是不可避免的。但是良好的设计和切分却可以减少此类情况的发生。解决这一问题的普遍做法是分两次查询实现。在第一次查询的结果集中找出关联数据的id,根据这些id发起第二次请求得到关联数据。 分库分表方案产品</p>\n</li>\n<li><p><strong>跨节点的count,order by,group by以及聚合函数问题</strong> 这些是一类问题，因为它们都需要基于全部数据集合进行计算。多数的代理都不会自动处理合并工作。解决方案：与解决跨节点join问题的类似，分别在各个节点上得到结果后在应用程序端进行合并。和join不同的是每个结点的查询可以并行执行，因此很多时候它的速度要比单一大表快很多。但如果结果集很大，对应用程序内存的消耗是一个问题。</p>\n</li>\n<li><p><strong>数据迁移，容量规划，扩容等问题</strong> 来自淘宝综合业务平台团队，它利用对2的倍数取余具有向前兼容的特性（如对4取余得1的数对2取余也是1）来分配数据，避免了行级别的数据迁移，但是依然需要进行表级别的迁移，同时对扩容规模和分表数量都有限制。总得来说，这些方案都不是十分的理想，多多少少都存在一些缺点，这也从一个侧面反映出了Sharding扩容的难度。</p>\n</li>\n<li><p><strong>ID问题</strong></p>\n</li>\n<li><p>一旦数据库被切分到多个物理结点上，我们将不能再依赖数据库自身的主键生成机制。一方面，某个分区数据库自生成的ID无法保证在全局上是唯一的；另一方面，应用程序在插入数据之前需要先获得ID,以便进行SQL路由. 一些常见的主键生成策略</p>\n</li>\n</ul>\n<p><strong>UUID</strong> 使用UUID作主键是最简单的方案，但是缺点也是非常明显的。由于UUID非常的长，除占用大量存储空间外，最主要的问题是在索引上，在建立索引和基于索引进行查询时都存在性能问题。 <strong>Twitter的分布式自增ID算法Snowflake</strong> 在分布式系统中，需要生成全局UID的场合还是比较多的，twitter的snowflake解决了这种需求，实现也还是很简单的，除去配置信息，核心代码就是毫秒级时间41位 机器ID 10位 毫秒内序列12位。</p>\n<ul>\n<li><p>跨分片的排序分页</p>\n<p>般来讲，分页时需要按照指定字段进行排序。当排序字段就是分片字段的时候，我们通过分片规则可以比较容易定位到指定的分片，而当排序字段非分片字段的时候，情况就会变得比较复杂了。为了最终结果的准确性，我们需要在不同的分片节点中将数据进行排序并返回，并将不同分片返回的结果集进行汇总和再次排序，最后再返回给用户。如下图所示：</p>\n<p><img src=\"https://img-blog.csdnimg.cn/ef858f4fba43491e986e67a4da939a65.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\" alt=\"在这里插入图片描述\"></p>\n</li>\n</ul>\n<h3 id=\"MySQL的复制原理以及流程\"><a href=\"#MySQL的复制原理以及流程\" class=\"headerlink\" title=\"MySQL的复制原理以及流程\"></a>MySQL的复制原理以及流程</h3><p>主从复制：将主数据库中的DDL和DML操作通过二进制日志（BINLOG）传输到从数据库上，然后将这些日志重新执行（重做）；从而使得从数据库的数据与主数据库保持一致。</p>\n<p><strong>主从复制的作用</strong></p>\n<ol>\n<li>主数据库出现问题，可以切换到从数据库。</li>\n<li>可以进行数据库层面的读写分离。</li>\n<li>可以在从数据库上进行日常备份。</li>\n</ol>\n<p><strong>MySQL主从复制解决的问题</strong></p>\n<ul>\n<li>数据分布：随意开始或停止复制，并在不同地理位置分布数据备份</li>\n<li>负载均衡：降低单个服务器的压力</li>\n<li>高可用和故障切换：帮助应用程序避免单点失败</li>\n<li>升级测试：可以用更高版本的MySQL作为从库</li>\n</ul>\n<p><strong>MySQL主从复制工作原理</strong></p>\n<ul>\n<li>在主库上把数据更高记录到二进制日志</li>\n<li>从库将主库的日志复制到自己的中继日志</li>\n<li>从库读取中继日志的事件，将其重放到从库数据中</li>\n</ul>\n<p><strong>基本原理流程，3个线程以及之间的关联</strong></p>\n<p><strong>主</strong>：binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中；</p>\n<p><strong>从</strong>：io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；</p>\n<p><strong>从</strong>：sql执行线程——执行relay log中的语句；</p>\n<p><strong>复制过程</strong></p>\n<p><img src=\"https://img-blog.csdnimg.cn/87fc1db60bec45fa916ebd6b6cd421b1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5pyI5Ly06aOe6bG8,size_20,color_FFFFFF,t_70,g_se,x_16\"></p>\n<p>Binary log：主数据库的二进制日志</p>\n<p>Relay log：从服务器的中继日志</p>\n<p>第一步：master在每个事务更新数据完成之前，将该操作记录串行地写入到binlog文件中。</p>\n<p>第二步：salve开启一个I/O Thread，该线程在master打开一个普通连接，主要工作是binlog dump process。如果读取的进度已经跟上了master，就进入睡眠状态并等待master产生新的事件。I/O线程最终的目的是将这些事件写入到中继日志中。</p>\n<p>第三步：SQL Thread会读取中继日志，并顺序执行该日志中的SQL事件，从而与主数据库中的数据保持一致。</p>\n<h3 id=\"读写分离有哪些解决方案？\"><a href=\"#读写分离有哪些解决方案？\" class=\"headerlink\" title=\"读写分离有哪些解决方案？\"></a>读写分离有哪些解决方案？</h3><p>读写分离是依赖于主从复制，而主从复制又是为读写分离服务的。因为主从复制要求slave不能写只能读（如果对slave执行写操作，那么show slave status将会呈现Slave_SQL_Running=NO，此时你需要按照前面提到的手动同步一下slave）。</p>\n<p><strong>方案一</strong></p>\n<p>使用mysql-proxy代理</p>\n<p>优点：直接实现读写分离和负载均衡，不用修改代码，master和slave用一样的帐号，mysql官方不建议实际生产中使用</p>\n<p>缺点：降低性能， 不支持事务</p>\n<p><strong>方案二</strong></p>\n<p>使用AbstractRoutingDataSource+aop+annotation在dao层决定数据源。<br>如果采用了mybatis， 可以将读写分离放在ORM层，比如mybatis可以通过mybatis plugin拦截sql语句，所有的insert/update/delete都访问master库，所有的select 都访问salve库，这样对于dao层都是透明。 plugin实现时可以通过注解或者分析语句是读写方法来选定主从库。不过这样依然有一个问题， 也就是不支持事务， 所以我们还需要重写一下DataSourceTransactionManager， 将read-only的事务扔进读库， 其余的有读有写的扔进写库。</p>\n<p><strong>方案三</strong></p>\n<p>使用AbstractRoutingDataSource+aop+annotation在service层决定数据源，可以支持事务.</p>\n<p>缺点：类内部方法通过this.xx()方式相互调用时，aop不会进行拦截，需进行特殊处理。</p>\n<h3 id=\"备份计划，mysqldump以及xtranbackup的实现原理\"><a href=\"#备份计划，mysqldump以及xtranbackup的实现原理\" class=\"headerlink\" title=\"备份计划，mysqldump以及xtranbackup的实现原理\"></a>备份计划，mysqldump以及xtranbackup的实现原理</h3><p><strong>(1)备份计划</strong></p>\n<p>视库的大小来定，一般来说 100G 内的库，可以考虑使用 mysqldump 来做，因为 mysqldump更加轻巧灵活，备份时间选在业务低峰期，可以每天进行都进行全量备份(mysqldump 备份出来的文件比较小，压缩之后更小)。</p>\n<p>100G 以上的库，可以考虑用 xtranbackup 来做，备份速度明显要比 mysqldump 要快。一般是选择一周一个全备，其余每天进行增量备份，备份时间为业务低峰期。</p>\n<p><strong>(2)备份恢复时间</strong></p>\n<p>物理备份恢复快，逻辑备份恢复慢</p>\n<p>这里跟机器，尤其是硬盘的速率有关系，以下列举几个仅供参考</p>\n<p>20G的2分钟（mysqldump）</p>\n<p>80G的30分钟(mysqldump)</p>\n<p>111G的30分钟（mysqldump)</p>\n<p>288G的3小时（xtra)</p>\n<p>3T的4小时（xtra)</p>\n<p>逻辑导入时间一般是备份时间的5倍以上</p>\n<p><strong>(3)备份恢复失败如何处理</strong></p>\n<p>首先在恢复之前就应该做足准备工作，避免恢复的时候出错。比如说备份之后的有效性检查、权限检查、空间检查等。如果万一报错，再根据报错的提示来进行相应的调整。</p>\n<p><strong>(4)mysqldump和xtrabackup实现原理</strong></p>\n<p>mysqldump</p>\n<p>mysqldump 属于逻辑备份。加入–single-transaction 选项可以进行一致性备份。后台进程会先设置 session 的事务隔离级别为 RR(SET SESSION TRANSACTION ISOLATION LEVELREPEATABLE READ)，之后显式开启一个事务(START TRANSACTION /*!40100 WITH CONSISTENTSNAPSHOT */)，这样就保证了该事务里读到的数据都是事务事务时候的快照。之后再把表的数据读取出来。如果加上–master-data=1 的话，在刚开始的时候还会加一个数据库的读锁(FLUSH TABLES WITH READ LOCK),等开启事务后，再记录下数据库此时 binlog 的位置(showmaster status)，马上解锁，再读取表的数据。等所有的数据都已经导完，就可以结束事务</p>\n<p>Xtrabackup:</p>\n<p>xtrabackup 属于物理备份，直接拷贝表空间文件，同时不断扫描产生的 redo 日志并保存下来。最后完成 innodb 的备份后，会做一个 flush engine logs 的操作(老版本在有 bug，在5.6 上不做此操作会丢数据)，确保所有的 redo log 都已经落盘(涉及到事务的两阶段提交</p>\n<p>概念，因为 xtrabackup 并不拷贝 binlog，所以必须保证所有的 redo log 都落盘，否则可能会丢最后一组提交事务的数据)。这个时间点就是 innodb 完成备份的时间点，数据文件虽然不是一致性的，但是有这段时间的 redo 就可以让数据文件达到一致性(恢复的时候做的事</p>\n<p>情)。然后还需要 flush tables with read lock，把 myisam 等其他引擎的表给备份出来，备份完后解锁。这样就做到了完美的热备。</p>\n<h3 id=\"数据表损坏的修复方式有哪些？\"><a href=\"#数据表损坏的修复方式有哪些？\" class=\"headerlink\" title=\"数据表损坏的修复方式有哪些？\"></a>数据表损坏的修复方式有哪些？</h3><p>使用 myisamchk 来修复，具体步骤：</p>\n<ul>\n<li>1）修复前将mysql服务停止。</li>\n<li>2）打开命令行方式，然后进入到mysql的/bin目录。</li>\n<li>3）执行myisamchk –recover 数据库所在路径/*.MYI</li>\n</ul>\n<p>使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。 OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cl0trzwei001nfhjif298dgi2","category_id":"cl0trzwel001yfhji883818sg","_id":"cl0trzwep002bfhjie0zp7esq"},{"post_id":"cl0trzwei001qfhji7by71yww","category_id":"cl0trzwel001yfhji883818sg","_id":"cl0trzwep002efhji3rp6hkd8"},{"post_id":"cl0trzwej001sfhjidpso9f1p","category_id":"cl0trzwel001yfhji883818sg","_id":"cl0trzwer002hfhji25b78i6t"},{"post_id":"cl0trzwf6003vfhji95g42rkm","category_id":"cl0trzwg00066fhjifi3ehx6i","_id":"cl0trzwg3006ffhji0tnv9ubg"},{"post_id":"cl0trzwf6003wfhjih3t376hs","category_id":"cl0trzwg00066fhjifi3ehx6i","_id":"cl0trzwg5006jfhji0wbg1dxs"},{"post_id":"cl0trzwf7003zfhji7rqnaz6c","category_id":"cl0trzwg00066fhjifi3ehx6i","_id":"cl0trzwg6006nfhjiaibx70q6"},{"post_id":"cl0trzwf80040fhjicsg231fx","category_id":"cl0trzwg00066fhjifi3ehx6i","_id":"cl0trzwg7006qfhji46wtaxnf"},{"post_id":"cl0trzwgq0085fhjieazrcu1o","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgs008bfhji1gych1wc"},{"post_id":"cl0trzwfh004sfhji4fvp3b06","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgs008efhjidtodbbpv"},{"post_id":"cl0trzwgq0087fhji11kjaqad","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgt008gfhji4b6s2wlj"},{"post_id":"cl0trzwgr0089fhji4za8ev67","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgv008jfhji5l5u82xr"},{"post_id":"cl0trzwfi004tfhji0ii74g5x","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgv008lfhjidvv48mgg"},{"post_id":"cl0trzwgr008afhjifd1h25y8","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgw008ofhjicval4608"},{"post_id":"cl0trzwgs008dfhji0rp470qq","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgw008qfhji3375hegu"},{"post_id":"cl0trzwfi004wfhjia4y0cxrs","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgx008tfhji55e0b6vo"},{"post_id":"cl0trzwgt008ffhjih85gbol0","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgy008vfhji9jg72or0"},{"post_id":"cl0trzwgu008ifhjiea9eh8v0","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgz008yfhji696fe3zd"},{"post_id":"cl0trzwfj004xfhjia0k17dv0","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwgz0090fhji9tpj3cic"},{"post_id":"cl0trzwgv008kfhjifpal1vtx","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh00093fhji8nrney52"},{"post_id":"cl0trzwgv008nfhjibcmm30sy","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh10095fhji6wv21mgz"},{"post_id":"cl0trzwfl0050fhjibuj29jry","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh10098fhji55ne4lj6"},{"post_id":"cl0trzwgw008pfhji8x9c39n7","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh2009afhji7s4q7jzg"},{"post_id":"cl0trzwgx008sfhjihi4x4zc2","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh3009dfhjibb9hclhq"},{"post_id":"cl0trzwfl0051fhjihnn8ap0j","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh3009ffhjick3r2feq"},{"post_id":"cl0trzwgx008ufhjihdq3gi2n","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh4009ifhji10qy6gpc"},{"post_id":"cl0trzwgy008xfhji0tic60ra","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh4009kfhji8x9a04ku"},{"post_id":"cl0trzwfm0054fhjid4gp9kqg","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh5009nfhji2k0c7nrx"},{"post_id":"cl0trzwgz008zfhji98qh4gdx","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh6009pfhji4hqz07o2"},{"post_id":"cl0trzwh00092fhjifi4xeyj6","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh7009sfhji76tl8as3"},{"post_id":"cl0trzwfm0055fhjidkaogyli","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh7009ufhji53zc0rju"},{"post_id":"cl0trzwh00094fhji9uwm7m6d","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh8009xfhjibm4qd0fa"},{"post_id":"cl0trzwh10097fhjibcps41f2","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh9009zfhji34rzgjbn"},{"post_id":"cl0trzwfn0058fhji2ggy2dcj","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwh900a2fhjib1higg8q"},{"post_id":"cl0trzwh10099fhji6b5z8q3y","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwha00a4fhjibzafd54i"},{"post_id":"cl0trzwh2009cfhji9zes15na","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhb00a7fhjiawbkdxdv"},{"post_id":"cl0trzwfo0059fhjiatrobi4s","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhc00a9fhji0ppnf72q"},{"post_id":"cl0trzwh3009efhji9en6g4bh","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhf00acfhji3mkjgyw2"},{"post_id":"cl0trzwh3009hfhjicz74arnq","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhf00aefhjia7cxfrp2"},{"post_id":"cl0trzwfo005cfhjiguoz757u","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhg00ahfhjid8bp9zfk"},{"post_id":"cl0trzwh4009jfhjiho9b4j88","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhh00ajfhji6zozb6yj"},{"post_id":"cl0trzwh5009mfhji24r9fa7u","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhi00amfhjid47e5451"},{"post_id":"cl0trzwfp005dfhjicjdzh1dc","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhi00aofhjidivi9zps"},{"post_id":"cl0trzwh5009ofhji33qhhd6s","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhj00arfhji5rjs53d7"},{"post_id":"cl0trzwh6009rfhjicpt39frc","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhk00atfhjib0ha8hts"},{"post_id":"cl0trzwfq005gfhjiag3j3a4d","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhk00awfhji7kth7kv0"},{"post_id":"cl0trzwh7009tfhji0f2p9hld","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhl00ayfhji0pu66bm4"},{"post_id":"cl0trzwh8009wfhji5tujb5ul","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhm00b1fhji56kthu99"},{"post_id":"cl0trzwfr005hfhji35ki5umj","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhm00b3fhji6ru4cey6"},{"post_id":"cl0trzwh8009yfhji3zgi7kon","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhn00b6fhji43dsd4gx"},{"post_id":"cl0trzwh900a1fhji2env415r","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwho00b8fhjidhdb2td8"},{"post_id":"cl0trzwfs005kfhjihfri6nwt","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwho00bbfhjida0979km"},{"post_id":"cl0trzwha00a3fhji3wzl3vf6","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhp00bdfhjiflav0app"},{"post_id":"cl0trzwha00a6fhji89z2bndf","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhp00bgfhjih4eh04f0"},{"post_id":"cl0trzwft005lfhjifu7l53sm","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhq00bifhjihdbg9pe7"},{"post_id":"cl0trzwft005ofhjia2fscwx6","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhr00blfhji4mhz1r52"},{"post_id":"cl0trzwfu005pfhjier0na23q","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhr00bnfhjibiz46h52"},{"post_id":"cl0trzwfv005sfhjic0yh1e7d","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhs00bqfhji80flcv1w"},{"post_id":"cl0trzwfv005tfhji3xu5egpv","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhs00bsfhjifju12hup"},{"post_id":"cl0trzwfw005wfhjiannif64i","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhu00bvfhji5jdl31tf"},{"post_id":"cl0trzwfx005xfhjidn8b907a","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhv00bxfhji6u69dljd"},{"post_id":"cl0trzwfy0060fhji0dls62gg","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhw00c0fhjif0mfcd7k"},{"post_id":"cl0trzwfy0061fhji08mm00k1","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhw00c2fhjiawo40mcq"},{"post_id":"cl0trzwfz0064fhji5umlegf8","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhx00c5fhji18i8fcp8"},{"post_id":"cl0trzwg00065fhjicqyu2mcy","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwhz00c7fhjihgu63i54"},{"post_id":"cl0trzwg10068fhjie9ngcx6u","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi000cafhji6w9j08z8"},{"post_id":"cl0trzwg10069fhji5p6pb2dc","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi000ccfhjigjezh6i5"},{"post_id":"cl0trzwg2006cfhjiefvedhj7","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi100cffhjiblej2tu8"},{"post_id":"cl0trzwg3006dfhji0ji18dcp","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi200chfhjihu3zddoi"},{"post_id":"cl0trzwg4006gfhjiddxr8omg","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi300ckfhji7o8s7ebu"},{"post_id":"cl0trzwg4006hfhji1m5lfslw","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi400cnfhjia2ds1lf6"},{"post_id":"cl0trzwg5006kfhji8ymw93bo","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi500crfhjicc7993li"},{"post_id":"cl0trzwg6006lfhji6oizfomc","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi600cvfhjia7oj7thi"},{"post_id":"cl0trzwg6006ofhji69bmabjw","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi800czfhji7gwdaalh"},{"post_id":"cl0trzwg7006pfhji19lsd6lh","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwi900d3fhjibmzua279"},{"post_id":"cl0trzwg7006sfhji8y5z6tn3","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwia00d7fhjiewpv7vjh"},{"post_id":"cl0trzwg8006tfhji31fk9ewo","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwic00dbfhjihn8sa40c"},{"post_id":"cl0trzwg9006wfhji6gm7bptr","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwid00dffhji4ivab7wl"},{"post_id":"cl0trzwga006xfhjia9tz3fxe","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwif00djfhjiczx745e0"},{"post_id":"cl0trzwgb0070fhji06qe87il","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwig00dnfhjig719fqgp"},{"post_id":"cl0trzwgb0071fhjihwfcazwo","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwih00drfhjigaecfmkb"},{"post_id":"cl0trzwgc0074fhji74uk0kh3","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwij00dvfhji9p284pqn"},{"post_id":"cl0trzwgd0075fhji3i8u00yi","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwik00dzfhji96773mo4"},{"post_id":"cl0trzwge0078fhji3zm34ey4","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwil00e3fhji6y5w4qez"},{"post_id":"cl0trzwge0079fhjianof20cj","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwin00e7fhjifdx600or"},{"post_id":"cl0trzwgf007cfhji2bbealqa","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwio00ebfhji2rcdf4zs"},{"post_id":"cl0trzwgf007dfhjig8gm2r9z","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwip00effhji5vqv41h1"},{"post_id":"cl0trzwgi007gfhjia20s2mfy","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwir00ejfhji3qww57rv"},{"post_id":"cl0trzwgj007hfhjihs3p507q","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwis00enfhji2izne3x4"},{"post_id":"cl0trzwgk007kfhjib4zz24y3","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwit00erfhji7gv61f9e"},{"post_id":"cl0trzwgk007lfhji17jaf58a","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwiu00evfhji0hgs5lv9"},{"post_id":"cl0trzwgl007ofhji18em7df8","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwiv00ezfhji3nn26g8z"},{"post_id":"cl0trzwgl007pfhjih0aa9fhi","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwiw00f3fhjie39219bj"},{"post_id":"cl0trzwgm007sfhji0jibff7i","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwiy00f7fhjicwnw0exz"},{"post_id":"cl0trzwgn007tfhji7n724shh","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwiz00fbfhji6r9t8ww6"},{"post_id":"cl0trzwgn007wfhjihtw47iwh","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwj200fffhjiaih5cr5z"},{"post_id":"cl0trzwgo007xfhji8h9ba8gr","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwj300fjfhji0gajhax2"},{"post_id":"cl0trzwgo0080fhjic3zhamwo","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwj400fnfhjibaadfe2z"},{"post_id":"cl0trzwgp0081fhjiaz5a4drr","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwj500frfhjia7194ytf"},{"post_id":"cl0trzwgp0084fhjibsgq5xkj","category_id":"cl0trzwgp0082fhji6cr48g3e","_id":"cl0trzwj600fufhji8j9y8hwy"},{"post_id":"cl0trzwi100cefhji6gmaecer","category_id":"cl0trzwka00j7fhjieuv6d8gl","_id":"cl0trzwkd00jgfhji7dg532nh"},{"post_id":"cl0trzwi200cgfhji858s9ujf","category_id":"cl0trzwka00j7fhjieuv6d8gl","_id":"cl0trzwke00jjfhji2l2hda52"},{"post_id":"cl0trzwil00e1fhjicmb4cvl8","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwla00mlfhji52w567eg"},{"post_id":"cl0trzwim00e4fhjigvy69vqg","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwlb00mpfhji5gky2w6d"},{"post_id":"cl0trzwim00e5fhjia2pnbdwi","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwlc00mtfhjifgdrbdra"},{"post_id":"cl0trzwin00e8fhji305n7p1f","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwld00mxfhji7wy6g5d1"},{"post_id":"cl0trzwin00e9fhji63e57tq4","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwle00n1fhjignhmcyqu"},{"post_id":"cl0trzwio00ecfhjigi2s31jc","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwlg00n5fhji9hww2f5z"},{"post_id":"cl0trzwip00edfhjignx41ako","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwlh00n9fhji7olg7z6k"},{"post_id":"cl0trzwiq00egfhji2wphgssg","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwli00ndfhji133me9r4"},{"post_id":"cl0trzwiq00ehfhji1sr63dcg","category_id":"cl0trzwl700mbfhji9v7mavwp","_id":"cl0trzwlj00ngfhji2owhapjx"},{"post_id":"cl0trzwis00epfhji1w7f64uy","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlm00ntfhji6f2dafip"},{"post_id":"cl0trzwit00esfhjic99lf0e5","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlm00nvfhjicpa7dl1j"},{"post_id":"cl0trzwiu00etfhji3ijwdqhp","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwln00nxfhji2n1ufj0y"},{"post_id":"cl0trzwiu00ewfhji4x0gbiqd","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwln00nzfhjibw704jip"},{"post_id":"cl0trzwiv00exfhjihkdshi14","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwln00o1fhji29toe6m8"},{"post_id":"cl0trzwiv00f0fhji5784d73p","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlo00o3fhjih2dm8kz6"},{"post_id":"cl0trzwiw00f1fhji105ucujv","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlo00o5fhji1x84b2mt"},{"post_id":"cl0trzwix00f4fhji2qdr7wp6","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlp00o7fhji62hb3kvh"},{"post_id":"cl0trzwix00f5fhji5sj3d5jn","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlp00o9fhjib0xkb9nm"},{"post_id":"cl0trzwiy00f8fhjid0l1fzf2","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlp00obfhji8lcw4cc9"},{"post_id":"cl0trzwiy00f9fhji2n747qjt","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlq00odfhjie9352jnq"},{"post_id":"cl0trzwiz00fcfhjidymccf5o","category_id":"cl0trzwll00nofhjidx1e0jcw","_id":"cl0trzwlq00oefhji7vu99bme"},{"post_id":"cl0trzwj500fpfhji71tned4h","category_id":"cl0trzwls00oofhjig6qzb9il","_id":"cl0trzwlt00otfhjihzn134k8"},{"post_id":"cl0trzwj500fsfhjiew68cdzl","category_id":"cl0trzwls00oofhjig6qzb9il","_id":"cl0trzwlt00ovfhji0z718iwi"},{"post_id":"cl0trzwj600ftfhjieggd0ouo","category_id":"cl0trzwls00oofhjig6qzb9il","_id":"cl0trzwlt00oxfhjifumuhkfu"},{"post_id":"cl0trzwj700fwfhjiaz4u3na1","category_id":"cl0trzwls00oofhjig6qzb9il","_id":"cl0trzwlu00ozfhjif4oncp80"},{"post_id":"cl0trzwj700fxfhji1dlse5q1","category_id":"cl0trzwls00oofhjig6qzb9il","_id":"cl0trzwlu00p0fhji6rjq1rxb"},{"post_id":"cl0trzwj800g0fhji42za1xty","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlu00p3fhji3czi6xzn"},{"post_id":"cl0trzwj800g1fhjibhm8193g","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlv00p5fhjiatdl9821"},{"post_id":"cl0trzwj900g4fhjibwdo6ssg","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlv00p7fhjia6pf5zwb"},{"post_id":"cl0trzwj900g5fhji22q22gzg","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlv00p9fhjigdfx6ef8"},{"post_id":"cl0trzwja00g8fhjid1a2h76n","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlw00pbfhji2q1tedpt"},{"post_id":"cl0trzwja00g9fhji9f6bakrv","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlw00pdfhji4a5c3nyz"},{"post_id":"cl0trzwjb00gcfhji6kdm1owl","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlx00pffhji6z3r9s8l"},{"post_id":"cl0trzwjc00gdfhjibm9q0757","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlx00phfhjie4jeerfm"},{"post_id":"cl0trzwjc00ggfhjigcc17i0j","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlx00pjfhjihq1g93c4"},{"post_id":"cl0trzwjd00ghfhji69yxamds","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwly00plfhji5vnaecdk"},{"post_id":"cl0trzwje00gkfhjies0ng2wu","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwly00pnfhjibxjjd9d6"},{"post_id":"cl0trzwje00glfhji6q1z4qp9","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwly00ppfhji6ugcb3ek"},{"post_id":"cl0trzwjf00gofhjib68ubtv3","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlz00prfhjihz9y5cfl"},{"post_id":"cl0trzwjf00gpfhjidffb8qzm","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwlz00ptfhji9482gn04"},{"post_id":"cl0trzwjg00gsfhji4tu65brq","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm000pvfhji4wnl265z"},{"post_id":"cl0trzwjh00gtfhji56xahlzx","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm000pxfhji3r6970yu"},{"post_id":"cl0trzwjh00gwfhji9py61n7g","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm000pzfhjieaxic23b"},{"post_id":"cl0trzwji00gxfhji55j75op7","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm100q1fhji6x7sgbh5"},{"post_id":"cl0trzwjj00h0fhji2rycb0qe","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm100q3fhji4n4rdran"},{"post_id":"cl0trzwjj00h1fhji06ehbo1d","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm100q5fhji11o5hyuy"},{"post_id":"cl0trzwjk00h4fhji7lgt4u7e","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm200q7fhji2yw2aqyy"},{"post_id":"cl0trzwjk00h5fhjicjo87rdb","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm200q9fhji7i5fhgwo"},{"post_id":"cl0trzwjl00h8fhji310p7f71","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm200qbfhji8kkncnfh"},{"post_id":"cl0trzwjm00h9fhji1y4na4be","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm300qdfhjigzv91mpy"},{"post_id":"cl0trzwjm00hcfhjihejw6ozc","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm300qffhjihihk3y7v"},{"post_id":"cl0trzwjn00hdfhjig1q511q0","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm400qhfhji197mapwz"},{"post_id":"cl0trzwjn00hgfhji8rwrds1p","category_id":"cl0trzwlu00oyfhji7ieeh3on","_id":"cl0trzwm400qifhjidkr295wa"},{"post_id":"cl0trzwk900j1fhji9di4f4yv","category_id":"cl0trzwmf00s0fhjiesmhbb70","_id":"cl0trzwmg00s5fhjid63zgxii"},{"post_id":"cl0trzwk900j4fhjifaqjgf0j","category_id":"cl0trzwmf00s0fhjiesmhbb70","_id":"cl0trzwmg00s7fhji04yyf0q0"},{"post_id":"cl0trzwka00j5fhjihtyh2jmc","category_id":"cl0trzwmf00s0fhjiesmhbb70","_id":"cl0trzwmh00s9fhjigswq3tna"},{"post_id":"cl0trzwka00j8fhji3s29c6lg","category_id":"cl0trzwmf00s0fhjiesmhbb70","_id":"cl0trzwmi00sbfhjiblw58mx9"},{"post_id":"cl0trzwkb00j9fhjich41b7ui","category_id":"cl0trzwmf00s0fhjiesmhbb70","_id":"cl0trzwmi00sdfhji0nyzd1ws"},{"post_id":"cl0trzwkb00jbfhji9ntkff1h","category_id":"cl0trzwmf00s0fhjiesmhbb70","_id":"cl0trzwmi00sefhji0jfl3xz7"},{"post_id":"cl0trzwki00jyfhji7zykght4","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmn00t3fhjifu9z1rd8"},{"post_id":"cl0trzwkj00k1fhji6nxgamsh","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmn00t5fhjigjk17hs0"},{"post_id":"cl0trzwkj00k2fhjigrardzdx","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmo00t7fhji5uqtcndk"},{"post_id":"cl0trzwkk00k5fhjiezdjg5r9","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmo00t9fhji3jat6fsr"},{"post_id":"cl0trzwkk00k6fhji6ooibuiz","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmp00tbfhji4xzhfe61"},{"post_id":"cl0trzwkl00k9fhji02rl1log","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmp00tdfhjiaknd106b"},{"post_id":"cl0trzwkl00kafhji4mrq6bvf","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmp00tffhjic7ze83z2"},{"post_id":"cl0trzwkm00kdfhji7v7n7d8v","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmq00thfhjidr85fr5r"},{"post_id":"cl0trzwkm00kefhji5zrm0xbq","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmq00tjfhji5bd2btq1"},{"post_id":"cl0trzwkn00khfhji799bf45y","category_id":"cl0trzwmm00syfhji7mre5s5h","_id":"cl0trzwmq00tkfhji7o5u0pmf"},{"post_id":"cl0trzwko00kifhjie463123i","category_id":"cl0trzwmq00tifhjih1d304h2","_id":"cl0trzwmr00tnfhjif9q9a9t2"},{"post_id":"cl0trzwko00klfhji6q8c4w4j","category_id":"cl0trzwmq00tifhjih1d304h2","_id":"cl0trzwmr00tpfhjifgj631oe"},{"post_id":"cl0trzwkp00kmfhjif98rbpr1","category_id":"cl0trzwmq00tifhjih1d304h2","_id":"cl0trzwmr00tqfhji39i87kzp"},{"post_id":"cl0trzwkp00kpfhjiarfq1kit","category_id":"cl0trzwmr00tofhjidarkbosr","_id":"cl0trzwms00ttfhji9gnn9zgp"},{"post_id":"cl0trzwkq00kqfhjid9fm18nv","category_id":"cl0trzwmr00tofhjidarkbosr","_id":"cl0trzwms00tvfhji8kxkcbwf"},{"post_id":"cl0trzwkq00ktfhji0vlg40or","category_id":"cl0trzwmr00tofhjidarkbosr","_id":"cl0trzwms00twfhji40ygd3b6"},{"post_id":"cl0trzwli00nffhjiccaqarml","category_id":"cl0trzwnb00wgfhjidfzn7k1l","_id":"cl0trzwnh00wsfhji0oap74ru"},{"post_id":"cl0trzwli00nffhjiccaqarml","category_id":"cl0trzwng00wpfhji4jim1a9x","_id":"cl0trzwnh00wtfhjih8h501vb"},{"post_id":"cl0trzwlj00nifhji7gkd8tvg","category_id":"cl0trzwnb00wgfhjidfzn7k1l","_id":"cl0trzwnh00wvfhjiaetdbt0c"},{"post_id":"cl0trzwlj00nifhji7gkd8tvg","category_id":"cl0trzwng00wpfhji4jim1a9x","_id":"cl0trzwni00wwfhjiceo9g5a7"},{"post_id":"cl0trzwlk00njfhjifc1120f0","category_id":"cl0trzwnb00wgfhjidfzn7k1l","_id":"cl0trzwni00wyfhji007p4n6n"},{"post_id":"cl0trzwlk00njfhjifc1120f0","category_id":"cl0trzwng00wpfhji4jim1a9x","_id":"cl0trzwni00wzfhji6ekld8ux"},{"post_id":"cl0trzwlk00nmfhji54rjbqnv","category_id":"cl0trzwnb00wgfhjidfzn7k1l","_id":"cl0trzwni00x0fhji3heq6jxw"},{"post_id":"cl0trzwlk00nmfhji54rjbqnv","category_id":"cl0trzwng00wpfhji4jim1a9x","_id":"cl0trzwni00x1fhji5ci2a1sr"},{"post_id":"cl0trzwll00nnfhjies2mhaqm","category_id":"cl0trzwnb00wgfhjidfzn7k1l","_id":"cl0trzwnj00x2fhjifpsgdw5u"},{"post_id":"cl0trzwll00nnfhjies2mhaqm","category_id":"cl0trzwng00wpfhji4jim1a9x","_id":"cl0trzwnj00x3fhji9qonfc6w"}],"PostTag":[],"Tag":[]}}