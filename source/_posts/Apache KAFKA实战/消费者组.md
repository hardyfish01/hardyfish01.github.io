---
title: 消费者组
categories: 
- Apache KAFKA实战
---

**Consumer Group是Kafka提供的可扩展且具有容错性的消费者机制**。

既然是一个组，那么组内必然可以有多个消费者或消费者实例，它们共享一个公共的ID，这个ID被称为Group ID。

组内的所有消费者协调在一起来消费订阅主题的所有分区。

> 每个分区只能由同一个消费者组内的一个Consumer实例来消费。

**Consumer Group三个特性：**

1. Consumer Group下可以有一个或多个Consumer实例，这里的实例可以是一个单独的进程，也可以是同一进程下的线程。
2. Group ID是一个字符串，在一个Kafka集群中，它标识唯一的一个Consumer Group。
3. Consumer Group下所有实例订阅的主题的单个分区，只能分配给组内的某个Consumer实例消费，这个分区当然也可以被其他的Group消费。

当Consumer Group订阅了多个主题后，组内的每个实例不要求一定要订阅主题的所有分区，它只会消费部分分区中的消息。

Consumer Group之间彼此独立，互不影响，它们能够订阅相同的一组主题而互不干涉。

**Kafka仅仅使用Consumer Group这一种机制，却同时实现了传统消息引擎系统的两大模型**：

* 如果所有实例都属于同一个Group，那么它实现的就是消息队列模型；

* 如果所有实例分别属于不同的Group，那么它实现的就是发布/订阅模型。

**一个Group下该有多少个Consumer实例呢？**

**理想情况下，Consumer实例的数量应该等于该Group订阅主题的分区总数。**

假设一个Consumer Group订阅了3个主题，分别是A、B、C，它们的分区数依次是1、2、3，那么通常情况下，为该Group设置6个Consumer实例是比较理想的情形，因为它能最大限度地实现高伸缩性。

**针对Consumer Group，Kafka是怎么管理位移的呢？**

**位移Offset**

老版本的Consumer Group把位移保存在ZooKeeper中。

Apache ZooKeeper是一个分布式的协调服务框架，Kafka重度依赖它实现各种各样的协调管理。

将位移保存在ZooKeeper外部系统的做法，最显而易见的好处就是减少了Kafka Broker端的状态保存开销。

不过ZooKeeper这类元框架其实并不适合进行频繁的写更新，而Consumer Group的位移更新却是一个非常频繁的操作。

> 这种大吞吐量的写操作会极大地拖慢ZooKeeper集群的性能。

在新版本的Consumer Group中，Kafka社区重新设计了Consumer Group的位移管理方式，采用了将位移保存在Kafka内部主题的方法。

这个内部主题就是`__consumer_offsets`。

**为什么要重设消费者组位移？**

Kafka和传统的消息引擎在设计上是有很大区别的，其中一个比较显著的区别就是，Kafka的消费者读取消息是可以重演的。

像RabbitMQ或ActiveMQ这样的传统消息中间件，它们处理和响应消息的方式是破坏性的，即一旦消息被成功处理，就会被从Broker上删除。

反观Kafka，由于它是基于日志结构的消息引擎，消费者在消费消息时，仅仅是从磁盘文件上读取数据而已，是只读的操作，因此消费者不会删除消息数据。

同时，由于位移数据是由消费者控制的，因此它能够很容易地修改位移的值，实现重复消费历史数据的功能。

> 在实际使用场景中，我该如何确定是使用传统的消息中间件，还是使用Kafka呢？

如果在你的场景中，消息处理逻辑非常复杂，处理代价很高，同时你又不关心消息之间的顺序，那么传统的消息中间件是比较合适的；

反之，如果你的场景需要较高的吞吐量，但每条消息的处理时间很短，同时你又很在意消息的顺序，此时，Kafka就是你的首选。

# 消费者策略

**第一种是Round**

默认，也叫轮循，说的是对于同一组消费者来说，使用轮训分配的方式，决定消费者消费的分区

![](https://img-blog.csdnimg.cn/04841a8fc5f24052b99c0e4a103e6d27.png)

**第二种叫做Range**

对一个消费者组来说决定消费方式是以分区总数除以消费者总数来决定，一般如果不能整除，往往是从头开始将剩余的分区分配开

![](https://img-blog.csdnimg.cn/16c0e67c905d4d5ab19f7d4c363e21f4.png)

**第三种叫Sticky**

前面两个当同组内有新的消费者加入或者旧的消费者退出的时候，会从新开始决定消费者消费方式，但是Sticky，在同组中有新的新的消费者加入或者旧的消费者退出时，不会直接开始新的Range分配，而是保留现有消费者原来的消费策略，将退出的消费者所消费的分区平均分配给现有消费者，新增消费者同理，同其他现存消费者的消费策略中分离