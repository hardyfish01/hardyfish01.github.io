---
title: 类加载机制
categories: 
- 读书笔记
- 深入理解JVM虚拟机
---

一个类型从被加载到虚拟机内存开始，到卸载出内存为止：

> 它的生命周期将会经历加载，验证，准备，解析，初始化，使用和卸载七个阶段。

<img src="https://img-blog.csdnimg.cn/583d4b7da4bc468ebba212aae0fc5a6a.png" alt="、" style="zoom:50%;" />

加载，验证，准备，初始化和卸载这五个阶段的开始顺序是确定的（注意确定的只有开始顺序，完成顺序不确定）。

解析阶段则不一定：

> 它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）

**什么情况下需要开始类加载的第一个阶段加载？**

有且只有6种情况必须立即对类进行**初始化**（而加载，验证，准备自然需要在此之前开始）

1. 遇到new、getstatic、putstatic或invokestatic这四条字节码时，如果类型没有进行过初始化，则需要先触发其初始化阶段。

   能够生成这四种指令的典型Java代码场景有：
   
   * 使用new关键字实例化对象的时候。
   * 读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外） 的时候。
   * 调用一个类型的静态方法的时候。

2. 使用`java.lang.reflect`包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发初始化。

3. 当初始化类的时候，如果发现其父类还没有初始化，则先触发器父类的初始化。

4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。

5. 当使用JDK 7新加入的动态语言支持时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果为`REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial`四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。

6. 当一个接口中定义了JDK8新加入的默认方法（被default关键字修饰的接口方法）时，如果有接口的实现类发生了初始化，那么该接口要在其之前先被初始化。

这六种场景称为对一个类型的**主动引用**。除此之外，所有引用类型的方式都不会触发其初始化，称为**被动引用**。

> 需要注意：
>
> new数组对象也算作不会触发其类的初始化，因为实际上虚拟机会自动生成一个数组类，这个动作触发的是这个**数组类**的初始化。

接口也有初始化过程， 类是用静态语句块`static{}`来输出初始化信息的，而接口中不能使用`static{}`语句块，但编译器仍然会为接口生成`<clinit>()`类构造器，用于初始化接口中所定义的成员变量。

接口与类区别：

> 当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

**被动引用的例子一**

```java
/**
 * 被动使用类字段演示一：
 * 通过子类引用父类的静态字段，不会导致子类初始化
 **/
public class SuperClass {

    static {
        System.out.println("SuperClass init!");
    }

    public static int value = 123;
}

public class SubClass extends SuperClass {

    static {
        System.out.println("SubClass init!");
    }
}

/**
 * 非主动使用类字段演示
 **/
public class NotInitialization {

    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }

}
```

**对于静态字段,只有直接定义这个字段的类才会被初始化** ，因此通过其子类来引用父类中定义的静态字段 ，只会触发父类的初始化而不会触发子类的初始化。

至于是否要触发子类的加载和验证,在虚拟机规范中并未明确规定，这点取决于虚拟机的具体实现。

对于Sun HotSpot虚拟机，可通过`-XX : +TraceClassLoading`参数观察到此操作会导致子类的加载。

**被动引用的例子二**

```java
package org.fenixsoft.classloading;

/**
 * 被动使用类字段演示二：
 * 通过数组定义来引用类，不会触发此类的初始化
 **/
public class NotInitialization {

    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }

}
```

这段代码里面触发了另外一个名为`[Lorg.fenixsoftclassloading.Superclass`的类的初始化阶段 ，对于用户代码来说，这并不是一个合法的类名称，它是一个由虚拟机自动生成的、直接继承于`java.lang.Object`的子类，创建动作由字节码指令newarray触发。

这个类代表了一个元素类型为`org.fenixsoft.classloading.SuperClass`的一维数组，数组中应有的属性和方法(用户可直接使用的只有被修饰为public的length属性和clone()方法)都实现在这个类里。

**被动引用的例子三**

```java
package org.fenixsoft.classloading;

/**
 * 被动使用类字段演示三：
 * 常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。
 **/
public class ConstClass {

    static {
        System.out.println("ConstClass init!");
    }

    public static final String HELLOWORLD = "hello world";
}

/**
 * 非主动使用类字段演示
 **/
public class NotInitialization {

    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}
```

虽然在Java源码中引用了ConstClass类中的常量HELLOWORLD，但其实在编译阶段通过**常量传播优化**，已经将此常量的值`hello world`存储到了Notlnitialization类的常量池中，以后Notlnitialization对常量`ConstClass.HELLOWORLD`的引用实际都被转化为Notlnitializationl对自身常量池的引用了。 

实际上Notlnitialization的Class文件之中并没有ConstClass类的符号引用入口，这两个类在编译成Class之后就不存在任何联系了。

# 类加载过程

## 加载

在加载阶段虚拟机需要完成以下三件事：

1. 通过一个类的全限定名称来获取此类的二进制字节流
2. 将这个字节流所代表的**静态存储结构**转化为方法区的**运行时数据结构**
3. 在内存中生成一个代表这个类的`java.lang.Class`对象，作为方法区这个类的各种数据的访问入口

通常来讲，一个类的全限定名称可以从zip、jar包中加载，也可以从网络中获取，也可以在运行的时候生成（反射机制）。

对于类的加载，可以分为**数组类型和非数组类型**，对于非数组类型可以通过系统的引导类加载器进行加载，也可以通过自定义的类加载器进行加载。

对于数组类型，数组类本身不通过类加载器进行加载，而是通过Java虚拟机直接进行加载的，那么是不是数组类型的类就不需要类加载器了呢？

> 答案是否定的。
>
> 因为当数组去除所有维度之后的类型最终还是要依靠类加载器进行加载的，所以数组类型的类与类加载器的关系还是很密切的。

**通常一个数组类型的类进行加载需要遵循以下的原则：**

1. 如果数组的组件类型（也就是数组类去除一个维度之后的类型，比如对于二维数组，去除一个维度之后是一个一维数组）是引用类型，那么递归采用上面的过程加载这个组件类型。
2. 如果数组类的组件类型不是引用类型，比如是基本数据类型，Java虚拟机将把数组类标记为与引导类加载器关联。
3. 数组类的可见性与组件类型的可见性是一致的。如果组件类型不是引用类型，那么数组类的可见性是public，意味着组件类型的可见性也是public。

加载阶段与连接阶段是**交叉进行**的，所以可能加载阶段还没有完成，连接阶段就已经开始。

但是即便如此，加载阶段与连接阶段之间的开始顺序仍然保持着**固定的顺序**。

## 验证

验证阶段的目的是为了确保Class字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机的安全。

虚拟机的验证阶段主要完后以下4项验证：

> 文件格式验证、元数据验证、字节码验证、符号引用验证。

**文件格式验证**

文件格式是指Class的文件规范，这一步的验证主要保证加载的字节流符合Class文件的规范（比如前四个字节是否是一个魔数等）以及保证这个字节流可以被虚拟机接受处理。

**元数据验证**

元数据验证主要目的是对类的元数据信息进行语义校验，保证不存在不符合Java语言规范（Java语法）的元数据信息。

具体的验证信息包括以下几个方面：

1. 这个类是否有父类（除了`java.lang.Object`外其余的类都应该有父类）
2. 这个类的父类是否继承了不允许被继承的类（比如被final修饰的类）
3. 如果这个类不是抽象类，是否实现了其父类或者接口中要求实现的方法
4. 类中的字段、方法是否与父类产生矛盾（比如是否覆盖了父类的final字段）

**字节码验证**

**符号引用验证**

符号引用是Class文件的逻辑符号，直接引用指向的方法区中某一个地址，在**解析阶段**，将符号引用转为直接引用，这里只进行转化前的匹配性校验。

符号引用验证主要是对类自身以外的信息进行匹配性校验。比如符号引用是否通过字符串描述的全限定名是否能够找到对应点类。

- 符号引用：
  符号引用以一组符号来描述所引用的目标，符号引用可以是任何形式的字面量，只要使用时能无歧义的定位到目标即可（**符号字面量，还没有涉及到内存**）。
- 直接引用：
  直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄（可以理解为**内存地址**）。

直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般都不相同，如果有了直接引用，那引用的目标必定已经在内存中存在。

进行符号引用验证的目的在于确保解析动作能够正常执行，如果无法通过符号引用验证那么将会抛出`java.lang.IncomingChangeError`异常的子类。

## 准备

准备阶段是正式**为变量分配内存空间并且设置类变量初始值**。

> 需要注意的是，这时候进行内存分配的仅仅是类变量（也就是被static修饰的变量），实例变量是不包括的，实例变量的初始化是在对象实例化的时候进行初始化，而且分配的内存区域是Java堆。

这里的初始值也就是在编程中默认值，也就是零值。

例如`public static int value = 123；`value在准备阶段后的初始值是0而不是123，因为此时尚未执行任何的Java方法，而把value赋值为123的putStatic指令是程序被编译后，存放在类构造器clinit()方法之中，把value赋值为123的动作将在初始化阶段才会执行。

如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量就会被初始化为ConstantValue属性所指定的值，例如`public static final int value = 123 `编译时javac将会为value生成ConstantValue属性。

> 在准备阶段虚拟机就会根据ConstantValue的设置将变量赋值为123。

## 解析

解析阶段是将常量池中的符号引用替换为直接引用的过程。

在进行解析之前需要对符号引用进行解析，不同虚拟机实现可以根据需要判断到底是在类被加载器加载的时候对常量池的符号引用进行解析（也就是初始化之前），还是等到一个符号引用被使用之前进行解析（也就是在初始化之后）。

> 解析动作主要针对的是类或者接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用。

## 初始化

只有到了初始化阶段，才开始真正执行这个自定义的过程，所以也可以说初始化阶段是执行类构造器方法clinit() 的过程。

> 这个`clinit() `方法是这么生成的呢？

clinit() 是编译器自动收集类中所有**类变量的赋值动作和静态语句块**合并生成的。

**编译器收集的顺序是由语句在源文件中出现的顺序决定的**。

静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。

```java
public class Test {
  static{
   i =0;   //给变量赋值可以正常编译通过
   System.out.println(i); //这句编译器会提示“非法向前引用”
  }
  static int i = 1;
}
```

**clinit() 方法与类的构造器方法不同，因为前者不需要显式调用父类构造器，因为虚拟机会保证在子类的clinit() 方法执行之前，父类的clinit() 方法已经执行完毕**

由于父类的clinit() 方法会先执行，所以就表示**父类的static方法会先于子类的clinit() 方法执行**。

如下面的例子所示，输出结果为2而不是1

```java
public class Parent { 
 public static int A = 1; 
 static{ 
  A = 2; 
 } 
} 
 
public class Sub extends Parent{ 
 public static int B = A; 
} 
 
public class Test { 
 public static void main(String[] args) { 
  System.out.println(Sub.B); 
 } 
}
```

clinit()方法对于类或者接口来说**并不是必需**的。

> 如果一个类中没有静态语句块也没有对变量的赋值操作，那么编译器可以不为这个类生成clinit()方法。

接口中不能使用静态语句块，但仍然有变量赋值的初始化操作，因此接口也会生成clinit()方法。

但是接口与类不同，执行接口的clinit()方法不需要先执行父接口的`clinit()`方法。

只有当父接口中定义的变量被使用时，父接口才会被初始化。

另外，接口的实现类在初始化时也不会执行接口的clinit()方法。

**虚拟机会保证一个类的clinit()方法在多线程环境中被正确地加锁和同步**。

如果有多个线程去同时初始化一个类，那么只会有一个线程去执行这个类的clinit()方法，其它线程都需要阻塞等待，直到活动线程执行clinit()方法完毕。

如果在一个类的clinit()方法中有耗时很长的操作，那么就可能造成多个进程阻塞。

# 类加载器

对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每个类加载器，都拥有一个独立的类名称空间。

两个类即使来源于同一个Class文件，被同一个Java虚拟机加载，只要加载他们的虚拟机不同，那这两个类就必定不相等。

自JDK1.2以来，Java一直保持着三层类加载器、双亲委派的类加载架构。

1. **启动类加载器（Bootstrap Class Loader）**
   负责加载存放在`<JAVA_HOME>\lib`目录，或被`-Xbootclasspath`参数所指定的路径中存放的，且是Java虚拟机能够识别的（按照文件名识别，如`rt.jar、tools.jar`名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机的内存中，启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器去处理，那直接使用null代替即可。
2. **扩展类加载器 （Extension Class Loader）**
   在类`sun.misc.Launcher$ExtClassLoader`中以Java代码的形式实现，负责加载`<JAVA_HOME>\lib\ext`目录中，或被`java.ext.dirs`系统变量所指定的路径中所有的类库，这是一种Java系统类库的扩展机制，将具有通用性的类库放置在ext目录里以扩展Java SE的功能，在JDK9之后，这种扩展机制被模块化带来的天然的扩展能力所取代，由于是由Java代码实现，开发者可直接在程序中使用扩展类加载器来加载Class文件。
3. **应用程序类加载器（Application Class Loader）**
   由`sun.misc.Launcher$AppClassLoader`来实现。由于应用程序类加载器是ClassLoader类中的`getSystemClassLoader()`方法的返回值，也称为系统类加载器，负责加载用户类路径（ClassPath）上所有的类库，可直接在代码中使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

# 双亲委派模型

<img src="https://img-blog.csdnimg.cn/0722d01166e24dbca09ed50e63ee6b21.png" style="zoom:25%;" />

它要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。

> 这里的类加载器之间的父子关系一般不是继承 的关系来实现的，而是通常使用组合关系来复用父加载器的代码。

**双亲委派模型的工作过程：**

* 如果一个类加载器收到了类加载的请求，它首先不会自己加载，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它搜索范围中没有找到所需的类）中，子加载器才会尝试自己去完成加载。

* 使用双亲委派模型来组织类加载器之间的关系，显而易见的好处就是Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系，如类`java.lang.Object`，它存放在`rt.jar`之中，无论哪一种类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。

* 反之，如果没有使用双亲委派模型，都由各个类加载器自行加载的话，如果用户编写了一个名为`java.lang.Object`的类，并放在程序的ClassPath中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱。

双亲委派模型对于保证Java程序的未定运行极为重要，但它的实现去异常简单，用以实现双亲委派的代码仅有短短十余行，全部集中在`java.lang.ClassLoader`的loadClass()方法之中。

先检查请求加载的类型是否已经被加载过，若没有则调用父加载器的 loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。假如父类加载器加载失败， 抛出`ClassNotFoundException`异常的话，才调用自己的findClass()方法尝试进行加载。

**破坏双亲委派模型**

当有基础类型又要调回用户的代码，该怎么办？

> 典型例子：

- JNDI服务：是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK1.3时加入到`rt.jar`）属于基础类型，但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口 SPI 的代码。
- 问题：启动类加载器绝不可能认识、加载这些代码，该怎么办？
- 解决方案：为解决这个困境，Java设计团队只好引入一个不太优雅的设计，线程上下文类加载器。
- 这个类加载器可以通过`java.lang.Thread`类的setContextClassLoader()方法设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应有程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。

有了线程上下文类加载器，JNDI使用它去加载所需的SPI服务代码，这是一种**父类加载器去请求子类加载器**完成类加载的行为，这种行为实际上打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则。

> Java中涉及SPI的加载基本都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。

在JDK1.6时，JDK提供了`java.util.ServiceLoader`类，以`META-INF/services`中的配置信息，辅以责任链模式，给SPI的加载提供了一种相对合理的解决方案。

**OSGi实现模块化热部署**

OSGi实现模块化热部署，每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。

在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。

**Tomcat为什么要破坏双亲委派模型**

每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。

大致是出于下面三类目的：

- 对于各个 webapp中的 class和 lib，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。

- 与 jvm一样的安全性问题。使用单独的 classloader去装载 tomcat自身的类库，以免其他恶意或无意的破坏。

- 热部署。

<img src="https://img-blog.csdnimg.cn/c4275d2dc32e44438d08738f38a8244b.png" style="zoom:25%;" />

对于一些需要加载的非基础类，会由一个叫作 WebAppClassLoader 的类加载器优先加载。

等它加载不到的时候，再交给上层的 ClassLoader 进行加载。

这个加载器用来隔绝不同应用的`.class`文件，比如你的两个应用，可能会依赖同一个第三方的不同版本，它们是相互没有影响的。

# 模块化系统

在JDK 9中引入的Java模块化系统，为了能够实现模块化的关键目标——可配置的封装隔离机制，Java虚拟机对类加载架构也做出了相应的变动调整，才使模块化系统得以顺利地运作。

**模块化下的类加载器**

<img src="https://img-blog.csdnimg.cn/4820f3cc3c0349578363eef45abba95e.png" style="zoom:25%;" />

JDK 9中虽然仍然维持着三层类加载器和双亲委派的架构，但类加载的委派关系也发生了 变动。

当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器 完成加载，也许这可以算是对双亲委派的第四次破坏。