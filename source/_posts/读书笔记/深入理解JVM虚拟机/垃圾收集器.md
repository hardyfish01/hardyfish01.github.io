---
title: 垃圾收集器
categories: 
- 读书笔记
- 深入理解JVM虚拟机
---

<img src="https://img-blog.csdnimg.cn/94796d43894d49b7b80a52b63f692953.png" style="zoom:25%;" />

# Serial

Serial收集器是最基础、历史最悠久的收集器，曾经(在JDK 1.3.1之前)是HotSpot虚拟机新生代收集器的唯一选择。

这个收集器是一个单线程工作的收集器，它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。

<img src="https://img-blog.csdnimg.cn/33bebd30b61743e48de9a90181004f69.png" style="zoom:50%;" />

它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器

# ParNew

ParNew收集器实质上是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外 ，其余的Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致，在实现上这两种收集器也共用了相当多的代码。

<img src="https://img-blog.csdnimg.cn/59c6c9cc2c024a9286ae9522fa1fa8b7.png" style="zoom:50%;" />

除了Serial收集器外，目前只有它能与CMS 收集器配合工作。

在JDK 5发布时，HotSpot推出了一款垃圾收集器 ——CMS收集器。

这款收集器是HotSpot虚拟机中第一款真正意义上支持并发的垃圾收集器，它首次 实现了让垃圾收集线程与用户线程(基本上)同时工作。

在JDK 5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者 Serial收集器中的一个。

> 自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。

官方希望它能完全被G1所取代，甚至还取消了ParNew加 Serial Old以及Serial加CMS这两组收集器组合的支持(其实原本也很少人这样使用)，并直接取消了`- XX:+UseParNewGC`参数。

它默认开启的收集线程数与处理器核心数量相同

可以使用`-XX:ParallelGCT hreads`参数来限制垃圾收集的线程数。

* 并行(Parallel):并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线 程在协同工作，通常默认此时用户线程是处于等待状态。

* 并发(Concurrent):并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾 收集器线程与用户线程都在运行。

# Parallel Scavenge

Parallel Scavenge收集器也是一款新生代收集器，它同样是基于标记-复制算法实现的收集器，也是 能够并行收集的多线程收集器

Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能地缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量(`Throughput`)。

**所谓吞吐量就是处理器用于运行用户代码的时间与处理器总消耗时间的比值**

Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间 的`-XX:MaxGCPauseMillis`参数以及直接设置吞吐量大小的`-XX:GCTimeRatio`参数。

Parallel Scavenge收集器还有一个参数`-XX:+UseAdaptiveSizePolicy`。

这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小(`-Xmn`)、Eden与Survivor区 的 比 例、 晋 升老 年代对 象 大 小等 细 节 参 数

虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。

这种调节方式称为垃圾收集的**自适应的调节策略(GC Ergonomics)**

# Serial Old

Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。

这个收集器的主要意义也是供客户端模式下的HotSpot虚拟机使用。

如果在服务端模式下，它也可能有两种用途:

* 一种是在JDK 5以及之前的版本中与Parallel Scavenge收集器搭配使用。

* 另外一种就是作为CMS 收集器发生失败时的后备预案，在并发收集发生Concurrent M ode Failure时使用。

<img src="https://img-blog.csdnimg.cn/70e78dfa74d2429a886ac362a502e2f2.png" style="zoom:50%;" />

# Parallel Old

Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实 现。

在注重 吞吐量或者处理器资源较为稀缺的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。

<img src="https://img-blog.csdnimg.cn/81f40d50d7ce4f28a88333ec61dde988.png" style="zoom:50%;" />

# CMS

CMS收集器是一种以获取最短回收停顿时间为目标的收集器。

CMS收集器是基于标记-清除算法实现的：

* 初始标记

* 并发标记

* 重新标记

* 并发清除

其中初始标记、重新标记这两个步骤仍然需要Stop The World。

* 初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。

* 并发标记阶段就是从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。

  在这个阶段的执行过程中，可能会产生很多变化：

  -  有些对象，从新生代晋升到了老年代； 

  -  有些对象，直接分配到了老年代； 

  -  老年代或者新生代的对象引用发生了变化。 

  在这个阶段受到影响的老年代对象所对应的卡页，会被标记为 dirty，用于后续重新标记阶段的扫描。

* 重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一 些，但也远比并发标记阶段的时间短。

* 并发清除阶段，清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。

由于在整个过程中耗时最长的并发标记和并发清除阶段中，垃圾收集器线程都可以与用户线程一 起工作，所以从总体上来说，CMS收集器的**内存回收过程是与用户线程**一起并发执行的。

<img src="https://img-blog.csdnimg.cn/69374386f15146ddb402650de4f0b71f.png" style="zoom:50%;" />

> CMS最主要的优点:并发收集、低停顿。

**三个明显的缺点:**

* 对处理器资源非常敏感，因为占用了一部分线程(或者说处理器的计算能力)而导致应用程序变慢，降低总吞吐量。

**CMS收集器无法处理浮动垃圾**

有可能出现Concurrent Mode Failure失败进而导致另一次完全Stop The World的Full GC的产生，在CMS的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。

在JDK 5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，如果 在实际应用中老年代增长并不是太快，可以适当调高参数`-XX:CMSInitiatingOccupancyFraction`的值 来提高CMS的触发百分比，降低内存回收频率，获取更好的性能。

> 到了JDK 6时，CMS收集器的启动阈值就已经默认提升至92%。

要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次并发失败(Concurrent Mode Failure)，这时候虚拟机将不 得不启动后备预案:

* 冻结用户线程的执行，临时启用Serial Old收集器来重新进行老年代的垃圾收集， 但这样停顿时间就很长了。

所以参数`-XX:CMSInitiatingOccupancyFraction`设置得太高将会很容易导致大量的并发失败产生，性能反而降低，用户应在生产环境中根据实际应用情况来权衡设置。

> CMS是一款基于标记-清除算法实现的收集器，会有大量空间碎片产生。

空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次Full GC的情况。

为了解决这个问题， CMS收集器提供了一个`-XX:+UseCMSCompactAtFullCollection`开关参数(默认是开启的，此参数从 JDK 9开始废弃)，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程。

**这个内存整理必须移动存活对象的。** 

参数`-XX:CM SFullGCsBeforeCompaction`(此参数从JDK 9开始废弃)：

* 这个参数的作用是要求CMS收集器在执行过若干次不整理空间的Full GC之后，下一次进入Full GC前会先进行碎片整理(默认值为0，表示每次进入Full GC时都进行碎片整理)。

# Garbage First

G1是一款主要面向服务端应用的垃圾收集器。

> JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。

G1把连续的Java堆划分为多个大小相等的独立区域(Region)，每一个Region都可以根据需要，扮演新生代的Eden空间、Survivor空间，或者老年代空间：

* Region中还有一类特殊的Humongous区域，专门用来存储大对象。

* G1认为只要大小超过了一个 Region容量一半的对象即可判定为大对象。

* 每个Region的大小可以通过参数`-XX:G1Heap RegionSize`设定，取值范围为1MB~32MB，且应为2的N次幂。

而对于那些超过了整个Region容量的超级大对象， 将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代 的一部分来进行看待。

虽然G1仍然保留新生代和老年代的概念，但新生代和老年代不再是固定的了，它们都是一系列区域(不需要连续)的动态集合。

> G1收集器之所以能建立可预测的停顿时间模型，是因为它将Region作为单次回收的最小单元，即每次收集到的内存空间都是Region大小的整数倍，这样可以有计划地避免在整个Java堆中进行全区域的垃圾收集。
>
> 在垃圾收集过程中，G1收集器会记录每个Region的回收耗时。

G1在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间(使用参数`-XX:MaxGCPauseMillis`指定，默认值是200毫秒)，优先处理回收价值收益最大的那些Region。 

**将Java堆分成多个独立Region后，Region里面存在的跨Region引用对象如何解决?**

使用记忆集避免全堆作为GC Roots扫描，但在G1收集器上记忆集的应用其实要复杂很多，它的每个Region都维护有自己的记忆集，这些记忆集会记录下别的Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。

G1的记忆集在存储结构的本质上是一种哈希表 ，Key是别的Region的起始地址 ，Value是一个集合 ，里面存储的元素是卡表的索引号 。 

这 种双向的卡表结构(卡表是我指向谁，这种结构还记录了谁指向我)比原来的卡表实现起来更复杂，同时由于Region数量比传统收集器的分代数量明显要多得多，因此G1收集器要比其他的传统垃 圾收集器有着更高的内存占用负担。

> 根据经验，G1至少要耗费大约相当于Java堆容量10%至20%的额外内存来维持收集器工作。

**G1收集器的运作过程大致可划分为以下四个步骤:**

* 初始标记：仅仅只是标记一下GC Roots能直接关联到的对象。

* 并发标记：从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行，当对象图扫描完成以后，还要重新处理SATB记录下的在并发时有引用变动的对象。

* 最终标记：对用户线程做另一个短暂的暂停，用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。

* 筛选回收：对各个`Region`的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region 构成回收集，然后把决定回收的那一部分`Region`的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间，这里的操作涉及存活对象的移动，是必须**暂停用户线程**，由多条收集器线程并行完成的。

<img src="https://img-blog.csdnimg.cn/84db616d120a43c0890d320154aca3c4.png" style="zoom:50%;" />

G1从整体来看是基于标记-整理算法实现的收集器，但从局部(两个`Region `之间)上看又是基于标记-复制算法实现，无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，垃圾收集完成之后能提供规整的可用内存。

这种特性有利于程序长时间运行，在程序为大 对象分配内存时不容易因无法找到连续内存空间而提前触发下一次收集。

目前在小内存应用上CM S的表现大概率仍然要会优于G1，而在大内存应用上G1则大多能发挥其优势，这个优劣势的Java堆容量平衡点通常在6GB至8GB之间。

**在并发标记阶段如何保证收集线程与用户线程互不干扰地运行?**

CMS收集器采用增量更新算法实现，而G1 收集器则是通过原始快照(SATB)算法来实现的。

**GC模式**

G1中提供了三种模式垃圾回收模式，young gc、mixed gc 和 full gc，在不同的条件下被触发。

> young gc

发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。

| 参数                    | 含义                                |
| ----------------------- | ----------------------------------- |
| -XX:MaxGCPauseMillis    | 设置G1收集过程目标时间，默认值200ms |
| -XX:G1NewSizePercent    | 新生代最小值，默认值5%              |
| -XX:G1MaxNewSizePercent | 新生代最大值，默认值60%             |

> mixed gc

当越来越多的对象晋升到老年代old region时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即mixed gc，该算法并不是一个old gc，除了回收整个young region，还会回收一部分的old region，可以选择哪些old region进行收集，从而可以对垃圾回收的耗时时间进行控制。

mixed gc中有一个阈值参数 `-XX:InitiatingHeapOccupancyPercent`，当老年代使用大小占整个堆大小百分比达到该阈值时，会触发一次mixed gc。

> full gc

如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc。

**参数：**

-XX:InitiatingHeapOccupancyPercent，默认值是45%

- 老年代占据了堆内存的45%的Region的时候，此时就会尝试触发一个新生代+老年代一起回收的混合回收阶段。

-XX:G1MixedGCCountTarget，在一次混合回收的过程中，最后一个阶段执行几次混合回收，默认值是8次

- 意味着最后一个阶段，先停止系统运行，混合回收一些Region，再恢复系统运行，接着再次禁止系统运行，混合回收一些Region，反复8次。

-XX:G1HeapWastePercent，默认值是5%

- 在混合回收的时候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着本次混合回收就结束了。

# ZGC

ZGC是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器。

**ZGC 最主要的特点包括：**

- GC 最大停顿时间不超过 10ms
- 堆内存支持范围广，小至几百 MB 的堆空间，大至 4TB 的超大堆内存（JDK 13 升至 16TB）
- 与 G1 相比，应用吞吐量下降不超过 15%

根据基准测试，在 128G 的大堆下，最大停顿时间只有 1.68ms，远远低于 10ms；和 G1 算法比起来相比，改进非常明显。