---
title: 常用命令
categories: 
- 读书笔记
- 深入理解JVM虚拟机
---

# jps

Jps 展示的是当前用户可看见的 Java 进程，如果看不见某些进程可能需要 sudo、su 之类的命令来切换权限。

# jstat

jstat 用来监控 JVM 内置的各种统计信息，主要是内存和 GC 相关的信息。

实例：

```shell
jstat -gcutil -t 864
```

`-gcutil` 选项是统计 GC 相关区域的使用率（utilization），结果如下：

| Timestamp  | S0   | S1    | E     | O     | M     | CCS   | YGC    | YGCT    | FGC  | FGCT  | GCT     |
| :--------- | :--- | :---- | :---- | :---- | :---- | :---- | :----- | :------ | :--- | :---- | :------ |
| 14251645.5 | 0.00 | 13.50 | 55.05 | 71.91 | 83.84 | 69.52 | 113767 | 206.036 | 4    | 0.122 | 206.158 |

`-t` 选项的位置是固定的，不能在前也不能在后。可以看出是用于显示时间戳，即 JVM 启动到现在的秒数。

简单分析一下：

- Timestamp 列：JVM 启动了 1425 万秒，大约 164 天。
- S0：就是 0 号存活区的百分比使用率。0% 很正常，因为 S0 和 S1 随时有一个是空的。
- S1：就是 1 号存活区的百分比使用率。
- E：就是 Eden 区，新生代的百分比使用率。
- O：就是 Old 区，老年代。百分比使用率。
- M：就是 Meta 区，元数据区百分比使用率。
- CCS：压缩 class 空间（Compressed class space）的百分比使用率。
- YGC（Young GC）：年轻代 GC 的次数。11 万多次，不算少。
- YGCT 年轻代 GC 消耗的总时间。206 秒，占总运行时间的万分之一不到，基本上可忽略。
- FGC：FullGC 的次数，可以看到只发生了 4 次，问题应该不大。
- FGCT：FullGC 的总时间，0.122 秒，平均每次 30ms 左右，大部分系统应该能承受。
- GCT：所有 GC 加起来消耗的总时间，即 YGCT + FGCT。

`-gc` 选项，GC 相关的堆内存信息。

```shell
jstat -gc -t 864 1s
jstat -gc -t 864 1s 3
jstat -gc -t -h 10 864 1s 15
```

其中的 `1s` 占了 `<interval>` 这个槽位，表示每 1 秒输出一次信息。

`1s 3` 的意思是每秒输出 1 次，最多 3 次。

如果只指定刷新周期，不指定 `<count>` 部分，则会一直持续输出。 退出输出按 `CTRL+C` 即可。

`-h 10` 的意思是每 10 行输出一次表头。

结果大致如下：

| Timestamp  | S0C    | S1C    | S0U   | S1U  | EC     | EU     | OC      | OU     | MC      | MU      | YGC    | YGCT    | FGC  | FGCT  |
| :--------- | :----- | :----- | :---- | :--- | :----- | :----- | :------ | :----- | :------ | :------ | :----- | :------ | :--- | :---- |
| 14254245.3 | 1152.0 | 1152.0 | 145.6 | 0.0  | 9600.0 | 2312.8 | 11848.0 | 8527.3 | 31616.0 | 26528.6 | 113788 | 206.082 | 4    | 0.122 |
| 14254246.3 | 1152.0 | 1152.0 | 145.6 | 0.0  | 9600.0 | 2313.1 | 11848.0 | 8527.3 | 31616.0 | 26528.6 | 113788 | 206.082 | 4    | 0.122 |
| 14254247.3 | 1152.0 | 1152.0 | 145.6 | 0.0  | 9600.0 | 2313.4 | 11848.0 | 8527.3 | 31616.0 | 26528.6 | 113788 | 206.082 | 4    | 0.122 |

详细的解读如下：

- Timestamp 列：JVM 启动了 1425 万秒，大约 164 天。
- S0C：0 号存活区的当前容量（capacity），单位 kB。
- S1C：1 号存活区的当前容量，单位 kB。
- S0U：0 号存活区的使用量（utilization），单位 kB。
- S1U：1 号存活区的使用量，单位 kB。
- EC：Eden 区，新生代的当前容量，单位 kB。
- EU：Eden 区，新生代的使用量，单位 kB。
- OC：Old 区，老年代的当前容量，单位 kB。
- OU：Old 区，老年代的使用量，单位 kB。 （需要关注）
- MC：元数据区的容量，单位 kB。
- MU：元数据区的使用量，单位 kB。
- CCSC：压缩的 class 空间容量，单位 kB。
- CCSU：压缩的 class 空间使用量，单位 kB。
- YGC：年轻代 GC 的次数。
- YGCT：年轻代 GC 消耗的总时间。 （重点关注）
- FGC：Full GC 的次数
- FGCT：Full GC 消耗的时间。 （重点关注）
- GCT：垃圾收集消耗的总时间。

最重要的信息是 GC 的次数和总消耗时间，其次是老年代的使用量。

# jmap

jmap 主要用来 Dump 堆内存。当然也支持输出统计信息。

> $ `jmap -histo 4524`

结果为：

```
 num     #instances         #bytes  class name
----------------------------------------------
   1:         52214       11236072  [C
   2:        126872        5074880  java.util.TreeMap$Entry
   3:          5102        5041568  [B
   4:         17354        2310576  [I
   5:         45258        1086192  java.lang.String
......
```

简单分析，其中 `[C` 占用了 11MB 内存，没占用什么空间。

`[C` 表示 `chat[]`，`[B` 表示 `byte[]`，`[I` 表示 `int[]`，其他类似。

Java 中的大对象、巨无霸对象，一般都是长度很大的数组。

# jstack

命令行工具、诊断工具：jstack 工具可以打印出 Java 线程的调用栈信息（Stack Trace）。

一般用来查看存在哪些线程，诊断是否存在死锁等。

# jinfo

诊断工具：jinfo 用来查看具体生效的配置信息以及系统属性，还支持动态增加一部分参数。