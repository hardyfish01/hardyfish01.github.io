---
title: 跳跃表
categories: 
- 读书笔记
- Redis设计与实现
---

跳跃表是一种**有序**的数据结构，通过在每个节点**维持多个指向其他节点的指针**，达到快速访问节点的目的。

如果一个有序集合中包含的元素数量比较多，又或者有序集合中元素的成员是较长的字符串，Redis就会使用跳跃表来作为有序集合键的底层实现。

* Redis只有在两个地方用到了跳跃表，一个是实现**有序集合键**，另一个是在**集群节点中**作为内部数据结构。

**为什么需要跳跃表(SkipList)？**

对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。

* 这样查找效率就会很低，时间复杂度会很高，是 `O(n)`。

如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。

每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作**索引**。

* 这个时候，我们假设要查找节点 8，我们可以先在索引层遍历，当遍历到索引层中值为 7 的结点时，发现下一个节点是 9，那么要查找的节点 8 肯定就在这两个节点之间。

* 我们下降到链表层继续遍历就找到了 8 这个节点。原先我们在单链表中找到 8 这个节点要遍历 8 个节点，而现在有了一级索引后只需要遍历五个节点。

* 从这个例子里，我们看出，加来一层索引之后，查找一个结点需要遍的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。

<img src="https://img-blog.csdnimg.cn/2e139e628bc048fd883a0e7a5a6de682.png" style="zoom:25%;" />

从图中我们可以看出，查找效率又有提升。

在例子中我们的数据很少，当有大量的数据时，我们可以增加**多级索引**，其查找效率可以得到明显提升。

**跳跃表的实现**

Redis的跳跃表由`redis.h/zskiplistNode`和`redis.h/zskiplist`两个数据结构定义。

```c
typedef struct zskiplist{
    //表头节点和表尾节点
    structz zskiplistNode *header,* tail;
    //表中节点的数量
    unsigned long length;
    //表中层数最大的节点的层数
    int level;
} zskiplist;
```

跳跃表由zskiplist组织，通过多个跳跃表节点zskiplistNode组成一个跳跃表。

值得注意的是，记录level时，表头节点的层高不会记录在内。

<img src="https://img-blog.csdnimg.cn/320f95245d9d44e38f8e65f3fe8aeca2.png" style="zoom:25%;" />

**跳跃表节点**

每次创建一个新的跳跃表节点的时候，程序都会随机生成一个介于 `1-32` 之间的值作为 `level` 数组的大小，这个大小就是层的高度。

> Redis的Level个数为什么要**用幂次定律生成（随机生成节点的层数）**？

通过幂次定律能保证越高level的结点数量越少 。

保证索引等级越高，**参与索引建立的元素越少**，如果每层都有很多level，那么这个索引建立的就没有意义了。

那么，为什么不用最均衡的方式，按照节点分数的排序情况均匀建立索引？

考虑到下一个插入的元素**具有随机性**，这样设计**不容易出现最坏的情况**。如果每次都以均匀固定的方式建索引，**维护的成本很高**，跳跃表的优点就是维持结构平衡的成本低，完全依靠随机。跳跃表相比二叉树有一个优势就在于**不需要主动Rebalance**去维护平衡。

> 分值Score

分值是一个**double类型的浮点数**，跳跃表中节点都按照分值排序。

> 成员对象

是一个指针，指向字符串**SDS对象**。一个跳跃表中，**对象必须是唯一的，但分值可以相同**。相同时按对象字典序来排序。

**跳跃表的时间复杂度**

跳跃表相关操作及时间复杂度：

<img src="https://img-blog.csdnimg.cn/9baae648f23644238b346e5d9102bb1a.png" style="zoom:50%;" />