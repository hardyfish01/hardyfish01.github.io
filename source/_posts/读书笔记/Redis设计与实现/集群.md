---
title: 集群
categories: 
- 读书笔记
- Redis设计与实现
---

集群是Redis提供的**分布式数据库**方案，通过**分片**来进行数据共享并提供复制和故障转移的功能。

**节点**

集群由多个节点组成，通过`CLUSTER MEET <ip> <port>`可以将节点连接起来。

这个命令主要是将目标节点加入到当前Redis所在的集群中。

**启动节点**

Redis服务器在启动时会根据cluster-enable配置是否为yes来决定是否开启集群模式。

**槽指派**

Redis通过分片方式保存键值对，集群的整个数据库被分为**16384**个槽（slot），数据库的每个键都属于某一个槽，每个节点可处理0~16384个槽。

* 当集群中的**每个槽都归某个节点**管理，集群处于上线状态；但凡有一个没人管，集群处于下线状态。

* 通过检查某节点**是否负责处理某个槽**或者**让节点负责**某个槽的操作的时间复杂度都为`O(1)`。

**传播节点的槽指派信息**

节点除了将自己负责的槽记录在`clusterNode.slots`中，还会将这个数组通过**消息发送**给其他节点，让他们都知道自己负责什么槽。

其他节点接收消息后，会对`clusterStaste.nodes`字典中对应的`clusterNode.slots`数据进行更新。

* `clusterState.slots`数组记录**集群中所有槽的信息**；`clusterNode.slots`数组记录当前节点**负责槽的信息**。

* 前者方便知道某个槽指派给谁，后者方便知道某个槽是否指派给自己，或者发送自己槽的指派信息。

**在集群中执行命令**

当客户端对节点发送与数据库键有关的命令时，接收命令的节点会计算属于哪个槽，检查这个槽是否指派给自己（根据Key的**CRC-16校验和&16383**来确定槽号i，再根据`clusterState.slots[i]`是否指向当前节点的clusterNode判断是否自己负责的）。

如果不是指派给自己的，就找负责该槽的IP和端口，指引客户端转向它，向客户端**返回MOVED错误**，引导客户端指向正确的节点并再次发送命令。

 <img src="https://img-blog.csdnimg.cn/eb71f5d19a504538ad460036957cd3da.png" style="zoom:25%;" />

**MOVED错误**

在集群模式下，会被隐藏，客户端会进行自动转向并重发命令。节点的转向其实就是**换对应套接字**来发送命令。

**节点数据库的实现**

节点对数据的存储和单机Redis的实现是一样的，只不过节点只能使用0号库。

**重新分片**

Redis集群的重新分片操作可以将任意数量已经指派给某个节点(源节点)的槽改为指派给另一个节点(目标节点)，并且相关槽所属的键值对也会从源节点被移动到目标节点。

重新分片通过集群管理软件redis-trib执行，步骤如下：

<img src="https://img-blog.csdnimg.cn/8054619535f943cda3b4e04870472e36.png" style="zoom:25%;" />

**ASK错误**

当客户端向源节点发送与数据库键相关的命令，并且该键恰好属于**被迁移的槽**时，源节点会先查自己有没有，有就返回；**没有则返回ASK错误**，指引客户端向正在导入槽的目标节点发送命令。

* 这个命令和MOVED类似，不会直接打印错误。

如果收到key命令请求的节点所属key的槽正好指派给了该节点，找到则返回，如果没找到则检查是否正在迁移，如果**正在迁移**，就向客户端返回ASK错误，引导其去**导入槽的节点查询**。

客户端接收到ASK错误后，根据IP和端口，转向目标节点，然后先向目标节点发送**ASKING**命令，再重新发送要执行的命令。

<img src="https://img-blog.csdnimg.cn/c5556a38947844e89a4ae0e87ea75f99.png" style="zoom:25%;" />

**ASK错误与MOVED错误的区别**

这两个错误都会客户端转向：

- MOVED错误代表槽的负责权**已经从一个节点到了另一个节点**。
- ASK错误只是两个节点再迁移槽过程中使用的**临时措施**。

**复制与故障转移**

Redis集群中的节点分主节点和从节点，主节点用于处理槽，从节点用于复制某个主节点（相当于备份，不处理读请求），并在被复制节点下线时，代替下线主节点继续处理命令请求。

**故障检测**

集群中每个节点都会定期向其他节点发送PING消息，如果没有在规定时间返回PONG消息，就会被标记位**疑似下线**。

* 在一个集群中，**半数以上**负责处理槽的主节点将某个主节点报告为疑似下线后，这个主节点将被**标记为已下线**。

并向集群广播一条关于该主节点FAIL的消息，所有收到消息的节点都会将其标记为已下线。

**选举新的主节点**

集群选举新主节点的具体过程：

1. 通过集群的配置纪元确定是哪一次选举，它是一个**自增计数器**，初始值为0。
2. 当集群里的某个节点开始一次故障转移操作时，集群配置纪元的值会被加一。
3. 集群里每个负责处理槽的主节点都有**一次投票的机会**，第一个向主节点要求投票的从节点将获得主节点的投票。
4. 当从节点发现自己正在复制的主节点进入已下线状态时，从节点会向集群**广播**一条 `CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST`消息，要求所有收到这条消息并且具有投票权的主节点向这个从节点投票。
5. 如果一个主节点具有投票权(它正在负责处理槽)，并且这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条`CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK`消息，表示这个主节点支持从节点成为新的主节点。
6. 每个参与选举的从节点都会接收`CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK`消息，并根据自己**收到消息的条数**来统计自己获得多少主节点的支持。
7. 如果集群里有N个具有投票权的主节点，那么当一个从节点收集到大于等于**N/2+1** 支持票时，这个从节点就会当选为新的主节点。
8. 配置纪元确定每个具有投票权的主节点只能投一次，所以如果有N个主节点进行投票，那么具有大于等于N/2+1张支持票的从节点只会有一个，这确保了新的主节点只会有一个。
9. 如果在一个配置纪元里没有从节点得到足够的票，那么集群进入一个新的配置纪元，并**再次进行选举**，直到选出新的主节点为止。

 **消息**

集群中节点主要通过发送消息来传递信息，主要有5种：

- MEET消息：发送者接收到客户端的MEET消息时，发送者向接收者发送MEET消息，**请求加入**发送者所在集群。
- PING消息：集群每个节点每隔一秒从已知节点**随机选出5个**节点，然后对**最长时间没发**PING消息的节点进行发送。除此之外，还会将最后一次收到PONG消息的节点中，如果时间**超过**配置的`cluster-node-timeout`选项的**一半**时，也会发送PING消息。
- PONG消息：应答MEET或PING消息。还可以通过PONG，告诉其他节点，刷新该节点的相关信息。
- FAIL消息：当某个主节点判断另一个主节点**已经进入FAIL状态**时，当前主节点会向集群**广播**一条关于已下线节点的FAIL消息。
- PUBLISH消息：当节点接收到PUBLISH命令时，执行这个命令，并向集群**广播**一条PUBLISH消息，所有接收到这条PUBLISH消息的节点都会执行相同的PUBLISH命令。

**MEET、PING、PONG消息的实现**

集群中的各个节点通过**Gossip协议**来交换各自关于不同节点的状态信息，Gossip协议由MEET、PING、PONG这三种消息实现。

**FAIL消息的实现**

在集群节点较多的情况下，单纯使用Gossip会带来一些**延迟**，FAIL消息需要所有节点立刻知道某个主节点下线了，从而尽快判断**是否需要标记为下线或故障转移**。