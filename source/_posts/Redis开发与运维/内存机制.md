---
title: 内存机制
categories: 
- Redis开发与运维
---

# 内存消耗

可通过执行info memory 命令获取内存相关指标。

当`mem_fragmentation_ratio>1`时，说明used_memory_rss-used_memory多出的部分内存并没有用于数据存储，而是被内存碎片所消耗，如果两者相差很大，说明碎片率严重。

当`mem_fragmentation_ratio<1`时，这种情况一般出现在操作系统把Redis内存交换(Swap)到硬盘导致，出现这种情况时要格外关注，由于硬盘速度远远慢于内存，Redis性能会变得很差，甚至僵死。

**内存消耗划分**

Redis进程内消耗主要包括:自身内存+对象内存+缓冲内存+内存碎片， 其中Redis空进程自身内存消耗非常少，通常used_memory_rss在3MB左右， used_memory在800KB左右，一个空的Redis进程消耗内存可以忽略不计。 

<img src="https://img-blog.csdnimg.cn/26c194e491534c37873fc809e62fadda.png" style="zoom:25%;" />

**对象内存**

Redis 所有的数据都采用key-value数据类型，每次创建键值对时，至少创建两个类型对象:key对象和value对象。

对象内存消耗可以简单理解为sizeof(keys) +sizeof(values)。

**缓冲内存**

缓冲内存主要包括:客户端缓冲、复制积压缓冲区、AOF缓冲区。

**内存碎片**

Redis默认的内存分配器采用jemalloc，可选的分配器还有:glibc、 tcmalloc。

内存分配器为了更好地管理和重复利用内存，分配内存策略一般 采用固定范围的内存块进行分配。

例如jemalloc在64位系统中将内存空间划 分为:小、大、巨大三个范围。每个范围内又划分为多个小的内存块单位

比如当保存5KB对象时jemalloc可能会采用8KB的块存储，而剩下的3KB 空间变为了内存碎片不能再分配给其他对象存储。

内存碎片问题虽然是所有内存服务的通病，但是jemalloc针对碎片化问题专门做了优化，一般不会存在过度碎片化的问题，正常的碎片率(`mem_fragmentation_ratio`)在1.03左右。

**内存分配库jemalloc**

jemalloc在分配内存时，会根据我们申请的字节数N，找一个比N大，但是最接近N的2的幂次数作为分配的空间，这样可以减少频繁分配的次数。

举个例子。如果你申请6字节空间，jemalloc实际会分配8字节空间；如果你申请24字节空间，jemalloc则会分配32字节。

**子进程内存消耗**

子进程内存消耗主要指执行AOF/RDB重写时Redis创建的子进程内存消耗。

Redis执行fork操作产生的子进程内存占用量对外表现为与父进程相同， 理论上需要一倍的物理内存来完成重写操作。

# 内存管理

**设置内存上限** 

Redis使用maxmemory参数限制最大可用内存。

限制内存的目的主要有:

* 用于缓存场景，当超出内存上限maxmemory时使用LRU等删除策略释放 空间。

* 防止所用内存超过服务器物理内存。

需要注意，maxmemory限制的是Redis实际使用的内存量，也就是 used_memory统计项对应的内存。

由于内存碎片率的存在，实际消耗的内存 可能会比maxmemory设置的更大，实际使用时要小心这部分内存溢出。

**动态调整内存上限**

Redis的内存上限可以通过config set maxmemory进行动态修改，即修改 最大可用内存。

**建议：**

Redis默认无限使用服务器内存，为防止极端情况下导致系统内存耗 尽，建议所有的Redis进程都要配置maxmemory。

在保证物理内存可用的情况下，系统中所有Redis实例可以调整 maxmemory参数来达到自由伸缩内存的目的。

## 内存回收策略

Redis的内存回收机制主要体现在以下两个方面: 

> 1.删除过期键对象

Redis采用惰性删除和定时任务删除机制实现过期键的内存回收。

* 惰性删除:惰性删除用于当客户端读取带有超时属性的键时，如果已经超过键设置的过期时间，会执行删除操作并返回空，这种策略是出于节省 CPU成本考虑，不需要单独维护TTL链表来处理过期键的删除。但是单独用这种方式存在内存泄露的问题，当过期键一直没有访问将无法得到及时删 除，从而导致内存不能及时释放。

* 定时任务删除:Redis内部维护一个定时任务，默认每秒运行10次(通过配置hz控制)。定时任务中删除过期键逻辑采用了自适应算法，根据键的过期比例、使用快慢两种速率模式回收键。

<img src="https://img-blog.csdnimg.cn/1252db66e16f4118802b663b55c7d52a.png" style="zoom:25%;" />

**流程说明:**

1.定时任务在每个数据库空间随机检查20个键，当发现过期时删除对应的键。

2.如果超过检查数25%的键过期，循环执行回收逻辑直到不足25%或运行超时为止，慢模式下超时时间为25毫秒。

3.如果之前回收键逻辑超时，则在Redis触发内部事件之前再次以快模式运行回收过期键任务，快模式下超时时间为1毫秒且2秒内只能运行1次。

4.快慢两种模式内部删除逻辑相同，只是执行的超时时间不同。

## 内存淘汰策略

当Redis所用内存达到maxmemory上限时会触发相应的溢出控制策略。

具体策略受maxmemory-policy参数控制，如下所示:

1. noeviction:默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息。
2. volatile-lru:根据LRU算法删除设置了超时属性(expire)的键，直 到腾出足够空间为止。如果没有可删除的键对象，回退到noeviction策略。
3. allkeys-lru:根据LRU算法删除键，不管数据有没有设置超时属性， 直到腾出足够空间为止。
4. allkeys-random:随机删除所有键，直到腾出足够空间为止。
5. volatile-random:随机删除过期键，直到腾出足够空间为止。
6. volatile-ttl:根据键值对象的ttl属性，删除最近将要过期数据。如果没有，回退到noeviction策略。
7. allkeys-lfu策略，使用LFU算法在所有数据中进行筛选。

建议线上Redis内存工作在`maxmemory>used_memory`状态下，避免频繁内存回收开销。

对于需要收缩Redis内存的场景，可以通过调小maxmemory来实现快速 回收。

比如对一个实际占用6GB内存的进程设置maxmemory=4GB，之后第一 次执行命令时，如果使用非noeviction策略，它会一次性回收到maxmemory指定的内存量，从而达到快速回收内存的目的。

注意，此操作会导致数据丢失和短暂的阻塞问题，一般在缓存场景下使用。

**在Redis中，LRU算法被做了简化，以减轻数据淘汰对缓存性能的影响。**

具体来说，Redis默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构RedisObject中的lru字段记录）。

然后，Redis在决定淘汰的数据时，第一次会随机选出N个数据，把它们作为一个候选集合。

接下来，Redis会比较这N个数据的lru字段，把lru字段值最小的数据从缓存中淘汰出去。

Redis提供了一个配置参数maxmemory-samples，这个参数就是Redis选出的数据个数N。

例如，我们执行如下命令，可以让Redis选出100个数据作为候选数据集：

```plain
CONFIG SET maxmemory-samples 100
```

当需要再次淘汰数据时，Redis需要挑选数据进入第一次淘汰时创建的候选集合。

这儿的挑选标准是：**能进入候选集合的数据的lru字段值必须小于候选集合中最小的lru值**。

当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了maxmemory-samples，Redis就把候选数据集中lru字段值最小的数据淘汰出去。

这样一来，Redis缓存不用为所有的数据维护一个大链表，也不用在每次数据访问时都移动链表项，提升了缓存的性能。

**LFU缓存策略的优化**

LFU缓存策略是在LRU策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。

当使用LFU策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。

如果两个数据的访问次数相同，LFU策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。

和那些被频繁访问的数据相比，扫描式单次查询的数据因为不会被再次访问，所以它们的访问次数不会再增加。

因此，LFU策略会优先把这些访问次数低的数据淘汰出缓存。这样一来，LFU策略就可以避免这些数据对**缓存造成污染**了。

**Redis在实现LFU策略的时候，只是把原来24bit大小的lru字段，又进一步拆分成了两部分**。

1. ldt值：lru字段的前16bit，表示数据的访问时间戳；

1. counter值：lru字段的后8bit，表示数据的访问次数。

> 总结一下：当LFU策略筛选数据时，Redis会在候选集合中，根据数据lru字段的后8bit选择访问次数最少的数据进行淘汰。

当访问次数相同时，再根据lru字段的前16bit值大小，选择访问时间最久远的数据进行淘汰。

**三个使用建议：**

- **优先使用allkeys-lru策略**。这样，可以充分利用LRU这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用allkeys-lru策略。

- 如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用allkeys-random策略，随机选择淘汰的数据就行。

- **如果你的业务中有置顶的需求**，比如置顶新闻、置顶视频，那么，可以使用volatile-lru策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据LRU规则进行筛选。

## 内存优化

Redis存储的所有值对象在内部定义为redisObject结构体

<img src="https://img-blog.csdnimg.cn/9cfbb18109b74dfda1c0e41b26ac45c0.png" style="zoom:25%;" />

Redis存储的数据都使用redisObject来封装，包括string、hash、list、 set、zset在内的所有数据类型。

* type字段:表示当前对象使用的数据类型，可以使用type{key}命令查看对象所属类 型，type命令返回的是值对象类型，键都是string类型。

* encoding字段:表示Redis内部编码类型，encoding在Redis内部使用， 代表当前对象内部采用哪种数据结构实现。

* lru字段:记录对象最后一次被访问的时间，当配置了maxmemory和 maxmemory-policy=volatile-lru或者allkeys-lru时，用于辅助LRU算法删除键数据。可以使用object idletime{key}命令在不更新lru字段情况下查看当前键的空闲时间。

可以使用scan+object idletime命令批量查询哪些键长时间未被访问，找出长时间不访问的键进行清理，可降低内存占用。

* refcount字段:记录当前对象被引用的次数，用于通过引用次数回收内 存，当refcount=0时，可以安全回收当前对象空间。使用object refcount{key} 获取当前对象引用。当对象为整数且范围在[0-9999]时，Redis可以使用共享 对象的方式来节省内存。

* `*ptr`字段:与对象的数据内容相关，如果是整数，直接存储数据;否则 表示指向数据的指针。Redis在3.0之后对值对象是字符串且长度<=39字节的 数据，内部编码为embstr类型，字符串sds和redisObject一起分配，从而只要 一次内存操作即可。

高并发写入场景中，在条件允许的情况下，建议字符串长度控制在39字节以内，减少创建redisObject内存分配次数，从而提高性能。

**缩减键值对象** 

降低Redis内存使用最直接的方式就是缩减键(key)和值(value)的长度。

**共享对象池**

共享对象池是指Redis内部维护[0-9999]的整数对象池。

创建大量的整数类型redisObject存在内存开销，每个redisObject内部结构至少占16字节，甚至超过了整数自身空间消耗。

所以Redis内存维护一个[0-9999]的整数对象 池，用于节约内存。除了整数值对象，其他类型如list、hash、set、zset内部元素也可以使用整数对象池。

因此开发中在满足需求的前提下，尽量使用整数对象以节省内存。

整数对象池在Redis中通过变量REDIS_SHARED_INTEGERS定义，不能通过配置修改。

可以通过object refcount命令查看对象引用数验证是否启用整数对象池技术
