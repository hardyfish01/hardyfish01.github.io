---
title: AOF持久化
categories: 
- Redis设计与实现
---

AOF持久化是通过保存Redis服务器所执行的写命令来记录数据库状态。

* 服务器启动时，可通过载入和执行AOF文件中保存的命令来还原服务器关闭前的数据库状态。

**AOF持久化的实现**

AOF持久化可分为命令追加，文件写入，文件同步三个步骤。

**命令追加**

开启AOF持久化后，服务器执行完一个写命令后，会以协议格式将被执行的写命令**追加**到服务器状态的**aof_buf缓冲区末尾**

**AOF文件的写入与同步**

Redis服务器进程就是一个**事件循环**，负责接收客户端命令请求及命令回复。

服务器每结束一个时间循环前，都会调用`flushAppendOnlyFile`函数，考虑是否有必要**将aof缓冲区中的内容写入和保存至AOF文件**里。

这个判断的依据就是根据配置文件的appendfsync值决定：

- always：将aof_buf缓冲区的所有内容**写入并同步**到AOF文件。
- everysec：将aof_buf缓冲区中的所有内容写入到AOF文件，如果上次同步AOF文件的时间**超过一秒**，就再次对AOF文件进行同步，并由一个线程专门负责。
- no：将aof_buf缓冲区中的所有内容写入到AOF文件，但并**不对AOF文件进行同步**，何时同步**由操作系统决定**。

**为什么有写入和同步的区分？**

为提高写效率，操作系统一般将写入数据**暂时保存在内存缓冲区**，等缓冲区**填满或超过**指定时间后才会真正地将**数据同步到磁盘里**。

操作系统提供了fsync和fdatasync两同步函数，可**强制操作系统同步数据**，保证数据安全性。

也就是说，每一次的事件循环，aof_buf中的指令**都会被写入操作系统的缓冲区**，根据appendfsync配置，当操作系统缓冲区满足一定条件后，就被**真实地写入**磁盘内。

**AOF文件的载入与数据还原**

步骤如下：

1. 创建一个没有网络连接的伪客户端。由于Redis命令只能在客户端上下文中执行，并且AOF文件在本地而不是网络。
2. 解析AOF文件并取出一条写命令。
3. 使用伪客户端执行被读出的写命令
4. 持续执行2和3，直到所有写命令都已经执行完毕

<img src="https://img-blog.csdnimg.cn/a02f7fa1a9534a5498113073884d4f23.png" style="zoom:25%;" />

**AOF创建和重写时对过期键的处理套路**

如果数据库中的某个键已经过期且没有被删除，AOF文件不会因为这个对过期键产生影响。

* 当过期间被惰性删除或定期删除后，AOF文件**追加一条DEL命令**来显式删除。

AOF重写时，程序会对数据库的键检查，已过期的**不会保存**到AOF文件中。

**AOF重写**

因为AOF持久化会将所有的写命令都记录，所以会有冗余情况，比如频繁地创建删除键值对，或者对同一个键的值频繁更新，都会导致文件的内容越来越多。

Redis提供AOF文件重写功能，让服务器创建一个新的AOF文件，替代现有的AOF文件，减少冗余命令。

**AOF文件重写的实现**

在新的AOF文件的重写过程中，不会读取旧AOF文件，而是通过**读取数据库状态**来实现的。

首先从数据库中读取键现在的值，然后用一条命令记录键值对，代替之前记录的多条命令。

* 注：在重写时会先检查键所包含的元素数量，因为多元素的键在命令转换时可能会导致客户端输入缓冲区溢出。

因此读取配置中对应的常量，默认超过64个就用多条指令记录。

**AOF后台重写过程**

AOF重写的过程中会有大量的写入操作，为了避免Redis服务器长时间的阻塞，重写工作将被放到**子进程中进行**。

这样的好处是：

- 父进程仍然可继续处理请求。
- 子进程有自己的数据副本，而非子线程，可以避免一些线程安全性问题的出现。

子进程在执行AOF重写期间，服务器进程还需要继续处理命令请求，而新的命令可能会对现有的数据库状态进行修改，导致**当前数据库状态与重写后的AOF文件保存状态不一致**。

为解决这个问题，设置了**AOF重写缓冲区**。

当重写子进程创建后，Redis服务器执行完写命令就会将其写入AOF缓冲区和AOF重写缓冲区，子进程执行重写期间，服务器进程要执行3个工作：

1. 执行客户端发来的命令。
2. 将执行后的写命令追加到AOF缓冲区。
3. 将执行后的写命令追加到AOF重写缓冲区。

<img src="https://img-blog.csdnimg.cn/99d46283b6474807994574d0a72377cb.png" style="zoom:25%;" />

当子进程完成重写后，会向父进程**发送一个信号**，父进程接收并调用信号处理函数，将重写缓冲区的所有内容写到新AOF文件中，原子地覆盖现有的AOF文件。

因此整个AOF文件重写的过程中，只有**信号处理函数执行时，才会阻塞**，将性能损耗降到最低。