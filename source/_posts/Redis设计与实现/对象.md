---
title: 对象
categories: 
- Redis设计与实现
---

Redis 的用到的主要的数据结构有：简单字符串(SDS)、链表、字典、压缩列表、整数集合等等。

> Redis 的对象都是由这些数据结构所实现。

Redis 为了可以对不同的对象在不同的使用场景下选择更加合适的数据结构实现，Redis 基于这些数据结构创建了一个对象系统，而这个对象系统包含了：字符串对象、列表对象、哈希对象、集合对象和有序集合对象这五种类型的对象。

**对象的类型和编码**

Redis使用对象来表示数据库中的键和值，每次当我们在 `Redis` 的数据库中新创建一个键值对时，我们至少会创建**两个对象**，一个对象用作键值对的键，另一个对象用作键值对的值。

```c
typedef struct redisObject {
    // 类型
    unsigned type:4;
    
    // 编码
    unsigned encoding:4;
    
    // 指向底层实现数据结构的指针
    void *ptr;
}
```

`Redis` 中的每个对象都由 `redisObject` 结构表示，该结构中和保存数据有关的三个属性分别是 `type`、`encoding` 和 `ptr`。

**对象类型**

对象的 `type` 属性记录了对象的类型

| 类型常量     | 对象的名称   |
| ------------ | ------------ |
| REDIS_STRING | 字符串对象   |
| REDIS_LIST   | 列表对象     |
| REDIS_HASH   | 哈希对象     |
| REDIS_SET    | 集合对象     |
| REDIS_ZSET   | 有序集合对象 |

可以通过使用 `TYPE` 命令来查询某个键值对的值的对象类型。

**对象编码**

`REDIS_STRING` 等对象类型由不同的编码组成，其根据存储的内容不同而使用不同的编码，而这些编码的信息则存储于 `encoding` 中。

* `ptr` 指针则是用于指向对象的底层由 `encoding` 决定的数据结构。

可以通过 `OBJECT ENCODING key` 命令来查看键值对的值所对应的编码。

**字符串对象**

字符串对象的编码可以是：int、raw 或者 embstr。

* 如果一个字符串对象保存的是整数值，那么字符串对象的编码设置为 int。

* 如果字符串对象保存的是一个字符串长度小于等于 `44` 字节的字符串时，那么字符串对象将使用 `embstr` 编码的方式来保存这个字符串值。
* 如果字符串对象保存的是一个字符串，并且这个字符串值的长度大于 `44` 字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为 `raw`。

**哈希对象**

哈希对象的编码：

- ziplist
- hashtable

> 以 ziplist 为编码的哈希对象

ziplist 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时，程序会先将保存了键的压缩列表节点推入到压缩列表表尾，然后再将保存了值的压缩列表节点推入到压缩列表表尾。

> 以 hashtable 为编码的哈希对象

`hashtable` 编码的哈希对象使用字典作为底层实现，哈希对象中的每个键值对都使用一个字典键值对来保存：

- 字典的每个键都是一个字符串对象，对象保存了键值对的键；
- 字典的每个值都是一个字符串对象，对象保存了键值对的值；

> 编码转换

当哈希对象可以同时满足以下两个条件时，哈希对象使用 `ziplist` 编码：

- 哈希对象保存的所有键值对的键和值的字符串长度都小于 `64` 字节；
- 哈希对象保存的键值对数量小于 `512` 个；

> 不能满足这两个条件的哈希对象，会使用 `hashtable` 编码。

**集合对象**

集合对象的编码：

- intset
- hashtable

> 以 intset 为编码的集合对象

`intset` 编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。

> 以 hashtable 为编码的集合对象

`hashtable` 编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为 `NULL`。

> 编码转换

当集合对象可以同时满足以下两个条件时，对象使用 `intset` 编码，否则使用 `hashtable` 编码：

- 集合对象保存的所有元素都是整数值；
- 集合对象保存的元素数量不超过 `512` 个。

**有序集合对象**

有序集合的编码：

* ziplist

* skiplist

> 以 ziplist 为编码的有序集合对象

ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用那个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员(member)，第二个元素保存元素的分值(score)。

压缩列表内的集合元素从小到大进行排序，分值较小的元素被放置在靠近表头的位置，而分值较大的元素则被放置在靠近表尾的位置。

> 以 skiplist 为编码的有序集合对象

`skiplist` 编码的有序集合对象使用 `zset` 结构作为底层实现，一个 `zset` 结构同时包含了一个字典和一个跳跃表

zset 结构中的 跳跃表按分值从小到大保存了所有集合元素，每个跳跃表节点都保存了一个集合元素：

* 跳跃表节点的 object 属性保存了元素的成员；

* 跳跃表节点的 score 属性保存了元素的分值。

通过这个跳跃表，程序可以对有序集合进行范围型操作，比如 ZRANK、ZRANGE 等命令。

除此之外，zset 结构中的 dict 字典为有序集合创建了一个从成员到分值的映射，字典中的每个键值对都保存了一个集合元素：

* 字典的键保存了元素的成员；

* 字典的值保存了元素的分值。

通过这个字典，程序可以用 O(1) 复杂度查找给定成员的分值，ZSCORE 命令就是根据这一特性实现的。

**为什么有序集合要同时使用跳跃表和字典来实现？**

> 只使用字典

虽然可以以 O(1) 复杂度查找成员的分值，但是因为字典是以无序的方式来保存元素的，所以每次在执行范围型操作时（比如：ZRANGE、ZRANK 等命令），程序都需要对字典保存的所有元素进行排序，完成这种排序至少需要 `O(NlogN)` 时间复杂度，以及额外的 O(N) 内存空间用于保存排序后的元素；

> 只使用跳跃表

跳跃表执行范围型操作的所有优点都会被保留，但因为没有字典，所以根据成员查找分值这一操作的复杂度即将从 O(1) 上升为O(logN)。

所以，为了让有序集合的查找和范围型操作都尽可能快地执行，Redis 选择了同时使用字典和跳跃表两种数据结构来实现有序集合。

> 编码转换

当有序集合对象可以同时满足以下两个条件时，对象使用 `ziplist` 编码

- 有序集合保存的元素数量小于 `128` 个；
- 有序集合保存的所有元素成员的长度都小于 `64` 字节。

> 不能满足以上两个条件的有序集合对象将使用 `skiplist` 编码

**列表对象**

在 Redis 3.2 之前，列表对象的编码可以是 ziplist 或者 linkedlist。

后来的 Redis 对列表数据结构进行了改造，使用 quicklist 代替了 ziplist 和 linkedlist。

**对象类型检查**

为了确保只有指定类型的键可以执行某些特定的命令，在执行一个类型特定的命令之前，Redis 会先检查输入键的类型是否正确，然后再决定是否执行给定的命令。

类型特定命令所进行的类型检查是通过 redisObject 结构的 type 属性来实现的：

* 在执行一个类型特定命令之前，服务器会先检查输入数据键的值对象是否为执行命令所需的类型，如果是的话，服务器就对键执行指定的命令；

* 否则，服务器将拒绝执行命令，并向客户端返回一个类型错误。

**多态命令**

Redis 除了会根据值对象的类型来判断键是否能够执行指定命令之外，还会根据值对象的编码方式选择正确的命令实现代码来执行命令。

实际上，我们可以将 DEL、EXPIRE、TYPE 等命令也称为多态命令，因为无论输入的键是什么类型，这些命令都可以正确地执行。

DEL、EXPIRE、TYPE 等命令和 SET、GET、APPEND、STRLEN 等命令的区别在于，前者是基于类型的多态，后者是基于编码的多态。

**内存回收**

因为 C 语言并不具备自动内存回收功能，所以 Redis 在自己的对象系统中构建了一个引用计数来实现的内存回收机制，通过这一机制，程序可以通过跟踪对象的引用计数信息，在适当的时候自动释放对象并进行内存回收。

每个对象的引用计数信息由 redisObject 结构的 refcount 属性记录：

```c
typedef struct redisObject {
    // 引用计数
    int refcount;
} robj;
```

对象的引用计数信息回随着对象的使用状态而不断变化：

* 在创建一个新对象时，引用计数的值会被初始化为：1；

* 当对象被一个新程序使用时，它的引用计数值会被：+1；

* 当对象不再被一个程序使用时，它的引用计数值会被：-1；

* 当对象的引用计数值变为 0 时，对象所占用的内存会被释放。

对象的整个生命周期可以划分为：创建对象、操作对象、释放对象三个阶段。

**对象共享**

目前来说，`Redis` 会在初始化服务器时，创建一万个字符串对象，这些对象包含了从 `0` 到 `9999` 的所有整数值，当服务器需要用到这个区间的整数值字符串对象时，服务器就会使用这些共享对象，而不是新创建对象。

尽管共享更复杂的对象可以节约更多的内存，但受到 `CPU` 时间的限制，`Redis` 只对包含整数值的字符串对象进行共享。

**对象的空转时长**

`redisObject` 结构包含的最后一个属性为 `lru` 属性，该属性记录了**对象最后一次被命令程序访问的时间**

通过使用 `OBJECT IDLETIME` 命令可以打印出给定键的空转时长，空转时长是通过将当前时间减去键的值对象的 `lru` 时间计算得出的。

除了可以被 OBJECT IDLETIME 命令打印出来之外，键的空转时长还有另外一项作用：

* 如果服务器打开了 maxmemory 选项，并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时，空转时长较高的那部分键会被优先被服务器释放，从而回收内存。