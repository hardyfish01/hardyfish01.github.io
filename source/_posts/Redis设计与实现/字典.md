---
title: 字典
categories: 
- Redis设计与实现
---

字典用于保存键值对的抽象数据结构。

当一个哈希键包含的键值对比较多时，或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现。

**字典的实现**

Redis的字典使用**哈希表**作为底层实现，一个哈希表里面可以有**多个哈希表节点**，每个哈希表节点保存了字典中的**一个键值对**。

**哈希表**

使用`dict.h/dictht`结构定义：

```c
typedef struct dictht{
    //哈希表数组
    dictEntry **table;
    //哈希表大小
    unsigned long size;
    //哈希表大小掩码，用于计算索引值
    //总是等于size-1
    unsigned long sizemask;
    //该哈希表已有节点的数量
    unsigned long used;
}dictht;
```

数组中的每个元素都是指向`dict.h/dictht`的结构，dictEntry就是一个键值对。

**哈希表节点**

哈希表节点使用dictEntry实现，每个dictEntry都存储着一个键值对：

```c
typedef struct dictEntry{
    //键
    void *key;
    //值
    union{
        void *val;
        uint64_t u64;
        int64_t s64;
    } v;
    //指向下个哈希表节点，形成链表
    struct dictEntry *next;
} dictEntry;
```

键值对的值可以是一个指针，或一个`uint64_t`整数，或一个`int64_t`整数。

next是**指向另一个哈希节点的指针**，可将多个**哈希值相同的键值对连接在一起**，以此来解决冲突。

<img src="https://img-blog.csdnimg.cn/0d1019e12c8d4237ac7bf08101fc896c.png" style="zoom:25%;" />

如图，表示的是两个哈希值相同的节点，通过指针连接在一起。

**字典**

Redis中的字典由`dict.h/dict`实现，由这个数据结构将字典组织在一起。

```c
typedef struct dict{
    //类型特定函数
    dictType *type;
    //私有数据
    void *privdata;
    //哈希表
    dictht ht[2];
    //rehash索引
    //当rehash不在进行时，值为-1
    int rehashidx;
} dict;
```

type和privdata属性是**针对不同类型**的键值对，为丰富键值对的使用场景而设置的。

- type属性是一个指向dictType的结构指针，每个dictType结构保存了用于**操作特定类型键值对的函数**，Redis为用途不同的字典设置不同类型特定函数。

**哈希算法**

当字典被用作数据库的底层实现或哈希键的底层实现时，Redis使用**MurmurHash2算法**来计算键的哈希值。

优点在于即使输入的键是有规律的，算法仍然能给出**很好的随机分布性**，并且计算**速度飞快**。

**解决键冲突**

当有两个或以上的键被分配到哈希表的**同个索引**，那么就发生了冲突。

Redis使用链地址法来解决冲突，被分配到索引的多个节点**使用链表连接**。

为了提高速度，每次都是将新节点添加到链表的**表头**位置。

**rehash**

为了让哈希表的负载因子维持在一个**合理的范围内**，当哈希表保存的键值对数量太多或者太少时，程序需要对哈希表的大小进行响应的扩容或缩容。扩容和缩容通过执行rehash来完成，Redis中**重新散列的步骤**如下：

1. 为字典ht[1]哈希表**分配空间**，大小取决于要执行的操作与ht[0]**当前键值对的数量**。
2. 将保存在ht[0]中的所有键值对存放到ht[1]指定的位置
3. 当ht[0]的所有键值对都迁移完毕后，**释放ht[0]**，并**指向**ht[1]，并在ht[1]上创建一个空的哈希表，为下次rehash准备。

**扩容与缩容场景**

扩容操作场景：

- 服务器目前没有在执行`BGSAVE`命令或`BGREWRITEAOF`命令，并且哈希表的**负载因子>=1**。
- 服务器正在执行`BGSAVE`命令或`BGREWRITEAOF`命令，并且哈希表的**负载因子>=5**。

负载因子=哈希表已存储节点数/哈希表大小

* `load_factor=ht[0].used/ht[0].size`

为什么根据`BGSAVE`**命令或**`BGREWRITEAOF`命令来判断是否扩展？

> 因为执行这些命令时，Redis需要创建当前服务器进程的**子进程**，大多数操作系统采用**写时复制技术**来优化子进程使用效率，此时提高负载因子，可以尽量避免子进程对哈希表扩展，避免不必要的内存写入操作，节约内存。

缩容操作场景：**负载因子<0.1**时，**自动**对哈希表执行收缩操作。

**渐进式rehash的过程**

rehash时会将ht[0]中所有的键值对rehash到ht[1]，如果键值对很多并且一次性操作的话，容易导致服务器在**一段时间内停止服务**。

为避免这种情况，Redis采用渐进式rehash，将ht[0]中的键值对分多次，**慢慢的rehash**到ht[1]之中。

**步骤：**

1. 为ht[1]分配空间，让字典同时持有两个哈希表。
2. 在字典中维持一个**索引计数器变量rehashidx**，将其设置为0，表示rehash正式开始。
3. 在rehash进行期间，每次对字典进行**添加，删除，查找或更新**操作时，程序除了执行指定的操作外，还会将ht[0]哈希表在rehashidx索引上的所有键值对 **rehash到ht[1]** ，当rehash工作完成后，将rehashidx++。
4. 某个时刻，ht[0]中的所有键值对都被rehash至ht[1]，此时设置`rehashidx=-1`时，表示rehash操作已经完成。

这种方式的rehash的好处在于采用了分而治之的方式，将rehash键值对所需的**计算工作均摊到对字典的每个操作中**，从而避免集中式rehash带来庞大计算量。

在rehash的期间，字典**同时使用**ht[0]，ht[1]两个哈希表。

对哈希表的操作会在两个表上进行，比如查找键时，**先在ht[0]里面查找**，如果为空，就**继续到ht[1]里查找**。

在此期间，新增的键值对**都会被添加到ht[1]**中，ht[0]**不承担任何添加**操作，保证ht[0]中的键值对只能是**越来越少**。

**字典时间复杂度**

字典相关操作及时间复杂度：

![](https://img-blog.csdnimg.cn/3c8d23a94dd74c5691cd1c77b595c7d8.png)