---
title: 类和接口
categories: 
- Effective Java
---

**使类和成员的可访问性最小化**

尽可能地使每个类或者成员不被外界访问。

Java中可以通过**包**、**访问修饰符**（private protected public）控制类、接口和成员的`可访问性（accessibility）` 

除了应该暴露的API之外，我们应该尽可能少的开放访问权。 因为一旦暴露给外界，可能会有风险，另外还需要保证一直维护与兼容。

可以想象一下，当我们使用一个第三方库的时候，如果它暴露了一个不该暴露的类（假设为BitmapUtil），而我们恰好用了它里面的方法，结果它一升级，把方法改了，或者把方法去掉了，那我们不是懵了？

所以**不要去暴露那些不该暴露的类、接口、成员** 

> 作者在最后给了小结：

应该始终尽可能地降低可访问性。应该防止把任何散乱的类、接口和成员变成API的一部分。除了公有静态final域的特殊情形之外，共有类都不应该包含公有域。并且要确保公有静态final域所引用的对象都不是可变的。

**在公有类中使用访问方法而非公有域**

```java
public class Point{
   public double x;
   public double y;
}
```

作者的意思是不应该直接暴露`x y`，要为它们提供`getter`、`setter`方法，这样有利于添加约束条件，辅助行为。

**使可变性最小化**

> 不可变类：实例不能被修改的类。**每个实例中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变**。如：String、基本类型的包装类、BigInteger和BigDecimal。

不可变类的五条规则：

1. 不要提供任何会修改对象状态的方法。
2. 保证类不会被扩展。 一般用final修饰
3. 使所有的域都是final的。
4. 使所有的域都成为私有的。（降低访问权限）

**不可变类的优缺点**

> 线程安全

不要求同步，无惧多线程并发访问

> 不可变对象可以被自由地共享

所以不需要保护性拷贝（如String类的拷贝构造器） 也可以重复利用，如:`Boolean.FALSE/TRUE`

> 唯一的缺点：对于每个不同的值都需要一个单独的对象

如FALSE TRUE ，不过如果值少，到也没什么关系，但是如String这样的不可变类，我们需要注意，多用StringBuilder（可变，性能好）

> 小结

除非有很好的理由要让类成为可变的类，否则就应该是不可变的。 

如果类不能被做成是不可变的，仍然应该尽可能地限制它的可变性。（降低出错的可能性）

**复合优先于继承**

**要么为继承而设计，并提供文档说明，要么就禁止继承**

**接口优于抽象类**

Java提供两种机制用来定义允许多个实现的类型：`接口`和`抽象类`。

> 区别

接口和抽象类的区别有很多，其中 **最为明显** 的区别是： **抽象类可以包含某些方法的实现，而接口不允许，即接口都是抽象方法** 

> 接口的优势

- 现有的类可以很容易被更新，以实现新的接口，当需要增加方法的时候只需要`implements`具体的接口即可，非常方便，而如果通过抽象类来实现，则需要在抽象类里新增方法，而这会导致其他继承该抽象类的类也被强制加上额外的方法！

我的理解是:**一个类，利用实现多个接口可以达到混合类型的目的，而利用抽象类只能继承一个类，则不能达到混合类型的效果！** 

**类层次优于标签类**

**标签类**， 我的理解是一个类，拥有多个风格，通过一个属性来区分不同的风格，类里充斥着`if else`或者`switch case` 

举个例子：

```java
class Person{
   boolean isMan;
   String sayHi(){
       if (isMan) {
           return "Yo hi man!~";
       }else{
           return "Hello";
       }
   }
}
```

Person类，通过`isMan`属性来区分是男的还是女的，`sayHi()`方法针对男女有不同的表现，这个就是一个非常简单的标签类。

标签类的缺点非常明显，当你要表现的风格非常多样的时候，你需要写大量的判断语句，非常容易出错，而且当你需要修改某一个风格的时候，你需要在一大堆代码里找出你要改的地方，很有可能引入bug，非常难以维护。

这个时候，将标签类转变成类层次就非常方便了：

```java
abstract class Person{
   abstract String sayHi();
}
class Man extends Person{
   @Override
   String sayHi() {
       return "Yo hi man!~";
   }
}
class Woman extends Person{
   @Override
   String sayHi() {
       return "Hello";
   }
}
```

抽象出一个`Person`类，定义`Man`和`Woman`类继承它，根据自己的需求实现`sayHi()`方法，当需要修改`Man`的行为时，你不需要也不用担心会破坏`Woman`的代码，代码可读性，可维护性一下子高了很多！

**优先考虑静态成员类**