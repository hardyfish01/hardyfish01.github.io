---
title: 服务端启动
categories: 
- Netty权威指南
- 源码解读
---

```java
public final class EchoServer {

    static final boolean SSL = System.getProperty("ssl") != null;
    static final int PORT = Integer.parseInt(System.getProperty("port", "8007"));

    public static void main(String[] args) throws Exception {
        final SslContext sslCtx;
        if (SSL) {
            SelfSignedCertificate ssc = new SelfSignedCertificate();
            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();
        } else {
            sslCtx = null;
        }

        // 事件循环组1, 先当做线程池看待即可, 线程数量为1
        EventLoopGroup bossGroup = new NioEventLoopGroup(1);
        // 事件循环组2, 线程数量默认, 默认是CPU逻辑处理器的数目
        EventLoopGroup workerGroup = new NioEventLoopGroup();
        final EchoServerHandler serverHandler = new EchoServerHandler();
        try {
            // 服务端启动配置工具类
            ServerBootstrap b = new ServerBootstrap();
            // 事件循环组
            b.group(bossGroup, workerGroup)
             // 使用基于NIO的ServerSocketChannel
             .channel(NioServerSocketChannel.class)
             .option(ChannelOption.SO_BACKLOG, 100)
             // ServerSocketChannel 处理器, 这里是一个日志处理器
             .handler(new LoggingHandler(LogLevel.INFO))
             // 通过在initChannel上面创建一连串的处理器添加到pipeline管道上,以后netty会根据读写状态,顺序执行pipeline的处理器(读状态就顺序执行实现读接口的处理器,写状态同理)
             .childHandler(new ChannelInitializer<SocketChannel>() {
                 @Override
                 public void initChannel(SocketChannel ch) throws Exception {
                     ChannelPipeline p = ch.pipeline();
                     // SocketChannel 处理器, 这里是一个日志处理器
                     if (sslCtx != null) {
                         p.addLast(sslCtx.newHandler(ch.alloc()));
                     }
                     p.addLast(serverHandler);
                 }
             });

            // 绑定端口,这个是一个非阻塞操作,必须通过ChannelFuture来确定结果
            // 通过sync(), 阻塞等待绑定结果
            ChannelFuture f = b.bind(PORT).sync();

            // 因为我们这里是通过主函数跑的,如果绑定成功以后不执行其他阻塞操作,程序就运行结束了
            // 可以调用 ServerSocketChannel.closeFuture(),该方法时用来确认ServerSocketChannel是否关闭的
            // 因为本程序不存在关闭ServerSocketChannel的操作,也就确保了主线程会一直阻塞下去,应为closeFuture()也是非阻塞的
            // 所以还得通过 sync() 阻塞等待, 确保了主线程会一直阻塞下去
            // 真实项目中往往不需要加这几句,因为对于服务端应用来讲,总会存在线程是未执行完的并且不是守护线程,不然就没法一直启动着了,而且如果我们阻塞着,还会浪费一个线程
            f.channel().closeFuture().sync();
        } finally {
            // 关闭事件循环组,里面有线程池得关闭掉,也会同时断开所有SocketChannel
            bossGroup.shutdownGracefully();
            workerGroup.shutdownGracefully();
        }
    }
}
```

channel()：

```java
public B channel(Class<? extends C> channelClass) {
        // 工厂方法设计模式获取NioServerSocketChannel对象
        return channelFactory(new ReflectiveChannelFactory<C>(
                ObjectUtil.checkNotNull(channelClass, "channelClass")
        ));
    }
```

doBind()：

```java
private ChannelFuture doBind(final SocketAddress localAddress) {
        // 完成实例化NioServerSocketChannel, 并且注册NioServerSocketChannel到Selector上
        final ChannelFuture regFuture = initAndRegister();
        final Channel channel = regFuture.channel();
        if (regFuture.cause() != null) {
            return regFuture;
        }

        if (regFuture.isDone()) {
            // 在这里,我们已经知道NioServerSocketChannel注册成功了
            ChannelPromise promise = channel.newPromise();
            // 提供一个触发机制 bind(),提供开发者使用
            doBind0(regFuture, channel, localAddress, promise);
            return promise;
        } else {
            final PendingRegistrationPromise promise = new PendingRegistrationPromise(channel);
            regFuture.addListener(new ChannelFutureListener() {
                @Override
                public void operationComplete(ChannelFuture future) throws Exception {
                    Throwable cause = future.cause();
                    if (cause != null) {
                        promise.setFailure(cause);
                    } else {
                        promise.registered();

                        doBind0(regFuture, channel, localAddress, promise);
                    }
                }
            });
            return promise;
        }
    }
```

initAndRegister()：

```java
final ChannelFuture initAndRegister() {
        Channel channel = null;
        try {
            // 创建 ServerSocketChannel 对象, 这里创建的同时,也会完成端口的绑定
            channel = channelFactory.newChannel();
            // 初始化ServerSocketChannel,这个方法由最终子类完成
            init(channel);
        } catch (Throwable t) {
            if (channel != null) {
                channel.unsafe().closeForcibly();
                return new DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE).setFailure(t);
            }
            return new DefaultChannelPromise(new FailedChannel(), GlobalEventExecutor.INSTANCE).setFailure(t);
        }

        // 这里不仅仅说是把ServerSocketChannel到Selector上
        // 还把事件循环组里面的一个事件循环绑定到了channel里面
        // 同时为该事件循环启动了一个线程
        ChannelFuture regFuture = config().group().register(channel);
        if (regFuture.cause() != null) {
            if (channel.isRegistered()) {
                channel.close();
            } else {
                channel.unsafe().closeForcibly();
            }
        }

        return regFuture;
    }
```

