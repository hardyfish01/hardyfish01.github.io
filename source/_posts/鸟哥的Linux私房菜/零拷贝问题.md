---
title: 零拷贝问题
categories: 
- 鸟哥的Linux私房菜
---

硬盘上的数据，在发往网络之前，需要经过多次缓冲区的拷贝，以及用户空间和内核空间的多次切换。

* 如果能减少一些拷贝的过程，效率就能提升，所以零拷贝应运而生。

**没有采取零拷贝手段如何实现文件传输？**

服务器提供文件传输功能，需要将磁盘上的文件读取出来，通过网络协议发送到客户端。

> 如果需要你自己编码实现这个文件传输功能，你会怎么实现呢？

通常最直接的方法：

* 从网络请求中找出文件在磁盘中的路径后，如果这个文件比较大，假设有320MB，可以在内存中分配32KB的缓冲区，再把文件分成一万份，每份只有32KB，这样，从文件的起始位置读入32KB到缓冲区，再通过网络API把这32KB发送到客户端。接着重复一万次，直到把完整的文件都发送完毕。

如下图所示：

<img src="https://img-blog.csdnimg.cn/d806fd311c0c431d85e3ca9e547e044e.png" style="zoom:25%;" />

应用进程的一次完整的读写操作，都需要在用户空间与内核空间中来回拷贝，并且每一次拷贝，都需要CPU进行一次上下文切换（由用户进程切换到系统内核，或由系统内核切换到用户进程）

**零拷贝如何提升文件传输性能？**

> 为什么读取磁盘文件时，一定要做上下文切换呢？

* 这是因为，读取磁盘或者操作网卡都由操作系统内核完成。

* 内核负责管理系统上的所有进程，它的权限最高，工作环境与用户进程完全不同。

* 只要我们的代码执行read或者write这样的系统调用，一定会发生2次上下文切换：首先从用户态切换到内核态，当内核执行完任务后，再切换回用户态交由进程代码执行。

* 因此，如果想减少上下文切换次数，就一定要减少系统调用的次数。解决方案就是把read、write两次系统调用合并成一次，在内核中完成磁盘与网卡的数据交换。

> 我们应该考虑如何减少内存拷贝次数。

* 每周期中的4次内存拷贝，其中与物理设备相关的2次拷贝是必不可少的，包括：把磁盘内容拷贝到内存，以及把内存拷贝到网卡。

* 但另外2次与用户缓冲区相关的拷贝动作都不是必需的，因为在把磁盘文件发到网络的场景中，**用户缓冲区没有必须存在的理由**。

* 如果内核在读取文件后，直接把PageCache中的内容拷贝到Socket缓冲区，待到网卡发送完毕后，再通知进程，这样就只有2次上下文切换，和3次内存拷贝。

<img src="https://img-blog.csdnimg.cn/7a4cba5f47614586a06e51c8f6ab48a4.png" style="zoom:25%;" />

如果网卡支持SG-DMA（The Scatter-Gather Direct Memory Access）技术，还可以再去除Socket缓冲区的拷贝，这样一共只有2次内存拷贝。

<img src="https://img-blog.csdnimg.cn/2e3658bf13234f6fb28680831d3e6525.png" style="zoom:25%;" />

**PageCache，磁盘高速缓存**

上面几张图，你会发现，读取文件时，是先把磁盘文件拷贝到PageCache上，再拷贝到进程中。

> 为什么这样做呢？有两个原因所致。

* 第一，由于磁盘比内存的速度慢许多，所以我们应该想办法把读写磁盘替换成读写内存，比如把磁盘中的数据复制到内存中，就可以用读内存替换读磁盘。但是，内存空间远比磁盘要小，内存中注定只能复制一小部分磁盘中的数据。

> 选择哪些数据复制到内存呢？

通常，刚被访问的数据在短时间内再次被访问的概率很高（**时间局部性原理**），用PageCache缓存最近访问的数据，当空间不足时淘汰最久未被访问的缓存（即LRU算法）。

读磁盘时优先到PageCache中找一找，如果数据存在便直接返回，这便大大提升了读磁盘的性能。

> 第二，读取磁盘数据时，需要先找到数据所在的位置，对于机械磁盘来说，就是旋转磁头到数据所在的扇区，再开始顺序读取数据。其中，旋转磁头耗时很长，为了降低它的影响，PageCache使用了**预读功能**。

* 也就是说，虽然read方法只读取了0-32KB的字节，但内核会把其后的32-64KB也读取到PageCache，这后32KB读取的成本很低。

* 如果在32-64KB淘汰出PageCache前，进程读取到它了，收益就非常大。

PageCache在90%以上场景下都会提升磁盘性能，**但在某些情况下，PageCache会不起作用，甚至由于多做了一次内存拷贝，造成性能的降低。**在这些场景中，使用了PageCache的零拷贝也会损失性能。

> 在高并发场景下，为了防止PageCache被大文件占满后不再对小文件产生作用，**大文件不应使用PageCache，进而也不应使用零拷贝技术处理。**

**异步IO + 直接IO**

高并发场景处理大文件时，应当使用异步IO和直接IO来替换零拷贝技术。

> 异步IO（异步IO既可以处理网络IO，也可以处理磁盘IO）可以解决阻塞问题。

* 它把读操作分为两部分，前半部分向内核发起读请求，但**不等待数据就位就立刻返回**，此时进程可以并发地处理其他任务。

* 当内核将磁盘中的数据拷贝到进程缓冲区后，进程将接收到内核的通知，再去处理数据，这是异步IO的后半部分。

如下图所示：

<img src="https://img-blog.csdnimg.cn/51ddaea1cdaf48e69b7a3d2cceab268d.png" style="zoom:25%;" />