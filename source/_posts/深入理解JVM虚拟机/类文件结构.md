---
title: 类文件结构
categories: 
- 深入理解JVM虚拟机
---

**Class类文件的结构**

Class文件是一组以8个字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。

当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。

根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型

无符号数和表：

* 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。

* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以`_info`结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表

无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的 容量计数器加若干个连续的数据项的形式，这时候称这一系列连续的某一类型的数据为某一类型的集合。

**魔数与Class文件的版本**

每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。

紧接着魔数的4个字节存储的是Class文件的版本号

第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。

Java的版本号是从45开始的，JDK 1.1之后 的每个JDK大版本发布主版本号向上加1(JDK 1.0~1.1使用了45.0~45.3的版本号)，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，因为《Java虚拟机规范》在Class文件校验部分明确要求了即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class 文件。

<img src="https://img-blog.csdnimg.cn/87774694985d48b3af9db493965107ea.png" style="zoom:25%;" />

# 常量池

紧接着主、次版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class 文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。

常量池中主要存放两大类常量:

* 字面量(Literal)和符号引用(Symbolic References)。

字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。

而符号引用则属于编译原理方面的概念，主要包括下面几类常量：

* 类和接口的全限定名(Fully Qualified Name)

* 字段的名称和描述符(Descriptor)

* 方法的名称和描述符

Java代码在进行Javac编译的时候，并不像C和C++那样有连接这一步骤，而是在虚拟机加载Class 文件的时候进行动态连接。

也就是说，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。

当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。

# 访问标志

在常量池结束之后，紧接着的2个字节代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括:这个Class是类还是接口

是否定义为public类型;是否定义为abstract 类型;如果是类的话，是否被声明为final;等等。

**类索引、父类索引与接口索引集合**

类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。

由于Java语言不允许多 重继承，所以父类索引只有一个，除了`java.lang.Object`之外，所有的Java类都有父类，因此除了 `java.lang.Object`外，所有Java类的父类索引都不为0。

接口索引集合就用来描述这个类实现了哪些接 口，这些被实现的接口将按implements关键字(如果这个Class文件表示的是一个接口，则应当是 extends 关 键 字 ) 后 的 接 口 顺 序 从 左 到 右 排 列 在 接 口 索 引 集 合 中 。

**字段表集合**

字段表用于描述接口或者类中声明的变量。

Java语言中的字段(Field)包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。

**方法表集合**

Class文件存储格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志(access_flags)、名称索引(name_index)、描述符索引(descrip tor_index)、属性表集合(attributes)几项。

**属性表集合** 

Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。

与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松一 些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任 何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识 的属性。

# 字节码指令

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字(称为操作码，Opcode) 以及跟随其后的零至多个代表此操作所需的参数(称为操作数，Operand)构成。

由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构，所 以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。

字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，由于限制了Java虚 拟机操作码的长度为一个字节(即0~255)，这意味着指令集的操作码总数不能够超过256条

**字节码与数据类型**

在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。

举个例子，iload指 令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。

这两 条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。

# 运行时栈帧结构

 Java虚拟机以方法作为最基本的执行单元，栈帧(Stack Frame)则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈的栈元素。

每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。 

在编译Java程序源码的时候，栈帧中需要多大的局部变量表，需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。

换言之，一个栈帧需要分配多少内存，并不会受到程序运行期变量数据的影响，而仅仅取决于程序源码和具体的虚拟机实现的栈内存布局形式。

一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。

而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为当前栈帧(Current Stack Frame)，与这个栈帧所关联的方法被称为当前方法(Current Method)。

执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作

**局部变量表**

局部变量表(Local Variables Table)是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。

在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量。

局部变量表的容量以变量槽(Variable Slot)为最小单位，《Java虚拟机规范》中并没有明确指出 一个变量槽应占用的内存空间大小，只是很有导向性地说到每个变量槽都应该能存放一个boolean、 byte、char、short、int、float、reference或returnAddress类型的数据，这8种数据类型，都可以使用32位或更小的物理内存来存储

<img src="https://img-blog.csdnimg.cn/6110e923319b481c83d2a7e955c7396c.png" style="zoom:25%;" />