---
title: 经典架构
categories: 
- 实现领域驱动设计
---

# 六边形架构

一种具有对称性特征的架构风格。

该架构中存在两个区域，分别是外部和内部区域，外部区域中不同的客户都可以提交输入；

内部系统用于获取持久化数据，并对程序输出进行存储(数据库)、转发(消息机制)。

每种类型的客户都有它自己的适配器，用于将客户输入转化为程序内部API所能理解的输入。

> 六边形每条不同的边代表了不同种类型的端口，端口要么处理输入，要么处理输出。

如下图中有3个客户请求均抵达相同的输入端口(适配器A\B\C)，另一个客户请求了适配器D。

可能前三个请求使用了HTTP协议，后一个用了AMQP协议。

端口是一个非常灵活的概念，当客户请求到达时，都有相应的适配器对输入进行转化，然后端口将调用应用程序的某个操作或者向应用程序发送一个事件，控制权由此交给内部区域。

<img src="https://img-blog.csdnimg.cn/5fe8fe84a5f14ae0a58a19ef6cc42f4c.png" style="zoom:50%;" />

在下图的六边形架构中，红圈内的核心业务逻辑（应用程序和领域模型）与外部资源（包括APP、Web应用以及数据库资源等）完全隔离，仅通过适配器进行交互。

它解决了业务逻辑与用户界面的代码交错问题，很好地实现了前后端分离。

六边形架构各层的依赖关系与整洁架构一样，都是由外向内依赖。

<img src="https://img-blog.csdnimg.cn/cd4f78b841b840c1a14426373eb53367.png" style="zoom:50%;" />

六边形架构将系统分为内六边形和外六边形两层，这两层的职能划分如下：

* 红圈内的六边形实现应用的核心业务逻辑；

* 外六边形完成外部应用、驱动和基础资源等的交互和访问，对前端应用以API主动适配的方式提供服务，对基础资源以依赖倒置被动适配的方式实现资源访问。

六边形架构的一个端口可能对应多个外部系统，不同的外部系统也可能会使用不同的适配器，由适配器负责协议转换。

这就使得应用程序能够以一致的方式被用户、程序、自动化测试和批处理脚本使用。

# 面向服务架构SOA

SOA、REST 和六边形架构的结合：

<img src="https://img-blog.csdnimg.cn/023064099a914834b77c7f46fe2eee24.png" style="zoom:50%;" />

# REST架构

REST：表现层状态转移，一种软件架构风格，不是标准，可用可不用

通过URL定位资源，HTTP描述操作。

如下：

```
##表示顾客22的订单11号
https://www.alipay.com/customers/22/orders/11

##表示新增一个顾客
POST https://www.alipay.com/customers
```

RESTful是指基于REST构建的API就是RESTful风格

# CQRS

**命令和查询职责分离(CQRS)**

CQRS架构是当下领域驱动设计比较流行的一种分层模式，核心思想在于将查询与更新分离，查询提供一套单独的从持久层到接口层的服务。对领域对象的更新操作通过Command事件驱动，领域层与持久层完全分离，持久层处理更新消息。

这种设计的优点在于查询与更新分离，持久层不必承载繁重的查询功能，可以交给专门做查询的服务实现，同时用事件驱动领域实体状态更新，事件可以追溯可以回放便于发现查找修复问题，缺点在于要设计复杂的消息格式消息总线，而且这种代码对于新人挑战比较大，代码跟踪到领域层就断了，不利于代码可读性。

**CQRS的规则：**

* 如果一个方法修改了对象的状态，该方法便是一个命令(Command)，它不应该返回数据。

* 如果一个方法返回了数据，该方法便是一个查询，它不应该通过直接/间接的手段修改对象状态。

这样的话，领域模型将一分为二，由命令模型和查询模型分开进行存储：

<img src="https://img-blog.csdnimg.cn/a861b12b0a544c36842e4311de123733.png" style="zoom:50%;" />

数据库分为只读，和读写。并根据不同的需求划分方法的业务编写，大量查询可以用数据库连接池。

根据不同的业务情况去处理查询模型(读)和命令模型(写)

# 整洁架构

在整洁架构里，同心圆代表应用软件的不同部分，从里到外依次是领域模型、领域服务、应用服务和最外围的容易变化的内容，比如用户界面和基础设施。

整洁架构最主要的原则是依赖原则，它定义了各层的依赖关系，越往里依赖越低，代码级别越高，越是核心能力。

外圆代码依赖只能指向内圆，内圆不需要知道外圆的任何情况。

<img src="https://img-blog.csdnimg.cn/a5f4dd5670ad4478b989b1e50095bd5d.png" style="zoom:25%;" />

# 微服务架构

**项目级微服务**

项目级微服务的内部遵循分层架构模型就可以了。

领域模型的核心逻辑在领域层实现，服务的组合和编排在应用层实现，通过API网关为前台应用提供服务，实现前后端分离。

但项目级的微服务可能会调用其它微服务，你看在下面这张图中，比如某个项目级微服务B调用认证微服务A，完成登录和权限认证。

通常项目级微服务之间的集成，发生在微服务的应用层，由应用服务调用其它微服务发布在API网关上的应用服务。

你看下图中微服务B中红色框内的应用服务B，它除了可以组合和编排自己的领域服务外，还可以组合和编排外部微服务的应用服务。

它只要将编排后的服务发布到API网关供前端调用，这样前端就可以直接访问自己的微服务了。

<img src="https://img-blog.csdnimg.cn/7f229aae216a40a5a3483fe809a51a53.png" style="zoom:30%;" />

**企业级中台微服务**

企业级中台微服务的集成不能像项目级微服务一样，在某一个微服务内完成跨微服务的服务组合和编排。

我们可以在中台微服务之上增加一层，你看下面这张图，增加的这一层就位于红色框内，它的主要职能就是处理跨中台微服务的服务组合和编排，以及微服务之间的协调，它还可以完成前端不同渠道应用的适配。

如果再将它的业务范围扩大一些，我可以将它做成一个面向不同行业和渠道的服务平台。

> 借用BFF（服务于前端的后端，Backend for Frontends）这个词，暂且称它为BFF微服务。

BFF微服务与其它微服务存在较大的差异，就是它没有领域模型，因此这个微服务内也不会有领域层。

BFF微服务可以承担应用层和用户接口层的主要职能，完成各个中台微服务的服务组合和编排，可以适配不同前端和渠道的要求。

<img src="https://img-blog.csdnimg.cn/ed0978de56584f338e83c316649e8620.png" style="zoom:25%;" />