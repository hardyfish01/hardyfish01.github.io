---
title: 仓库和工厂
categories: 
- 实现领域驱动设计
---

采用了领域驱动设计以后，通常就会实现一个仓库（Repository） 去通过装载和查询完成对数据库的访问。

> 装载与查询：

所谓的 **装载（Load）**，就是通过主键 ID 去查询某条记录。

* 比如，要装载一个订单，就是通过订单 ID 去查询该订单。

> 与 DAO 不同的是：

订单仓库在查询订单时，只是简单地查询订单表，不会去 Join 其他表，比如 Join 用户表，不会做这些事情；

* 当查询到该订单以后，将其封装在订单对象中，然后再去通过查询补填用户对象、订单明细对象；

* 通过补填以后，就会得到一个用户对象、多个订单明细对象，需要将它们装配到订单对象中。

那些创建、装配的工作都交给了另外一个组件——工厂来完成。

**工厂**

DDD 中的工厂，主要的工作是通过装配，创建领域对象，是领域对象生命周期的起点。

譬如，系统要通过 ID 装载一个订单：

* 这时订单仓库会将这个任务交给订单工厂，订单工厂就会分别调用订单 DAO、订单明细 DAO 和用户 DAO 去进行查询；

* 然后将得到的订单对象、订单明细对象、用户对象进行装配，即将订单明细对象与用户对象，分别 set 到订单对象的订单明细与用户属性中；

* 最后，订单工厂将装配好的订单对象返回给订单仓库。

这些就是 DDD 中工厂要做的事情。

**仓库**

当订单工厂将订单对象返回给订单仓库以后，订单仓库不是简单地将该对象返回给客户程序，它还有一个缓存的功能。

* 系统创建的所有领域对象都放在仓库中，当需要这些对象时，通过 ID 到仓库中去获取。

数据库是仓库进行数据持久化的一种内部实现，它也可以有另外一种内部实现，就是将最近反复使用的领域对象放入缓存中。

* 这样，当客户程序通过 ID 去获取某个领域对象时，仓库会通过这个 ID 先到缓存中进行查找：

* 查找到了，则直接返回，不需要查询数据库；

* 没有找到，则通知工厂，工厂调用 DAO 去数据库中查询，然后装配成领域对象返回给仓库。

* 仓库在收到这个领域对象以后，在返回给客户程序的同时，将该对象放到缓存中。

以上是通过 ID 装载订单的过程，那么通过某些条件查询订单的过程又是怎么做呢？查询订单的操作同样是交给订单仓库去完成。

* 订单仓库会先通过订单 DAO 去查询订单表，但这里是只查询订单表，不做 Join 操作；

* 订单 DAO 查询了订单表以后，会进行一个分页，将某一页的数据返回给订单仓库；

* 这时，订单仓库就会将查询结果交给订单工厂，让它去补填其对应的用户与订单明细，完成相应的装配，最终将装配好的订单对象集合返回给仓库。

**仓库与工厂的设计**

传统的 DDD 设计，每个模块都有自己的仓库与工厂，工厂是领域对象创建与装配的地方，是生命周期的开始。

创建出来后放到仓库的缓存中，供上层应用访问。当领域对象在经过一系列操作以后，最后通过仓库完成数据的持久化。

这个领域对象数据持久化的过程，对于普通领域对象来说就是存入某个单表，然而对于有聚合关系的领域对象来说，需要存入多个表中，并将其放到同一事务中。

> 在这个过程中，聚合关系会出现跨库的事务操作吗？

即具有聚合关系的多个领域对象会被拆分为多个微服务吗？

不可能的，因为聚合就是一种强相关的封装，是不可能因微服务而拆分的。

如果出现了，要么不是聚合关系，要么就是微服务设计出现了问题。因此，仓库是不可能完成跨库的事务处理的。