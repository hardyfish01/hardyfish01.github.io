---
title: 领域模型
categories: 
- 实现领域驱动设计
---

# 贫血模型

在软件设计中，有很多的 POJO对象，它们除了有一堆 get/set 方法，几乎没有任何业务逻辑。

这样的设计被称为**贫血模型**。

```java
// 贫血模型下的实现
public class User{

private Integer id; 
  private String name; ... // 省略get/set方法

}

public class UserManager{
  public void save(User user){
  // 持久化操作.... 
  }
}

//充血模型
// 保存用户的操作可能是这样
userManager.save(user);
// 充血模型下的实现
public class User{
  private Integer id;
  private String name;
  ...
  // 省略get/set方法

  public void save(){ // 持久化操作.... }

}

// 保存用户的操作可能是这样
user.save();
```

# 充血模型

**两种设计思路的优劣比较**

> 贫血模型比充血模型更加简单易行

充血模型是将领域模型的原貌直接映射成了程序设计，因此在程序设计时需要增加更多的诸如仓库、工厂的组件，对设计能力与架构提出了更高的要求。

> 譬如，现在要设计一个订单系统，在领域建模时，每个订单需要有多个订单明细，还要对应相关的客户信息、商品信息。

因此，在装载一个订单时，需要同时查出它的订单明细，以及对应的客户信息、商品信息，这些需要有强大的订单工厂进行装配；

装载订单以后，还需要放到仓库中进行缓存，需要订单仓库具备缓存的能力；此外，在保存订单的时候，还需要同时保存订单和订单明细，并将它们放到一个事务中。所有这些都需要强有力的技术平台的支持。

<img src="https://img-blog.csdnimg.cn/685c1f8e4a6d4396a1f06dd6de97d7b7.png" style="zoom:25%;" />

相反，贫血模型就显得更加贫民化。在贫血模型中，MVC 层直接调用 Service，Service 通过DAO进行数据访问。

* 在这个过程中，每个 DAO 都只查询数据库中的某个表，然后直接交给 Service 去使用，去完成各种处理。

* 以订单系统为例，订单有订单 DAO，负责查询订单；订单明细有订单明细 DAO，负责查询订单明细。它们查询出来以后，不需要装配，而是直接交给订单 Service 使用。在保存订单时，订单 DAO 负责保存订单，订单明细 DAO 负责保存订单明细。

它们都是通过订单 Service 进行组织，并建立事务。贫血模型不需要仓库，不需要工厂，也不需要缓存，一切都显得那么简单粗暴但一目了然。

<img src="https://img-blog.csdnimg.cn/398b43b784ef4bd3a72ba104b6add878.png?" style="zoom:25%;" />

> 充血模型需要具备更强的设计与协作能力

比如，在该场景中，当订单在进行创建时，需要对用户以及用户地址的相关信息进行查询。

* 此时，订单 Service 不能直接去查询用户和用户地址的相关表，而是去调用用户 Service 的相关接口，由用户 Service 去完成对用户相关表的查询。这时候，开发订单模块的团队，需要向开发用户模块的团队提出接口需求。

* 与充血模型相比，贫血模型就比较简单与直接。所有业务处理过程都交给 Service 去完成。

在业务处理过程中，需要哪些表的数据，就去调用相应的 DAO：需要订单就找订单 DAO；需要用户就找用户 DAO；需要商品就找商品 DAO。程序简单就易于理解，日后维护起来也比较容易。

> 贫血模型更容易应对复杂的业务处理场景

充血模型在进行设计时，是将所有的业务处理过程在领域对象的相应方法中实现的。

这样的设计，如果业务处理过程比较简单，还可以从容应对；但如果是面对非常复杂的业务处理场景时，就有一些力不从心。

* 在这些复杂的业务处理场景中，如果采用贫血模型，可以将复杂的业务处理场景，划分成多个相对独立的步骤；

* 然后将这些独立的步骤分配给多个 Service 串联起来执行。

这样，各个步骤就是以一种松耦合的形式串联地组织在一起，以领域对象作为参数在各个Service 中进行传递。

关键是要先弄清楚它们的差别，也就是业务逻辑应当在哪里实现：

> 贫血模型的业务逻辑在 Service 中实现，但充血模型是在**领域对象**中实现。

**哪些业务逻辑需要封装起来按照充血模型设计呢？**

* 如果在领域模型中出现了类似继承、多态的情况，则应当将继承与多态的部分以充血模型的形式在领域对象中实现。
* 如果在软件设计的过程中需要将一些类型或者编码进行转换，则将转换的部分封装在领域对象中。
* 希望在软件设计中能更好地表现领域对象之间的关系。比如，在查询订单的时候想要显示每个订单对应的用户，以及每个订单包含的订单明细。这时，除了要将领域模型中的关系体现在领域对象的设计外，还需要有仓库与工厂的支持。
* 最后一种情况被称为聚合，也就是在真实世界中那些代表整体与部分的事物。比如，在订单中有订单和订单明细，一个订单对应多个订单明细。从业务关系来说，它们是整体与部分的关系，订单明细是订单的一个部分，没有了这张订单，它的订单明细就没有任何意义了。