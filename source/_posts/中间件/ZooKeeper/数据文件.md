---
title: 数据文件
categories: 
- 中间件
- ZooKeeper
---

从存储位置上来说，事务日志和数据快照一样，都存储在本地磁盘上；而从业务角度来讲，内存数据就是我们创建数据节点、添加监控等请求时直接操作的数据。

* 事务日志数据主要用于记录本地事务性会话操作，用于 ZooKeeper 集群服务器之间的数据同步。

* 事务快照则是将内存数据持久化到本地磁盘。

> 这里要注意的一点是，数据快照是每间隔一段时间才把内存数据存储到本地磁盘，因此数据并不会一直与内存数据保持一致。

在单台 ZooKeeper 服务器运行过程中因为异常而关闭时，可能会出现数据丢失等情况。

**内存数据**

ZooKeeper 的数据模型可以看作一棵树形结构，而数据节点就是这棵树上的叶子节点。

从数据存储的角度看，ZooKeeper 的数据模型是存储在内存中的。

我们可以把 ZooKeeper 的数据模型看作是存储在内存中的数据库，而这个数据库不但存储数据的节点信息，还存储每个数据节点的 ACL 权限信息以及 stat 状态信息等。

* 而在底层实现中，ZooKeeper 数据模型是通过 DataTree 类来定义的。

DataTree 类定义了一个 ZooKeeper 数据的内存结构。

DataTree 的内部定义类 nodes 节点类型、root 根节点信息、子节点的 WatchManager 监控信息等数据模型中的相关信息。

可以说，一个 DataTree 类定义了 ZooKeeper 内存数据的逻辑结构。

**事务日志**

为了整个 ZooKeeper 集群中数据的一致性，Leader 服务器会向 ZooKeeper 集群中的其他角色服务发送数据同步信息，在接收到数据同步信息后， ZooKeeper 集群中的 Follow 和 Observer 服务器就会进行数据同步。

> 而这两种角色服务器所接收到的信息就是 Leader 服务器的事务日志。

在接收到事务日志后，并在本地服务器上执行。这种数据同步的方式，避免了直接使用实际的业务数据，减少了网络传输的开销，提升了整个 ZooKeeper 集群的执行性能。

在我们启动一个 ZooKeeper 服务器之前，首先要创建一个 `zoo.cfg`文件并进行相关配置，其中有一项配置就是 dataLogDir 。

* 在这项配置中，我们会指定该台 ZooKeeper 服务器事务日志的存放位置。

在 ZooKeeper 服务的底层实现中，是通过 FileTxnLog 类来实现事务日志的底层操作的。

在 FileTxnLog 类中定义了一些属性字段，分别是：

- preAllocSize：可存储的日志文件大小。如用户不进行特殊设置，默认的大小为`65536*1024`字节。
- TXNLOG_MAGIC：设置日志文件的魔数信息为ZKLG。
- VERSION：设置日志文件的版本信息。
- lastZxidSeen：最后一次更新日志得到的 ZXID。

定义了事务日志操作的相关指标参数后，在 FileTxnLog 类中调用 static 静态代码块，来将这些配置参数进行初始化。

* 比如读取 preAllocSize 参数分配给日志文件的空间大小等操作。

经过参数定义和日志文件的初始化创建后，在 ZooKeeper 服务器的 dataDir 路径下就生成了一个用于存储事务性操作的日志文件。

> 我们知道在 ZooKeeper 服务运行过程中，会不断地接收和处理来自客户端的事务性会话请求，这就要求每次在处理事务性请求的时候，都要记录这些信息到事务日志中。

在 FileTxnLog 类中，实现记录事务操作的核心方法是 append。

从方法的命名中可以看出，ZooKeeper 采用末尾追加的方式来维护新的事务日志数据到日志文件中。

append 方法首先会解析事务请求的头信息，并根据解析出来的 zxid 字段作为事务日志的文件名，之后设置日志的文件头信息 magic、version、dbid 以及日志文件的大小。

在 datadir 配置参数路径下存放着 ZooKeeper 服务器所有的事务日志，所有事务日志的命名方法都是`log.+ 该条事务会话的 zxid`。

**数据快照**

一个快照可以看作是当前系统或软件服务运行状态和数据的副本。

* 在 ZooKeeper 中，数据快照的作用是将内存数据结构存储到本地磁盘中。

因此，从设计的角度说，数据快照与内存数据的逻辑结构一样，都使用 DataTree 结构。

在 ZooKeeper 服务运行的过程中，数据快照每间隔一段时间，就会把 ZooKeeper 内存中的数据存储到磁盘中，快照文件是间隔一段时间后对内存数据的备份。

因此，与内存数据相比，快照文件的数据具有滞后性。而与上面介绍的事务日志文件一样，在创建数据快照文件时，也是使用 zxid 作为文件名称。

* ZooKeeper 通过 FileTxnSnapLog 类来实现数据快照的相关功能。

在FileTxnSnapLog 类的内部，最核心的方法是 save 方法，在 save 方法的内部，首先会创建数据快照文件，之后调用 FileSnap 类对内存数据进行序列化，并写入到快照文件中。

**底层实现**

**搜集日志**

ZooKeeper 是如何搜集程序的运行信息的。在统计操作情况的日志信息中，ZooKeeper 通过第三方开源日志服务框架 SLF4J 来实现的。

> SLF4J 是一个采用门面设计模式（Facade） 的日志框架。

门面模式也叫作外观模式，采用这种设计模式的主要作用是，对外隐藏系统内部的复杂性，并向外部调用的客户端或程序提供统一的接口。门面模式通常以接口的方式实现，可以被程序中的方法引用。

在 ZooKeeper 中使用 SLF4J 日志框架，首先在类中通过工厂函数创建日志工具类 LOG，然后在需要搜集的操作流程处引入日志搜集函数`LOG.info`即可。

```java
protected static final Logger LOG = LoggerFactory.getLogger(Learner.class);
LOG.info("Revalidating client: 0x" + Long.toHexString(clientId));
LOG.warn("Couldn't find the leader with id = "
        + current.getId());
```

**存储日志**

系统日志的存放位置，在 `zoo.cfg`文件中。假设我们的日志路径为`dataDir=/var/lib/zookeeper`，打开系统命令行，进入到该文件夹，所有系统日志文件都放在了该文件夹下。

**快照文件**

快照日志文件主要用来存储 ZooKeeper 服务中的事务性操作日志，并通过数据快照文件实现集群之间服务器的数据同步功能。

**快照创建**

在 ZooKeeper 的源码中定义了一个 SnapShot 接口类，在该接口中描述了 ZooKeeper 服务的相关属性和方法。

* 其中 serialize 函数是用来将内存中的快照文件转存到本地磁盘中时的序列化操作。

* deserialize 的作用正好与其相反，是把快照文件从本地磁盘中加载到内存中时的反序列化操作。

无论是序列化还是反序列化，整个快照所操作的数据对象是 ZooKeeper 数据模型，也就是由 Znode 组成的结构树。

**快照存储**

其实在整个 ZooKeeper 中，随着服务的不同阶段变化，数据快照存放文件的位置也随之变化。

存储位置的变化，主要是内存和本地磁盘之间的转变。当 ZooKeeper 集群处理来自客户端的事务性的会话请求的时候，会首先在服务器内存中针对本次会话生成数据快照。

当整个集群可以执行该条事务会话请求后，提交该请求操作，就会将数据快照持久化到本地磁盘中。

存储到本地磁盘中的数据快照文件，是经过 ZooKeeper 序列化后的二进制格式文件，通常我们无法直接查看，但如果想要查看，也可以通过 ZooKeeper 自带的 SnapshotFormatter 类来实现。

在 SnapshotFormatter 类的内部用来查看快照文件的几种函数分别是： printDetails 函数，用来打印日志中的数据节点和 Session 会话信息；printZnodeDetails 函数，用来查看日志文件中节点的详细信息，包括节点 id 编码、state 状态信息、version 节点版本信息等。

虽然 ZooKeeper 提供了 SnapshotFormatter 类，但其实现的查询功能比较单一，按照自己的业务需求，编写自己的快照文件查看器。

无论是数据日志文件，还是数据快照文件，最终都会存储在本地磁盘中。而从文件的生成方式来看，两种日志文件的不同是：数据日志文件实施性更高，相对的产生的日志文件也不断变化，只要 ZooKeeper 服务一直运行，就会产生新的操作日志数据；而数据快照并非实时产生，它是当集群中数据发生变化后，先在内存中生成数据快照文件，经过序列化后再存储到本地磁盘中。