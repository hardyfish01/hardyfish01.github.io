---
title: 垃圾回收
categories: 
- JVM相关
---

**引用计数法与可达性分析**

如何辨别一个对象是存是亡？

> 引用计数法。

它的做法是为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。一旦某个对象的引用计数器为 0，则说明该对象已经死亡，便可以被回收了。

> 它的具体实现是这样子的：

如果有一个引用，被赋值为某一对象，那么将该对象的引用计数器 +1。如果一个指向某一对象的引用，被赋值为其他值，那么将该对象的引用计数器 -1。也就是说，我们需要截获所有的引用更新操作，并且相应地增减目标对象的引用计数器。

除了需要额外的空间来存储计数器，以及繁琐的更新操作，引用计数法还有一个重大的漏洞，那便是无法处理循环引用对象。

举个例子，假设对象 a 与 b 相互引用，除此之外没有其他引用指向 a 或者 b。在这种情况下，a 和 b 实际上已经死了，但由于它们的引用计数器皆不为 0，在引用计数法的心中，这两个对象还活着。因此，这些循环引用对象所占据的空间将不可回收，从而造成了内存泄露。

<img src="https://img-blog.csdnimg.cn/58759d0bd03846a2a3df2169622a7286.png" style="zoom:50%;" />

目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。

这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集，然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，这个过程我们也称之为标记。最终，未被探索到的对象便是死亡的，是可以回收的。

**什么是 GC Roots ？**

一般而言，GC Roots 包括（但不限于）如下几种：

* Java 方法栈桢中的局部变量；

* 已加载类的静态变量；

* JNI handles；

* 已启动且未停止的 Java 线程。

虽然可达性分析的算法本身很简明，但是在实践中还是有不少其他问题需要解决的。

比如说，在多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而造成误报（将引用设置为 null）或者漏报（将引用设置为未被访问过的对象）。

误报并没有什么伤害，Java 虚拟机至多损失了部分垃圾回收的机会。漏报则比较麻烦，因为垃圾回收器可能回收事实上仍被引用的对象内存。一旦从原引用访问已经被回收了的对象，则很有可能会直接导致 Java 虚拟机崩溃。

**安全点**

Java 虚拟机中的 Stop-the-world 是通过安全点 机制来实现的。

当 Java 虚拟机收到 Stop-the-world 请求，它便会等待所有的线程都到达安全点，才允许请求 Stop-the-world 的线程进行独占的工作。

> 安全点的初始目的并不是让其他线程停下，而是找到一个稳定的执行状态。
>
> 在这个执行状态下，Java 虚拟机的堆栈不会发生变化。这么一来，垃圾回收器便能够“安全”地执行可达性分析。

举个例子，当 Java 程序通过 JNI 执行本地代码时，如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。

只要不离开这个安全点，Java 虚拟机便能够在垃圾回收的同时，继续运行这段本地代码。

由于本地代码需要通过 JNI 的 API 来完成上述三个操作，因此 Java 虚拟机仅需在 API 的入口处进行**安全点检测**，测试是否有其他线程请求停留在安全点里，便可以在必要的时候挂起当前线程。

除了执行 JNI 本地代码外，Java 线程还有其他几种状态：

> 解释执行字节码、执行即时编译器生成的机器码和线程阻塞。

* 阻塞的线程由于处于 Java 虚拟机线程调度器的掌控之下，因此属于安全点。

* 其他几种状态则是运行状态，需要虚拟机保证在可预见的时间内进入安全点。

* 否则，垃圾回收线程可能长期处于等待所有线程进入安全点的状态，从而变相地提高了垃圾回收的暂停时间。

* 对于解释执行来说，字节码与字节码之间皆可作为安全点。

Java 虚拟机采取的做法是，当有安全点请求时，执行一条字节码便进行一次安全点检测。

执行即时编译器生成的机器码则比较复杂。由于这些代码直接运行在底层硬件之上，不受 Java 虚拟机掌控，因此在生成机器码时，即时编译器需要插入安全点检测，以避免机器码长时间没有安全点检测的情况。

HotSpot 虚拟机的做法便是在生成代码的方法出口以及非计数循环的循环回边处插入安全点检测。

**为什么不在每一条机器码或者每一个机器码基本块处插入安全点检测呢？**

* 第一，安全点检测本身也有一定的开销。

* 第二，即时编译器生成的机器码打乱了原本栈桢上的对象分布状况。

由于这些信息需要不少空间来存储，因此即时编译器会尽量避免过多的安全点检测。

> 不过，不同的即时编译器插入安全点检测的位置也可能不同。

除了垃圾回收之外，Java 虚拟机其他一些对**堆栈内容的一致性**有要求的操作也会用到安全点这一机制。