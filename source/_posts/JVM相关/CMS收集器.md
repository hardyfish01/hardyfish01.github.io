---
title: CMS收集器
categories: 
- JVM相关
---

CMS GC 的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：

- 第一，不对老年代进行整理，而是使用空闲列表来管理内存空间的回收。
- 第二，在标记—清除阶段的大部分工作和应用线程一起并发执行。

也就是说，在这些阶段并没有明显的应用线程暂停。但值得注意的是，它仍然和应用线程争抢 CPU 时间。

> 默认情况下，CMS 使用的并发线程数等于 CPU 核心数的 1/4。

在实际情况下，进行老年代的并发回收时，可能会伴随着多次年轻代的 minor GC。

在这种情况下，full GC 的日志中就会掺杂着多次 minor GC 事件。

CMS对年轻代采用并行 STW 方式的 标记—复制 算法，对老年代主要使用并发 标记—清除 算法。

下面是基本过程！

**Initial Mark（初始标记）**

这个阶段伴随着 STW 暂停。

初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象（老年代单独回收）。

<img src="https://img-blog.csdnimg.cn/7b7b6736a5ea45338ae95eb64aa4e4d3.png" style="zoom:25%;" />

**Concurrent Mark（并发标记）**

在此阶段，CMS GC 遍历老年代，标记所有的存活对象，从前一阶段“Initial Mark”找到的根对象开始算起。

“并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段。

请注意，并非所有老年代中存活的对象都在此阶段被标记，因为在标记过程中对象的引用关系还在发生变化。

<img src="https://img-blog.csdnimg.cn/05bbe3fcca294e86b0d6581ffc1865cb.png" style="zoom:25%;" />

在上面的示意图中，“当前处理的对象”的一个引用就被应用线程给断开了，即这个部分的对象关系发生了变化。

**Concurrent Preclean（并发预清理）**

此阶段同样是与应用线程并发执行的，不需要停止应用线程。

因为前一阶段“并发标记”与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中引用关系发生了变化，JVM 会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的“卡片标记（Card Marking）”。

<img src="https://img-blog.csdnimg.cn/3df00411733944eeb8af48e125aee36a.png" style="zoom:25%;" />

在预清理阶段，这些脏对象会被统计出来，它们所引用的对象也会被标记。此阶段完成后，用以标记的 card 也就会被清空。

<img src="https://img-blog.csdnimg.cn/96d1f610d7bc4e9ca5479c4fd6d6a24f.png" style="zoom:25%;" />

**Concurrent Abortable Preclean（可取消的并发预清理）**

此阶段也不停止应用线程。本阶段尝试在 STW 的 Final Remark 阶段 之前尽可能地多做一些工作。

本阶段的具体时间取决于多种因素，因为它循环做同样的事情，直到满足某个退出条件（如迭代次数，有用工作量，消耗的系统时间等等）。

**Final Remark（最终标记）**

最终标记阶段是此次 GC 事件中的第二次（也是最后一次）STW 停顿。

本阶段的目标是完成老年代中所有存活对象的标记. 因为之前的预清理阶段是并发执行的，有可能 GC 线程跟不上应用程序的修改速度。

所以需要一次 STW 暂停来处理各种复杂的情况。

通常 CMS 会尝试在年轻代尽可能空的情况下执行 Final Remark 阶段，以免连续触发多次 STW 事件。

在 5 个标记阶段完成之后，老年代中所有的存活对象都被标记了，然后 GC 将清除所有不使用的对象来回收老年代空间。

**Concurrent Sweep（并发清除）**

此阶段与应用程序并发执行，不需要 STW 停顿。JVM 在此阶段删除不再使用的对象，并回收它们占用的内存空间。

<img src="https://img-blog.csdnimg.cn/94ed361ecc1a4d6390f6d32392ad293c.png" style="zoom:25%;" />

**Concurrent Reset（并发重置）**

此阶段与应用程序并发执行，重置 CMS 算法相关的内部数据，为下一次 GC 循环做准备。

总之，CMS 垃圾收集器在减少停顿时间上做了很多复杂而有用的工作，用于垃圾回收的并发线程执行的同时，并不需要暂停应用线程。

当然，CMS 也有一些缺点，其中最大的问题就是老年代内存碎片问题（因为不压缩），在某些情况下 GC 会造成不可预测的暂停时间，特别是堆内存较大的情况下。