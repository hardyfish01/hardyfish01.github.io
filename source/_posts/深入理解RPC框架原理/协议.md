---
title: 协议
categories: 
- 深入理解RPC框架原理
---

相对于HTTP的用处，RPC更多的是负责应用间的通信，所以性能要求相对更高。

但HTTP协议的数据包大小相对请求数据本身要大很多，又需要加入很多无用的内容，比如换行符号、回车符等；

还有一个更重要的原因是，HTTP协议属于无状态协议，客户端无法对请求和响应进行关联，每次请求都需要重新建立连接，响应完成后再关闭连接。

因此，对于要求高性能的RPC来说，HTTP协议基本很难满足需求，所以RPC会选择设计更紧凑的私有协议。

**怎么设计一个私有RPC协议呢？**

> 要完成RPC通信的时候，在协议里面需要放哪些内容。

首先要想到的就是我们前面说的消息边界了，但RPC每次发请求发的大小都是不固定的，所以我们的协议必须能让接收方正确地读出不定长的内容。

我们可以先固定一个长度（比如4个字节）用来保存整个请求数据大小，这样收到数据的时候，我们先读取固定长度的位置里面的值，值的大小就代表协议体的长度，接着再根据值的大小来读取协议体的数据。

> 但上面这种协议，只实现了正确的断句效果，在RPC里面还行不通。

因为对于服务提供方来说，他是不知道这个协议体里面的二进制数据是通过哪种序列化方式生成的。如果不能知道调用方用的序列化方式，即使服务提供方还原出了正确的语义，也并不能把二进制还原成对象，那服务提供方收到这个数据后也就不能完成调用了。

因此我们需要把序列化方式单独拿出来，类似协议长度一样用固定的长度存放，这些需要固定长度存放的参数我们可以统称为**协议头**，这样整个协议就会拆分成两部分：**协议头和协议体**。

在协议头里面，我们除了会放协议长度、序列化方式，还会放一些像协议标示、消息ID、消息类型这样的参数，而协议体一般只放请求接口方法、请求的业务参数值和一些扩展属性。

这样一个完整的RPC协议大概就出来了，协议头是由一堆固定的长度参数组成，而协议体是根据请求接口和参数构造的，长度属于可变的：

<img src="https://img-blog.csdnimg.cn/d449a93ce3a54495babe08f6f9c9c86a.png" style="zoom:50%;" />

**可扩展的协议**

举个具体例子，假设你设计了一个88Bit的协议头，其中协议长度占用32bit，然后你为了加入新功能，在协议头里面加了2bit，并且放到协议头的最后。

升级后的应用，会用新的协议发出请求，然而没有升级的应用收到的请求后，还是按照88bit读取协议头，新加的2个bit会当作协议体前2个bit数据读出来，但原本的协议体最后2个bit会被丢弃了，这样就会导致协议体的数据是错的。

那要实现读取不定长的协议头里面的内容，在这之前肯定需要一个固定的地方读取长度，所以我们需要一个固定的写入协议头的长度。

整体协议就变成了三部分内容：固定部分、协议头内容、协议体内容，前两部分我们还是可以统称为**协议头**，具体协议如下：

![](https://img-blog.csdnimg.cn/066f403f76044994b678bcd9015a9806.png)