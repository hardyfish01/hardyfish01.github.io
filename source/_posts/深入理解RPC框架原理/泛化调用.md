---
title: 泛化调用
categories: 
- 深入理解RPC框架原理
---

让调用端在没有服务提供方提供接口API的情况下仍然可以发起RPC调用的功能，在RPC框架中也是非常有价值的。

> RPC框架要实现这个功能，我们可以使用泛化调用。

* 在RPC调用的过程中，调用端向服务端发起请求，首先要通过动态代理，动态代理可以帮助我们屏蔽RPC处理流程，真正地让我们发起远程调用就像调用本地一样。

那么在RPC调用的过程中，既然调用端是通过动态代理向服务端发起远程调用的，那么在调用端的程序中就一定要依赖服务提供方提供的接口API，因为调用端是通过这个接口API自动生成动态代理的。

> 那如果没有接口API呢？我们该如何让调用端仍然能够发起RPC调用呢？

所谓的RPC调用，本质上就是调用端向服务端发送一条请求消息，服务端接收并处理，之后向调用端发送一条响应消息，调用端处理完响应消息之后，一次RPC调用就完成了。

所以只要调用端将服务端需要知道的信息，如接口名、业务分组名、方法名以及参数信息等封装成请求消息发送给服务端，服务端就能够解析并处理这条请求消息，这样问题就解决了。

我们可以定义一个统一的接口（GenericService），调用端在创建GenericService代理时指定真正需要调用的接口的接口名以及分组名，而GenericService接口的`$invoke`方法的入参就是方法名以及参数信息。

这样我们传递给服务端所需要的所有信息，包括接口名、业务分组名、方法名以及参数信息等都可以通过调用GenericService代理的`$invoke`方法来传递。

具体的接口定义如下：

```java
class GenericService {

  Object $invoke(String methodName, String[] paramTypes, Object[] params);
  
}
```

这个通过统一的GenericService接口类生成的动态代理，来实现在没有接口的情况下进行RPC调用的功能，我们就称之为泛化调用。

RPC框架可以通过异步的方式提升吞吐量，还有如何实现全异步的RPC框架，其关键点就是RPC框架对CompletableFuture的支持，那么我们的泛化调用是否也可以支持异步呢？

> 当然可以！

我们可以给GenericService接口再添加一个异步方法`$asyncInvoke`，方法的返回值就是CompletableFuture，GenericService接口的具体定义如下：

```java
class GenericService {

  Object $invoke(String methodName, String[] paramTypes, Object[] params);

  CompletableFuture $asyncInvoke(String methodName, String[] paramTypes, Object[] params);

}
```

**有这样几个问题？**

在没有服务提供方提供接口API的情况下，我们可以用泛化调用的方式实现RPC调用，但是如果没有服务提供方提供接口API，我们就没法得到入参以及返回值的Class类，也就不能对入参对象进行正常的序列化。

> 这时我们会面临两个问题：

**问题1：**

调用端不能对入参对象进行正常的序列化，那调用端、服务端在接收到请求消息后，入参对象又该如何序列化与反序列化呢？

我们通过插件体系来提高RPC框架的可扩展性，在RPC框架的整体架构中就包括了序列化插件，我们可以为泛化调用提供专属的序列化插件，通过这个插件，解决泛化调用中的序列化与反序列化问题。

**问题2：**

调用端的入参对象与返回值应该是什么类型呢？

在服务提供方提供的接口API中，被调用的方法的入参类型是一个对象，那么使用泛化调用功能的调用端，可以使用Map类型的对象，之后通过泛化调用专属的序列化方式对这个Map对象进行序列化，服务端收到消息后，再通过泛化调用专属的序列化方式将其反序列成对象。