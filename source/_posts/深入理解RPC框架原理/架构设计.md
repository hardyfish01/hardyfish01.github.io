---
title: 架构设计
categories: 
- 深入理解RPC框架原理
---

<img src="https://img-blog.csdnimg.cn/475fee87950047fba23077941003fd7e.png" style="zoom:25%;" />

**协议模块**

RPC本质上就是一个远程调用，那肯定就需要通过网络来传输数据。

虽然传输协议可以有多种选择，但考虑到可靠性的话，我们一般默认采用TCP协议。

用户请求的时候是基于方法调用，方法出入参数都是对象数据，对象是肯定没法直接在网络中传输的，我们需要提前把它转成可传输的二进制，这就是我们说的序列化过程。

但只是把方法调用参数的二进制数据传输到服务提供方是不够的，我们需要在方法调用参数的二进制数据后面增加断句符号来分隔出不同的请求，在两个断句符号中间放的内容就是我们请求的二进制数据，这个过程我们叫做协议封装。

我们还可以在协议模块中加入压缩功能，这是因为压缩过程也是对传输的二进制数据进行操作。

**传输模块**

为了屏蔽网络传输的复杂性，我们需要封装一个单独的数据传输模块用来收发二进制数据，这个单独模块我们可以叫做传输模块。

在实际的网络传输过程中，我们的请求数据包在数据链路层可能会因为太大而被拆分成多个数据包进行传输，为了减少被拆分的次数，从而导致整个传输过程时间太长的问题，我们可以在RPC调用的时候这样操作：在方法调用参数或者返回值的二进制数据大于某个阈值的情况下，我们可以通过压缩框架进行无损压缩，然后在另外一端也用同样的压缩算法进行解压，保证数据可还原。

传输和协议这两个模块是RPC里面最基础的功能，它们使对象可以正确地传输到服务提供方。

**Bootstrap模块**

但距离RPC的目标——实现像调用本地一样地调用远程，还缺少点东西。

这就需要我们在RPC里面把这些细节对研发人员进行屏蔽，让他们感觉不到本地调用和远程调用的区别。

假设有用到Spring的话，我们希望RPC能让我们把一个RPC接口定义成一个Spring Bean，并且这个Bean也会统一被Spring Bean Factory管理，可以在项目中通过Spring依赖注入到方式引用。这是RPC调用的入口，叫做Bootstrap模块。

**集群模块**

所谓集群能力，就是针对同一个接口有着多个服务提供者，但这多个服务提供者对于我们的调用方来说是透明的，所以在RPC里面我们还需要给调用方找到所有的服务提供方，并需要在RPC里面维护好接口跟服务提供者地址的关系，这样调用方在发起请求的时候才能快速地找到对应的接收地址，这就是我们常说的服务发现。

**在RPC框架里面，我们是怎么支持插件化架构的呢？**

我们可以将每个功能点抽象成一个接口，将这个接口作为插件的契约，然后把这个功能的接口与功能的实现分离，并提供接口的默认实现。

> 在Java里面，JDK有自带的SPI（Service Provider Interface）服务发现机制，它可以动态地为某个接口寻找服务实现。

使用SPI机制需要在Classpath下的`META-INF/services`目录里创建一个以服务接口命名的文件，这个文件里的内容就是这个接口的具体实现类。

加上了插件功能之后，我们的RPC框架就包含了两大核心体系——核心功能体系与插件体系，如下图所示：

<img src="https://img-blog.csdnimg.cn/312ddd1159c64286a7852593b70ad928.png" style="zoom:25%;" />