---
title: 优雅关闭
categories: 
- 深入理解RPC框架原理
---

当服务提供方要上线的时候，一般是通过部署系统完成实例重启。

在这个过程中，服务提供方的团队并不会事先告诉调用方他们需要操作哪些机器，从而让调用方去事先切走流量。

而对调用方来说，它也无法预测到服务提供方要对哪些机器重启上线，因此负载均衡就有可能把要正在重启的机器选出来，这样就会导致把请求发送到正在重启中的机器里面，从而导致调用方不能拿到正确的响应结果。

在服务重启的时候，对于调用方来说，这时候可能会存在以下几种情况：

- 调用方发请求前，目标服务已经下线。对于调用方来说，跟目标节点的连接会断开，这时候调用方可以立马感知到，并且在其健康列表里面会把这个节点挪掉，自然也就不会被负载均衡选中。
- 调用方发请求的时候，目标服务正在关闭，但调用方并不知道它正在关闭，而且两者之间的连接也没断开，所以这个节点还会存在健康列表里面，因此该节点就有一定概率会被负载均衡选中。

**我们要讨论的就是当出现第二种情况的时候，在RPC里面怎么避免调用方业务受损。**

> 这时候，可能你还会想到，RPC里面不是有服务发现吗？

当服务提供方关闭前，是不是可以先通知注册中心进行下线，然后通过注册中心告诉调用方进行节点摘除？

整个关闭过程中依赖了两次RPC调用，一次是服务提供方通知注册中心下线操作，一次是注册中心通知服务调用方下线节点操作。

注册中心通知服务调用方都是异步的，**服务发现只保证最终一致性**，并不保证实时性，所以注册中心在收到服务提供方下线的时候，并不能成功保证把这次要下线的节点推送到所有的调用方。

所以这么来看，通过服务发现并不能做到应用无损关闭。

**优雅关闭**

因为服务提供方已经开始进入关闭流程，那么很多对象就可能已经被销毁了，关闭后再收到的请求按照正常业务请求来处理，肯定是没法保证能处理的。

所以我们可以在关闭的时候，设置一个请求挡板，挡板的作用就是告诉调用方，我已经开始进入关闭流程了，我不能再处理你这个请求了。

> 基于这个思路，我们可以这么处理：当服务提供方正在关闭，如果这之后还收到了新的业务请求，服务提供方直接返回一个特定的异常给调用方（比如ShutdownException）。

这个异常就是告诉调用方我已经收到这个请求了，但是我正在关闭，并没有处理这个请求，然后调用方收到这个异常响应后，RPC框架把这个节点从健康列表挪出，并把请求自动重试到其他节点，因为这个请求是没有被服务提供方处理过，所以可以安全地重试到其他节点，这样就可以实现对业务无损。

但如果只是靠等待被动调用，就会让这个关闭过程整体有点漫长。

因为有的调用方那个时刻没有业务请求，就不能及时地通知调用方了，所以我们可以加上主动通知流程，这样既可以保证实时性，也可以避免通知失败的情况。

**那要怎么捕获到关闭事件呢？**

可以通过捕获操作系统的进程信号来获取，在Java语言里面，对应的是`Runtime.addShutdownHook`方法，可以注册关闭的钩子。

在RPC启动的时候，我们提前注册关闭钩子，并在里面添加了两个处理程序，一个负责开启关闭标识，一个负责安全关闭服务对象，服务对象在关闭的时候会通知调用方下线节点。

同时需要在我们调用链里面加上挡板处理器，当新的请求来的时候，会判断关闭标识，如果正在关闭，则抛出特定异常。

**关闭过程中已经在处理的请求会不会受到影响呢？**

如果进程结束过快会造成这些请求还没有来得及应答，同时调用方会也会抛出异常。

为了尽可能地完成正在处理的请求，首先我们要把这些请求识别出来。

> 我们也可以利用这个原理在服务对象加上引用计数器，每开始处理请求之前加一，完成请求处理减一，通过该计数器我们就可以快速判断是否有正在处理的请求。

服务对象在关闭过程中，会拒绝新的请求，同时根据引用计数器等待正在处理的请求全部结束之后才会真正关闭。

但考虑到有些业务请求可能处理时间长，或者存在被挂住的情况，为了避免一直等待造成应用无法正常退出，我们可以在整个ShutdownHook里面，加上超时时间控制，当超过了指定时间没有结束，则强制退出应用。

超时时间我建议可以设定成10s，基本可以确保请求都处理完了。整个流程如下图所示。

<img src="https://img-blog.csdnimg.cn/0d6016e9211944d788087c900d99ac7a.png" style="zoom:25%;" />