---
title: 序列化
categories: 
- 深入理解RPC框架原理
---

![](https://img-blog.csdnimg.cn/592fbcbef05442cfb200ea94166baa8d.png)

**JSON**

JSON进行序列化有这样两个问题，你需要格外注意：

- JSON进行序列化的额外空间开销比较大，对于大数据量服务这意味着需要巨大的内存和磁盘开销；
- JSON没有类型，但像Java这种强类型语言，需要通过反射统一解决，所以性能不会太好。

所以如果RPC框架选用JSON序列化，服务提供者与服务调用者之间传输的数据量要相对较小，否则将严重影响性能。

**Hessian**

Hessian是动态类型、二进制、紧凑的，并且可跨语言移植的一种序列化框架。

Hessian协议要比JDK、JSON更加紧凑，性能上要比JDK、JSON序列化高效很多，而且生成的字节数也更小。

相对于JDK、JSON，由于Hessian更加高效，生成的字节数更小，有非常好的兼容性和稳定性，所以Hessian更加适合作为RPC框架远程通信的序列化协议。

但Hessian本身也有问题，官方版本对Java里面一些常见对象的类型不支持，比如：

- Linked系列，LinkedHashMap、LinkedHashSet等，但是可以通过扩展CollectionDeserializer类修复；
- Locale类，可以通过扩展ContextSerializerFactory类修复；
- Byte/Short反序列化的时候变成Integer。

以上这些情况，你在实践时需要格外注意。

**Protobuf**

Protobuf 是 Google 公司内部的混合语言数据标准，是一种轻便、高效的结构化数据存储格式，可以用于结构化数据序列化，支持Java、Python、C++、Go等语言。

Protobuf使用的时候需要定义IDL，然后使用不同语言的IDL编译器，生成序列化工具类，它的优点是：

- 序列化后体积相比 JSON、Hessian小很多；
- IDL能清晰地描述语义，所以足以帮助并保证应用程序之间的类型不会丢失，无需类似 XML 解析器；
- 序列化反序列化速度很快，不需要通过反射获取类型；
- 消息格式升级和兼容性不错，可以做到向后兼容。

Protobuf 非常高效，但是对于具有反射和动态能力的语言来说，这样用起来很费劲，这一点就不如Hessian，比如用Java的话，这个预编译过程不是必须的，可以考虑使用Protostuff。

Protostuff不需要依赖IDL文件，可以直接对Java领域对象进行反/序列化操作，在效率上跟Protobuf差不多，生成的二进制格式和Protobuf是完全相同的，可以说是一个Java版本的Protobuf序列化框架。

但在使用过程中，我遇到过一些不支持的情况，也同步给你：

- 不支持null；
- ProtoStuff不支持单纯的Map、List集合对象，需要包在对象里面。
