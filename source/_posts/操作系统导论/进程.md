---
title: 进程
categories: 
- 操作系统导论
---

在系统中正在运行的一个应用程序；程序一旦运行就是进程；是资源分配的最小单位。

在操作系统中能同时运行多个进程；

开机的时候，磁盘的内核镜像被导入内存作为一个执行副本，成为内核进程。

进程可以分成**用户态进程和内核态进程**两类，用户态进程通常是应用程序的副本，内核态进程就是内核本身的进程。

如果用户态进程需要申请资源，比如内存，可以通过系统调用向内核申请。

每个进程都有独立的内存空间，存放代码和数据段等，程序之间的切换会有较大的开销；

**分时和调度**

每个进程在执行时都会获得操作系统分配的一个时间片段，如果超出这个时间，就会轮到下一个进程（线程）执行。

> 注意，现代操作系统都是直接调度线程，不会调度进程。

**分配时间片段**

如下图所示，进程 1 需要 2 个时间片段，进程 2 只有 1 个时间片段，进程 3 需要 3 个时间片段。

因此当进程 1 执行到一半时，会先挂起，然后进程 2 开始执行；进程 2 一次可以执行完，然后进程 3 开始执行，不过进程 3 一次执行不完，在执行了 1 个时间片段后，进程 1 开始执行；就这样如此周而复始，这个就是分时技术。

<img src="https://img-blog.csdnimg.cn/ca30e5c197ef4bbe8ae706f4ba577628.png" style="zoom:25%;" />

# 创建进程

用户想要创建一个进程，最直接的方法就是从命令行执行一个程序，或者双击打开一个应用，但对于程序员而言，显然需要更好的设计。

首先，应该有 API 打开应用，比如可以通过函数打开某个应用；

另一方面，如果程序员希望执行完一段代价昂贵的初始化过程后，将当前程序的状态复制好几份，变成一个个单独执行的进程，那么操作系统提供了 fork 指令。

<img src="https://img-blog.csdnimg.cn/1b06cbc132e047ac987f130e50ad68df.png" style="zoom:25%;" />

也就是说，每次 fork 会多创造一个克隆的进程，这个克隆的进程，所有状态都和原来的进程一样，但是会有自己的地址空间。

如果要创造 2 个克隆进程，就要 fork 两次。

> 那如果我就是想启动一个新的程序呢？

操作系统提供了启动新程序的 API。

如果我就是想用一个新进程执行一小段程序，比如说每次服务端收到客户端的请求时，我都想用一个进程去处理这个请求。

如果是这种情况，建议你不要单独启动进程，而是使用线程。

因为进程的创建成本实在太高了，因此不建议用来做这样的事情：要创建条目、要分配内存，特别是还要在内存中形成一个个段，分成不同的区域。所以通常，我们更倾向于多创建线程。

不同程序语言会自己提供创建线程的 API，比如 Java 有 Thread 类；go 有 go-routine（注意不是协程，是线程）。

# 进程状态

<img src="https://img-blog.csdnimg.cn/a33a07f3e1b944ecb03ccf39227e378f.png" style="zoom:50%;" />

**创建状态**

进程由创建而产生，创建进程是一个非常复杂的过程，一般需要通过多个步骤才能完成：如首先由进程申请一个空白的进程控制块(PCB)，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后，把该进程转入就绪状态并插入到就绪队列中

**就绪状态**

这是指进程已经准备好运行的状态，即进程已分配到除CPU以外所有的必要资源后，只要再获得CPU，便可立即执行，如果系统中有许多处于就绪状态的进程，通常将它们按照一定的策略排成一个队列，该队列称为就绪队列，有执行资格，没有执行权的进程

**运行状态**

这里指进程已经获取CPU，其进程处于正在执行的状态。对任何一个时刻而言，在单处理机的系统中，只有一个进程处于执行状态而在多处理机系统中，有多个进程处于执行状态，既有执行资格，又有执行权的进程

**阻塞状态**

这里是指正在执行的进程由于发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，即进程执行受到阻塞，此时引起进程调度，操作系统把处理机分配给另外一个就绪的进程，而让受阻的进程处于暂停的状态，一般将这个暂停状态称为阻塞状态

**终止状态**

# 进程间通信IPC

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信

**管道/匿名管道**

管道是半双工的，数据只能向一个方向流动；需要双方通信时，需要建立起两个管道。

* 只能用于父子进程或者兄弟进程之间(具有亲缘关系的进程);

* 单独构成一种独立的文件系统：管道对于管道两端的进程而言，就是一个文件，但它不是普通的文件，它不属于某种文件系统，而是自立门户，单独构成一种文件系统，并且只存在与内存中。

* 数据的读出和写入：一个进程向管道中写的内容被管道另一端的进程读出，写入的内容每次都添加在管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。

**有名管道(FIFO)**

匿名管道，由于没有名字，只能用于亲缘关系的进程间通信。

为了克服这个缺点，提出了有名管道(FIFO)。

有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，以有名管道的文件形式存在于文件系统中，这样，即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信，因此，通过有名管道不相关的进程也能交换数据。

**信号**

信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。

如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。

如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

**消息队列**

消息队列是存放在内核中的消息链表，每个消息队列由消息队列标识符表示。

与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。

另外与管道不同的是，消息队列在某个进程往一个队列写入消息之前，并不需要另外某个进程在该队列上等待消息的到达

**共享内存**

使得多个进程可以直接读写同一块内存空间，是最快的可用IPC形式，是针对其他通信机制运行效率较低而设计的。

为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。

由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

共享内存示意图：

<img src="https://img-blog.csdnimg.cn/535398a7779c4995aee2ae6974410c37.png" style="zoom:25%;" />

一旦这样的内存映射到共享它的进程的地址空间，这些进程间数据传递不再涉及到内核，换句话说是进程不再通过执行进入内核的系统调用来传递彼此的数据。

**信号量**

信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。

为了获得共享资源，进程需要执行下列操作：

1. 创建一个信号量：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。 

2. 等待一个信号量：该操作会测试这个信号量的值，如果小于0，就阻塞，也称为P操作。 
3. 挂出一个信号量：该操作将信号量的值加1，也称为V操作。

**套接字(Socket)**

套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。

# 信号

信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。

也可以简单理解为信号是某种形式上的软中断

可运行`kill -l`查看Linux支持的信号列表：

```
kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX
```

**几个常用的信号：**

| 信号    | 描述                                                         |
| ------- | ------------------------------------------------------------ |
| SIGHUP  | 当用户退出终端时，由该终端开启的所有进程都会接收到这个信号，默认动作为终止进程。 |
| SIGINT  | 程序终止(interrupt)信号, 在用户键入INTR字符(通常是`Ctrl+C`)时发出，用于通知前台进程组终止进程。 |
| SIGQUIT | 和`SIGINT`类似, 但由QUIT字符(通常是`Ctrl+\`)来控制，进程在因收到`SIGQUIT`退出时会产生`core`文件, 在这个意义上类似于一个程序错误信号。 |
| SIGKILL | 用来立即结束程序的运行，本信号不能被阻塞、处理和忽略。       |
| SIGTERM | 程序结束(terminate)信号, 与`SIGKILL`不同的是该信号可以被阻塞和处理。通常用来要求程序自己正常退出。 |
| SIGSTOP | 停止(stopped)进程的执行. 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行，本信号不能被阻塞, 处理或忽略 |

# 进程同步

**临界区**

通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问

优点：保证在某一时刻只有一个线程能访问数据的简便办法

缺点：虽然临界区同步速度很快，但却只能用来同步本进程内的线程，而不可用来同步多个进程中的线程

**互斥量**

为协调共同对一个共享资源的单独访问而设计的

互斥量跟临界区很相似，比临界区复杂，互斥对象只有一个，只有拥有互斥对象的线程才具有访问资源的权限

优点：使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享

**信号量**

为控制一个具有有限数量用户资源而设计，它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目，互斥量是信号量的一种特殊情况，当信号量的最大资源数=1就是互斥量了

信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** ，0 表示临界区已经加锁，1 表示临界区解锁。

**事件**

用来通知线程有一些事件已发生，从而启动后继任务的开始

优点：事件对象通过通知操作的方式来保持线程的同步，并且可以实现不同进程中的线程同步操作

**管程**

管程有一个重要特性：在一个时刻只能有一个进程使用管程。

进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。

对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。

signal() 操作用于唤醒被阻塞的进程。

使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

# 上下文切换

对于单核单线程CPU而言，在某一时刻只能执行一条CPU指令。

上下文切换(Context Switch)是一种将CPU资源从一个进程分配给另一个进程的机制。

从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。

**在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。**

# 进程调度算法

**先来先服务调度算法**

该算法既可用于作业调度，也可用于进程调度，当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列

**短作业优先调度算法**

从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行

**时间片轮转法**

每次调度时，把CPU分配给队首进程，并令其执行一个时间片，时间片的大小从几ms到几百ms，当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾

然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片，这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间

**最短剩余时间优先**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度，当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。

如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

**多级反馈队列调度算法**：

前面介绍的几种进程调度的算法都有一定的局限性，如**短进程优先的调度算法，仅照顾了短进程而忽略了长进程**，多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业迅速完成，因而它是目前**被公认的一种较好的进程调度算法**，UNIX 操作系统采取的便是这种调度算法。

> 举例：

多级队列，就是多个队列执行调度，先考虑最简单的两级模型

<img src="https://img-blog.csdnimg.cn/cbf1f574cfe54f85b01a6c1253c52b92.png" style="zoom:25%;" />

上图中设计了两个优先级不同的队列，从下到上优先级上升，上层队列调度紧急任务，下层队列调度普通任务。

只要上层队列有任务，下层队列就会让出执行权限。

低优先级队列可以考虑抢占 + 优先级队列的方式实现，这样每次执行一个时间片段就可以判断一下高优先级的队列中是否有任务。

高优先级队列可以考虑用非抢占（每个任务执行完才执行下一个）+ 优先级队列实现，这样紧急任务优先级有个区分，如果遇到十万火急的情况，就可以优先处理这个任务。

上面这个模型虽然解决了任务间的优先级问题，但是还是没有解决短任务先行的问题，可以考虑再增加一些队列，让级别更多。

> 比如下图这个模型：

<img src="https://img-blog.csdnimg.cn/6f7d4bfa7f2e4df8a9cb56adead8de5a.png" style="zoom:25%;" />

紧急任务仍然走高优队列，非抢占执行。

普通任务先放到优先级仅次于高优任务的队列中，并且只分配很小的时间片；如果没有执行完成，说明任务不是很短，就将任务下调一层。

下面一层，最低优先级的队列中时间片很大，长任务就有更大的时间片可以用。

通过这种方式，短任务会在更高优先级的队列中执行完成，长任务优先级会下调，也就类似实现了最短作业优先的问题。

实际操作中，可以有 n 层，一层层把大任务筛选出来，最长的任务，放到最闲的时间去执行，要知道，大部分时间 CPU 不是满负荷的。

**优先级调度** 

为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推，具有相同优先级的进程以 FCFS 方式执行，可以根据内存要求，时间要求或任何其他资源要求来确定优先级。

# 守护进程

守护进程是脱离于终端并且在后台运行的进程，脱离终端是为了避免在执行的过程中的信息在终端上显示，并且进程也不会被任何终端所产生的终端信息所打断。

守护进程一般的生命周期是系统启动到系统停止运行。

Linux系统中有很多的守护进程，最典型的就是我们经常看到的服务进程。

当然，我们也经常会利用守护进程来完成很多的系统或者自动化任务。

# 孤儿进程

父进程早于子进程退出时候子进程还在运行，子进程会成为孤儿进程，Linux会对孤儿进程的处理，把孤儿进程的父进程设为进程号为1的进程，也就是由init进程来托管，init进程负责子进程退出后的善后清理工作

# 僵尸进程

子进程执行完毕时发现父进程未退出，会向父进程发送 SIGCHLD 信号，但父进程没有使用 wait/waitpid 或其他方式处理 SIGCHLD 信号来回收子进程，子进程变成为了对系统有害的僵尸进程

子进程退出后留下的进程信息没有被收集，会导致占用的进程控制块PCB不被释放，形成僵尸进程，进程已经死去，但是进程资源没有被释放掉

**问题及危害**

如果系统中存在大量的僵尸进程，他们的进程号就会一直被占用，但是系统所能使用的进程号是有限的，系统将因为没有可用的进程号而导致系统不能产生新的进程

任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理，这是每个子进程在结束时都要经过的阶段，如果子进程在exit()之后，父进程没有来得及处理，这时用ps命令就能看到子进程的状态是Z。

如果父进程能及时处理，可能用ps命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态

产生僵尸进程的元凶其实是他们的父进程，杀掉父进程，僵尸进程就变为了孤儿进程，便可以转交给 init 进程回收处理

# 死锁

**产生原因**

系统资源的竞争：系统资源的竞争导致系统资源不足，以及资源分配不当，导致死锁。

进程运行推进顺序不合适：进程在运行过程中，请求和释放资源的顺序不当，会导致死锁。

**发生死锁的四个必要条件**

互斥条件：一个资源每次只能被一个进程使用，即在一段时间内某资源仅为一个进程所占有，此时若有其他进程请求该资源，则请求进程只能等待

请求与保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求时，该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放

不可剥夺条件:进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)

循环等待条件: 若干进程间形成首尾相接循环等待资源的关系

这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁

**只要我们破坏其中一个，就可以成功避免死锁的发生**

其中，互斥这个条件我们没有办法破坏，因为我们用锁为的就是互斥

1. 对于占用且等待这个条件，我们可以一次性申请所有的资源，这样就不存在等待了。
2. 对于不可抢占这个条件，占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源，这样不可抢占这个条件就破坏掉了。
3. 对于循环等待这个条件，可以靠按序申请资源来预防，所谓按序申请，是指资源是有线性顺序的，申请的时候可以先申请资源序号小的，再申请资源序号大的，这样线性化后自然就不存在循环了。

**处理方法**

主要有以下四种方法：

- 鸵鸟策略
- 死锁检测与死锁恢复
- 死锁预防，破坏4个必要条件
- 死锁避免，银行家算法

**鸵鸟策略**

把头埋在沙子里，假装根本没发生问题。

因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。

当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。

**死锁检测**

不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。

1. 每种类型一个资源的死锁检测

2. 每种类型多个资源的死锁检测

**死锁恢复**

- 利用抢占恢复
- 利用回滚恢复
- 通过杀死进程恢复

# 哲学家进餐问题

五个哲学家围着一张圆桌，每个哲学家面前放着食物。

哲学家的生活有两种交替活动：吃饭以及思考。

当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。

如果所有哲学家同时拿起左手边的筷子，那么所有哲学家都在等待其它哲学家吃完并释放自己手中的筷子，导致死锁。

哲学家进餐问题可看作是并发进程并发执行时处理共享资源的一个有代表性的问题。

**为了防止死锁的发生，可以设置两个条件：**

- 必须同时拿起左右两根筷子；
- 只有在两个邻居都没有进餐的情况下才允许进餐。

# 银行家算法

银行家算法的命名是它可以用了银行系统，当不能满足所有客户的需求时，银行绝不会分配其资金。

当新进程进入系统时，它必须说明其可能需要的每种类型资源实例的最大数量这一数量不可以超过系统资源的总和。

当用户申请一组资源时，系统必须确定这些资源的分配是否处于安全状态，如何安全，则分配，如果不安全，那么进程必须等待指导某个其他进程释放足够资源为止。

**安全状态**

在避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次资源分配的安全性，若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，令进程等待

因此，避免死锁的实质在于：系统在进行资源分配时，如何使系统不进入不安全状态

# Fork函数

`fork`函数用于创建一个与当前进程一样的子进程，所创建的子进程将复制父进程的代码段、数据段、BSS段、堆、栈等所有用户空间信息，在内核中操作系统会重新为其申请一个子进程执行的位置。

`fork`系统调用会通过复制一个现有进程来创建一个全新的进程，新进程被存放在一个叫做任务队列的双向循环链表中，链表中的每一项都是类型为`task_struct`的进程控制块`PCB`的结构。

<img src="https://img-blog.csdnimg.cn/5e4479948ed041b080bb71fb84611e7b.png" style="zoom:50%;" />

每个进程都由独特换不相同的进程标识符（PID），通过`getpid()`函数可获取当前进程的进程标识符，通过`getppid()`函数可获得父进程的进程标识符。

一个现有的进程可通过调用`fork`函数创建一个新进程，由`fork`创建的新进程称为子进程`child process`，`fork`函数被调用一次但返回两次，两次返回的唯一区别是子进程中返回0而父进程中返回子进程ID。

**为什么`fork`会返回两次呢？**

因为复制时会复制父进程的堆栈段，所以两个进程都停留在`fork`函数中等待返回，因此会返回两次，一个是在父进程中返回，一次是在子进程中返回，两次返回值是不一样的。

- 在父进程中将返回新建子进程的进程ID
- 在子进程中将返回0
- 若出现错误则返回一个负数

因此可以通过`fork`的返回值来判断当前进程是子进程还是父进程。

**fork执行执行流程**

当进程调用`fork`后控制转入内核，内核将会做4件事儿：

1. 分配新的内存块和内核数据结构给子进程
2. 将父进程部分数据结构内容（数据空间、堆栈等）拷贝到子进程
3. 添加子进程到系统进程列表中
4. `fork`返回开始调度器调度

**为什么`pid`在父子进程中不同呢？**

其实就相当于链表，进程形成了链表，父进程的`pid`指向子进程的进程ID，因此子进程没有子进程，所以PID为0，这里的`pid`相当于链表中的指针。