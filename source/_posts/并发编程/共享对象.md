---
title: 共享对象
categories: 
- 并发编程
---

# 可见性、原子性与有序性

**可见性**

可见性指的是当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值

多线程环境下由于线程对共享变量的操作都是线程拷贝到各自的工作内存进行操作后才写回到主内存中的，这就可能存在一个线程A修改了共享变量的值，还未写回主内存时，另外一个线程B又对主内存中同一个共享变量进行操作，但此时A线程工作内存中共享变量的修改对线程B来说并不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题

**原子性**

原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会被其他线程影响

**有序性**

多线程环境，则可能出现乱序现象，因为程序编译成机器码指令后可能会出现指令重排现象，重排后的指令与原指令的顺序未必一致

**如何解决原子性&可见性&有序性问题**

> 原子性问题

除了JVM自身提供的对基本数据类型读写操作的原子性外，可以通过Synchronized和Lock实现原子性，因为Synchronized和Lock能够保证任一时刻只有一个线程访问该代码块

> 可见性问题

Volatile关键字保证可见性，当一个共享变量被Volatile修饰时，它会保证修改的值立即被其他的线程看到，即修改的值立即更新到主存中，当其他线程需要读取时，它会去内存中读取新值，Synchronized和Lock也可以保证可见性，因为它们可以保证任一时刻只有一个线程能访问共享资源，并在其释放锁之前将修改的变量刷新到内存中

> 有序性问题

可以通过Volatile关键字来保证一定的有序性，另外可以通过Synchronized和Lock来保证有序性，很显然，Synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性

> Java内存模型具备一些先天的有序性，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before原则

如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

**处理器如何实现原子操作**

CAS是调用处理器底层指令来实现原子操作，那么处理器底层又是如何实现原子操作的呢？

处理器和物理内存之间的通信速度要远慢于处理器间的处理速度，所以处理器有自己的内部缓存。

如下图所示，在执行操作时，频繁使用的内存数据会缓存在处理器的L1、L2和L3高速缓存中，以加快频繁读取的速度。

<img src="https://img-blog.csdnimg.cn/e30e6e67c1af4221923b120a9973ad0e.png" style="zoom:33%;" />

一般情况下，一个单核处理器能自我保证基本的内存操作是原子性的，当一个线程读取一个字节时，所有进程和线程看到的字节都是同一个缓存里的字节，其它线程不能访问这个字节的内存地址。

但现在的服务器通常是多处理器，并且每个处理器都是多核的。每个处理器维护了一块字节的内存，每个内核维护了一块字节的缓存，这时候多线程并发就会存在缓存不一致的问题，从而导致数据不一致。

这个时候，处理器提供了**总线锁定**和**缓存锁定**两个机制来保证复杂内存操作的原子性。

当处理器要操作一个共享变量的时候，其在总线上会发出一个Lock信号，这时其它处理器就不能操作共享变量了，该处理器会独享此共享内存中的变量。但总线锁定在阻塞其它处理器获取该共享变量的操作请求时，也可能会导致大量阻塞，从而增加系统的性能开销。

于是，后来的处理器都提供了缓存锁定机制，也就说当某个处理器对缓存中的共享变量进行了操作，就会通知其它处理器放弃存储该共享资源或者重新读取该共享资源。目前最新的处理器都支持缓存锁定机制。

**long 和 double 的原子性**

long 和 double 的值需要占用 64 位的内存空间，而对于 64 位值的写入，可以分为两个 32 位的操作来进行。

这样一来，本来是一个整体的赋值操作，就可能被拆分为低 32 位和高 32 位的两个操作。如果在这两个操作之间发生了其他线程对这个值的读操作，就可能会读到一个错误、不完整的值。

JVM 的开发者可以自由选择是否把 64 位的 long 和 double 的读写操作作为原子操作去实现，并且规范推荐 JVM 将其实现为原子操作。

> 规范同样规定，如果使用 volatile 修饰了 long 和 double，那么其读写操作就必须具备原子性了。

而在目前各种平台下的主流虚拟机的实现中，几乎都会把 64 位数据的读写操作作为原子操作来对待，因此我们在编写代码时一般不需要为了避免读到**半个变量**而把 long 和 double 声明为 volatile 的。

# Volatile

volatile是Java虚拟机提供的轻量级的同步机制

**volatile关键字有如下两个作用**

- 保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。

- 禁止指令重排序优化。

**如何实现内存可见性**

- 第一： 使用volatile关键字会强制将修改的值立即写入主存；

- 第二： 使用volatile关键字的话，当线程2进行修改时， 会导致线程1的工作内存中缓存变量的缓存行无效；

- 第三： 由于线程1的工作内存中缓存变量的缓存行无效，所以线程1再次读取变量的值时会去主存读取。

**禁止重排序**

1. 当程序执行到volatile变量的读操作或者写操作时， 在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见

2. 在进行指令优化时，不能把volatile变量前面的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。

为了实现volatile的内存语义， 加入 volatile 关键字时， 编译器在生成字节码时，会在指令序列中插入内存屏障， 会多出一个 lock 前缀指令。

**内存屏障，有2个作用：**

1. 先于这个内存屏障的指令必须先执行， 后于这个内存屏障的指令必须后执行。
2. 使得内存可见性。 所以， 如果你的字段是 volatile， 在读指令前插入读屏障， 可以让高速缓存中的数据失效， 重新从主内存加载数据。 在写指令之后插入写屏障， 能让写入缓存的最新数据写回到主内存。

**硬件层的内存屏障**

Intel硬件提供了一系列的内存屏障，主要有：

* lfence，是一种Load Barrier 读屏障

* sfence, 是一种Store Barrier 写屏障

* mfence, 是一种全能型的屏障，具备ifence和sfence的能力

* Lock前缀，Lock不是一种内存屏障，但是它能完成类似内存屏障的功能，Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁

不同硬件实现内存屏障的方式不同，Java内存模型屏蔽了这种底层硬件平台的差异，由JVM来为不同的平台生成相应的机器码。

**JVM中提供了四类内存屏障指令：**

| 屏障类型   | 指令示例                   | 说明                                                         |
| ---------- | -------------------------- | ------------------------------------------------------------ |
| LoadLoad   | Load1; LoadLoad; Load2     | 保证load1的读取操作在load2及后续读取操作之前执行             |
| StoreStore | Store1; StoreStore; Store2 | 在store2及其后的写操作执行前，保证store1的写操作已刷新到主内存 |
| LoadStore  | Load1; LoadStore; Store2   | 在stroe2及其后的写操作执行前，保证load1的读操作已读取结束    |
| StoreLoad  | Store1; StoreLoad; Load2   | 保证store1的写操作已刷新到主内存之后，load2及其后的读操作才能执行 |

> Load-Load Barriers

保证 load1 数据的装载优先于 load2 以及所有后续装载指令的装载。

对于 Load Barrier 来说，在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。

```
load1
LoadLoad
load2
```

> Load-Store Barriers

保证 load1 数据装载优先于 store2 以及后续的存储指令刷新到内存。

```
load1
LoadStore
store2
```

> Store-Store Barriers

保证 store1 数据对其他处理器可见，优先于 store2 以及所有后续存储指令的存储。

对于 Store Barrier 来说，在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。

```
store1
StoreStore
store
```

> Store-Load Barriers

在 Load2 及后续所有读取操作执行前，保证 Store1 的写入对所有处理器可见。

这条内存屏障指令是一个全能型的屏障，它同时具有其他 3 条屏障的效果，而且它的开销也是四种屏障中最大的一个。

```
store1
StoreLoad
load2
```

JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略。

- 在每个volatile写操作的前面插入一个StoreStore屏障。
- 在每个volatile写操作的后面插入一个StoreLoad屏障。
- 在每个volatile读操作的后面插入一个LoadLoad屏障。
- 在每个volatile读操作的后面插入一个LoadStore屏障。

**无法保证原子性**

```java
//示例
public class VolatileVisibility {
    public static volatile int i =0;
    public static void increase(){
        i++;
    }
}
```

在并发场景下，i变量的任何改变都会立马反应到其他线程中，但是如此存在多条线程同时调用increase()方法的话，就会出现线程安全问题，毕竟i++，操作并不具备原子性，该操作是先读取值，然后写回一个新值，相当于原来的值加上1，分两步完成

如果第二个线程在第一个线程读取旧值和写回新值期间读取i的域值，那么第二个线程就会与第一个线程一起看到同一个值，并执行相同值的加1操作，这也就造成了线程安全失败，因此对于increase方法必须使用synchronized修饰，以便保证线程安全

需要注意的是一旦使用synchronized修饰方法后，由于synchronized本身也具备与volatile相同的特性，即可见性，因此在这样种情况下就完全可以省去volatile修饰变量

# 线程封闭

**栈封闭**

栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量才能访问对象。

局部变量的固有属性之一就是封闭在执行线程中。

```java
public int loadTheArk(Collection<Animal> candidates) {
    SortedSet<Animal> animals;
    int numPairs = 0;
    Animal candidate = null;
    
    // animals 被封闭在方法中，不要使它们逸出！
    animals = new TreeSet<Animal>(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for (Animal a : animals) {
        if (candidate == null || !candidate.isPotentialMate(a)) {
            candidate = a;
        } else {
            ark.load(new AnimalPair(candidate, a));
            ++numPairs;
            candidate = null;
        }
    }
    return numPairs;
}
```

注意到 `animals` 引用被封闭到了局部变量中，因此也被封闭在执行线程中。

返回的 `numPairs` 是一个基本类型，由于任何方法都无法获得对基本类型的引用，因此 Java语言的这种语义就确保了基本类型的局部变量始终封闭在线程内。

# 不变性

满足同步需求的另一种方法时使用不可变对象（Immutable Object）。

> 不可变对象一定是线程安全的
>
> 当满足以下条件时，对象才是不可变的：
>
> - 对象创建以后其状态就不能修改
> - 对象的所有域都是 final 类型
> - 对象是正确创建的（在对象的创建期间，this 引用没有逸出）

# 安全发布

**安全发布的常用模式**

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。

一个正确构造的对象可以通过以下方式来安全地发布：

- 在静态初始化函数中初始化一个对象引用。

  （由于在在 JVM 内部存在着同步机制，因此通过这种方法初始化的任何对象都可以被安全地发布）

- 将对象的引用保存到 `volatile` 类型的域或者 `AtomicaReference` 对象中。

- 将对象的引用保存到某个正确构造对象的 `final` 类型域中。

- 将对象的引用保存到一个由锁保护的域中。

在线程安全容器内部的同步意味着，在将对象放入到某个容器，例如 `Vector` 或 `synchronizedList` 时，将满足上述最后一条需求。

如果线程 A 将对象 X 放入一个线程安全的容器，随后线程 B 读取这个对象，那么可以确保 B 看到 A 设置的 X 状态，即便在这段读 / 写 X 的应用程序代码中没有包含显示的同步。
