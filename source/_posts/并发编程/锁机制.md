---
title: 锁机制
categories: 
- 并发编程
---

# 锁分类

**偏向锁/轻量级锁/重量级锁**

**可重入锁/非可重入锁**

可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。

```java
public class LockExample {
    public static void main(String[] args) {
        reentrantA(); // 可重入锁
    }
    /**
     * 可重入锁 A 方法
     */
    private synchronized static void reentrantA() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantA");
        reentrantB();
    }
    /**
     * 可重入锁 B 方法
     */
    private synchronized static void reentrantB() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantB");
    }
}
```

从结果可以看出 reentrantA 方法和 reentrantB 方法的执行线程都是`main`，我们调用了 reentrantA 方法，它的方法中嵌套了 reentrantB，如果 synchronized 是不可重入的话，那么线程会被一直堵塞。

可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为 0，当被线程占用和重入时分别加 1，当锁被释放时计数器减 1，直到减到 0 时表示此锁为空闲状态。

**共享锁/独占锁**

共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。

我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。

读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。

**公平锁/非公平锁**

公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。

而非公平锁它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。

公平和非公平的优缺点：

|          | 优势                                                       | 劣势                                                         |
| -------- | ---------------------------------------------------------- | ------------------------------------------------------------ |
| 公平锁   | 各线程公平平等，每一个线程在等待一段时间后，总有执行的机会 | 更慢，吞吐量更少                                             |
| 非公平锁 | 更快，吞吐量更大                                           | 有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行 |

**悲观锁/乐观锁**

悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到独占的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。

而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。

两种锁的使用场景

- 像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。
- 但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适**
- 悲观锁适合用于并发写入多、临界区代码复杂、竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。
- 乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是并发并不激烈的场景。
- 在这些场景下，乐观锁不加锁的特点能让性能大幅提高。

**自旋锁/非自旋锁**

自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁。

相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。

> 自旋锁的好处

阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。

自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。

> 适用场景

所以我们就要看一下自旋锁的适用场景。首先，自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。

可是如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。

**可中断锁/不可中断锁**

在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。

而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。

# 锁优化

相比于 JDK 1.5，在 JDK 1.6 中 HotSopt 虚拟机对 synchronized 内置锁的性能进行了很多优化，包括自适应的自旋、锁消除、锁粗化、偏向锁、轻量级锁等。

**自适应的自旋锁**

自旋就是不释放 CPU，一直循环尝试获取锁。

自旋的缺点在于如果自旋时间过长，那么性能开销是很大的，浪费了 CPU 资源。

在 JDK 1.6 中引入了自适应的自旋锁来解决长时间自旋的问题。自适应意味着自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。

自旋的持续时间是变化的，比如，如果最近尝试自旋获取某一把锁成功了，那么下一次可能还会继续使用自旋，并且允许自旋更长的时间；但是如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。

**锁消除**

经过逃逸分析之后，如果发现某些对象不可能被其他线程访问到，那么就可以把它们当成栈上数据，栈上数据由于只有本线程可以访问，自然是线程安全的，也就无需加锁，所以会把这样的锁给自动去除掉。

**锁粗化**

```java
public void lockCoarsening() {
    synchronized (this) {
        //do something
    }
    synchronized (this) {
        //do something
    }
    synchronized (this) {
        //do something
    }
}
```

那么其实这种释放和重新获取锁是完全没有必要的，如果我们把同步区域扩大，也就是只在最开始加一次锁，并且在最后直接解锁，那么就可以把中间这些无意义的解锁和加锁的过程消除，相当于是把几个 synchronized 块合并为一个较大的同步块。

这样做的好处在于在线程执行这些代码时，就无须频繁申请与释放锁了，这样就减少了性能开销。

不过，我们这样做也有一个副作用，那就是我们会让同步区域变大。如果在循环中我们也这样做，如代码所示：

```java
for (int i = 0; i < 1000; i++) {
    synchronized (this) {
        //do something
    }
}
```

也就是我们在第一次循环的开始，就开始扩大同步区域并持有锁，直到最后一次循环结束，才结束同步代码块释放锁的话，这就会导致其他线程长时间无法获得锁。所以，这里的锁粗化不适用于循环的场景，仅适用于非循环的场景。

锁粗化功能是默认打开的，用 `-XX:-EliminateLocks`可以关闭该功能。

# 死锁

死锁就是两个或多个线程（或进程）被无限期地阻塞，相互等待对方手中资源的一种状态。

```java
// 共享变量 1
private static final Object share1 = new Object();
// 共享变量 2
private static final Object share2 = new Object();
@Test
public void testDeadLock() throws InterruptedException {
  // 初始化线程 1，线程 1 需要在锁定 share1 共享资源的情况下再锁定 share2
  Thread thread1 = new Thread(() -> {
    synchronized (share1){
      try {
        Thread.sleep(2000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized (share2){
        log.info("{} is run",Thread.currentThread().getName());
      }
    }
  });
 
  // 初始化线程 2，线程 2 需要在锁定 share2 共享资源的情况下再锁定 share1
  Thread thread2 = new Thread(() -> {
    synchronized (share2){
      try {
        Thread.sleep(2000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized (share1){
        log.info("{} is run",Thread.currentThread().getName());
      }
    }
  });
  // 当线程 1、2 启动后，都在等待对方锁定的资源，但都得不到，造成死锁
  thread1.start();
  thread2.start();
  Thread.sleep(1000000000);
}
```

**如何预防死锁**

> 1.尽量保证加锁顺序是一样的

例如有A,B,C三把锁。

Thread 1的加锁顺序为A、B、C这样的。

Thread 2的加锁顺序为A、C，这样就不会死锁。

如果Thread2的加锁顺序为B、A或者C、A这样顺序就不一致了，就会出现死锁问题。

> 2.尽量用超时放弃机制

Lock接口提供了`tryLock(long time, TimeUnit unit)`方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。可以避免死锁问题

**如何定位死锁**

利用 jstack 来定位死锁的方法，jstack 可以用来帮助我们分析线程持有的锁和需要的锁，然后分析出是否有循环依赖形成死锁的情况。