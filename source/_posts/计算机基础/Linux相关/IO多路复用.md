---
title: IO多路复用
categories: 
- 计算机基础
- Linux相关
---

IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程

* 目前支持I/O多路复用的系统调用有 `select，pselect，poll，epoll`

I/O多路复用通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作

但`select，pselect，poll，epoll`本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间

# Select

select 函数监视文件描述符，调用后select函数会阻塞，直到有描述符就绪，通过遍历fdset，来找到就绪的描述符

**缺点**

* select最大的缺陷就是单个进程所打开的FD是有一定限制的，它由`FD_SETSIZE`设置，默认值是1024

* 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低

# Poll

poll和select区别：

* 它没有最大连接数的限制，原因是它是基于链表来存储的

* poll还有一个特点是**水平触发**，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd

# Epoll

epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。

epoll使用事件的就绪通知方式，通过`epoll_ctl`注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，`epoll_wait`便可以收到通知。

epoll是被动触发方式，给fd注册了相应事件的时候，我们为每一个fd指定了一个回调函数，当数据准备好之后，就会把就绪的fd加入一个就绪的队列中，`epoll_wait`的工作方式实际上就是在这个就绪队列中查看有没有就绪的fd，如果有，就唤醒就绪队列上的等待者，然后调用回调函数。

**优点：**

* 没有最大并发连接的限制

* 效率提升，不是轮询的方式，不会随着FD数目的增加效率下降。只有活跃可用的FD才会调用callback函数；即Epoll最大的优点就在于它只管你活跃的连接，而跟连接总数无关，因此在实际的网络环境中，Epoll的效率就会远远高于select和poll

* 内存拷贝，利用mmap()文件映射内存加速与内核空间的消息传递；即epoll使用mmap减少复制开销

**文件描述符的操作有两种模式：LT和ET**

LT模式是默认模式，LT模式与ET模式的区别如下：

* LT模式：当`epoll_wait`检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用`epoll_wait`时，会再次响应应用程序并通知此事件
* ET模式：当`epoll_wait`检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用`epoll_wait`时，不会再次响应应用程序并通知此事件

**epoll的核心是3个API，核心数据结构是：1个红黑树和1个链表**

<img src="https://img-blog.csdnimg.cn/ee84016b0d5c40bb99fa5a2c30ea8abc.png" style="zoom:25%;" />

**结论**

* 表面上看epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调

* select低效是因为每次它都需要轮询