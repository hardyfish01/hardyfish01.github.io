---
title: 布隆过滤器
categories: 
- 计算机基础
- 数据结构和算法
---

布隆过滤器的核心实现是一个超大的位数组和几个哈希函数，假设位数组的长度为m，哈希函数的个数为k

**具体的操作流程：**

假设集合里面有3个元素`{x, y, z}`，哈希函数的个数为3

* 首先将位数组进行初始化，将里面每个位都设置位0，对于集合里面的每一个元素，将元素依次通过3个哈希函数进行映射，每次映射都会产生一个哈希值，这个值对应位数组上面的一个点，然后将位数组对应的位置标记为1

* 查询W元素是否存在集合中的时候，同样的方法将W通过哈希映射到位数组上的3个点，如果3个点的其中有一个点不为1，则可以判断该元素一定不存在集合，反之，如果3个点都为1，则该元素可能存在集合中

> 注意：此处不能判断该元素是否一定存在集合中，可能存在一定的误判率

理论情况下添加到集合中的元素越多，误报的可能性就越大，并且存放在布隆过滤器的数据不容易删除

位数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1，这样申请一个 100w个元素的位数组只占用 `1000000Bit/8 = 125000 Byte = 125000/1024 kb ≈ 122kb` 的空间

**基本使用**

利用Google开源的 Guava中自带的布隆过滤器

```xml
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>28.0-jre</version>
</dependency>
```

我们创建了一个最多存放 最多 1500个整数的布隆过滤器，并且我们可以容忍误判的概率为百分之（0.01）

```java
// 创建布隆过滤器对象
BloomFilter<Integer> filter = BloomFilter.create(
        Funnels.integerFunnel(),
        1500,
        0.01);
// 判断指定元素是否存在
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
// 将元素添加进布隆过滤器
filter.put(1);
filter.put(2);
System.out.println(filter.mightContain(1));
System.out.println(filter.mightContain(2));
```

当mightContain()方法返回true时，我们可以99％确定该元素在过滤器中，当过滤器返回false时，我们可以100％确定该元素不存在于过滤器

**Redis中的布隆过滤器**

Redis v4.0 之后有了 Module（模块/插件） 功能，Redis Modules 让 Redis 可以使用外部模块扩展其功能 ，布隆过滤器就是其中的 Module

* 详情可以查看 Redis 官方对 Redis Modules 的介绍 ：https://redis.io/modules

官网推荐了一个 RedisBloom 作为 Redis 布隆过滤器的 Module，地址：https://github.com/RedisBloom/RedisBloom

**如何减少布隆过滤器的误判？**

关于减少误判的产生，方法有两个：

* 第一个是增加二进制位数。在原始情况下我们设置索引位到达了 100，但是如果我们把它放大 1 万倍，到达了 100 万，是不是 Hash 以后的数据会变得更分散，出现重复的情况就会更小，这是第一种方式。

* 第二个是增加 Hash 的次数。其实每一次 Hash 处理都是在增加数据的特征，特征越多，出现误判的概率就越小。

**布隆过滤器在项目中的应用**

* 第一个部分是在应用启动时，我们去初始化布隆过滤器

例如将 1000 个、1 万个、10 万个商品进行初始化，完成从 0 到 1 的转化工作。

之后便是当用户发来请求时，会附加商品编号，如果布隆过滤器判断编号存在，则直接去读取存储在 Redis 缓存中的数据；

如果此时 Redis 缓存没有存在对应的商品数据，则直接去读取数据库，并将读取到的信息重新载入到 Redis 缓存中，这样下一次用户在查询相同编号数据时，就可以直接读取缓存了。

其实在大多数情况下，我们出现误判也不会对系统产生额外的影响。因为像刚才我们设置 1% 的误判率，1 万次请求才可能会出现 100 次误判的情况。我们已经将 99% 的无效请求进行了拦截，而这些漏网之鱼也不会对我们系统产生任何实质影响。

* 另外一种情况是，如果布隆过滤器判断没有包含编号，则直接返回数据不存在的消息提示，这样便可以在 Redis 层面将请求进行拦截。

**延伸问题：初始化后，对应商品被删怎么办？**

假如布隆过滤器初始化后，对应商品被删除了，该怎么办呢？这是一个布隆过滤器的小难点。

因为布隆过滤器某一位的二进制数据，可能被多个编号的 Hash 位进行引用，比如说，布隆过滤器中 2 号位是 1，但是它可能被 3、5、100、1000 这 4 个商品编号同时引用，这里是不允许直接对布隆过滤器某一位进行删除的，否则数据就乱了，怎么办呢？

**这里业内有两种常见的解决方案：**

* 定时异步重建布隆过滤器：比如说我们每过 4 个小时在额外的一台服务器上，异步去执行一个任务调度，来重新生成布隆过滤器，替换掉已有的布隆过滤器。

* 计数布隆过滤器：在标准的布隆过滤器下，是无法得知当前某一位它是被哪些具体数据进行了引用，但是计数布隆过滤器它是在这一位上额外的附加的计数信息，表达出该位被几个数据进行了引用。

**使用场景**

布隆过滤器的巨大用处就是，能够迅速判断一个元素是否在一个集合中。

因此他有如下三个使用场景:

1. 网页爬虫对URL的去重，避免爬取相同的URL地址
2. 反垃圾邮件，从数十亿个垃圾邮件列表中判断某邮箱是否垃圾邮箱（同理，垃圾短信）
3. 缓存穿透，将已存在的缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉。

缓存穿透，将所有可能存在的数据缓存放到布隆过滤器中，当黑客访问不存在的缓存时迅速返回避免缓存及DB挂掉

```java
String get(String key) {
    String value = redis.get(key);     
    if (value  == null) {
        if(!bloomfilter.mightContain(key)){
            return null; 
        }else{
            value = db.get(key); 
            redis.set(key, value); 
        }    
    }
    return value；
}
```