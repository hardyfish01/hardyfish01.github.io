---
title: 常见面试题
categories: 
- 计算机基础
- 操作系统相关
---

**进程、线程的区别**

操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。

<img src="https://img-blog.csdnimg.cn/49e02558c5a946ac9509a2f5d77b3739.png" style="zoom:25%;" />

调度：线程作为CPU调度和分配的基本单位，进程作为拥有资源的基本单位；

并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行；

> 拥有资源：

进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源。

进程所维护的是程序所包含的资源（静态资源）， 如：地址空间，打开的文件句柄集，文件系统状态，信号处理handler等；

线程所维护的运行相关的资源（动态资源），如：运行栈，调度相关的控制信息，待处理的信号集等；

> 系统开销：

在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。

但是进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。

线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个进程死掉就等于所有的线程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。

**一个进程可以创建多少线程**

理论上，一个进程可用虚拟空间是2G，默认情况下，线程的栈的大小是1MB，所以理论上最多只能创建2048个线程。

如果要创建多于2048的话，必须修改编译器的设置。

在一般情况下，你不需要那么多的线程，过多的线程将会导致大量的时间浪费在线程切换上，给程序运行效率带来负面影响。

**外中断和异常有什么区别**

外中断是指由 CPU 执行指令以外的事件引起，如 I/O 完成中断，表示设备输入/输出处理已经完成，处理器能够发送下一个输入/输出请求，此外还有时钟中断、控制台中断等。

而异常时由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。

**解决Hash冲突四种方法**

开放定址法

- 开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。

链地址法

- 将哈希表的每个单元作为链表的头结点，所有哈希地址为i的元素构成一个同义词链表。即发生冲突时就把该关键字链在以该单元为头结点的链表的尾部。

再哈希法

- 当哈希地址发生冲突用其他的函数计算另一个哈希函数地址，直到冲突不再产生为止。

建立公共溢出区

- 将哈希表分为基本表和溢出表两部分，发生冲突的元素都放入溢出表中。

**分页机制和分段机制有哪些共同点和区别**

共同点

- 分页机制和分段机制都是为了提高内存利用率，较少内存碎片。
- 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存是连续的。

区别

- 页的大小是固定的，由操作系统决定；而段的大小不固定，取决于我们当前运行的程序。
- 分页仅仅是为了满足操作系统内存管理的需求，而段是逻辑信息的单位，在程序中可以体现为代码段，数据段，能够更好满足用户的需要。
- 分页是一维地址空间，分段是二维的。

**介绍一下几种典型的锁**

> 读写锁

- 可以同时进行多个读
- 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）
- 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）

> 互斥锁

一次只能一个线程拥有互斥锁，其他线程只有等待

互斥锁是在抢锁失败的情况下主动放弃CPU进入睡眠状态直到锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁的状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁操作时涉及上下文的切换。

互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁（每次占用锁的时间很短）的效果可能不亚于使用自旋锁

> 条件变量

互斥锁一个明显的缺点是他只有两种状态：锁定和非锁定。

而条件变量通过允许线程阻塞和等待另一个线程发送信号的方法弥补了互斥锁的不足，他常和互斥锁一起使用，以免出现竞态条件。

当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。

一旦其他的某个线程改变了条件变量，他将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。

总的来说**互斥锁是线程间互斥的机制，条件变量则是同步机制。**

> 自旋锁

如果进线程无法取得锁，进线程不会立刻放弃CPU时间片，而是一直循环尝试获取锁，直到获取为止。

如果别的线程长时期占有锁，那么自旋就是在浪费CPU做无用功，但是自旋锁一般应用于加锁时间很短的场景，这个时候效率比较高。

虽然它的效率比互斥锁高，但是它也有些不足之处：

- 自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。
- 在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。

**如何让进程后台运行**

1.命令后面加上&即可，实际上，这样是将命令放入到一个作业队列中了

2.ctrl + z 挂起进程，使用jobs查看序号，在使用bg %序号后台运行进程

3.nohup + &，将标准输出和标准错误缺省会被重定向到 `nohup.out` 文件中，忽略所有挂断（SIGHUP）信号

```
nohup ping www.ibm.com &
```

4.运行指令前面 + setsid，使其父进程变成init进程，不受SIGHUP信号的影响

```
[root@pvcent107 ~]# setsid ping www.ibm.com
[root@pvcent107 ~]# ps -ef |grep www.ibm.com
root     31094     1  0 07:28 ?        00:00:00 ping www.ibm.com
root     31102 29217  0 07:29 pts/4    00:00:00 grep www.ibm.com
```

上例中我们的进程 ID(PID)为31094，而它的父 ID（PPID）为1（即为 init 进程 ID），并不是当前终端的进程 ID。

> 5.将命令+ &放在()括号中，也可以是进程不受HUP信号的影响

```
[root@pvcent107 ~]# (ping www.ibm.com &)
```

**异常和中断的区别**

> 中断

当我们在敲击键盘的同时就会产生中断，当硬盘读写完数据之后也会产生中断，所以，我们需要知道，中断是由硬件设备产生的，而它们从物理上说就是电信号，之后，它们通过中断控制器发送给CPU，接着CPU判断收到的中断来自于哪个硬件设备（这定义在内核中），最后，由CPU发送给内核，有内核处理中断。

下面这张图显示了中断处理的流程：

<img src="https://img-blog.csdnimg.cn/6c0a43b5915e44bf8d05b6d871fd3b25.png" style="zoom:25%;" />

> 异常

CPU处理程序的时候一旦程序不在内存中，会产生缺页异常；当运行除法程序时，当除数为0时，又会产生除0异常。

**异常是由CPU产生的，同时，它会发送给内核，要求内核处理这些异常**

下面这张图显示了异常处理的流程：

<img src="https://img-blog.csdnimg.cn/fa69b2ce6ee7405ea351b0e4acd2e616.png" style="zoom:25%;" />

> 相同点

- 最后都是由CPU发送给内核，由内核去处理
- 处理程序的流程设计上是相似的

> 不同点

- 产生源不相同，异常是由CPU产生的，而中断是由硬件设备产生的
- 内核需要根据是异常还是中断调用不同的处理程序
- 中断不是时钟同步的，这意味着中断可能随时到来；异常由于是CPU产生的，所以它是时钟同步的
- 当处理中断时，处于中断上下文中；处理异常时，处于进程上下文中