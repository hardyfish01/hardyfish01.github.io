---
title: 序列化
categories: 
- Apache Dubbo实战
---

**常见序列化算法**

> Apache Avro

与编程语言无关的序列化格式。

Avro 依赖于用户自定义的 Schema，在进行序列化数据的时候，无须多余的开销，就可以快速完成序列化，并且生成的序列化数据也较小。当进行反序列化的时候，需要获取到写入数据时用到的 Schema。

* 在 Kafka、Hadoop 以及 Dubbo 中都可以使用 Avro 作为序列化方案。

> FastJson

阿里开源的 JSON 解析库，可以解析 JSON 格式的字符串。

它支持将 Java 对象序列化为 JSON 字符串，反过来从 JSON 字符串也可以反序列化为 Java 对象。

> Fst（fast-serialization）

高性能 Java 对象序列化工具包，100% 兼容 JDK 原生环境，序列化速度大概是JDK 原生序列化的 4~10 倍，序列化后的数据大小是 JDK 原生序列化大小的 1/3 左右。

> Kryo

高效的 Java 序列化/反序列化库，目前 Twitter、Yahoo、Apache 等都在使用该序列化技术，特别是 Spark、Hive 等大数据领域用得较多。Kryo 提供了一套快速、高效和易用的序列化 API。

无论是数据库存储，还是网络传输，都可以使用 Kryo 完成 Java 对象的序列化。

> Hessian2

支持动态类型、跨语言的序列化协议，Java 对象序列化的二进制流可以被其他语言使用。

* Hessian2 序列化之后的数据可以进行自描述，不会像 Avro 那样依赖外部的 Schema 描述文件或者接口定义。

* Hessian2 可以用一个字节表示常用的基础类型，这极大缩短了序列化之后的二进制流。

需要注意的是，在 Dubbo 中使用的 Hessian2 序列化并不是原生的 Hessian2 序列化，而是阿里修改过的 Hessian Lite，它是 Dubbo 默认使用的序列化方式。

其序列化之后的二进制流大小大约是 Java 序列化的 50%，序列化耗时大约是 Java 序列化的 30%，反序列化耗时大约是 Java 序列化的 20%。

> Protobuf（Google Protocol Buffers）

Google 公司开发的一套灵活、高效、自动化的、用于对结构化数据进行序列化的协议。

* 但相比于常用的 JSON 格式，Protobuf 有更高的转化效率，时间效率和空间效率都是 JSON 的 5 倍左右。

Protobuf 可用于通信协议、数据存储等领域，它本身是语言无关、平台无关、可扩展的序列化结构数据格式。

* 目前 Protobuf提供了 C++、Java、Python、Go 等多种语言的 API，GRPC 底层就是使用 Protobuf 实现的序列化。

**Serialize层**

Dubbo 为了支持多种序列化算法，单独抽象了一层 Serialize 层，在整个 Dubbo 架构中处于最底层，对应的模块是 dubbo-serialization 模块。

* 定义了 Dubbo 序列化层的核心接口，其中最核心的是 Serialization 接口，它是一个扩展接口，被 @SPI 接口修饰，默认扩展实现是 Hessian2Serialization。

Dubbo 提供了多个 Serialization 接口实现，用于接入各种各样的序列化算法。
