---
title: 秒杀系统
categories: 
- 架构师修炼之道
---

# 需求描述

**产品需求**

双十一业务要上线活动大促，需要通过秒杀这种玩法来为整个会场蓄流量。

* 秒杀活动的玩法是：指定几个商品，商品库存有限，同时每个商品还限制单个用户累计只能买N件。

**业务流程**

<img src="https://img-blog.csdnimg.cn/7c6de9f1dd0944af8c8da7cfefacfb47.png" style="zoom:25%;" />

通过对需求分析，我们提炼出秒杀活动的三大子流程：

* （运营）创建秒杀活动、（运营/买家）查看秒杀活动、（买家）参与秒杀活动；

**E-R 关系图**

> E-R关系图，用于指导如何建立领域模型。

从E-R图上我们能看出，几个比较重要的领域模型：

* 如活动、活动商品，系统真正编码落地的时候，就紧紧围绕这些领域模型去建模，做到代码和领域模型的表达是一致的。

<img src="https://img-blog.csdnimg.cn/7b5aafe18cd2406faffdcebdc2d51c6a.png" style="zoom:25%;" />

**产品边界**

活动上下文是我们关注的重点，同时也应该看到，我们需要商品团队、交易团队的协作。

<img src="https://img-blog.csdnimg.cn/cd21e414a3c149bab4211886ad831382.png" style="zoom:25%;" />

# 动静分离

**怎样对静态数据做缓存呢？**

第一，你应该把静态数据缓存到离用户最近的地方。

* 静态数据就是那些相对不会变化的数据，因此我们可以把它们缓存起来。缓存的地方常见的就三种，用户浏览器里、CDN上或者在服务端的Cache中。你应该根据情况，把它们尽量缓存到离用户最近的地方。

* 第二，静态化改造就是要直接缓存HTTP连接。静态化改造是直接缓存HTTP连接而不是仅仅缓存数据，Web代理服务器根据请求URL，直接取出对应的HTTP响应头和响应体然后直接返回，这个响应过程简单得连HTTP协议都不用重新组装，甚至连HTTP请求头也不需要解析。

**如何做动静分离的改造**

用缓存的方式来处理静态数据。

而动态内容的处理通常有两种方案：

1. 在Web代理服务器上做动态内容请求，并将请求插入到静态页面中，当用户拿到页面时已经是一个完整的页面了。这种方式对服务端性能有些影响，但是用户体验较好。
2. 单独发起一个异步JavaScript 请求，以向服务端获取动态内容。这种方式服务端性能更佳，但是用户端页面可能会延时，体验稍差。

**动静分离的架构方案**

> 方案：使用CDN

让用户的请求先回源的CDN的二级Cache中，如果没命中再回源站获取数据，部署方式如下图所示：

<img src="https://img-blog.csdnimg.cn/261cb68abb5b4f6eb3810b8113701ea1.png" style="zoom:25%;" />

# 热点数据

**发现热点数据**

用户访问商品时经过的路径有很多，主要是依赖前面的导购页面（包括首页、搜索页面、商品详情、购物车等）提前识别哪些商品的访问量高，通过这些系统中的中间件来收集热点数据，并记录到日志中。

<img src="https://img-blog.csdnimg.cn/7ca815395eb947a784744f1f5a04a661.png" style="zoom:25%;" />

我们通过部署在每台机器上的Agent把日志汇总到聚合和分析集群中，然后把符合一定规则的热点数据，通过订阅分发系统再推送到相应的系统中。

你可以是把热点数据填充到Cache中，或者直接推送到应用服务器的内存中，还可以对这些数据进行拦截，总之下游系统可以订阅这些数据，然后根据自己的需求决定如何处理这些数据。

**处理热点数据**

> 优化热点数据

最有效的办法就是缓存热点数据，如果热点数据做了动静分离，那么可以长期缓存静态数据。

但是，缓存热点数据更多的是临时缓存，即不管是静态数据还是动态数据，都用一个队列短暂地缓存数秒钟，由于队列长度有限，可以采用LRU淘汰算法替换。

> 限制流量

一种保护机制，限制的办法也有很多，例如对被访问商品的ID做一致性Hash，然后根据Hash做分桶，每个分桶设置一个处理队列，这样可以把热点商品限制在一个请求队列里，防止因某些热点商品占用太多的服务器资源，而使其他请求始终得不到服务器的处理资源。

> 隔离操作

秒杀系统设计的第一个原则就是将这种热点数据隔离出来，不要让1%的请求影响到另外的99%，隔离出来后也更方便对这1%的请求做针对性的优化。

我们可以在以下几个层次实现隔离：

1. **业务隔离**。把秒杀做成一种营销活动，卖家要参加秒杀这种营销活动需要单独报名，从技术上来说，卖家报名后对我们来说就有了已知热点，因此可以提前做好预热。
2. **系统隔离**。系统隔离更多的是运行时的隔离，可以通过分组部署的方式和另外99%分开。秒杀可以申请单独的域名，目的也是让请求落到不同的集群中。
3. **数据隔离**。秒杀所调用的数据大部分都是热点数据，比如会启用单独的Cache集群或者MySQL数据库来放热点数据，目的也是不想0.01%的数据有机会影响99.99%数据。

# 减库存设计

**减库存有哪几种方式**

- **下单减库存**，即当买家下单后，在商品的总库存中减去买家购买数量。下单减库存是最简单的减库存方式，也是控制最精确的一种，下单时直接通过数据库的事务机制控制商品库存，这样一定不会出现超卖的情况。但是你要知道，有些人下完单可能并不会付款。
- **付款减库存**，即买家下单后，并不立即减库存，而是等到有用户付款后才真正减库存，否则库存一直保留给其他买家。但因为付款时才减库存，如果并发比较高，有可能出现买家下单后付不了款的情况，因为可能商品已经被其他人买走了。
- **预扣库存**，这种方式相对复杂一些，买家下单后，库存为其保留一定的时间（如10分钟），超过这个时间，库存将会自动释放，释放后其他买家就可以继续购买。在买家付款前，系统会校验该订单的库存是否还有保留：如果没有保留，则再次尝试预扣；如果库存不足（也就是预扣失败）则不允许继续付款；如果预扣成功，则完成付款并实际地减去库存。

**减库存可能存在的问题**

假如我们采用**下单减库存**的方式，即用户下单后就减去库存，正常情况下，买家下单后付款的概率会很高，所以不会有太大问题。

* 如果有竞争对手通过恶意下单的方式将该卖家的商品全部下单，让这款商品的库存减为零，那么这款商品就不能正常售卖了。要知道，这些恶意下单的人是不会真正付款的，这正是**下单减库存**方式的不足之处。

**付款减库存**方式：

* 会导致库存超卖。

假如有100件商品，就可能出现300人下单成功的情况，因为下单时不会减库存，所以也就可能出现下单成功数远远超过真正库存数的情况，这尤其会发生在做活动的热门商品上。这样一来，就会导致很多买家下单成功但是付不了款，买家的购物体验自然比较差。

既然**下单减库存**和**付款减库存**都有缺点，我们能否把两者相结合，将两次操作进行前后关联起来，下单时先预扣，在规定时间内不付款再释放库存，即采用**预扣库存**这种方式呢？

> 这种方案确实可以在一定程度上缓解上面的问题，但是没有彻底解决！

针对恶意下单这种情况，虽然把有效的付款时间设置为10分钟，但是恶意买家完全可以在10分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。

* 例如，给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买3件），以及对重复下单不付款的操作进行次数限制等。

针对**库存超卖**这种情况，在10分钟时间内下单的数量仍然有可能超过库存数量，遇到这种情况我们只能区别对待：对普通的商品下单数量超过库存数量的情况，可以通过补货来解决；但是有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。

**大型秒杀中如何减库存？**

目前来看，业务系统中最常见的就是预扣库存方案，像你在买机票、买电影票时，下单后一般都有个有效付款时间，超过这个时间订单自动释放，这都是典型的预扣库存方案。

> 而具体到秒杀这个场景，应该采用哪种方案比较好呢？

由于参加秒杀的商品，成功下单后却不付款的情况比较少，再加上卖家对秒杀商品的库存有严格限制，所以秒杀商品采用**下单减库存**更加合理。另外，理论上由于**下单减库存**比**预扣库存**以及涉及第三方支付的**付款减库存**在逻辑上更为简单，所以性能上更占优势。

**下单减库存**在数据一致性上，主要就是保证大并发请求时库存数据不能为负数，也就是要保证数据库中的库存字段值不能为负数，一般我们有多种解决方案：

* 一种是在应用程序中通过事务来判断，即保证减后库存不能为负数，否则就回滚；

* 另一种办法是直接设置数据库的字段数据为无符号整数，这样减后库存字段值小于零时会直接执行SQL语句来报错；

* 再有一种就是使用CASE WHEN判断语句，例如这样的SQL语句：

```sql
UPDATE item SET inventory = CASE WHEN inventory >= xxx THEN inventory-xxx ELSE inventory END
```

**如何在缓存中减库存以及如何在数据库中减库存**

秒杀商品和普通商品的减库存还是有些差异的，例如商品数量比较少，交易时间段也比较短，能否把秒杀商品减库存直接放到缓存系统中实现，也就是直接在缓存中减库存或者在一个带有持久化功能的缓存系统（如Redis）中完成呢？

> 如果你的秒杀商品的减库存逻辑非常单一，比如没有复杂的SKU库存和总库存这种联动关系的话，完全可以。
>
> 但是如果有比较复杂的减库存逻辑，或者需要使用事务，你还是必须在数据库中完成减库存。

由于MySQL存储数据的特点，同一数据在数据库里肯定是一行存储，因此会有大量线程来竞争InnoDB行锁，而并发度越高时等待线程会越多，TPS（即每秒处理的消息数）会下降，响应时间（RT）会上升，数据库的吞吐量就会严重受影响。

这就可能引发一个问题，就是单个热点商品会影响整个数据库的性能， 导致0.01%的商品影响99.99%的商品的售卖，这是我们不愿意看到的情况。

> 一个解决思路是进行隔离，把热点商品放到单独的热点库中。
>
> 但是这无疑会带来维护上的麻烦，比如要做热点数据的动态迁移以及单独的数据库等。

而分离热点商品到单独的数据库还是没有解决并发锁的问题，我们应该怎么办呢？要解决并发锁的问题，有两种办法：

- **应用层做排队**。按照商品维度设置队列顺序执行，这样能减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库连接的数量，防止热点商品占用太多的数据库连接。
- **数据库层做排队**。应用层只能做到单机的排队，但是应用机器数本身很多，这种排队方式控制并发的能力仍然有限，所以如果能在数据库层做全局排队是最理想的。