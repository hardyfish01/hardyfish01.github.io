---
title: 异地多活
categories: 
- 架构师修炼之道
---

**一个好的软件架构应该遵循以下 3 个原则：**

1. 高性能
2. 高可用
3. 易扩展

其中，高性能意味着系统拥有更大流量的处理能力，更低的响应延迟。例如 1 秒可处理 10W 并发请求，接口响应时间 5 ms 等等。

易扩展表示系统在迭代新功能时，能以最小的代价去扩展，系统遇到流量压力时，可以在不改动代码的前提下，去扩容系统。

**高可用通常用 2 个指标来衡量：**

- **平均故障间隔 MTBF**（Mean Time Between Failure）：表示两次故障的间隔时间，也就是系统正常运行的平均时间，这个时间越长，说明系统稳定性越高
- **故障恢复时间 MTTR**（Mean Time To Repair）：表示系统发生故障后恢复的时间，这个值越小，故障对用户的影响越小

**可用性与这两者的关系：**

> 可用性（Availability）= MTBF / (MTBF + MTTR) * 100%

这个公式得出的结果是一个比例，通常我们会用 **N 个 9** 来描述一个系统的可用性。

<img src="https://img-blog.csdnimg.cn/715fc8a9c2c7451bbf23ec26f4efe6d6.png" style="zoom:25%;" />

从这张图可以看到，要想达到 4 个 9 以上的可用性，平均每天故障时间必须控制在 10 秒以内。

也就是说，只有故障的时间越短，整个系统的可用性才会越高，每提升 1 个 9，都会对系统提出更高的要求。

**同城灾备**

可以在同一个城市再搭建一个机房，原机房我们叫作 A 机房，新机房叫 B 机房，这两个机房的网络用一条专线连通。

A 机房的数据，定时在 B 机房做备份（拷贝数据文件），这样即使整个 A 机房遭到严重的损坏，B 机房的数据不会丢，通过备份可以把数据恢复回来，重启服务。

> 但备份的问题：数据不完整、恢复数据期间业务不可用，整个系统的可用性还是无法得到保证。

所以，我们还是需要用**主从副本**的方式，在 B 机房部署 A 机房的数据副本。

**同城双活**

A 机房挂掉，全部流量切到 B 机房，B 机房能否真的如我们所愿，正常提供服务？

> 我们需要让 B 机房也接入流量，实时提供服务！

因为 A 机房的存储都是主库，所以我们把 A 机房叫做主机房，B 机房叫从机房。

两个机房部署在同城，物理距离比较近，而且两个机房用专线网络连接，虽然跨机房访问的延迟，比单个机房内要大一些，但整体的延迟还是可以接受的。

B 机房慢慢接入流量，从 10%、30%、50% 逐渐覆盖到 100%，你可以持续观察 B 机房的业务是否存在问题，有问题及时修复，逐渐让 B 机房的工作能力，达到和 A 机房相同水平。

**两地三中心**

两地是指 2 个城市，三中心是指有 3 个机房，其中 2 个机房在同一个城市，并且同时提供服务，第 3 个机房部署在异地，只做数据灾备。

这种架构方案，通常用在银行、金融、政企相关的项目中。

> 它的问题：启用灾备机房需要时间，而且启用后的服务，不确定能否如期工作。

所以，要想真正的抵御城市级别的故障，越来越多的互联网公司，开始实施**异地双活**。

**异地双活**

我们不再把 A、B 机房部署在同一个城市，而是分开部署，例如 A 机房放在北京，B 机房放在上海。

> 这样的话需要在**存储层**做改造了。

两个机房的存储必须都是**主库**，而且两个机房的数据还要**互相同步**数据，即客户端无论写哪一个机房，都能把这条数据同步到另一个机房。

因为只有两个机房都拥有全量数据，才能支持任意切换机房，持续提供服务。

**怎么实现这种双主架构呢？**

MySQL 本身就提供了双主架构，它支持双向复制数据，需要对应的数据同步中间件来实现双向同步的功能。

> 业界也开源出了很多数据同步中间件，例如阿里的 Canal、RedisShake、MongoShake，可分别在两个机房同步 MySQL、Redis、MongoDB 数据。

**如何实施异地双活**

> 按业务类型分片

举例：假设我们一共有 4 个应用，北京和上海机房都部署这些应用。

但应用 1、2 只在北京机房接入流量，在上海机房只是热备。应用 3、4 只在上海机房接入流量，在北京机房是热备。

这样一来，应用 1、2 的所有业务请求，只读写北京机房存储，应用 3、4 的所有请求，只会读写上海机房存储。

> 直接哈希分片

这种方案就是，最上层的路由层，会根据用户 ID 计算哈希取模，然后从路由表中找到对应的机房，之后把请求转发到指定机房内。

举例：一共 200 个用户，根据用户 ID 计算哈希值，然后根据路由规则，把用户 1 - 100 路由到北京机房，101 - 200 用户路由到上海机房，这样，就避免了同一个用户修改同一条数据的情况发生。

> 按地理位置分片

这种方案，非常适合与地理位置密切相关的业务，例如打车、外卖服务就非常适合这种方案。

拿外卖服务举例，你要点外卖肯定是就近点餐，整个业务范围相关的有商家、用户、骑手，它们都是在相同的地理位置内的。

针对这种特征，就可以在最上层，按用户的地理位置来做分片，分散到不同的机房。

举例：北京、河北地区的用户点餐，请求只会打到北京机房，而上海、浙江地区的用户，请求则只会打到上海机房。这样的分片规则，也能避免数据冲突。