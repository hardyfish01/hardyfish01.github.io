---
title: Hystrix
categories: 
- SpringCloud微服务实战
---

Hystrix 是由 Netflix 发布的针对微服务分布式系统的熔断保护中间件，相当于电路中的保险丝，它的关注度也非常高，在 GitHub 上已经有超过 18000 颗星，也经过了 Netflix 线上大规模流量的验证，性能非常稳定。

在微服务架构下，很多服务都相互依赖，如果不能对依赖的服务进行隔离，那么服务本身也有可能发生故障，Hystrix 通过HystrixCommand 对调用进行隔离，这样可以阻止故障的连锁反应，能够快速失败并迅速恢复服务或者进行回退并优雅降级。

Spring Cloud 将原生 Hystrix 整合进来，提供了最简洁的使用方式，并且跟 Feign、Zuul 等组件做了集成，极大的降低了使用的难度。

**工作原理**

* 第 1 步是构建一个 HystrixCommand 或者 HystrixObservableCommand 对象，将请求包装到 Command 对象中。

* 第 2 步就是执行构建好的命令。

* 第 3 步是判断当前请求是否有缓存，如果在缓存中就直接返回缓存的内容。

* 第 4 步是判断断路器是否处于打开的状态，如果是打开状态，那么 Hystrix 就不再会去执行命令，直接跳到第 8 步，获取 fallback 方法，执行 fallback 逻辑，也就是回退逻辑。 

* 如果断路器没有打开，那么继续执行第 5 步，判断是否能够执行该命令，如果是线程池隔离模式，会判断线程池队列的容量，如果是信号量隔离模式，会判断信号量的值是否已经被使用完。

* 如果线程池和信号量都已经满了，那么同样请求不会再执行，会直接跳到第 8 步。

* 如果容量满足执行条件，那么继续第 6 步，执行` HystrixObservableCommand.construct() `或者`  HystrixCommand.run() `方法，正在执行的请求逻辑就封装在 construct() 或者 run() 方法中。

* 在执行过程中，如果出现异常或超时，会直接到第 8 步，执行成功就返回结果，需要注意的是执行的结果会将数据上报给断路器，断路器会根据上报的数据来判断断路器是否打开。

到此为止，整个 Hystrix 的工作便完成了。

**Hystrix隔离方式**            

Hystrix 支持线程池和信号量两种隔离方式

* 线程池隔离是当用户请求到 A 服务后，A 服务需要调用其他服务，这个时候可以为不同的服务创建独立的线程池，假如 A 需要调用 B 和 C，那么可以创建 2 个独立的线程池，将调用 B 服务的线程丢入到一个线程池，将调用 C 服务的线程丢入到另一个线程池，这样就起到隔离效果，就算其中某个线程池请求满了，无法处理请求了，对另一个线程池也没有影响。 

* 信号量隔离就比较简单了，信号量就是一个计数器，比如初始化值是 100，那么每次请求过来的时候就会减 1，当信号量计数为 0 的时候，请求就会被拒绝，等之前的请求处理完成后，信号量会加 1，同时也起到了限流的作用，这就是信号量隔离，信号量隔离是在请求主线程中执行的。

线程池隔离的特点是 Command 运行在独立的线程池中，可以支持超时，是单独的线程，支持异步。

信号量隔离运行在调用的主线程中，不支持超时，只能同步调用。