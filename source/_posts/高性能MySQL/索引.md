---
title: 索引
categories: 
- 高性能MySQL
---

索引是帮助MySQL高效获取数据的数据结构，简单理解为：排好序的快速查找数据结构

**索引分类**

按结构分：

* Hash索引和B+树索引

根据索引字段个数划分：

* 单值和复合索引

根据是否是在主键上建立的索引进行划分：

* 主键索引，辅助索引

根据数据与索引的存储关联性划分：

* 聚簇索引/非聚簇索引

其他分类：唯一索引，全文索引

**聚簇索引/非聚簇索引**

* 聚簇索引：Innodb的主键索引，非叶子节点存储的是索引指针，叶子节点存储的是既有索引也有数据

* 非聚簇索引：MyISAM中索引和数据文件分开存储，B+Tree的叶子节点存储的是数据存放的地址，而不是具体的数据

**二级索引**

针对`select * from table where name='xx'`这样的语句，你先根据name字段值在name字段的索引B+树里找，找到叶子节点也仅仅可以找到对应的主键值，而找不到这行数据完整的所有字段。

此时还需要进行回表，这个回表，就是说还需要根据主键值，再到聚簇索引里从根节点开始，一路找到叶子节点的数据页，定位到主键对应的完整数据行，此时才能把`select *`要的全部字段值都拿出来。

**联合索引查询原理以及全值匹配规则**

有一个表是存储学生成绩的，这个表当然有id了，这个id是一个自增主键，默认就会基于它做一个聚簇索引。

* 平时查询，可能比较多的就是查找某个班的某个学生的某个科目的成绩。

可以针对学生班级、学生姓名和科目名称建立一个联合索引。

<img src="https://img-blog.csdnimg.cn/0579693fb8a74e1894ec3ac97eca05c0.png" style="zoom:50%;" />

有两个数据页，第一个数据页里有三条数据，每条数据都包含了联合索引的三个字段的值和主键值，数据页内部是按照顺序排序的。

* 首先按照班级字段的值来排序，如果一样则按照学生姓名字段来排序，如果一样，则按照科目名称来排序，所以数据页内部都是按照三个字段的值来排序的，而且还组成了单向链表。

* 数据页之间也是有顺序的，第二个数据页里的三个字段的值一定都大于上一个数据页里三个字段的值，比较方法也是按照班级名称、学生姓名、科目名称依次来比较的，数据页之间组成双向链表。

索引页里就是两条数据，分别指向两个数据页，索引存放的是每个数据页里最小的那个数据的值，索引页里指向两个数据页的索引项里都是存放了那个数据页里最小的值！

* 索引页内部的数据页是组成单向链表有序的，如果有多个索引页，那么索引页之间也是有序的，组成了双向链表。

假设想要搜索：1班+王五+数学的成绩，此时可能会写一个类似下面的SQL语句：

```sql
select * from student_score where class_name=‘1班’ and student_name=‘王五’ and subject_name=‘数学’
```

上面的SQL语句是百分百可以用联合索引来查询的。

* 首先到索引页里去找，索引页里有多个数据页的最小值记录，此时直接在索引页里基于二分查找法来找就可以了，先是根据班级名称来找1班这个值对应的数据页，直接可以定位到它所在的数据页。

* 然后就直接找到索引指向的那个数据页就可以了，在数据页内部本身也是一个单向链表，也是直接就做二分查找就可以了，先按1班这个值来找，会发现几条数据都是1班，此时就可以按照王五这个姓名来二分查找，如果会发现多条数据都是王五，接着就会按照科目名称数学来二分查找，找到主键id=127的数据。

* 然后就根据主键id=127到聚簇索引里按照一样的思路，从索引根节点开始二分查找迅速定位下个层级的页，再不停的找，很快就可以找到id=127的那条数据，然后从里面提取所有字段，包括分数，就可以了。

对于联合索引而言，就是依次按照各个字段来进行二分查找，先定位到第一个字段对应的值在哪个页里，然后如果第一个字段有多条数据值都一样，就根据第二个字段来找，以此类推，一定可以定位到某条或者某几条数据！

**索引结构**

MySQL使用B+树作为索引结构

![](https://img-blog.csdnimg.cn/fe2bdc29aaa645ee8839cce481d5db84.png)

**B+树索引的特点是：** 

* 基于磁盘的平衡树，但树非常矮，通常为 3~4 层，能存放千万到上亿的排序数据。

* 树矮意味着访问效率高，从千万或上亿数据里查询一条数据，只用 3、4 次 I/O。

* 又因为现在的固态硬盘每秒能执行至少 10000 次 I/O ，所以查询一条数据，哪怕全部在磁盘上，也只需要 0.003 ~ 0.004 秒。

* 另外，因为 B+ 树矮，在做排序时，也只需要比较 3~4 次就能定位数据需要插入的位置，排序效率非常不错。

* B+ 树索引由根节点（root node）、中间节点（non leaf node）、叶子节点组成，其中叶子节点存放所有排序后的数据

* 当 B+ 树的高度大于等于 2 时，根节点和中间节点存放的是索引键对，由（索引键、指针）组成。

* 索引键就是排序的列，而指针是指向下一层的地址，在 MySQL 的 InnoDB 存储引擎中占用 6 个字节。

如果我们使用的是MyISAM存储引擎，由于MyISAM使用的是辅助索引，索引中每一个叶子节点仅仅记录的是每行数据的物理地址，即行指针，如下图所示：

<img src="https://img-blog.csdnimg.cn/f72e085fc82b4c79b640d70c2c35849d.png" style="zoom:50%;" />

如果我们使用的是InnoDB存储引擎，由于InnoDB使用的是聚簇索引，聚簇索引中的叶子节点则记录了主键值、事务id、用于事务和MVCC的回流指针以及所有的剩余列，如下图所示：

<img src="https://img-blog.csdnimg.cn/ed85ca4e31b841eb9995038e4feea95f.png" style="zoom:50%;" />

**B+树比B树更适合数据库索引的原因**

* B+树的查询效率更加稳定，任何关键字的查找必须走一条从根结点到叶子结点，所有关键字查询的路径长度相同，导致每一个数据的查询效率相当

* 由于非叶子节点不存储 data，所以一个节点可以存储更多的索引节点，每个节点能索引的范围更大更精确，也就是说使用 B+树单次磁盘 I/O 的信息量相比较 B 树更大，I/O 效率更高

* B+树只要遍历叶子节点就可以实现整棵树的遍历，支持基于范围的查询

**页分裂**

* 你的主键并不是自增长的，可能会出现你后一个数据页的主键值里，有的主键是小于前 一个数据页的主键值的。

* 使用非自增主键，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为页分裂。

**覆盖索引**

针对类似`select xx1,xx2,xx3 from table order by xx1,xx2,xx3`这样的 语句，这种情况下，你仅仅需要联合索引里的几个字段的值，那么其实就只要扫描联合索引的索引树就可以了，不需要 回表去聚簇索引里找其他字段了。

* 所以这个时候，需要的字段值直接在索引树里就能提取出来，不需要回表到聚簇索引，这种查询方式就是覆盖索引

通常在InnoDB中，除了查询部分字段可以使用覆盖索引来优化查询性能之外，统计数量也会用到。

例如，`SELECT COUNT(*)`时，如果不存在辅助索引，此时会通过查询聚簇索引来统计行数，如果此时正好存在一个辅助索引，则会通过查询辅助索引来统计行数，减少I/O操作。

# 索引失效

**最佳左前缀法则**

* 如果索引了多个列，要遵守最佳左前缀法则。指的是查询从索引的最左前列开始 并且 不跳过索引中的列

不要在索引上做任何操作（计算、函数、自动/手动类型转换），不然会导致索引失效而转向全表扫描

```sql
select * from tradelog where id + 1 = 10000
//where id = 10000 -1
```

* 不能继续使用索引中范围条件（bettween、<、>、in等）右边的列

* 尽量使用覆盖索引（只查询索引的列（索引列和查询列一致）），减少`select *`

* 索引字段上使用（！= 或者 < >）判断时，会导致索引失效而转向全表扫描

* 索引字段上使用 is null / is not null 判断时，会导致索引失效而转向全表扫描

* 索引字段使用like以通配符开头（%字符串）时，会导致索引失效而转向全表扫描

* 索引字段是字符串，但查询时不加单引号，会导致索引失效而转向全表扫描

* 索引字段使用 or 时，会导致索引失效而转向全表扫描

> 隐式字符编码转换

因为这两个表的字符集不同，一个是utf8，一个是utf8mb4，所以做表连接查询的时候用不上关联字段的索引

字符集utf8mb4是utf8的超集，所以当这两个类型的字符串在做比较的时候，MySQL内部的操作是，先把utf8字符串转成utf8mb4字符集，再做比较。

# 索引下推

**索引条件下推优化（Index Condition Pushdown (ICP) ）是MySQL5.6添加的，用于优化数据查询。** 

**索引条件下推优化可以减少存储引擎查询基础表的次数，也可以减少MySQL服务器从存储引擎接收数据的次数。** 

假设有一张people表,包含字段name、address、first_name

* 索引为**(name,address,first_name)**

然后我们执行下面的查询 

```sql
SELECT * FROM person WHERE `name` = "1" AND `address` LIKE "%222"
```

如果不使用索引条件下推优化的话，MySQL只能根据索引查询出name=1的所有行，然后再依次比较是否符合全部条件。

当使用了索引条件下推优化技术后，可以通过索引中存储的数据判断当前索引对应的数据是否符合条件，只有符合条件的数据才将整行数据查询出来，查看执行计划时发现extra一栏中有Using index condition信息，说明使用了索引下推。

* 索引下推优化是默认开启的。

# CBO

SQL 优化器会分析所有可能的执行计划，选择成本最低的执行，这种优化器称之为：

* CBO（Cost-based Optimizer，基于成本的优化器）。

在 MySQL中，一条 SQL 的计算成本计算如下所示：

```
Cost = Server Cost + Engine Cost
= CPU Cost + IO Cost
```

* CPU Cost：表示计算的开销，比如索引键值的比较、记录值的比较、结果集的排序……这些操作都在 Server 层完成；

* IO Cost：表示引擎层 IO 的开销，MySQL 8.0 可以通过区分一张表的数据是否在内存中，分别计算读取内存 IO 开销以及读取磁盘 IO 的开销。

* IO成本，是从磁盘把数据加载到内存的成本。默认情况下，读取数据页的IO成本常数是1（也就是读取1个页成本是1）。

* CPU成本，是检测数据是否满足条件和排序等CPU操作的成本。默认情况下，检测记录的成本是0.2。

在MySQL 5.6及之后的版本中，我们可以使用`optimizer trace`功能查看优化器生成执行计划的整个过程。

有了这个功能，我们不仅可以了解优化器的选择过程，更可以了解每一个执行环节的成本，然后依靠这些信息进一步优化查询。

# 索引合并

MySQL在 5.0版本中引入新特性：

* 索引合并优化，当查询中单张表可以使用多个索引时，同时扫描多个索引并将扫描结果进行合并。

通俗解释就是: 一条SQL中使用两个或多个索引，查出来的数据集取交集或并集。

**该特新主要应用于以下三种场景：**

* 对OR语句求并集，如查询`SELECT * FROM TB1 WHERE c1="xxx" OR c2="xxx"`时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果合并（union）操作，得到最终结果

* 对AND语句求交集，如查询`SELECT * FROM TB1 WHERE c1="xxx" AND c2="xxx"`时，如果c1和c2列上分别有索引，可以按照c1和c2条件进行查询，再将查询结果取交集（intersect）操作，得到最终结果

* 对AND和OR组合语句求结果。
