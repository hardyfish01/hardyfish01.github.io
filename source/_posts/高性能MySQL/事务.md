---
title: 事务
categories: 
- 高性能MySQL
---

**并发事务带来的问题**

脏写、脏读、不可重复读、幻读，都是因为业务系统会多线程并发执行，每个线程可能都会开启一个事务，每个事务都会执行增删改查操作。多个事务可能会并发的对缓存页里的同一批数据进行增删改查操作。

为了解决多事务并发问题，数据库才设计了事务隔离机制、MVCC多版本隔离机制、锁机制，用一整套机制来解决多事务并发问题。

> 1.数据丢失

![](https://img-blog.csdnimg.cn/c6067920668845e5941d078feb79647c.png)

> 2.脏读

![](https://img-blog.csdnimg.cn/19c33e0fe6644837967ac535a86b9b04.png)

> 3.不可重复读

![](https://img-blog.csdnimg.cn/61081a7f78b14189997e55768b9e8fce.png)

> 4.幻读

![](https://img-blog.csdnimg.cn/5a4a60066ff940c1b7cbad05f04aeecd.png)

**脏写**

他的本质就是事务B去修改了事务A修改过的值，但是此时事务A还没提交，所以事务A随时会回滚， 导致事务B修改的值也没了

**脏读**

他的本质其实就是事务B去查询了事务A修改过的数据，但是此时事务A还没提交，所以事务A随时会回滚导致事务B再次查询就读不到刚才事务A修改的数据了

无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据。

因为另外一个事务还没提交，所以他随时可能会反悔会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了

**不可重复读**

事务A在执行期间多次查询一条数据，每次都可以查到其它已经提交的事务修改过的值，那么就是不可重复读的。

假设你事务A刚开始执行，第一次查询读到的是值A，然后后续你希望事务执行期间，读到的一直都是这个值A，不管其它事务如何更新这个值，哪怕它们都提交了，你就希望你读到的一直是第一次查询到的值A，那么你就是希望可重复读的。

**幻读**

幻读指的就是你一个事务用一样的SQL多次查询，结果每次查询都会发现查到了一些之前没看到过的数据

> 在可重复读隔离级别下，普通的查询是快照读，是不会看到别的事务插入的数据的。因此，幻读在当前读下才会出现。

查询都是加了for update，都是当前读。而当前读的规则，就是要能读到所有已经提交的记录的最新值。

# ACID

**原子性**

根据定义，原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做，即要么转账成功，要么转账失败

**怎么保证原子性的**

利用Innodb的undo log

undo log名为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息

- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据

**隔离性**

根据定义，隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰

**怎么保证隔离性的**

利用的是锁和MVCC机制

**持久性**

根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的

**怎么保证持久性的**

利用Innodb的redo log

* 当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。

* 当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚数据还是提交数据

**一致性**

根据定义，一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的

**那什么是合法的数据状态**

这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的，满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的

# 事务隔离级别

<img src="https://img-blog.csdnimg.cn/5da327149627474081d16a7d12179ba8.png" style="zoom:50%;" />

**读未提交**

当隔离级别设置为Read uncommitted 时，就可能出现脏读

不允许发生脏写：不可能两个事务在没提交的情况下去更新同一行数据的值

**读已提交**

> Oracle和SQL Server默认隔离级别

当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读

**可重复读**

> MySQL默认隔离级别

Repeatable read避免了不可重复读，但还有可能出现幻读

这个级别下，不会发生脏写、脏读和不可重复读的问题，因为你一个事务多次查询一个数据的值，哪怕别的事务修改了这个值还提交了，你不会读到人家提交事务修改过的值，你事务一旦开始，多次查询一个值，会一直读到同一个值！

但是它还是会发生幻读的，因为假设你一次SQL是根据条件查询，比如`“select * from table where id>10”`，第一次查出来10条数据，结果另外一个事务插入了一条数据，下次你可能会查出来11条数据，还是会有幻读问题的！

> 在 RR隔离级别下，MySQL 为了解决幻读的问题，以牺牲并行度为代价，通过 Gap 锁来防止数据的写入，而这种锁，因为其并行度不够，冲突很多，经常会引起死锁。
>
> 现在流行的 Row 模式可以避免很多冲突甚至死锁问题，所以推荐默认使用 Row + RC模式的隔离级别，可以很大程度上提高数据库的读写并行度。

**什么时候需要可重复读的场景呢**？

我们来看一个数据校对逻辑的案例。

假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

**可序列化**

Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读

这种级别，根本就不允许你多个事务并发执行，只能串行起来执行，先执行事务A提交，然后执行事务B提交，接着执行事务C提交，所以此时你根本不可能有幻读的问题，因为事务压根儿都不并发执行！

**MySQL都有哪些锁机制**

InnoDB实现了两种类型的锁机制：共享锁（S）和排他锁（X）。

* 共享锁允许一个事务读数据，不允许修改数据，如果其他事务要再对该行加锁，只能加共享锁；

* 排他锁是修改数据时加的锁，可以读取和修改数据，一旦一个事务对该行数据加锁，其他事务将不能再对该数据加任务锁。

**InnoDB中的RC和RR隔离事务是基于多版本并发控制（MVCC）实现高性能事务。**

**控制事务的大小，减少锁定的资源量和锁定时间长度**

在抢购系统的日志中，在活动区间，我们经常可以看到这种异常日志：

```
MySQLQueryInterruptedException: Query execution was interrupted
```

由于在抢购提交订单中开启了事务，在高并发时对一条记录进行更新的情况下，由于更新记录所在的事务还可能存在其他操作，导致一个事务比较长，当有大量请求进入时，就可能导致一些请求同时进入到事务中。

* 又因为锁的竞争是不公平的，当多个事务同时对一条记录进行更新时，极端情况下，一个更新操作进去排队系统后，可能会一直拿不到锁，最后因超时被系统打断踢出。

在用户购买商品时，首先我们需要查询库存余额，再新建一个订单，并扣除相应的库存。这一系列操作是处于同一个事务的。

以上业务若是在两种不同的执行顺序下，其结果都是一样的，但在事务性能方面却不一样：

* 这是因为虽然这些操作在同一个事务，但锁的申请在不同时间，只有当其他操作都执行完，才会释放所有锁。

* 因为扣除库存是更新操作，属于行锁，这将会影响到其他操作该数据的事务，所以我们应该尽量避免长时间地持有该锁，尽快释放该锁。

* 又因为先新建订单和先扣除库存都不会影响业务，所以我们可以将扣除库存操作放到最后，也就是使用执行顺序1，以此尽量减小锁的持有时间。

![](https://img-blog.csdnimg.cn/5521bc7c0c6341b6897e19d3be623e7c.png)
