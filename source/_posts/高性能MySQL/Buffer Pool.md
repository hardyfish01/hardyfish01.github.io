---
title: Buffer Pool
categories: 
- 高性能MySQL
---

缓冲池（Buffer Pool），这里面会缓存很多的数据，以便于以后在查询的时候，万一你要是内存缓冲池里有数据，就可以不用去查磁盘了

<img src="https://img-blog.csdnimg.cn/da3dec69c2a944dcb67e805d2a00d695.png" style="zoom:25%;" />

**如果数据库突然崩溃了，那么内存里更新好的数据不是都没了吗？** 

* MySQL引入了一个redo log机制，你在对内存里的数据进行增删改的时候，他同时会把增删改对应的日志写入redo log中。

* 只要从redo log日志文件里读取出来你之前做过哪些增删改操作，瞬间就可以重新把这些增删改操作在你的内存里执行一遍，这就可以恢复出来你之前做过哪些增删改操作了。

**如何配置Buffer Pool的大小？**

Buffer Pool默认情况下是128MB。 

* 配置：`[server] innodb_buffer_pool_size = 2147483648`

假设我们要更新一行数据，此时数据库会找到这行数据所在的数据页，然后从磁盘文件里把这行数据所在的数据页直接给加载到Buffer Pool里去。 

**磁盘上的数据页和Buffer Pool中的缓存页是如何对应起来的？**

实际上默认情况下，磁盘中存放的数据页的大小是16KB，也就是说，一页数据包含了16KB的内容。 

Buffer Pool中默认情况下，一个缓存页的大小和磁盘上的一个数据页的大小是一一对应起来的，都是16KB。 

**缓存页对应的描述信息？**

对于每个缓存页，他实际上都会有一个描述信息，这个描述信息大体可以认为是用来描述这个缓存页的。

比如包含如下的一些东西：

* 这个数据页所属的表空间、数据页的编号、这个缓存页在Buffer Pool中的地址。 

* 每个缓存页都会对应一个描述信息，这个描述信息本身也是一块数据，在Buffer Pool中，每个缓存页的描述数据放在最前面，然后各个缓存页放在后面。

<img src="https://img-blog.csdnimg.cn/f3a252cda15b4467a227f03cb02518cc.png" style="zoom:25%;" />

Buffer Pool中的描述数据大概相当于缓存页大小的5%左右，也就是每个描述数据大概是800个字节左右的大小。

# Free链表

他是一个双向链表数据结构，这个free链表里，每个节点就是一个空闲的缓存页的描述数据块的地址，只要你一个缓存页是空闲的，那么他的描述数据块就会被放入这个free链表中。

* 刚开始数据库启动的时候，可能所有的缓存页都是空闲的，因为此时可能是一个空的数据库，一条数据都没有，所以此时所有缓存页的描述数据块，都会被放入这个free链表中

**怎么知道数据页有没有被缓存？**

数据库会用表空间号+数据页号，作为一个key，然后缓存页的地址作为value。

* 当你要使用一个数据页的时候，通过**表空间号+数据页号**作为key去这个哈希表里查一下，如果没有就读取数据页，如果已经有了，就说明数据页已经被缓存了。

<img src="https://img-blog.csdnimg.cn/77bd8056f0cd42e59a48941201816c25.png" style="zoom:25%;" />

# Flush链表

由于Buffer Pool大小是固定的，当Buffer Pool划分完全部的缓存页和描述数据块之后，还剩一点点的内存，而这一点点内存又放不下任何一个缓存页，就只能放着不能用，这就是内存碎片。

数据块在Buffer Pool中划分缓存页的时候，会让所有的缓存页和描述数据块都紧密的挨在一起，从而尽可能的减少内存浪费，来减少内存碎片的产生。

**脏数据页**

当你去更新Buffer Pool的缓存页中的数据，此时一旦你更新了缓存页中的数据。

* 那么缓存页里的数据和磁盘上的数据页里的数据，就不一致了。

此时，我们就说缓存页是脏数据，脏页。

<img src="https://img-blog.csdnimg.cn/77bd8056f0cd42e59a48941201816c25.png" style="zoom:25%;" />

数据库里引入了flush链表，这个flush链表本质也是通过缓存页的描述数据块中的两个指针，让被修改过的缓存页的描述数据块，组成一个双向链表。

* 被修改过的缓存页，都会把它的描述数据块加入到flush链表中去，flush的意思是这些都是脏页，后续都是要flush刷新到磁盘上去的。

MySQL有一个后台的IO线程，会在之后某个时间里，随机的把内存buffer pool中的修改后的脏数据给刷回到磁盘上的数据文件里去

要合理地设置`innodb_io_capacity`的值，并且平时要多关注脏页比例，不要让它经常接近75%。

# LRU链表

如果所有的缓存页都被写满了数据，此时无法从磁盘上加载新的数据页到缓存页里去，那么就只能淘汰掉一些缓存页了。

* 所谓淘汰缓存页，就是把一个缓存页里被修改过的数据，给刷回到磁盘上的数据页里去，然后这个缓存页就可以清空了，让他重新变成一个空闲的缓存页。

接着再把磁盘上你需要的新的数据页加载到这个腾出来的空闲缓存页中去。

**LRU链表的工作原理**

* 假设从磁盘加载一个数据页到缓存页的时候，就把这个缓存页的描述数据块放到LRU链表头部去，那么只要有数据的缓存页，它都会放在LRU里，而且最近被加载数据的缓存页，都会被放到LRU链表的头部去。

* 假设某个缓存页的描述数据块本来在LRU链表的尾部，后续只要查询或者修改了这个缓存页的数据，也要把这个缓存页挪动到LRU链表的头部去，也就是说最近被访问过的缓存页，一定在LRU链表的头部。

<img src="https://img-blog.csdnimg.cn/7df54e5402ac4eb28bc3d6e27c12ea2d.png" style="zoom:25%;" />

# 生产配置

**Buffer Pool 在访问过程中的加锁机制**

Buffer Pool本质就是一大块内存数据结构，由一大堆的缓存页和描述数据块组成的，然后加上了各种链表（free、flush、lru）来辅助它的运行。

* 如果MySQL同时接收到了多个请求，它就会用多个线程来处理这多个请求，每个线程会负责处理一个请求。

> 这里要注意的是，当多个线程来并发的访问这个Buffer Pool，此时他们都是在访问内存里的一些共享的数据结构，比如说缓存页、各种链表之类的。

这时候，就必须对Buffer Pool加锁，先让一个线程完成一系列的操作，比如说加载数据页到缓存页，更新 free 链表，更新 lru链表，然后释放锁，接着下一个线程再执行一系列的操作。

**多线程并发访问加锁，对数据库性能的影响**

其实这种多线程加锁排队执行的机制，对数据库的性能影响并不是太大。

* 因为大部分情况下，每个线程都是查询或者更新缓存页里的数据，这个操作是发生在内存里的，基本都是微秒级的，很快很快，包括更新free、flush、lru这些链表，它因为都是基于链表进行一些指针操作，性能也是极高的。

**MySQL的生产优化经验：多个Buffer Pool优化并发能力**

一般来说，MySQL默认的规则是，如果它给Buffer Pool分配的内存小于1GB，那么最多就只会给你一个Buffer Pool。

如果机器的内存很大，就必然会给 Buffer Pool 分配较大的内存，比如给它个8G内存，那么此时你是同时可以设置多个Buffer Pool的。

* 给buffer pool设置了8GB的总内存，然后设置了它应该有4个Buffer Pool，也就是说，每个Buffer Pool的大小就是2GB。

**生产环境中应该给Buffer Pool设置多少内存**

在生产环境中，给Buffer Pool设置的内存不是占满整个机器的内存量，而是有一个合理、健康的比例，也就是给Buffer Pool 设置当前的机器内存的50%~60%左右。

* 比如当前有32G的机器，那么给Buffer 设置个20GB的内存，剩下的留给OS和其他人使用，就比较合理了。

# Chunk机制

**Buffer Pool不能在运行期间动态调整**

因为想要动态调整Buffer Pool大小，比如Buffer Pool本来是8G，运行期间调整为16G。

这一实现是需要向操作系统申请一块新的16GB的连续内存，然后把现在的Buffer Pool中的所有缓存页、描述数据块、各种链表，都拷贝到新的16GB的内存中去，这个过程是极为耗时的，性能很低下，是不可以接受的。

**基于chunk机制把buffer pool给拆小**

buffer pool 是由很多chunk组成的，它的大小是 `innodb_buffer_pool_chunk_size`参数控制的，默认值就是128MB。

* 比如现在给Buffer Pool设置一个总大小是8GB，然后有4个buffer Pool，那么每个Buffer Pool就是2GB，此时每个buffer pool是由一系列的128MB的chunk组成的也就是说每个buffer pool会有16个chunk。

每个buffer pool里的每个chunk里就是一系列的描述数据块和缓存页，每个buffer pool里的多个chunk共享一套free、flush、lru这些链表。

<img src="https://img-blog.csdnimg.cn/209659641c1b447a9245dc38daab0eca.png" style="zoom:50%;" />

**基于chunk机制在运行期间动态调整buffer pool大小**

假设现在Buffer Poool总大小是8GB，计划要动态加到16GB，那么此时只要申请一系列的128MB大小的chunk就可以了，只要每个chunk是连续的128MB内存就行了。然后把这些申请到的chunk内存分配给buffer pool就行了。

# Change Buffer

当需要更新一个数据页时，如果数据页在内存中就直接更新，而如果这个数据页还没有在内存中的话，在不影响数据一致性的前提下，InnoDB会将这些更新操作缓存在change buffer中，这样就不需要从磁盘中读入这个数据页了。

在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作。

**什么条件下可以使用change buffer呢？**

> 对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。

比如，要插入(4,400)这个记录，就要先判断现在表中是否已经存在k=4的记录，而这必须要将数据页读入内存才能判断。

如果都已经读入到内存了，那直接更新内存会更快，就没必要使用change buffer了。

因此，唯一索引的更新就不能使用change buffer，实际上也只有普通索引可以使用。

* change buffer用的是buffer pool里的内存，因此不能无限增大。

* change buffer的大小，可以通过参数`innodb_change_buffer_max_size`来动态设置。

* 这个参数设置为50的时候，表示change buffer的大小最多只能占用buffer pool的50%。

**change buffer的使用场景**

* 对于写多读少的业务来说，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好。这种业务模型常见的就是账单类、日志类的系统。
* 假设一个业务的更新模式是写入之后马上会做查询，那么即使满足了条件，将更新先记录在change buffer，但之后由于马上要访问这个数据页，会立即触发merge过程。
* 这样随机访问IO的次数不会减少，反而增加了change buffer的维护代价。所以，对于这种业务模式来说，change buffer反而起到了副作用。

**redo log 主要节省的是随机写磁盘的IO消耗（转成顺序写），而change buffer主要节省的则是随机读磁盘的IO消耗。**