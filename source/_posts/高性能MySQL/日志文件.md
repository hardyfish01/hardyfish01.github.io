---
title: 日志文件
categories: 
- 高性能MySQL
---

# Bin Log

用于记录数据库执行的写入性操作(不包括查询)信息，以二进制的形式保存在磁盘中

> 可以简单理解为记录的就是sql语句

binlog 是 mysql 的逻辑日志，并且由 `Server`层进行记录，使用任何存储引擎的 mysql 数据库都会记录 binlog 日志

binlog也叫归档日志，他里面记录的类似于**对users表中的id=10的一行数据做了更新操作，更新以后的值是什么**

**使用场景**

在实际应用中， binlog 的主要使用场景有两个，分别是 主从复制 和 数据恢复

**刷盘时机**

mysql 通过 `sync_binlog` 参数控制 biglog 的刷盘时机，取值范围是 0-N：

- 0：不去强制要求，不是直接进入磁盘文件，而是进入os cache内存缓存，由系统自行判断何时写入磁盘；

- 1：每次 commit 的时候都要将 binlog 写入磁盘；

- N：每N个事务，才会将 binlog 写入磁盘。

可以看出， `sync_binlog` 最安全的是设置是 1

**日志格式**

binlog 日志有三种格式，分别为 STATMENT 、 ROW 和 MIXED

在 MySQL 5.7.7 之前，默认的格式是 STATEMENT ， MySQL 5.7.7 之后，默认值是 ROW

日志格式通过 `binlog-format` 指定。

- STATMENT ： 基于 SQL 语句的复制，每一条会修改数据的sql语句会记录到 binlog 中

- ROW ： 基于行的复制，记录每一行数据修改的细节，不记录执行 SQL 语句的上下文相关的信息，仅记录行数据的修改。假设有一个批量更新操作，会以行记录的形式来保存二进制文件，这样可能会产生大量的日志内容。

- MIXED ： 基于 STATMENT 和 ROW 两种模式的混合复制，比如一般的数据操作使用 row 格式保存，有些表结构的变更语句，使用 statement 来记录

我们还可以通过mysql提供的查看工具mysqlbinlog查看文件中的内容，例如：

```
mysqlbinlog mysql-bin.00001 | more
```

binlog文件大小和个数会不断的增加，后缀名会按序号递增，例如`mysql-bin.00002`等。

**基于binlog和redo log完成事务的提交**

当我们把binlog写入磁盘文件之后，接着就会完成最终的事务提交，此时会把本次更新对应的binlog文件名称和这次更新的binlog日志在文件里的位置，都写入到redo log日志文件里去，**同时在redo log日志文件里写入一个commit标记**。

![](https://img-blog.csdnimg.cn/2278260803ea43a5a8950d942384d51c.png)

**在redo日志中写入commit标记的意义是什么？**

他其实是用来保持redo log日志与binlog日志一致的。

必须是在redo log中写入最终的事务commit标记了，然后此时事务提交成功，而且redo log里有本次更新对应的日志，binlog里也有本次更新对应的日志 ，redo log和binlog完全是一致的。

# Redo Log

redo log本质是保证事务提交之后，修改的数据绝对不会丢失的。

> 提交事务的时候，保证把对缓存页做的修改以日志的形式，写入到redo log日志文件里去的。

有了redo log，InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为**crash-safe**。

**这种日志大致的格式：对表空间XX中的数据页XX中的偏移量为XXXX的地方更新了数据XXX**

redo log写日志，是顺序写入磁盘文件，每次都是追加到磁盘文件末尾去，速度也是很快的

包括两部分：一个是内存中的日志缓冲( redo log buffer )，另一个是磁盘上的日志文件

* mysql 每执行一条 DML 语句，先将记录写入 `redo log buffer` ，后续某个时间点再一次性将多个操作记录写到 redo log file

这种 先写日志，再写磁盘 的技术就是 MySQL里经常说到的**WAL 技术**

**提交事务的时候将redo日志写入磁盘中**

此时这个策略是通过`innodb_flush_log_at_trx_commit`来配置的。

* 当这个参数的值为0：提交事务的时候，不会把redo log buffer里的数据刷入磁盘文件的。
* 当这个参数的值为1：提交事务的时候，就必须把redo log从内存刷入到磁盘文件里去，只要事务提交成功，那么redo log就必然在磁盘里了。
* 当这个参数的值为2：提交事务的时候，把redo日志写入磁盘文件对应的os cache缓存里去，而不是直接进入磁盘文件，可能1秒后才会把os cache里的数据写入到磁盘文件里去。

**内部结构**

一条redo log看起来大致的结构如下：

* 日志类型（就是类似`MLOG_1BYTE`之类的），表空间ID，数据页号，数据页中的偏移量，具体修改的数据

**redo log buffer**

它就是MySQL专门设计了用来缓冲redo log写入的。

* redo log buffer其实就是MySQL在启动的时候，就跟操作系统申请的一块连续内存空间。

redo log buffer申请出来的一片连续内存，然后里面划分出了N多个空的redo log block。

* redo log都是先写入内存里的redo log block数据结构里去的，然后完事儿了才会把redo log block写入到磁盘文件里去的。

直到所有的redo log block都写满。

万一要是redo log buffer里所有的redo log block都写满了，会强制把redo log block刷入到磁盘中去的！

**什么时候可以写入磁盘**

* 如果写入redo log buffer的日志已经占据了redo log buffer总容量的一半了，也就是超过了8MB的redo log在缓冲里了，此时就会把它们刷入到磁盘文件里去。

* 一个事务提交的时候，必须把它的那些redo log所在的redo log block都刷入到磁盘文件里去，只有这样，当事务提交之后，它修改的数据绝对不会丢失，因为redo log里有重做日志，随时可以恢复事务做的修改。

* 后台线程定时刷新，有一个后台线程每隔1秒就会把redo log buffer里的redo log block刷到磁盘文件里去

* MySQL关闭的时候，redo log block都会刷入到磁盘里去

* 因为关闭MySQL的时候必然会刷redo log到磁盘，如果瞬间执行大量的高并发的SQL语句，1秒内就产生了超过8MB的redo log，此时占据了redo log buffer一半的空间了，必然会直接把你的redo log刷入磁盘里去


**redo log block**

redo log也不是单行单行的写入日志文件的，它是用一个redo log block来存放多个单行日志的。

* 对于redo log而言，它确实是不停的追加写入到redo log磁盘文件里去的，但是其实每一个redo log都是写入到文件里的一个redo log block里去的，一个block最多放496自己的redo log日志。

如果依次在磁盘文件里的末尾追加不停的写字节数据，就是**磁盘顺序写**；

但是假设现在磁盘文件里已经有很多很多的redo log block了，此时要在磁盘里某个随机位置找到一个redo log block去修改他里面几个字节的数据，这就是磁盘随机写

**redo log与bin log区别**

|          | redo log                                                     | binlog                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 文件大小 | `redo log`的大小是固定的。                                   | `binlog`可通过配置参数 `max_binlog_size`设置每个`binlog`文件的大小。 |
| 实现方式 | `redo log`是 `InnoDB`引擎层实现的，并不是所有引擎都有。      | `binlog`是 `Server` 层实现的，所有引擎都可以使用 `binlog`日志 |
| 记录方式 | redo log 采用循环写的方式记录，当写到结尾时，会回到开头循环写日志。 | binlog通过追加的方式记录，当文件大小大于给定值后，后续的日志会记录到新的文件上 |
| 适用场景 | `redo log`适用于崩溃恢复(crash-safe)                         | `binlog`适用于主从复制和数据恢复                             |

# Undo Log

> 原子性底层就是通过 undo log 实现的

undo log 主要记录了数据的逻辑变化，比如一条 INSERT语句，对应一条 DELETE 的 `undo log` ，对于每个 UPDATE 语句，对应一条相反的 UPDATE 的 undo log ，这样在发生错误时，就能回滚到事务之前的数据状态。

> `undo log` 也是 MVCC(多版本并发控制)实现的关键

你现在在buffer pool的一个缓存页里插入了一条数据了，执行了insert语句，然后你写了一条undo log

现在事务要是回滚了，你直接就把这条insert语句的undo log拿出来。然后在undo log里就知道在哪个表里插入的数据，主键是什么，直接定位到那个表和主键对应的缓存页，从里面删除掉之前insert语句插入进去的数据就可以了，这样就可以实现事务回滚的效果了！