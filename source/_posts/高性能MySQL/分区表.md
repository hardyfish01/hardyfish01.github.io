---
title: 分区表
categories: 
- 高性能MySQL
---

分区表就是把物理表结构相同的几张表，通过一定算法，组成一张逻辑大表。

* 这种算法叫分区函数，当前 MySQL 数据库支持的分区函数类型有 RANGE、LIST、HASH、KEY、COLUMNS。

无论选择哪种分区函数，都要指定相关列成为分区算法的输入条件，这些列就叫**分区列**。

* 另外，在 MySQL 分区表中，主键也必须是分区列的一部分，不然创建分区表时会失败

```sql
CREATE TABLE t (
    a INT,
    b INT,
    c DATETIME,
    d VARCHAR(32),
    e INT,
    PRIMARY KEY (a,b,c),
    KEY idx_e (e)
)
partition by range columns(c) (
    PARTITION p0000 VALUES LESS THAN ('2019-01-01'),
    PARTITION p2019 VALUES LESS THAN ('2020-01-01'),
    PARTITION p2020 VALUES LESS THAN ('2021-01-01'),
    PARTITION p9999 VALUES LESS THAN (MAXVALUE)
);
```

* 创建完表后，在物理存储上会看到四个分区所对应 ibd 文件，也就是把数据根据时间列 c 存储到对应的 4 个文件中

MySQL 中的分区表是把一张大表拆成了多张表，每张表有自己的索引，从逻辑上看是一张表，但物理上存储在不同文件中。

**分区表技术不是用于提升 MySQL 数据库的性能，而是方便数据的管理。**

> 分区表设计不解决性能问题，更多的是解决数据迁移和备份的问题。

**分区表在业务上的设计**

以电商中的订单表 Orders 为例，如果在类似淘宝的海量互联网业务中，Orders 表的数据量会非常巨大，假设一天产生 5000 万的订单，那么一年表 Orders 就有近 180 亿的记录。

* 所以对于订单表，在数据库中通常只保存最近一年甚至更短时间的数据，而历史订单数据会入历史库。

* 除非存在 1 年以上退款的订单，大部分订单一旦完成，这些数据从业务角度就没用了。

**如果你想方便管理订单表中的数据，可以对表 Orders 按年创建分区表**

* 这时 Orders 表的主键修改为了(`o_orderkey,O_ORDERDATE`)，数据按照年进行分区存储。

那么如果要删除 1 年前的数据，比如删除 1998 年的数据，之前需要使用下面的 SQL，比如:

```sql
DELETE FROM Orders 
WHERE o_orderdate >= '1998-01-01' 
  AND o_orderdate < '1999-01-01'
```

可这条 SQL 的执行相当慢，产生大量二进制日志，在生产系统上，也会导致数据库主从延迟的问题。

而使用分区表的话，对于数据的管理就容易多了，你直接使用清空分区的命令就行：

```sql
ALTER TABLE orders_par 
TRUNCATE PARTITION p1998
```

上述 SQL 执行速度非常快，因为实际执行过程是把分区文件删除和重建。

另外产生的日志也只有一条 DDL 日志，也不会导致主从复制延迟问题。