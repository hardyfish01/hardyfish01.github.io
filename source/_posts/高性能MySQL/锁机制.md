---
title: 锁机制
categories: 
- 高性能MySQL
---

**在 MySQL 中有三种级别的锁：页级锁、表级锁、行级锁。**

* 表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 会发生在：MyISAM、memory、InnoDB、BDB 等存储引擎中。

* 行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。会发生在：InnoDB 存储引擎。

* 页级锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。会发生在：BDB 存储引擎。

InnoDB既实现了行锁，也实现了表锁。

> 行锁是通过索引实现的，如果不通过索引条件检索数据，那么InnoDB将对表中所有的记录进行加锁，其实就是升级为表锁了。

* 只在可重复读或以上隔离级别下的特定操作才会取得gap lock或next-key lock。

* 在Select 、Update和Delete时，除了基于唯一索引的查询之外，其他索引查询时都会获取gap lock或next-key lock(注意指的是间隙锁），即锁住其扫描的范围。
* 主键索引也属于唯一索引，所以主键索引是不会使用gap lock或next-key lock。(注意指的是间隙锁）

# 全局锁

全局锁就是对整个数据库实例加锁。MySQL提供了一个加全局读锁的方法，命令是` Flush tables with read lock (FTWRL)`。

当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：

* 数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

**全局锁的典型使用场景是，做全库逻辑备份。**也就是把整库每个表都select出来存成文本。

# 行锁

> 行锁，也称为记录锁，顾名思义就是在记录上加的锁

**行锁类型**

> Record Locks：

就是仅仅把一条记录锁上，官方的类型名称为：`LOCK_REC_NOT_GAP`。

记录锁是有S（共享）锁和X（排他）锁之分的，分别称之为S型记录锁和X型记录锁，当一个事务获取了一条记录的S型记录锁后，其他事务也可以继续获取该记录的S型记录锁，但不可以继续获取X型记录锁；

当一个事务获取了一条记录的X型记录锁后，其他事务既不可以继续获取该记录的S型记录锁，也不可以继续获取X型记录锁；

> Gap Locks：

MySQL在REPEATABLE READ隔离级别下是可以解决幻读问题的

于是InnoDB他们提出了一种称之为Gap Locks的锁，官方的类型名称为：`LOCK_GAP`

> Next-Key Locks：

有时候我们既想锁住某条记录，又想阻止其他事务在该记录前边的间隙插入新记录，所以设计InnoDB就提出了一种称之为Next-Key Locks的锁，官方的类型名称为：`LOCK_ORDINARY`，我们也可以简称为next-key锁。

next-key锁的本质就是一个记录锁和一个gap锁的合体，它既能保护该条记录，又能阻止别的事务将新记录插入被保护记录前边的间隙。

# 间隙锁

间隙锁，锁的就是两个值之间的空隙。

**间隙锁和next-key lock的引入，帮我们解决了幻读的问题**

**间隙锁的引入，可能会导致同样的语句锁住更大的范围，这其实是影响了并发度的**

* 间隙锁是在可重复读隔离级别下才会生效的。所以，你如果把隔离级别设置为读提交的话，就没有间隙锁了。

* 如果读提交隔离级别够用，也就是说，业务不需要可重复读的保证，这样考虑到读提交下操作数据的锁范围更小（没有间隙锁），这个选择是合理的。

# 共享锁和独占锁

其实多个事务同时更新一行数据，此时都会加锁，然后都会排队等待，必须一个事务执行完毕了，提交了，释放了锁，才能唤醒别的事务继续执行。

> 在这多个事务运行的时候，他们加的是什么锁呢

其实是X锁，也就是Exclude独占锁，当有一个事务加了独占锁之后，此时其他事务再要更新这行数据， 都是要加独占锁的，但是只能生成独占锁在后面等待。

MySQL也支持一种共享锁，就是S锁，这个共享锁的语法如下：`select * from table lock in share mode`，你在一个查询语句后面加上`lock in share mode`，意思就是查询的时候对一行数据加共享锁。

| 锁类型 | 独占锁 | 共享锁 |
| ------ | ------ | ------ |
| 独占锁 | 互斥   | 互斥   |
| 共享锁 | 互斥   | 不互斥 |

一般开发业务系统的时候，其实你查询主动加共享锁，这种情况较为少见，数据库的行锁是实用功能，但是一般不会在数据库层面做复杂的手动加锁操作，反而会用基于redis/zookeeper的分 布式锁来控制业务系统的锁逻辑。

> 查询操作还能加互斥锁，他的方法是：`select * from table for update`。

一旦你查询的时候加了独占锁，此时在你事务提交之前，任何人都不能更新数据了，只能你在本事务里更新数据，等你提交了，别人再更新数据

# 表锁

当你执行增删改的时候默认加行锁，然后**执行DDL语句的时候，比如alter table之类 的语句，会默认在表级别加表锁**。

> 这么说也不太正确，但是也有一定的道理，因为确实你执行DDL的时 候，会阻塞所有增删改操作；执行增删改的时候，会阻塞DDL操作

但这是通过MySQL通用的**元数据锁**实现的，也就是Metadata Locks，但这还不是表锁的概念。

MDL不需要显式使用，在访问一个表的时候会被自动加上。

> MDL的作用保证读写的正确性。你可以想象一下，如果一个查询正在遍历一个表中的数据，而执行期间另一个线程对这个表结构做变更，删了一列，那么查询线程拿到的结果跟表结构对不上，肯定是不行的。

在MySQL 5.5版本中引入了MDL，当对一个表做增删改查操作的时候，加MDL读锁；当要对表做结构变更操作的时候，加MDL写锁。

- 读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

> 事务中的MDL锁，在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到整个事务提交后再释放。

**表锁分为两种，一种就是表锁，一种是表级的意向锁**

InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁。

表锁又分为三种。

* 意向共享锁（IS）：事务计划给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。

* 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

* 自增锁（AUTO-INC Locks）：特殊表锁，自增长计数器通过该锁来获得子增长计数器最大的计数值。

这个表锁，可以用如下语法来加：

- LOCK TABLES xxx READ：这是加表级共享锁

- LOCK TABLES xxx WRITE：这是加表级独占锁

> 可以用`unlock tables`主动释放锁

另外两个情况会加表级锁。

* 如果有事务在表里执行增删改操作，那在行级会加独占锁，此时 其实同时会在表级加一个意向独占锁；

* 如果有事务在表里执行查询操作，那么会在表级加一个意向共享锁。

* 假设有一个事务要在表里更新id=10的一行数据，在表上加了一个意向独占锁，此时另外 一个事务要在表里更新id=20的一行数据，也会在表上加一个意向独占锁，因为他们俩更新的都是表里不同的数据，所以意向锁之间是根本不会互斥的

| 锁类型     | 独占锁 | 意向独占锁 | 共享锁 | 意向共享锁 |
| ---------- | ------ | ---------- | ------ | ---------- |
| 独占锁     | 互斥   | 互斥       | 互斥   | 互斥       |
| 意向独占锁 | 互斥   | 不互斥     | 互斥   | 不互斥     |
| 共享锁     | 互斥   | 互斥       | 不互斥 | 不互斥     |
| 意向共享锁 | 互斥   | 不互斥     | 不互斥 | 不互斥     |

其实更新数据自动加的表级意向独占锁，会跟你用 `LOCK TABLES xxx WRITE` 手动加的表级独占锁是互斥的，所以说，假设你手动加了表级独占锁，此时任何人都不能执行更新操作了

# 死锁

在发生死锁时，InnoDB 存储引擎会自动检测，并且会自动回滚代价较小的事务来解决死锁问题。

但很多时候一旦发生死锁，InnoDB 存储引擎的处理的效率是很低下的或者有时候根本解决不了问题，需要人为手动去解决。

**如何避免死锁的产生呢？**

* 加锁顺序一致；

* 尽量基于 primary 或 unique key 更新数据。

* 单次操作数据量不宜过多，涉及表尽量少。

* 在编程中尽量按照固定的顺序来处理数据库记录，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；

* 在允许幻读和不可重复读的情况下，尽量使用RC事务隔离级别，可以避免gap lock导致的死锁问题；

* 更新表时，尽量使用主键更新；

* 避免长事务，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；

* 设置锁等待超时参数，我们可以通过`innodb_lock_wait_timeout`设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。

**死锁检测**

主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。

> 死锁检测要耗费大量的CPU资源。