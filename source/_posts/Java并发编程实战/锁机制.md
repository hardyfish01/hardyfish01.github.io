---
title: 锁机制
categories: 
- Java并发编程实战
---

# 锁分类

**偏向锁/轻量级锁/重量级锁**

**可重入锁/非可重入锁**

可重入锁指的是线程当前已经持有这把锁了，能在不释放这把锁的情况下，再次获取这把锁。

```java
public class LockExample {
    public static void main(String[] args) {
        reentrantA(); // 可重入锁
    }
    /**
     * 可重入锁 A 方法
     */
    private synchronized static void reentrantA() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantA");
        reentrantB();
    }
    /**
     * 可重入锁 B 方法
     */
    private synchronized static void reentrantB() {
        System.out.println(Thread.currentThread().getName() + "：执行 reentrantB");
    }
}
```

从结果可以看出 reentrantA 方法和 reentrantB 方法的执行线程都是`main`，我们调用了 reentrantA 方法，它的方法中嵌套了 reentrantB，如果 synchronized 是不可重入的话，那么线程会被一直堵塞。

可重入锁的实现原理，是在锁内部存储了一个线程标识，用于判断当前的锁属于哪个线程，并且锁的内部维护了一个计数器，当锁空闲时此计数器的值为 0，当被线程占用和重入时分别加 1，当锁被释放时计数器减 1，直到减到 0 时表示此锁为空闲状态。

**共享锁/独占锁**

共享锁指的是我们同一把锁可以被多个线程同时获得，而独占锁指的就是，这把锁只能同时被一个线程获得。

我们的读写锁，就最好地诠释了共享锁和独占锁的理念。读写锁中的读锁，是共享锁，而写锁是独占锁。

读锁可以被同时读，可以同时被多个线程持有，而写锁最多只能同时被一个线程持有。

**公平锁/非公平锁**

公平锁的公平的含义在于如果线程现在拿不到这把锁，那么线程就都会进入等待，开始排队，在等待队列里等待时间长的线程会优先拿到这把锁，有先来先得的意思。

而非公平锁它会在一定情况下，忽略掉已经在排队的线程，发生插队现象。

公平和非公平的优缺点：

|          | 优势                                                       | 劣势                                                         |
| :------- | :--------------------------------------------------------- | :----------------------------------------------------------- |
| 公平锁   | 各线程公平平等，每一个线程在等待一段时间后，总有执行的机会 | 更慢，吞吐量更少                                             |
| 非公平锁 | 更快，吞吐量更大                                           | 有可能产生线程饥饿，也就是某些线程在长时间内，始终得不到执行 |

**悲观锁/乐观锁**

悲观锁的概念是在获取资源之前，必须先拿到锁，以便达到独占的状态，当前线程在操作资源的时候，其他线程由于不能拿到锁，所以其他线程不能来影响我。

而乐观锁恰恰相反，它并不要求在获取资源前拿到锁，也不会锁住资源；相反，乐观锁利用 CAS 理念，在不独占资源的情况下，完成了对资源的修改。

> 两种锁的使用场景

像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。

但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适**

悲观锁适合用于并发写入多、临界区代码复杂、竞争激烈等场景，这种场景下悲观锁可以避免大量的无用的反复尝试等消耗。

乐观锁适用于大部分是读取，少部分是修改的场景，也适合虽然读写都很多，但是并发并不激烈的场景。

在这些场景下，乐观锁不加锁的特点能让性能大幅提高。

**自旋锁/非自旋锁**

自旋锁的理念是如果线程现在拿不到锁，并不直接陷入阻塞或者释放 CPU 资源，而是开始利用循环，不停地尝试获取锁。

相反，非自旋锁的理念就是没有自旋的过程，如果拿不到锁就直接放弃，或者进行其他的处理逻辑，例如去排队、陷入阻塞等。

> 自旋锁的好处

阻塞和唤醒线程都是需要高昂的开销的，如果同步代码块中的内容不复杂，那么可能转换线程带来的开销比实际业务代码执行的开销还要大。

自旋锁用循环去不停地尝试获取锁，让线程始终处于 Runnable 状态，节省了线程状态切换带来的开销。

> 适用场景

所以我们就要看一下自旋锁的适用场景。首先，自旋锁适用于并发度不是特别高的场景，以及临界区比较短小的情况，这样我们可以利用避免线程切换来提高效率。

可是如果临界区很大，线程一旦拿到锁，很久才会释放的话，那就不合适用自旋锁，因为自旋会一直占用 CPU 却无法拿到锁，白白消耗资源。

**可中断锁/不可中断锁**

在 Java 中，synchronized 关键字修饰的锁代表的是不可中断锁，一旦线程申请了锁，就没有回头路了，只能等到拿到锁以后才能进行其他的逻辑处理。

而我们的 ReentrantLock 是一种典型的可中断锁，例如使用 lockInterruptibly 方法在获取锁的过程中，突然不想获取了，那么也可以在中断之后去做其他的事情，不需要一直傻等到获取到锁才离开。

# Synchronized

[面试题：再谈Synchronized实现原理！](https://mp.weixin.qq.com/s/zAEwHgim-rXbo4-OjmKG2Q)

多线程编程中，有可能会出现多个线程同时访问同一个共享、可变资源的情况，这个资源我们称之其为临界资源；

Java提供了两种方式来实现同步互斥访问临界资源：**synchronized和Lock**

当多个线程执行一个方法时，该方法内部的局部变量并不是临界资源，因为这些局部变量是在每个线程的私有栈中，因此不具有共享性，不会导致线程安全问题。

synchroniz能够保证在同一时刻最多只有一个线程执行该段代码，以达到保证并发安全的效果

**synchronized和lock的区别**：

-  synchronized属于JVM层面，底层通过 `monitorenter` 和 monitorexit 两个指令实现；lock是JUC提供的具体类，是API层面的东西； 
-  synchronized不需要用户手动释放锁，当synchronized代码执行完毕之后会自动让线程释放持有的锁；lock需要一般使用try-finally模式去手动释放锁，并且加锁-解锁数量需要一直，否则容易出现死锁或者程序不终止现象； 
-  synchronized是不可中断的，除非抛出异常或者程序正常退出；lock可中断：设置超时方法`tryLock(time, unit)；`使用`lockInterruptibly`，调用interrupt方法可中断； 
-  synchronized是非公平锁；lock默认是非公平锁，但是可以通过构造函数传入boolean类型值更改是否为公平锁； 
-  锁是否能绑定多个条件：synchronized没有condition的说法，要么唤醒所有线程，要么随机唤醒一个线程；lock可以使用condition实现分组唤醒需要唤醒的线程，实现精准唤醒； 
-  加解锁顺序不同，对于 Lock 而言如果有多把 Lock 锁，Lock 可以不完全按照加锁的反序解锁，比如我们可以先获取 Lock1 锁，再获取 Lock2 锁，解锁时则先解锁 Lock1，再解锁 Lock2，加解锁有一定的灵活度 
-  synchronized 锁只能同时被一个线程拥有，但是 Lock 锁没有这个限制，例如在读写锁中的读锁，是可以同时被多个线程持有的，可是 `synchronized` 做不到 
-  性能区别：在 Java 5 以及之前，`synchronized`的性能比较低，但是到了 Java 6 以后，发生了变化，因为 JDK 对 synchronized 进行了很多优化，比如自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等，所以后期的 Java 版本里的 synchronized 的性能并不比 Lock 差。 

如果 synchronized 关键字适合你的程序， 那么请尽量使用它，这样可以减少编写代码的数量，减少出错的概率。因为一旦忘记在 finally 里 unlock，代码可能会出很大的问题，而使用 synchronized 更安全

如果特别需要 Lock 的特殊功能，比如尝试获取锁、可中断、超时功能等，才使用 Lock

**两类用法**

对象锁：包括方法锁（默认锁对象为this当前实例对象）和同步代码块锁（自己指定锁对象）

类锁：指`synchronized`修饰静态的方法或指定锁为Class对象。

**多线程访问同步方法的几种情况**

> 两个线程同时访问一个对象的同步方法。

由于同步方法锁使用的是this对象锁，同一个对象的this锁只有一把，两个线程同一时间只能有一个线程持有该锁，所以该方法将会串行运行。

> 两个线程访问的是两个对象的同步方法。

由于两个对象的this锁互不影响，synchronized将不会起作用，所以该方法将会并行运行。

> 两个线程访问的是synchronized的静态方法。

synchronized修饰的静态方法获取的是当前类模板对象的锁，该锁只有一把，无论访问多少个该类对象的方法，都将串行执行。

> 同时访问同步方法与非同步方法

非同步方法不受影响。

访问同一个对象的不同的普通同步方法。

由于this对象锁只有一个，不同线程访问多个普通同步方法将串行运行。

> 同时访问静态synchronized和非静态synchronized方法

静态synchronized方法的锁为class对象的锁，非静态synchronized方法锁为this的锁，它们不是同一个锁，所以它们将并行运行。

**可重入性质**

同一线程的外层函数获得锁之后，内层函数可以直接再次获取该锁。

一个线程拿一旦拿到一把锁，它可以对锁进行多次使用，那么就是可重入的，所以可重入锁也叫递归锁；如果一个线程拿到一把锁后，如果想要再次使用就必须先释放锁，然后和其它线程进行竞争，这就是不可重入。

**好处**

避免死锁：比如说有两个方法A、B都被`synchronized`修饰了，线程1执行到了方法A，获取了这把锁，要想执行方法B也需要获取该锁。

假设synchronized不具备可重入性质，线程1执行方法A虽然获取了该锁，但是想要访问方法B不能直接使用该锁，此时既想获取锁又不想释放锁，这就造成永远等待即死锁。

**不可中断性**

一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁。如果别人永远不释放锁，那么我只能永远地等下去。

相比之下，Lock类可以拥有中断的能力，第一点，如果我觉得我等的时间太长了，有权中断现在已经获取到锁的线程的执行；第二点，如果我觉得我等待的时间太长了不想再等了，也可以退出

**深入原理**

```java
public class SynTest {
    public void synBlock() {
        synchronized (this) {
            System.out.println("vincent");
        }
    }
}

  public void synBlock();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=3, args_size=1
         0: aload_0
         1: dup
         2: astore_1
         3: monitorenter
         4: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;
         7: ldc           #3                      // String vincent
         9: invokevirtual #4               // Method java/io/PrintStream.println:(Ljava/lang/String;)V
        12: aload_1
        13: monitorexit
        14: goto          22
        17: astore_2
        18: aload_1
        19: monitorexit
        20: aload_2
        21: athrow
        22: return
```

synchronized 代码块实际上多了 monitorenter 和 monitorexit 指令，第3、13、19行指令分别对应的是 monitorenter 和 monitorexit。

可以把执行 monitorenter 理解为加锁，执行 monitorexit 理解为释放锁

**monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异常退出释放锁**；

**同步方法**

方法的同步并没有通过指令 monitorenter 和 monitorexit 来完成（理论上其实也可以通过这两条指令来实现），不过相对于普通方法，其常量池中多了`ACC_SYNCHRONIZED`标示符。JVM就是根据该标示符来实现方法的同步的

当方法调用时，调用指令将会检查方法的`ACC_SYNCHRONIZED`访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。

在方法执行期间，其他任何线程都无法再获得同一个monitor对象。

参照下面的代码，在命令行执行 javac，然后再执行` javap -v -p`，就可以看到它具体的字节码

```java
synchronized void syncMethod() {
        System.out.println("syncMethod");
}

======字节码=====
synchronized void syncMethod();
    descriptor: ()V
    flags: ACC_SYNCHRONIZED
    Code:
      stack=2, locals=1, args_size=1
         0: getstatic     #4
         3: ldc           #5
         5: invokevirtual #6
```

**可见性原理**

synchronized修饰的方法或者代码块在执行完毕后，该方法或者代码块中对共享变量的所作的任何修改都要在释放锁之前从线程内存写入到主内存中，因此就保证了线程内存的变量与主内存中变量的一致性。

同样，在进入同步代码块或者方法中所得到的共享变量值也是直接从主内存中获取的。

**Monitor**

它通常被描述为一个对象，所有的Java对象是天生的Monitor

在Java虚拟机（HotSpot）中，Monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码`ObjectMonitor.hpp`文件，C++实现的）：

```c++
ObjectMonitor() {
    _header       = NULL;
    _count        = 0; // 记录个数
    _waiters      = 0,
    _recursions   = 0;
    _object       = NULL;
    _owner        = NULL;
    _WaitSet      = NULL; // 处于wait状态的线程，会被加入到_WaitSet
    _WaitSetLock  = 0 ;
    _Responsible  = NULL ;
    _succ         = NULL ;
    _cxq          = NULL ;
    FreeNext      = NULL ;
    _EntryList    = NULL ; // 处于等待锁block状态的线程，会被加入到该列表
    _SpinFreq     = 0 ;
    _SpinClock    = 0 ;
    OwnerIsThread = 0 ;
  }
```

每个 Java 对象在 JVM 的对等对象的头中保存锁状态，指向 ObjectMonitor

ObjectMonitor 保存了当前持有锁的线程引用，EntryList 中保存目前等待获取锁的线程，WaitSet 保存 wait 的线程。

此外还有一个计数器，每当线程获得 monitor 锁，计数器 +1，当线程重入此锁时，计数器还会 +1。

* 当计数器不为0时，其它尝试获取 monitor 锁的线程将会被保存到EntryList中，并被阻塞。

* 当持有锁的线程释放了monitor 锁后，计数器 -1。

* 当计数器归位为 0 时，所有 EntryList 中的线程会尝试去获取锁，但只会有一个线程会成功，没有成功的线程仍旧保存在 EntryList 中。

同时，Monitor对象存在于每个Java对象的对象头Mark Word中（存储的指针的指向），Synchronized锁便是通过这种方式获取锁的

这也是为什么Java中任意对象可以作为锁的原因，同时`notify/notifyAll/wait`等方法会使用到Monitor锁对象，所以必须在同步代码块中使用

![](https://img-blog.csdnimg.cn/2b759b755b5940fc927243e230dac896.png)

**那 WaitSet 中的线程是如何再次被激活的呢？**

在某个地方，**执行了锁的 notify 或者 notifyAll 命令**，会造成 WaitSet 中的线程，转移到 EntryList 中，重新进行锁的争夺。

如此周而复始，线程就可按顺序排队执行

# 锁升级

> **锁只能升级，不能降级**，所以一旦升级为重量级锁，就只能依靠操作系统进行调度

**偏向锁**

偏向锁主要用来优化同一线程多次申请同一个锁的竞争。

在某些情况下，大部分时间是同一个线程竞争锁资源，例如，在创建一个线程并在线程中执行循环监听的场景下，或单线程操作一个线程安全集合时，同一线程每次都需要获取和释放锁，每次操作都会发生用户态与内核态的切换。

在只有一个线程使用了锁的情况下，偏向锁能够保证更高的效率

> 具体过程是这样的：

当第一个线程第一次访问同步块时，会先检测对象头 Mark Word 中的标志位 Tag 是否为 01，以此判断此时对象锁是否处于无锁状态或者偏向锁状态（匿名偏向锁）。

01 也是锁默认的状态，线程一旦获取了这把锁，就会把自己的线程 ID 写到 MarkWord 中，在其他线程来获取这把锁之前，锁都处于偏向锁状态。

当下一个线程参与到偏向锁竞争时，会先判断 MarkWord 中保存的线程 ID 是否与这个线程 ID 相等，如果不相等，会立即撤销偏向锁，升级为轻量级锁

一旦出现其它线程竞争锁资源时，偏向锁就会被撤销。偏向锁的撤销需要等待全局安全点，暂停持有该锁的线程，同时检查该线程是否还在执行该方法，如果是，则升级锁，反之则被其它线程抢占。

在高并发场景下，当大量线程同时竞争同一个锁资源时，偏向锁就会被撤销，发生stop the word后， 开启偏向锁无疑会带来更大的性能开销，这时我们可以通过添加JVM参数关闭偏向锁来调优系统性能，示例代码如下：

```
-XX:-UseBiasedLocking //关闭偏向锁（默认打开）
```

或：

```
-XX:+UseHeavyMonitors  //设置重量级锁
```

<img src="https://img-blog.csdnimg.cn/b39dc14682e0499b8c9b7635fd83c40b.png" style="zoom:25%;" />

**轻量级锁**

轻量级锁的获取是怎么进行的呢？它们使用的是自旋方式

参与竞争的每个线程，会在自己的线程栈中生成一个 LockRecord ( LR )，然后每个线程通过 CAS（自旋）的方式，将锁对象头中的 MarkWord 设置为指向自己的 LR 的指针，哪个线程设置成功，就意味着哪个线程获得锁。

当锁处于轻量级锁的状态时，就不能够再通过简单地对比 Tag 的值进行判断，每次对锁的获取，都需要通过自旋。

当然，自旋也是面向不存在锁竞争的场景，比如一个线程运行完了，另外一个线程去获取这把锁；但如果自旋失败达到一定的次数，锁就会膨胀为重量级锁

轻量级锁适用于线程交替执行同步块的场景，绝大部分的锁在整个同步周期内都不存在长时间的竞争。

<img src="https://img-blog.csdnimg.cn/1a7975780ee343ada6f1e11a54065e7a.png" style="zoom:25%;" />

**重量级锁**

重量级锁，这种情况下，线程会挂起，进入到操作系统内核态，等待操作系统的调度，然后再映射回用户态。

系统调用是昂贵的，所以重量级锁的名称由此而来。

如果系统的共享变量竞争非常激烈，锁会迅速膨胀到重量级锁，这些优化就名存实亡。如果并发非常严重，可以通过参数` -XX:-UseBiasedLocking` 禁用偏向锁，理论上会有一些性能提升，但实际上并不确定

在锁竞争不激烈且锁占用时间非常短的场景下，自旋锁可以提高系统性能。一旦锁竞争激烈或锁占用的时间过长，自旋锁将会导致大量的线程一直处于CAS重试状态，占用CPU资源，反而会增加系统性能开销。所以自旋锁和重量级锁的使用都要结合实际场景。

在高负载、高并发的场景下，我们可以通过设置JVM参数来关闭自旋锁，优化系统性能，示例代码如下：

```
-XX:-UseSpinning //参数关闭自旋锁优化(默认打开) 
-XX:PreBlockSpin //参数修改默认的自旋次数。JDK1.7后，去掉此参数，由jvm控制
```

<img src="https://img-blog.csdnimg.cn/4abd51b4f73148a8bebe30eeb7615a6e.png" style="zoom:25%;" />

# 锁优化

相比于 JDK 1.5，在 JDK 1.6 中 HotSopt 虚拟机对 synchronized 内置锁的性能进行了很多优化，包括自适应的自旋、锁消除、锁粗化、偏向锁、轻量级锁等。

**自适应的自旋锁**

自旋就是不释放 CPU，一直循环尝试获取锁

```java
public final long getAndAddLong(Object var1, long var2, long var4) {
    long var6;
    do {
        var6 = this.getLongVolatile(var1, var2);
    } while(!this.compareAndSwapLong(var1, var2, var6, var6 + var4));
 
    return var6;
}
```

代码中使用一个 do-while 循环来一直尝试修改 long 的值。

自旋的缺点在于如果自旋时间过长，那么性能开销是很大的，浪费了 CPU 资源。

在 JDK 1.6 中引入了自适应的自旋锁来解决长时间自旋的问题。自适应意味着自旋的时间不再固定，而是会根据最近自旋尝试的成功率、失败率，以及当前锁的拥有者的状态等多种因素来共同决定。

自旋的持续时间是变化的，比如，如果最近尝试自旋获取某一把锁成功了，那么下一次可能还会继续使用自旋，并且允许自旋更长的时间；但是如果最近自旋获取某一把锁失败了，那么可能会省略掉自旋的过程，以便减少无用的自旋，提高效率。

**锁消除**

经过逃逸分析之后，如果发现某些对象不可能被其他线程访问到，那么就可以把它们当成栈上数据，栈上数据由于只有本线程可以访问，自然是线程安全的，也就无需加锁，所以会把这样的锁给自动去除掉。

例如，我们的 StringBuffer 的 append 方法如下所示：

```java
@Override
public synchronized StringBuffer append(Object obj) {
    toStringCache = null;
    super.append(String.valueOf(obj));
    return this;
}
```

从代码中可以看出，这个方法是被 synchronized 修饰的同步方法，因为它可能会被多个线程同时使用。

但是在大多数情况下，它只会在一个线程内被使用，如果编译器能确定这个 StringBuffer 对象只会在一个线程内被使用，就代表肯定是线程安全的，那么我们的编译器便会做出优化，把对应的 synchronized 给消除，省去加锁和解锁的操作，以便增加整体的效率。

**锁粗化**

```java
public void lockCoarsening() {
    synchronized (this) {
        //do something
    }
    synchronized (this) {
        //do something
    }
    synchronized (this) {
        //do something
    }
}
```

那么其实这种释放和重新获取锁是完全没有必要的，如果我们把同步区域扩大，也就是只在最开始加一次锁，并且在最后直接解锁，那么就可以把中间这些无意义的解锁和加锁的过程消除，相当于是把几个 synchronized 块合并为一个较大的同步块。

这样做的好处在于在线程执行这些代码时，就无须频繁申请与释放锁了，这样就减少了性能开销。

不过，我们这样做也有一个副作用，那就是我们会让同步区域变大。如果在循环中我们也这样做，如代码所示：

```java
for (int i = 0; i < 1000; i++) {
    synchronized (this) {
        //do something
    }
}
```

也就是我们在第一次循环的开始，就开始扩大同步区域并持有锁，直到最后一次循环结束，才结束同步代码块释放锁的话，这就会导致其他线程长时间无法获得锁。所以，这里的锁粗化不适用于循环的场景，仅适用于非循环的场景。

锁粗化功能是默认打开的，用 `-XX:-EliminateLocks `可以关闭该功能。

# 死锁

死锁就是两个或多个线程（或进程）被无限期地阻塞，相互等待对方手中资源的一种状态

```java
// 共享变量 1
private static final Object share1 = new Object();
// 共享变量 2
private static final Object share2 = new Object();
@Test
public void testDeadLock() throws InterruptedException {
  // 初始化线程 1，线程 1 需要在锁定 share1 共享资源的情况下再锁定 share2
  Thread thread1 = new Thread(() -> {
    synchronized (share1){
      try {
        Thread.sleep(2000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized (share2){
        log.info("{} is run",Thread.currentThread().getName());
      }
    }
  });
 
  // 初始化线程 2，线程 2 需要在锁定 share2 共享资源的情况下再锁定 share1
  Thread thread2 = new Thread(() -> {
    synchronized (share2){
      try {
        Thread.sleep(2000);
      } catch (InterruptedException e) {
        e.printStackTrace();
      }
      synchronized (share1){
        log.info("{} is run",Thread.currentThread().getName());
      }
    }
  });
  // 当线程 1、2 启动后，都在等待对方锁定的资源，但都得不到，造成死锁
  thread1.start();
  thread2.start();
  Thread.sleep(1000000000);
}
```

**如何预防死锁**

> 1.尽量保证加锁顺序是一样的

例如有A,B,C三把锁。

Thread 1的加锁顺序为A、B、C这样的。

Thread 2的加锁顺序为A、C，这样就不会死锁。

如果Thread2的加锁顺序为B、A或者C、A这样顺序就不一致了，就会出现死锁问题。

> 2.尽量用超时放弃机制

Lock接口提供了`tryLock(long time, TimeUnit unit)`方法，该方法可以按照固定时长等待锁，因此线程可以在获取锁超时以后，主动释放之前已经获得的所有的锁。可以避免死锁问题

> 如何定位死锁

利用 jstack 来定位死锁的方法，jstack 可以用来帮助我们分析线程持有的锁和需要的锁，然后分析出是否有循环依赖形成死锁的情况。