---
title: 初识Redis
categories: 
- 数据库
- Redis
---

Redis官网：

* http://www.redis.cn/
* https://redis.io/

本书相关网站：https://cachecloud.github.io/，该网站持续更新Redis开发运维的相关知识和经验。

**Redis使用场景**

1.缓存

2.排行榜系统

3.计数器应用

4.社交网络

赞/踩、粉丝、共同好友/喜好、推送、下拉刷新等是社交网站的必备功能，由于社交网站访问量通常比较大，而且传统的关系型数据不太适合保存这种类型的数据，Redis提供的数据结构可以相对比较容易地实现这些功能。

5.消息队列系统

[面试题：Redis如何实现分布式锁！](https://mp.weixin.qq.com/s/VHRO754P2jIjb3H4xhU4hg)

**Redis重大版本**

Redis借鉴了Linux操作系统对于版本号的命名规则:

* 版本号第二位如果是奇数，则为非稳定版本(例如2.7、2.9、3.1)

* 如果是偶数，则为稳定版本(例如2.6、2.8、3.0、3.2)

当前奇数版本就是下一个稳定版本的开发版本，例如2.9版本是3.0版本的开发版本。

所以我们在生产环境通常选取偶数版本的Redis，如果对于某些新的特性想提前了解和使用，可以选择最新的奇数版本。

**Redis3.0**

Redis3.0最大的改动就是添加Redis的分布式实现Redis Cluster，填补了 Redis官方没有分布式实现的空白。

**Redis4.0**

* 提供了模块系统，见：http://redismodules.com

* 提供了新的缓存剔除算法：LFU

* 提供了非阻塞del和flushall/flushdb功能，有效解决删除bigkey可能造成的Redis阻塞。 

* 提供了RDB-AOF混合持久化格式，充分利用了AOF和RDB各自优势。

# 单线程架构

Redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。

Redis是单线程，主要是指Redis的网络IO和键值对读写是由一个线程来完成的

但Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的

Redis客户端与服务端的模型可以简化成：

* 每次客户端调用都经历 了**发送命令、执行命令、返回结果**三个过程。

因为Redis是单线程来处理命令的，所以一 条命令从客户端达到服务端不会立刻被执行，所有命令都会进入一个队列中，然后逐个被执行。所以命令的执行顺序是不确定的，但是可以确定不会有两条命令被同时执行。

<img src="https://img-blog.csdnimg.cn/1012e93c0d664c5c8e6c1814dd4b5f73.png" style="zoom:25%;" />

**为什么单线程还能这么快**

第一，纯内存访问，Redis将所有数据放在内存中，内存的响应时长大约为100纳秒，这是Redis达到每秒万级别访问的重要基础。

第二，非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上 Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。

第三，单线程避免了线程切换和竞态产生的消耗。

但是单线程会有一个问题:对于每个命令的执行时间是有要求的。

如果某个命令执行过长，会造成其他命令的阻塞，对于Redis这种高性能的服务来说是致命的。

**下图就是基于多路复用的Redis IO模型。**

<img src="https://img-blog.csdnimg.cn/d5d7017fb07d45b6b65183159d3c7beb.png" style="zoom:15%;" />

图中的多个FD就是所说的多个套接字。

Redis网络框架调用epoll机制，让内核监听这些套接字。

此时，Redis线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。

正因为此，Redis可以同时和多个客户端连接并处理请求，从而提升并发性。

为了在请求到达时能通知到Redis线程，select/epoll提供了**基于事件的回调机制**，即**针对不同事件的发生，调用相应的处理函数**。

select/epoll一旦监测到FD上有请求到达时，就会触发相应的事件。

这些事件会被放进一个事件队列，Redis单线程对该事件队列不断进行处理。

这样一来，Redis无需一直轮询是否有请求实际发生，这就可以避免造成CPU资源浪费。

同时，Redis在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。

因为Redis一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis的响应性能。

**以连接请求和读数据请求为例，具体解释一下。**

这两个请求分别对应Accept事件和Read事件，Redis分别对这两个事件注册accept和get回调函数。

当Linux内核监听到有连接请求或读数据请求时，就会触发Accept事件和Read事件，此时，内核就会回调Redis相应的accept和get函数进行处理。

不过，需要注意的是，即使你的应用场景中部署了不同的操作系统，多路复用机制也是适用的。

因为这个机制的实现有很多种，既有基于Linux系统下的select和epoll实现，也有基于FreeBSD的kqueue实现，以及基于Solaris的evport实现，这样，你可以根据Redis实际运行的操作系统，选择相应的多路复用实现。

**采用单线程的缺点很明显，无法使用多核CPU。**

Redis作者提到，由于Redis的大部分操作并不是CPU密集型任务，而Redis的瓶颈在于内存和网络带宽。

在高并发请求下，Redis需要更多的内存和更高的网络带宽，否则瓶颈很容易出现在内存不够用和网络延迟等待的情况。

当然，如果你觉得单个Redis实例的性能不足以支撑业务，Redis作者推荐部署多个Redis节点，组成集群的方式来利用多核CPU的能力，而不是在单个实例上使用多线程来处理。

**多线程优化**

Redis Server本身是多线程的，除了请求处理流程是单线程处理之外，Redis内部还有其他工作线程在后台执行，它负责异步执行某些比较耗时的任务，例如AOF每秒刷盘、AOF文件重写都是在另一个线程中完成的。

在Redis 4.0之后，Redis引入了`lazyfree`的机制，提供了`unlink`、`flushall aysc`、`flushdb async`等命令和`lazyfree-lazy-eviction`、`lazyfree-lazy-expire`等机制来异步释放内存，它主要是为了解决在释放大内存数据导致整个redis阻塞的性能问题。

在删除大key时，释放内存往往都比较耗时，所以Redis提供异步释放内存的方式，让这些耗时的操作放到另一个线程中异步去处理，从而不影响主线程的执行，提高性能。

到了Redis 6.0，Redis又引入了多线程来完成**请求数据的协议解析**，进一步提升性能。

它主要是解决高并发场景下，单线程解析请求数据协议带来的压力。请求数据的协议解析由多线程完成之后，后面的请求处理阶段依旧还是单线程排队处理。

# 数据库管理

Redis默认配置中是有16个数据库，默认使用的就是0号数据库。

Redis3.0中已经逐渐弱化这个功能，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，只不过为了向下兼容老版本的数据库功能， 该功能没有完全废弃掉。

**为什么要废弃掉这个优秀的功能呢?**

总结起来有三点:

* Redis是单线程的，如果使用多个数据库，那么这些数据库仍然是使用一个CPU，彼此之间还是会受到影响的。
* 多数据库的使用方式，会让调试和运维不同业务的数据库变的困难， 假如有一个慢查询存在，依然会影响其他数据库，这样会使得别的业务方定位问题非常的困难。
* 部分Redis的客户端根本就不支持这种方式，即使支持，在开发的时候来回切换数字形式的数据库，很容易弄乱。

建议如果要使用多个数据库功能，完全可以在一台机器上部署多个 Redis实例，彼此用端口来做区分，因为现代计算机或者服务器通常是有多个CPU的，这样既保证了业务之间不会受到影响，又合理地使用了CPU资源。

**渐进式遍历**

Redis从2.8版本后，提供了一个新的命令scan，它能有效的解决keys命令存在的问题。

和keys命令执行时会遍历所有键不同，scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是 O(1)，但是要真正实现keys的功能，需要执行多次scan。