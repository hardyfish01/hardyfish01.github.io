---
title: 数据结构
categories: 
- 数据库
- Redis
---

# 内部编码

type命令实际返回的就是当前键的数据结构类型，它们分别是: 

* string(字符串)、hash(哈希)、list(列表)、set(集合)、zset(有序集合)，但这些只是Redis对外的数据结构。

**每种数据结构都有自己底层的内部编码实现**，而且是多种实现， 这样Redis会在合适的场景选择合适的内部编码。

可以通过object encoding命令查询内部编码:

```c
127.0.0.1:6379> object encoding hello 
"embstr"
127.0.0.1:6379> object encoding mylist 
"ziplist"
```

可以看到键hello对应值的内部编码是embstr，键mylist对应值的内部编码是ziplist。

<img src="https://img-blog.csdnimg.cn/d839f7d86b72451c9fd400e8cc2ca951.png" style="zoom:23%;" />

**键和值用什么结构组织？**

为了实现从键到值的快速访问，Redis使用了一个哈希表来保存所有键值对。

* 一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。

一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。

哈希桶中的entry元素中保存了`*key`和`*value`指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过`*value`指针被查找到。

<img src="https://img-blog.csdnimg.cn/6afaada688894f1399e8280d476e619b.png" style="zoom:23%;" />

<img src="https://img-blog.csdnimg.cn/2d4b7c24c9ad44d4b75451dc6482c46c.png" style="zoom:25%;" />

因为这个哈希表保存了所有的键值对，所以，我也把它称为**全局哈希表**。

哈希表的最大好处很明显，就是让我们可以用`O(1)`的时间复杂度来快速查找到键值对

* 我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的entry元素。

<img src="https://img-blog.csdnimg.cn/53f416f6000b4835b862c53175dfd8c1.png" style="zoom:25%;" />

Redis键值对中的每一个值都是用RedisObject保存的。

RedisObject的内部组成包括了type、encoding、lru和refcount 4个元数据，以及1个`*ptr`指针。

- type：表示值的类型；

- encoding：是值的编码方式，用来表示Redis中实现各个基本类型的底层数据结构，例如SDS、压缩列表、哈希表、跳表等；

- lru：记录了这个对象最后一次被访问的时间，用于淘汰过期的键值对；

- refcount：记录了对象的引用计数；

- `*ptr`：是指向数据的指针。

# 数据类型

## 字符串

字符串类型的值实际可以是字符串(简单的字符串、复杂的字符串(例如JSON、XML))、数字 (整数、浮点数)，甚至是二进制(图片、音频、视频)，但是值最大不能超过512MB。

**内部编码**

字符串类型的内部编码有3种：

* int:8个字节的长整型。 

* embstr:小于等于39个字节的字符串。 

* raw:大于39个字节的字符串。 

Redis会根据当前值的类型和长度决定使用哪种内部编码实现。 整数类型示例如下：

```c
127.0.0.1:6379> set key 8653
OK
127.0.0.1:6379> object encoding key "int"
```

```c
#大于39个字节的字符串:raw
127.0.0.1:6379> set key "one string greater than 39 byte........." OK
127.0.0.1:6379> object encoding key
"raw"
127.0.0.1:6379> strlen key
(integer) 40
```

**典型使用场景**

> 缓存功能

设计键名：比较推荐的方式是使用`“业务名:对象名:id:[属性]”`作为键名(也可以不是分号)。

例如MySQL的数据库名为 vs，用户表名为user，那么对应的键可以用`"vs:user:1"，"vs:user:1:name"`来表示，如果当前Redis只被一个业务使用，甚至可以去掉`“vs:”`。

如果键名比较长，例如`“user:{uid}:friends:messages:{mid}”`，可以在能描述键含义的前提下适当减少键的长度，例如变为`“u:{uid}:fr:m:{mid}”`，从而减少由于键过长的内存浪费。

> 计数

> 共享Session 

> 限速

## 哈希

在Redis中，哈希类型是指键值本身又是一个键值对结构，形如`value={{field1，value1}，...{fieldN，valueN}}`。

Redis键值对和哈希类型二者的关系可以用图来表示。

<img src="https://img-blog.csdnimg.cn/1590d9f23e7948c2bf762aacfb81dabc.png" style="zoom:25%;" />

**内部编码**

哈希类型的内部编码有两种：

* ziplist(压缩列表)：当哈希类型元素个数小于hash-max-ziplist-entries 配置(默认512个)、同时所有值都小于hash-max-ziplist-value配置(默认64 字节)时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的 结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。

* hashtable(哈希表)：当哈希类型无法满足ziplist的条件时，Redis会使 用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而 hashtable的读写时间复杂度为O(1)。

**使用场景** 

记录用户信息：

<img src="https://img-blog.csdnimg.cn/43591c3bc2814007af31b08154ba7e7f.png" style="zoom:25%;" />

相比于使用字符串序列化缓存用户信息，哈希类型变得更加直观，并且在更新操作上会更加便捷。

可以将每个用户的id定义为键后缀，多对field- value对应每个用户的属性。

## 列表

列表(list)类型是用来存储多个有序的字符串，一个列表最多可以存储`2^32-1`个元素。

在Redis中，可 以对列表两端插入(push)和弹出(pop)，还可以获取指定范围的元素列表、获取指定索引下标的元素等。

列表是一种比 较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。

**列表类型有两个特点:**

第一、列表中的元素是有序的，这就意味着可以 通过索引下标获取某个元素或者某个范围内的元素列表，例如要获取第5个元素，可以执行`lindex user:1:message4`(索引从0算起)就可以得到元素。

第二、列表中的元素可以是重复的。

**内部编码** 

列表类型的内部编码有两种：

* ziplist(压缩列表):当列表的元素个数小于list-max-ziplist-entries配置 (默认512个)，同时列表中每个元素的值都小于list-max-ziplist-value配置时 (默认64字节)，Redis会选用ziplist来作为列表的内部实现来减少内存的使 用。

* linkedlist(链表):当列表类型无法满足ziplist的条件时，Redis会使用 linkedlist作为列表的内部实现。

Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节 点的linkedlist，它结合了ziplist和linkedlist两者的优势。

**使用场景** 

> 消息队列

Redis的lpush+brpop命令组合即可实现阻塞队列，生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令 阻塞式的抢列表尾部的元素，多个客户端保证了消费的负载均衡和高可用 性。

> 文章列表 

每个用户有属于自己的文章列表，现需要分页展示文章列表。

此时可以考虑使用列表，因为列表不但是有序的，同时支持按照索引范围获取元素。

## 集合

集合(set)类型也是用来保存多个的字符串元素，但和列表类型不一 样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。

一个集合最多可以存储`2^32-1`个元 素。

Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。

**内部编码** 

集合类型的内部编码有两种：

* intset(整数集合):当集合中的元素都是整数且元素个数小于set-max- intset-entries配置(默认512个)时，Redis会选用intset来作为集合的内部实 现，从而减少内存的使用。

* hashtable(哈希表):当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。

**使用场景**

集合类型比较典型的使用场景是标签(tag)。

例如一个用户可能对娱乐、体育比较感兴趣，另一个用户可能对历史、新闻比较感兴趣，这些兴趣点就是标签。

## 有序集合

有序集合中的元素可以排序。

有序集合每个字符串元素都关联到一个双精度64位的浮点型数字字符串score，里面的元素总是通过score进行着排序，因此它是可以检索的一系列元素

有序集合中的元素不能重复，但是score可以重复，就和一个班里的同学学号不能重复，但是考试成绩可以相同。

默认升序排列，即通过命令ZRANGE实现；如果要按照降序排列，需要通过命令ZREVRANGE实现

当score即得分一样时，按照字典顺序对member进行排序，字典排序用的是二进制，它比较的是字符串的字节数组，所以实际上是比较ASCII码

**内部编码** 

有序集合类型的内部编码有两种:

* ziplist(压缩列表):当有序集合的元素个数小于zset-max-ziplist- entries配置(默认128个)，同时每个元素的值都小于zset-max-ziplist-value配置(默认64字节)时，Redis会用ziplist来作为有序集合的内部实现，ziplist 可以有效减少内存的使用。
* skiplist(跳跃表):当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。

**ziplist编码**

ziplist编码的有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score

ziplist内的集合元素按score从小到大排序，score较小的排在表头位置

**skiplist编码**

skiplist编码的有序集合底层包含一个字典和一个跳跃表 ，跳跃表按score从小到大保存所有集合元素，而字典则保存着从member到score的映射，这样就可以用O(1)的复杂度来查找member对应的score值

- 向有序集合中添加score和element 时间复杂度 `O(logN)`
- 获取element的分数，时间复杂度O(1)
- 自增element的分数，时间复杂度O(1)
- 返回有序集合中元素的个数，时间复杂度O(1)

**使用场景**

有序集合比较典型的使用场景就是排行榜系统。

例如视频网站需要对用 户上传的视频做排行榜，榜单的维度可能是多个方面的:按照时间、按照播放数量、按照获得的赞数。

## BitMap

Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。

Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同。

可以把Bitmaps想象成一个以位为单位的数组，数组的 每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。

![](https://img-blog.csdnimg.cn/3d43881fc76942258461078ffc4105c0.png)

假设网站有1亿用户，每天独立访问的用户有5千万，如果每天用集合类型和Bitmaps分别存储活跃用户，这种情况下使用Bitmaps能节省很多的内存空间。

## HyperLogLog

通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。

HyperLogLog不是100%的正确，其中一定存在误差率。

Redis官方给出的数字是0.81%的失误率。

**开发者在进行数据结构选型时只需要确认如下两条即可:**

* 只为了计算独立总数，不需要获取单条数据。

* 可以容忍一定误差率，毕竟HyperLogLog在内存的占用量上有很大的优势。

# SDS

当你保存64位有符号整数时，String类型会把它保存为一个8字节的Long类型整数，这种保存方式通常也叫作int编码方式。

当你保存的数据中包含字符时，String类型就会用简单动态字符串（Simple Dynamic String，SDS）结构体来保存

- **buf**：字节数组，保存实际数据。为了表示字节数组的结束，Redis会自动在数组最后加一个0，这就会额外占用1个字节的开销。

- **len**：占4个字节，表示buf的已用长度。

- **alloc**：也占个4字节，表示buf的实际分配长度，一般大于len。

在SDS中，buf保存实际数据，而len和alloc本身其实是SDS结构体的额外开销。

另外，对于String类型来说，除了SDS的额外开销，还有一个来自于RedisObject结构体的开销。

因为Redis的数据类型有很多，而且，不同数据类型都有些相同的元数据要记录（比如最后一次访问的时间、被引用的次数等），所以，Redis会用一个RedisObject结构体来统一记录这些元数据，同时指向实际数据。

一个RedisObject包含了8字节的元数据和一个8字节指针，这个指针再进一步指向具体数据类型的实际数据所在，例如指向String类型的SDS结构所在的内存地址。

**为了节省内存空间，Redis还对Long类型整数和SDS的内存布局做了专门的设计。**

当保存的是Long类型整数时，RedisObject中的指针就直接赋值为整数数据了，这样就不用额外的指针再指向整数了，节省了指针的空间开销。

当保存的是字符串数据，并且字符串小于等于44字节时，RedisObject中的元数据、指针和SDS是一块连续的内存区域，这样就可以避免内存碎片。这种布局方式也被称为embstr编码方式。

当字符串大于44字节时，SDS的数据量就开始变多了，Redis就不再把SDS和RedisObject布局在一起了，而是会给SDS分配独立的空间，并用指针指向SDS结构。这种布局方式被称为raw编码模式。

# 压缩列表

压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。

和数组不同的是，压缩列表在表头有三个字段zlbytes、zltail和zllen，分别表示列表长度、列表尾的偏移量和列表中的entry个数；

压缩列表在表尾还有一个zlend，表示列表结束。

<img src="https://img-blog.csdnimg.cn/42acd208f913451aaee9022e4f02d7da.png" style="zoom:20%;" />

压缩列表之所以能节省内存，就在于它是用一系列连续的entry保存数据。

每个entry的元数据包括下面几部分。

- **prev_len**，表示前一个entry的长度。

- **len**：表示自身长度，4字节；

- **encoding**：表示编码方式，1字节；

- **content**：保存实际数据。

在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)。

而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是O(N)了。

# 跳表

有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。

具体来说，跳表在链表的基础上，**增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位**，如下图所示：

<img src="https://img-blog.csdnimg.cn/44839657fccb4eb6a8b74448744fda93.png" style="zoom:25%;" />

如果我们要在链表中查找33这个元素，只能从头开始遍历链表，查找6次，直到找到33为止。此时，复杂度是O(N)，查找效率很低。

为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。

例如，从前两个元素中抽取元素1作为一级索引，从第三、四个元素中抽取元素11作为一级索引。

此时，我们只需要4次查找就能定位到元素33了。

如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。

例如，从一级索引中抽取1、27、100作为二级索引，二级索引指向一级索引。这样，我们只需要3次查找，就能定位到元素33了。

当数据量很大时，跳表的查找复杂度就是`O(logN)`。

# Rehash

Redis默认使用了两个全局哈希表：哈希表1和哈希表2。

一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。

随着数据逐步增多，Redis开始执行rehash，这个过程分为三步：

1. 给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；
2. 把哈希表1中的数据重新映射并拷贝到哈希表2中；
3. 释放哈希表1的空间。

到此，我们就可以从哈希表1切换到哈希表2，用增大的哈希表2保存更多数据，而原来的哈希表1留作下一次rehash扩容备用。

第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据都迁移完，会造成Redis线程阻塞，无法服务其他请求。此时，Redis就无法快速访问数据了。

为了避免这个问题，Redis采用了**渐进式rehash**。

在第二步拷贝数据时，Redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有entries拷贝到哈希表2中；

等处理下一个请求时，再顺带拷贝哈希表1中的下一个索引位置的entries。