---
title: 事务
categories: 
- 数据库
- MySQL
---

**并发事务带来的问题**

脏写、脏读、不可重复读、幻读，都是因为业务系统会多线程并发执行，每个线程可能都会开启一个事务，每个事务都会执行增删改查操作。多个事务可能会并发的对缓存页里的同一批数据进行增删改查操作。

为了解决多事务并发问题，数据库才设计了事务隔离机制、MVCC多版本隔离机制、锁机制，用一整套机制来解决多事务并发问题。

> 脏写

有两个事务，事务 A 和事务 B 同时在更新一条数据，原先数据库中的值为NULL。

事务 A 先把它更新为 A 值，事务 B 紧接着就把它更新为 B 值，因为事务B是后更新的，所以数据库中最后会保存B值。

但此时，事务A回滚了操作，直接就会把那行数据的值更新回 NULL 值。

此时事务 B 一看，为什么我更新的 B 值没了？因为事务 A 把数据值回滚成 NULL 了，结果我更新的 B 值也不见 了。

所以对于事务 B 看到的场景而言，就是自己明明更新了，结果值却没了，这就是脏写。

> 脏读

假设事务 A 更新了一行数据的值为 A 值，此时事务 B 去查询了一下这行数据的值，看到的值是 A 值。

接着，事务 B 拿着刚才查询到的 A 值做各种业务处理，但是此时事务 A 突然回滚了事务，导致它刚才更新的A 值没了，此时那行数据的值回滚为 NULL 值。然后事务 B 再次查询那行数据的值，看到的居然是 NULL 值。

> 不可重复读

假设我们有一个事务 A 开启了，在这个事务 A 里会多次对一条数据进行查询。

另外有两个事务：事务 B、事务 C，他们两都是对这条数据进行更新的，然后我们假设一个前提，就是比如说事务 B 更新之后，如果还没提交，那么事务 A 是读不到的，必须要事务 B 提交之后，它修改的值才能被事务 A 读取到，其实这种情况下，就是我们首先避免了脏读的发生。

假设缓存页里一条数据原来的值是 A 值，此时事务 A 开启之后，第一次查询这条数据，读取到的就是 A 值。

接着事务 B 更新了那行数据的值为 B 值并且提交，此时事务 A 还没提交，它在事务执行期间第二次查询数据，此时查到的是事务 B 修改过的值，B 值，因为事务 B 已经提交了，所以事务 A 是可以读到的，紧接着事务 C 再次更新数据为 C 值，并且提交事务，此时在事务 A 还没提交的情况下，第三次查询数据，查到的值为 C 值。

明显事务A每次查询到的值都是不重复的，因为事务 B 和事务 C 一旦更新值并且提交了，事务 A 会读到别的值，所以此时这行数据的值是不可重复读的。

> 幻读

事务 A，先执行一条查询语句，如 `SELECT * FROM table WHERE id > 10`。

它一开始查询出来了 10 条数据，这时，事务 B往表里插了几条数据，而且事务 B 还提交了，此时多了表中几行数据。

接着事务 A 继续执行同样的查询语句，发现两次查询的结果是不一样的，这就是幻读。

# ACID

**原子性**

根据定义，原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做，即要么转账成功，要么转账失败

**怎么保证原子性的**

利用Innodb的undo log

undo log为回滚日志，是实现原子性的关键，当事务回滚时能够撤销所有已经成功执行的sql语句，他需要记录你要回滚的相应日志信息

- 当你delete一条数据的时候，就需要记录这条数据的信息，回滚的时候，insert这条旧数据

**隔离性**

根据定义，隔离性是指多个事务并发执行的时候，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰

**怎么保证隔离性的**

利用的是锁和MVCC机制

**持久性**

根据定义，持久性是指事务一旦提交，它对数据库的改变就应该是永久性的

**怎么保证持久性的**

利用Innodb的redo log

- 当做数据修改的时候，不仅在内存中操作，还会在redo log中记录这次操作。当事务提交的时候，会将redo log日志进行刷盘(redo log一部分在内存中，一部分在磁盘上)。
- 当数据库宕机重启的时候，会将redo log中的内容恢复到数据库中，再根据undo log和bin log内容决定回滚数据还是提交数据

**一致性**

根据定义，一致性是指事务执行前后，数据处于一种合法的状态，这种状态是语义上的而不是语法上的

**那什么是合法的数据状态**

这个状态是满足预定的约束就叫做合法的状态，再通俗一点，这状态是由你自己来定义的，满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的

# 隔离级别

<img src="https://img-blog.csdnimg.cn/5da327149627474081d16a7d12179ba8.png" alt="img" style="zoom:25%;" />

**读未提交**

当隔离级别设置为Read uncommitted 时，就可能出现脏读

**读已提交**

Oracle和SQL Server默认隔离级别

当隔离级别设置为Read committed 时，避免了脏读，但是可能会造成不可重复读

**可重复读**

MySQL默认隔离级别

Repeatable read避免了不可重复读，但还有可能出现幻读

在 RR隔离级别下，MySQL 为了解决幻读的问题，以牺牲并行度为代价，通过 Gap 锁来防止数据的写入，而这种锁，因为其并行度不够，冲突很多，经常会引起死锁。

现在流行的 Row 模式可以避免很多冲突甚至死锁问题，所以推荐默认使用 Row + RC模式的隔离级别，可以很大程度上提高数据库的读写并行度。

**什么时候需要可重复读的场景呢**？

> 我们来看一个数据校对逻辑的案例。

假设你在管理一个个人银行账户表。一个表存了账户余额，一个表存了账单明细。到了月底你要做数据校对，也就是判断上个月的余额和当前余额的差额，是否与本月的账单明细一致。你一定希望在校对过程中，即使有用户发生了一笔新的交易，也不影响你的校对结果。

**可序列化**

Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读

这种级别，根本就不允许你多个事务并发执行，只能串行起来执行，先执行事务A提交，然后执行事务B提交，接着执行事务C提交，所以此时你根本不可能有幻读的问题，因为事务压根儿都不并发执行！